{"version":3,"sources":["../../../src/migration/rollback-manager.ts"],"sourcesContent":["/**\n * Rollback Manager - Handles rollback operations and backup management\n */\n\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport type { MigrationBackup, BackupFile } from './types.js';\nimport { logger } from './logger.js';\nimport * as chalk from 'chalk';\nimport * as inquirer from 'inquirer';\n\nexport class RollbackManager {\n  private projectPath: string;\n  private backupDir: string;\n\n  constructor(projectPath: string, backupDir: string = '.claude-backup') {\n    this.projectPath = projectPath;\n    this.backupDir = path.join(projectPath, backupDir);\n  }\n\n  async createBackup(metadata: Record<string, any> = {}): Promise<MigrationBackup> {\n    const timestamp = new Date();\n    const backupId = timestamp.toISOString().replace(/[:.]/g, '-');\n    const backupPath = path.join(this.backupDir, backupId);\n\n    logger.info(`Creating backup at ${backupPath}...`);\n\n    await fs.ensureDir(backupPath);\n\n    const backup: MigrationBackup = {\n      timestamp,\n      version: '1.0.0',\n      files: [],\n      metadata: {\n        projectPath: this.projectPath,\n        backupId,\n        ...metadata,\n      },\n    };\n\n    // Backup critical files and directories\n    const backupTargets = [\n      '.claude',\n      'CLAUDE.md',\n      '.roomodes',\n      'package.json',\n      'memory/memory-store.json',\n      'coordination/config.json',\n    ];\n\n    for (const target of backupTargets) {\n      const sourcePath = path.join(this.projectPath, target);\n      const targetPath = path.join(backupPath, target);\n\n      if (await fs.pathExists(sourcePath)) {\n        const stats = await fs.stat(sourcePath);\n\n        if (stats.isDirectory()) {\n          await this.backupDirectory(sourcePath, targetPath, backup);\n        } else {\n          await this.backupFile(sourcePath, targetPath, backup, target);\n        }\n      }\n    }\n\n    // Save backup manifest\n    const manifestPath = path.join(backupPath, 'backup-manifest.json');\n    await fs.writeJson(manifestPath, backup, { spaces: 2 });\n\n    // Update backup index\n    await this.updateBackupIndex(backup);\n\n    logger.success(`Backup created with ${backup.files.length} files`);\n    return backup;\n  }\n\n  private async backupDirectory(\n    sourcePath: string,\n    targetPath: string,\n    backup: MigrationBackup,\n  ): Promise<void> {\n    await fs.ensureDir(targetPath);\n\n    const entries = await fs.readdir(sourcePath);\n\n    for (const entry of entries) {\n      const entrySource = path.join(sourcePath, entry);\n      const entryTarget = path.join(targetPath, entry);\n      const stats = await fs.stat(entrySource);\n\n      if (stats.isDirectory()) {\n        await this.backupDirectory(entrySource, entryTarget, backup);\n      } else {\n        const relativePath = path.relative(this.projectPath, entrySource);\n        await this.backupFile(entrySource, entryTarget, backup, relativePath);\n      }\n    }\n  }\n\n  private async backupFile(\n    sourcePath: string,\n    targetPath: string,\n    backup: MigrationBackup,\n    relativePath: string,\n  ): Promise<void> {\n    const content = await fs.readFile(sourcePath, 'utf-8');\n    const checksum = crypto.createHash('sha256').update(content).digest('hex');\n\n    await fs.ensureDir(path.dirname(targetPath));\n    await fs.writeFile(targetPath, content);\n\n    const backupFile: BackupFile = {\n      path: relativePath,\n      content,\n      checksum,\n      permissions: (await fs.stat(sourcePath)).mode.toString(8),\n    };\n\n    backup.files.push(backupFile);\n  }\n\n  async listBackups(): Promise<MigrationBackup[]> {\n    if (!(await fs.pathExists(this.backupDir))) {\n      return [];\n    }\n\n    const backupFolders = await fs.readdir(this.backupDir);\n    const backups: MigrationBackup[] = [];\n\n    for (const folder of backupFolders.sort().reverse()) {\n      const manifestPath = path.join(this.backupDir, folder, 'backup-manifest.json');\n\n      if (await fs.pathExists(manifestPath)) {\n        try {\n          const backup = await fs.readJson(manifestPath);\n          backups.push(backup);\n        } catch (error) {\n          logger.warn(\n            `Invalid backup manifest in ${folder}: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n    }\n\n    return backups;\n  }\n\n  async rollback(backupId?: string, interactive: boolean = true): Promise<void> {\n    const backups = await this.listBackups();\n\n    if (backups.length === 0) {\n      throw new Error('No backups found');\n    }\n\n    let selectedBackup: MigrationBackup;\n\n    if (backupId) {\n      selectedBackup = backups.find((b) => b.metadata.backupId === backupId);\n      if (!selectedBackup) {\n        throw new Error(`Backup not found: ${backupId}`);\n      }\n    } else if (interactive) {\n      selectedBackup = await this.selectBackupInteractively(backups);\n    } else {\n      selectedBackup = backups[0]; // Most recent\n    }\n\n    logger.info(`Rolling back to backup from ${selectedBackup.timestamp.toISOString()}...`);\n\n    // Confirm rollback\n    if (interactive) {\n      const confirm = await inquirer.prompt([\n        {\n          type: 'confirm',\n          name: 'proceed',\n          message: `Are you sure you want to rollback? This will overwrite current files.`,\n          default: false,\n        },\n      ]);\n\n      if (!confirm.proceed) {\n        logger.info('Rollback cancelled');\n        return;\n      }\n    }\n\n    // Create pre-rollback backup\n    const preRollbackBackup = await this.createBackup({\n      type: 'pre-rollback',\n      rollingBackTo: selectedBackup.metadata.backupId,\n    });\n\n    try {\n      // Restore files\n      await this.restoreFiles(selectedBackup);\n\n      // Validate restoration\n      await this.validateRestore(selectedBackup);\n\n      logger.success('Rollback completed successfully');\n    } catch (error) {\n      logger.error('Rollback failed, attempting to restore pre-rollback state...');\n\n      try {\n        await this.restoreFiles(preRollbackBackup);\n        logger.success('Pre-rollback state restored');\n      } catch (restoreError) {\n        logger.error('Failed to restore pre-rollback state:', restoreError);\n        throw new Error('Rollback failed and unable to restore previous state');\n      }\n\n      throw error;\n    }\n  }\n\n  private async selectBackupInteractively(backups: MigrationBackup[]): Promise<MigrationBackup> {\n    const choices = backups.map((backup) => ({\n      name: `${backup.timestamp.toLocaleString()} - ${backup.files.length} files (${backup.metadata.type || 'migration'})`,\n      value: backup,\n      short: backup.metadata.backupId,\n    }));\n\n    const answer = await inquirer.prompt([\n      {\n        type: 'list',\n        name: 'backup',\n        message: 'Select backup to rollback to:',\n        choices,\n        pageSize: 10,\n      },\n    ]);\n\n    return answer.backup;\n  }\n\n  private async restoreFiles(backup: MigrationBackup): Promise<void> {\n    logger.info(`Restoring ${backup.files.length} files...`);\n\n    for (const file of backup.files) {\n      const targetPath = path.join(this.projectPath, file.path);\n\n      logger.debug(`Restoring ${file.path}`);\n\n      await fs.ensureDir(path.dirname(targetPath));\n      await fs.writeFile(targetPath, file.content);\n\n      // Restore permissions if available\n      if (file.permissions) {\n        try {\n          await fs.chmod(targetPath, parseInt(file.permissions, 8));\n        } catch (error) {\n          logger.warn(\n            `Could not restore permissions for ${file.path}: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n    }\n  }\n\n  private async validateRestore(backup: MigrationBackup): Promise<void> {\n    logger.info('Validating restored files...');\n\n    const errors: string[] = [];\n\n    for (const file of backup.files) {\n      const filePath = path.join(this.projectPath, file.path);\n\n      if (!(await fs.pathExists(filePath))) {\n        errors.push(`Missing file: ${file.path}`);\n        continue;\n      }\n\n      const content = await fs.readFile(filePath, 'utf-8');\n      const checksum = crypto.createHash('sha256').update(content).digest('hex');\n\n      if (checksum !== file.checksum) {\n        errors.push(`Checksum mismatch: ${file.path}`);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Validation failed:\\n${errors.join('\\n')}`);\n    }\n\n    logger.success('Validation passed');\n  }\n\n  async cleanupOldBackups(retentionDays: number = 30, maxBackups: number = 10): Promise<void> {\n    const backups = await this.listBackups();\n\n    if (backups.length <= maxBackups) {\n      return; // No cleanup needed\n    }\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n    const backupsToDelete = backups.filter((backup, index) => {\n      // Keep the most recent maxBackups\n      if (index < maxBackups) {\n        return false;\n      }\n\n      // Delete old backups\n      return backup.timestamp < cutoffDate;\n    });\n\n    if (backupsToDelete.length === 0) {\n      return;\n    }\n\n    logger.info(`Cleaning up ${backupsToDelete.length} old backups...`);\n\n    for (const backup of backupsToDelete) {\n      const backupPath = path.join(this.backupDir, backup.metadata.backupId);\n      await fs.remove(backupPath);\n      logger.debug(`Removed backup: ${backup.metadata.backupId}`);\n    }\n\n    logger.success(`Cleanup completed, removed ${backupsToDelete.length} backups`);\n  }\n\n  async getBackupInfo(backupId: string): Promise<MigrationBackup | null> {\n    const backups = await this.listBackups();\n    return backups.find((b) => b.metadata.backupId === backupId) || null;\n  }\n\n  async exportBackup(backupId: string, exportPath: string): Promise<void> {\n    const backup = await this.getBackupInfo(backupId);\n    if (!backup) {\n      throw new Error(`Backup not found: ${backupId}`);\n    }\n\n    const backupPath = path.join(this.backupDir, backup.metadata.backupId);\n    await fs.copy(backupPath, exportPath);\n\n    logger.success(`Backup exported to ${exportPath}`);\n  }\n\n  async importBackup(importPath: string): Promise<MigrationBackup> {\n    const manifestPath = path.join(importPath, 'backup-manifest.json');\n\n    if (!(await fs.pathExists(manifestPath))) {\n      throw new Error('Invalid backup: missing manifest');\n    }\n\n    const backup = await fs.readJson(manifestPath);\n    const backupPath = path.join(this.backupDir, backup.metadata.backupId);\n\n    await fs.copy(importPath, backupPath);\n    await this.updateBackupIndex(backup);\n\n    logger.success(`Backup imported: ${backup.metadata.backupId}`);\n    return backup;\n  }\n\n  private async updateBackupIndex(backup: MigrationBackup): Promise<void> {\n    const indexPath = path.join(this.backupDir, 'backup-index.json');\n\n    let index: Record<string, any> = {};\n    if (await fs.pathExists(indexPath)) {\n      index = await fs.readJson(indexPath);\n    }\n\n    index[backup.metadata.backupId] = {\n      timestamp: backup.timestamp,\n      version: backup.version,\n      fileCount: backup.files.length,\n      metadata: backup.metadata,\n    };\n\n    await fs.writeJson(indexPath, index, { spaces: 2 });\n  }\n\n  printBackupSummary(backups: MigrationBackup[]): void {\n    if (backups.length === 0) {\n      console.log(chalk.yellow('No backups found'));\n      return;\n    }\n\n    console.log(chalk.bold('\\n💾 Available Backups'));\n    console.log(chalk.gray('─'.repeat(70)));\n\n    backups.forEach((backup, index) => {\n      const isRecent = index === 0;\n      const date = backup.timestamp.toLocaleString();\n      const type = backup.metadata.type || 'migration';\n      const fileCount = backup.files.length;\n\n      console.log(\n        `\\n${isRecent ? chalk.green('●') : chalk.gray('○')} ${chalk.bold(backup.metadata.backupId)}`,\n      );\n      console.log(`  ${chalk.gray('Date:')} ${date}`);\n      console.log(`  ${chalk.gray('Type:')} ${type}`);\n      console.log(`  ${chalk.gray('Files:')} ${fileCount}`);\n\n      if (backup.metadata.strategy) {\n        console.log(`  ${chalk.gray('Strategy:')} ${backup.metadata.strategy}`);\n      }\n    });\n\n    console.log(chalk.gray('\\n' + '─'.repeat(70)));\n  }\n}\n"],"names":["fs","path","crypto","logger","chalk","inquirer","RollbackManager","projectPath","backupDir","join","createBackup","metadata","timestamp","Date","backupId","toISOString","replace","backupPath","info","ensureDir","backup","version","files","backupTargets","target","sourcePath","targetPath","pathExists","stats","stat","isDirectory","backupDirectory","backupFile","manifestPath","writeJson","spaces","updateBackupIndex","success","length","entries","readdir","entry","entrySource","entryTarget","relativePath","relative","content","readFile","checksum","createHash","update","digest","dirname","writeFile","permissions","mode","toString","push","listBackups","backupFolders","backups","folder","sort","reverse","readJson","error","warn","Error","message","String","rollback","interactive","selectedBackup","find","b","selectBackupInteractively","confirm","prompt","type","name","default","proceed","preRollbackBackup","rollingBackTo","restoreFiles","validateRestore","restoreError","choices","map","toLocaleString","value","short","answer","pageSize","file","debug","chmod","parseInt","errors","filePath","cleanupOldBackups","retentionDays","maxBackups","cutoffDate","setDate","getDate","backupsToDelete","filter","index","remove","getBackupInfo","exportBackup","exportPath","copy","importBackup","importPath","indexPath","fileCount","printBackupSummary","console","log","yellow","bold","gray","repeat","forEach","isRecent","date","green","strategy"],"mappings":"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"}