{"version":3,"sources":["../../../src/permissions/permission-manager.ts"],"sourcesContent":["/**\n * Permission Manager - 4-Level Hierarchical Permissions\n *\n * Implements hierarchical permission system with fallback chain:\n * USER (global) → PROJECT (.claude-flow/) → LOCAL (file-based) → SESSION (runtime)\n *\n * Features:\n * - Fast permission resolution with caching\n * - Granular control at each level\n * - Override capabilities\n * - Automatic fallback chain\n * - Thread-safe operations\n */\n\nimport { readFile, writeFile, mkdir, access } from 'fs/promises';\nimport { join, dirname } from 'path';\nimport { constants } from 'fs';\nimport type { PermissionBehavior, PermissionRuleValue, PermissionUpdate } from '@anthropic-ai/claude-code/sdk';\n\n// ===== Core Permission Types =====\n\nexport type PermissionLevel = 'user' | 'project' | 'local' | 'session';\n\nexport interface PermissionRule {\n  toolName: string;\n  ruleContent?: string;\n  behavior: PermissionBehavior;\n  scope: PermissionLevel;\n  priority: number;\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface PermissionConfig {\n  mode: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan';\n  rules: PermissionRule[];\n  allowedDirectories: string[];\n  deniedDirectories: string[];\n  metadata?: Record<string, any>;\n}\n\nexport interface PermissionQuery {\n  toolName: string;\n  toolInput?: Record<string, unknown>;\n  context?: {\n    sessionId?: string;\n    workingDir?: string;\n    agentType?: string;\n  };\n}\n\nexport interface PermissionResolution {\n  behavior: PermissionBehavior;\n  level: PermissionLevel;\n  rule?: PermissionRule;\n  fallbackChain: PermissionLevel[];\n  cached: boolean;\n  resolutionTime: number;\n}\n\n// ===== Cache Entry =====\n\ninterface CacheEntry {\n  resolution: PermissionResolution;\n  timestamp: number;\n}\n\n// ===== Permission Manager Class =====\n\nexport class PermissionManager {\n  private userConfig?: PermissionConfig;\n  private projectConfig?: PermissionConfig;\n  private localConfig?: PermissionConfig;\n  private sessionConfig: PermissionConfig;\n\n  private cache: Map<string, CacheEntry> = new Map();\n  private cacheEnabled: boolean;\n  private cacheTTL: number;\n\n  private userConfigPath?: string;\n  private projectConfigPath?: string;\n  private localConfigPath?: string;\n\n  constructor(options?: {\n    cacheEnabled?: boolean;\n    cacheTTL?: number;\n    userConfigPath?: string;\n    projectConfigPath?: string;\n    localConfigPath?: string;\n  }) {\n    this.cacheEnabled = options?.cacheEnabled ?? true;\n    this.cacheTTL = options?.cacheTTL ?? 300000; // 5 minutes default\n\n    this.userConfigPath = options?.userConfigPath;\n    this.projectConfigPath = options?.projectConfigPath;\n    this.localConfigPath = options?.localConfigPath;\n\n    // Initialize session config\n    this.sessionConfig = this.createDefaultConfig('session');\n  }\n\n  /**\n   * Initialize permission manager by loading all configs\n   */\n  async initialize(): Promise<void> {\n    await Promise.allSettled([\n      this.loadUserConfig(),\n      this.loadProjectConfig(),\n      this.loadLocalConfig(),\n    ]);\n  }\n\n  /**\n   * Resolve permission for a query using fallback chain\n   */\n  async resolvePermission(query: PermissionQuery): Promise<PermissionResolution> {\n    const startTime = Date.now();\n\n    // Check cache\n    if (this.cacheEnabled) {\n      const cacheKey = this.generateCacheKey(query);\n      const cached = this.cache.get(cacheKey);\n\n      if (cached && (Date.now() - cached.timestamp) < this.cacheTTL) {\n        return {\n          ...cached.resolution,\n          cached: true,\n          resolutionTime: Date.now() - startTime,\n        };\n      }\n    }\n\n    // Resolve using fallback chain: SESSION → LOCAL → PROJECT → USER\n    const fallbackChain: PermissionLevel[] = ['session', 'local', 'project', 'user'];\n\n    for (const level of fallbackChain) {\n      const rule = this.findRule(query, level);\n\n      if (rule) {\n        const resolution: PermissionResolution = {\n          behavior: rule.behavior,\n          level,\n          rule,\n          fallbackChain: fallbackChain.slice(0, fallbackChain.indexOf(level) + 1),\n          cached: false,\n          resolutionTime: Date.now() - startTime,\n        };\n\n        // Cache result\n        if (this.cacheEnabled) {\n          this.cache.set(this.generateCacheKey(query), {\n            resolution,\n            timestamp: Date.now(),\n          });\n        }\n\n        return resolution;\n      }\n    }\n\n    // No rule found, use default 'ask' behavior\n    return {\n      behavior: 'ask',\n      level: 'session',\n      fallbackChain,\n      cached: false,\n      resolutionTime: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Update permissions at specified level\n   */\n  async updatePermissions(\n    level: PermissionLevel,\n    update: PermissionUpdate\n  ): Promise<void> {\n    const config = this.getConfigForLevel(level);\n\n    switch (update.type) {\n      case 'addRules':\n        this.addRules(config, update.rules, update.behavior);\n        break;\n\n      case 'replaceRules':\n        this.replaceRules(config, update.rules, update.behavior);\n        break;\n\n      case 'removeRules':\n        this.removeRules(config, update.rules);\n        break;\n\n      case 'setMode':\n        config.mode = update.mode;\n        break;\n\n      case 'addDirectories':\n        config.allowedDirectories.push(...update.directories);\n        break;\n\n      case 'removeDirectories':\n        config.allowedDirectories = config.allowedDirectories.filter(\n          d => !update.directories.includes(d)\n        );\n        break;\n    }\n\n    // Clear cache on updates\n    this.clearCache();\n\n    // Persist changes for persistent levels\n    if (level !== 'session') {\n      await this.saveConfig(level, config);\n    }\n  }\n\n  /**\n   * Get current configuration for a level\n   */\n  getConfig(level: PermissionLevel): PermissionConfig | undefined {\n    switch (level) {\n      case 'user':\n        return this.userConfig;\n      case 'project':\n        return this.projectConfig;\n      case 'local':\n        return this.localConfig;\n      case 'session':\n        return this.sessionConfig;\n    }\n  }\n\n  /**\n   * Clear permission cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; entries: number } {\n    return {\n      size: this.cache.size,\n      entries: this.cache.size,\n    };\n  }\n\n  /**\n   * Prune expired cache entries\n   */\n  pruneCache(): number {\n    const now = Date.now();\n    let pruned = 0;\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp >= this.cacheTTL) {\n        this.cache.delete(key);\n        pruned++;\n      }\n    }\n\n    return pruned;\n  }\n\n  // ===== Private Methods =====\n\n  private async loadUserConfig(): Promise<void> {\n    if (!this.userConfigPath) return;\n\n    try {\n      await access(this.userConfigPath, constants.R_OK);\n      const content = await readFile(this.userConfigPath, 'utf-8');\n      this.userConfig = JSON.parse(content);\n    } catch (error) {\n      // Create default if not exists\n      this.userConfig = this.createDefaultConfig('user');\n    }\n  }\n\n  private async loadProjectConfig(): Promise<void> {\n    if (!this.projectConfigPath) return;\n\n    try {\n      await access(this.projectConfigPath, constants.R_OK);\n      const content = await readFile(this.projectConfigPath, 'utf-8');\n      this.projectConfig = JSON.parse(content);\n    } catch (error) {\n      // Create default if not exists\n      this.projectConfig = this.createDefaultConfig('project');\n    }\n  }\n\n  private async loadLocalConfig(): Promise<void> {\n    if (!this.localConfigPath) return;\n\n    try {\n      await access(this.localConfigPath, constants.R_OK);\n      const content = await readFile(this.localConfigPath, 'utf-8');\n      this.localConfig = JSON.parse(content);\n    } catch (error) {\n      // Create default if not exists\n      this.localConfig = this.createDefaultConfig('local');\n    }\n  }\n\n  private async saveConfig(level: PermissionLevel, config: PermissionConfig): Promise<void> {\n    let configPath: string | undefined;\n\n    switch (level) {\n      case 'user':\n        configPath = this.userConfigPath;\n        break;\n      case 'project':\n        configPath = this.projectConfigPath;\n        break;\n      case 'local':\n        configPath = this.localConfigPath;\n        break;\n    }\n\n    if (!configPath) return;\n\n    // Ensure directory exists\n    await mkdir(dirname(configPath), { recursive: true });\n\n    // Write config\n    await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');\n  }\n\n  private findRule(query: PermissionQuery, level: PermissionLevel): PermissionRule | undefined {\n    const config = this.getConfigForLevel(level);\n    if (!config) return undefined;\n\n    // Check if mode bypasses rules\n    if (config.mode === 'bypassPermissions') {\n      return {\n        toolName: '*',\n        behavior: 'allow',\n        scope: level,\n        priority: 1000,\n        timestamp: Date.now(),\n      };\n    }\n\n    // Find matching rule with highest priority\n    return config.rules\n      .filter(rule => this.ruleMatches(rule, query))\n      .sort((a, b) => b.priority - a.priority)[0];\n  }\n\n  private ruleMatches(rule: PermissionRule, query: PermissionQuery): boolean {\n    // Exact match\n    if (rule.toolName === query.toolName) {\n      return this.ruleContentMatches(rule, query);\n    }\n\n    // Wildcard match\n    if (rule.toolName === '*') {\n      return this.ruleContentMatches(rule, query);\n    }\n\n    // Pattern match (simple glob-style)\n    if (rule.toolName.includes('*')) {\n      const pattern = rule.toolName.replace(/\\*/g, '.*');\n      if (new RegExp(`^${pattern}$`).test(query.toolName)) {\n        return this.ruleContentMatches(rule, query);\n      }\n    }\n\n    return false;\n  }\n\n  private ruleContentMatches(rule: PermissionRule, query: PermissionQuery): boolean {\n    if (!rule.ruleContent || !query.toolInput) {\n      return true; // No content means rule applies to all\n    }\n\n    // Simple string matching for now\n    // In production, this would parse ruleContent and match against toolInput\n    return true;\n  }\n\n  private getConfigForLevel(level: PermissionLevel): PermissionConfig {\n    switch (level) {\n      case 'user':\n        if (!this.userConfig) {\n          this.userConfig = this.createDefaultConfig('user');\n        }\n        return this.userConfig;\n\n      case 'project':\n        if (!this.projectConfig) {\n          this.projectConfig = this.createDefaultConfig('project');\n        }\n        return this.projectConfig;\n\n      case 'local':\n        if (!this.localConfig) {\n          this.localConfig = this.createDefaultConfig('local');\n        }\n        return this.localConfig;\n\n      case 'session':\n        return this.sessionConfig;\n    }\n  }\n\n  private createDefaultConfig(scope: PermissionLevel): PermissionConfig {\n    return {\n      mode: 'default',\n      rules: [],\n      allowedDirectories: [],\n      deniedDirectories: [],\n      metadata: {\n        scope,\n        created: Date.now(),\n      },\n    };\n  }\n\n  private addRules(\n    config: PermissionConfig,\n    rules: PermissionRuleValue[],\n    behavior: PermissionBehavior\n  ): void {\n    const newRules: PermissionRule[] = rules.map((r, index) => ({\n      ...r,\n      behavior,\n      scope: config.metadata?.scope || 'session',\n      priority: 100 + index,\n      timestamp: Date.now(),\n    }));\n\n    config.rules.push(...newRules);\n  }\n\n  private replaceRules(\n    config: PermissionConfig,\n    rules: PermissionRuleValue[],\n    behavior: PermissionBehavior\n  ): void {\n    config.rules = rules.map((r, index) => ({\n      ...r,\n      behavior,\n      scope: config.metadata?.scope || 'session',\n      priority: 100 + index,\n      timestamp: Date.now(),\n    }));\n  }\n\n  private removeRules(config: PermissionConfig, rules: PermissionRuleValue[]): void {\n    const toRemove = new Set(rules.map(r => `${r.toolName}:${r.ruleContent || ''}`));\n\n    config.rules = config.rules.filter(rule => {\n      const key = `${rule.toolName}:${rule.ruleContent || ''}`;\n      return !toRemove.has(key);\n    });\n  }\n\n  private generateCacheKey(query: PermissionQuery): string {\n    return JSON.stringify({\n      tool: query.toolName,\n      input: query.toolInput,\n      session: query.context?.sessionId,\n    });\n  }\n}\n\n// ===== Factory Functions =====\n\nexport function createPermissionManager(options?: {\n  workingDir?: string;\n  cacheEnabled?: boolean;\n  cacheTTL?: number;\n}): PermissionManager {\n  const workingDir = options?.workingDir || process.cwd();\n\n  return new PermissionManager({\n    cacheEnabled: options?.cacheEnabled,\n    cacheTTL: options?.cacheTTL,\n    userConfigPath: join(process.env.HOME || '~', '.claude-flow', 'permissions.json'),\n    projectConfigPath: join(workingDir, '.claude-flow', 'permissions.json'),\n    localConfigPath: join(workingDir, '.permissions.json'),\n  });\n}\n\n// Export singleton instance\nexport const permissionManager = createPermissionManager({\n  cacheEnabled: true,\n  cacheTTL: 300000,\n});"],"names":["readFile","writeFile","mkdir","access","join","dirname","constants","PermissionManager","userConfig","projectConfig","localConfig","sessionConfig","cache","Map","cacheEnabled","cacheTTL","userConfigPath","projectConfigPath","localConfigPath","options","createDefaultConfig","initialize","Promise","allSettled","loadUserConfig","loadProjectConfig","loadLocalConfig","resolvePermission","query","startTime","Date","now","cacheKey","generateCacheKey","cached","get","timestamp","resolution","resolutionTime","fallbackChain","level","rule","findRule","behavior","slice","indexOf","set","updatePermissions","update","config","getConfigForLevel","type","addRules","rules","replaceRules","removeRules","mode","allowedDirectories","push","directories","filter","d","includes","clearCache","saveConfig","getConfig","clear","getCacheStats","size","entries","pruneCache","pruned","key","entry","delete","R_OK","content","JSON","parse","error","configPath","recursive","stringify","undefined","toolName","scope","priority","ruleMatches","sort","a","b","ruleContentMatches","pattern","replace","RegExp","test","ruleContent","toolInput","deniedDirectories","metadata","created","newRules","map","r","index","toRemove","Set","has","tool","input","session","context","sessionId","createPermissionManager","workingDir","process","cwd","env","HOME","permissionManager"],"mappings":"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"}