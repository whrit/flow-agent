{"version":3,"sources":["../../../src/neural/index.ts"],"sourcesContent":["/**\n * Neural Module - Advanced Domain Mapping and GNN Analysis\n * \n * This module provides Graph Neural Network (GNN) based domain relationship\n * mapping, analysis, and optimization capabilities for Claude Flow.\n * \n * Key Features:\n * - Domain structure to graph conversion\n * - GNN-based relationship analysis\n * - Domain cohesion scoring\n * - Cross-domain dependency identification\n * - Predictive boundary optimization\n * - Neural network training and inference\n * - Integration with Claude Flow hooks system\n * \n * @author Claude Flow Neural Team\n * @version 2.0.0\n */\n\n// Core exports\nexport {\n  NeuralDomainMapper,\n  type DomainNode,\n  type DomainEdge,\n  type DomainGraph,\n  type CohesionAnalysis,\n  type DependencyAnalysis,\n  type BoundaryOptimization,\n  type GNNLayerConfig,\n  type TrainingConfig,\n} from './NeuralDomainMapper.js';\n\n// Integration exports\nexport {\n  NeuralDomainMapperIntegration,\n  createDomainMapperIntegration,\n  type DomainMapperIntegrationConfig,\n  type DomainAnalysisResult,\n} from './integration.js';\n\n// Re-export commonly used types from the hooks system\nexport type {\n  Pattern,\n  TrainingData,\n  Prediction,\n  Adaptation,\n  AgenticHookContext,\n  NeuralHookPayload,\n} from '../services/agentic-flow-hooks/types.js';\n\n/**\n * Neural module version\n */\nexport const NEURAL_MODULE_VERSION = '2.0.0';\n\n/**\n * Default configurations for common use cases\n */\nexport const DEFAULT_CONFIGS = {\n  /**\n   * Configuration for small-scale domain analysis (< 50 domains)\n   */\n  SMALL_SCALE: {\n    training: {\n      learningRate: 0.01,\n      batchSize: 16,\n      epochs: 50,\n      optimizer: 'adam' as const,\n      lossFunction: 'mse' as const,\n      regularization: {\n        l1: 0.0001,\n        l2: 0.0001,\n        dropout: 0.1,\n      },\n      earlyStoping: {\n        enabled: true,\n        patience: 10,\n        minDelta: 0.001,\n      },\n      validationSplit: 0.2,\n    },\n    integration: {\n      enableAutoAnalysis: true,\n      enableOptimizationSuggestions: true,\n      enableContinuousLearning: true,\n      confidenceThreshold: 0.6,\n      analysisInterval: 60000, // 1 minute\n      maxOptimizationProposals: 5,\n    },\n  },\n\n  /**\n   * Configuration for medium-scale domain analysis (50-200 domains)\n   */\n  MEDIUM_SCALE: {\n    training: {\n      learningRate: 0.005,\n      batchSize: 32,\n      epochs: 100,\n      optimizer: 'adam' as const,\n      lossFunction: 'mse' as const,\n      regularization: {\n        l1: 0.0001,\n        l2: 0.0001,\n        dropout: 0.15,\n      },\n      earlyStoping: {\n        enabled: true,\n        patience: 15,\n        minDelta: 0.0005,\n      },\n      validationSplit: 0.2,\n    },\n    integration: {\n      enableAutoAnalysis: true,\n      enableOptimizationSuggestions: true,\n      enableContinuousLearning: true,\n      confidenceThreshold: 0.7,\n      analysisInterval: 30000, // 30 seconds\n      maxOptimizationProposals: 10,\n    },\n  },\n\n  /**\n   * Configuration for large-scale domain analysis (> 200 domains)\n   */\n  LARGE_SCALE: {\n    training: {\n      learningRate: 0.001,\n      batchSize: 64,\n      epochs: 200,\n      optimizer: 'adamw' as const,\n      lossFunction: 'mse' as const,\n      regularization: {\n        l1: 0.0002,\n        l2: 0.0002,\n        dropout: 0.2,\n      },\n      earlyStoping: {\n        enabled: true,\n        patience: 20,\n        minDelta: 0.0001,\n      },\n      validationSplit: 0.15,\n    },\n    integration: {\n      enableAutoAnalysis: true,\n      enableOptimizationSuggestions: true,\n      enableContinuousLearning: false, // Disable for performance\n      confidenceThreshold: 0.8,\n      analysisInterval: 120000, // 2 minutes\n      maxOptimizationProposals: 20,\n    },\n  },\n\n  /**\n   * Configuration for high-frequency real-time analysis\n   */\n  REAL_TIME: {\n    training: {\n      learningRate: 0.01,\n      batchSize: 8,\n      epochs: 20,\n      optimizer: 'sgd' as const,\n      lossFunction: 'mse' as const,\n      regularization: {\n        l1: 0,\n        l2: 0,\n        dropout: 0.05,\n      },\n      earlyStoping: {\n        enabled: true,\n        patience: 5,\n        minDelta: 0.01,\n      },\n      validationSplit: 0.1,\n    },\n    integration: {\n      enableAutoAnalysis: true,\n      enableOptimizationSuggestions: false, // Disable for speed\n      enableContinuousLearning: true,\n      confidenceThreshold: 0.5,\n      analysisInterval: 5000, // 5 seconds\n      maxOptimizationProposals: 3,\n    },\n  },\n} as const;\n\n/**\n * Utility functions for common operations\n */\nexport const NeuralUtils = {\n  /**\n   * Create a simple domain graph from a basic structure\n   */\n  createSimpleDomainGraph: (\n    domains: Array<{ id: string; name: string; type: string }>,\n    relationships: Array<{ source: string; target: string; type?: string }>\n  ) => {\n    const graph: DomainGraph = {\n      nodes: new Map(),\n      edges: new Map(),\n      metadata: {\n        created: Date.now(),\n        lastTraining: 0,\n        version: '1.0.0',\n        cohesionScore: 0,\n        totalNodes: domains.length,\n        totalEdges: relationships.length,\n      },\n    };\n\n    // Add nodes\n    domains.forEach(domain => {\n      const node: DomainNode = {\n        id: domain.id,\n        name: domain.name,\n        type: domain.type as DomainNode['type'],\n        features: Array.from({ length: 64 }, () => Math.random()),\n        metadata: {\n          size: 1,\n          complexity: 0.5,\n          stability: 0.8,\n          dependencies: [],\n          lastUpdated: Date.now(),\n          version: '1.0.0',\n        },\n        activation: 0,\n        embedding: Array.from({ length: 32 }, () => (Math.random() - 0.5) * 0.1),\n      };\n      graph.nodes.set(domain.id, node);\n    });\n\n    // Add edges\n    relationships.forEach(rel => {\n      const edgeId = `${rel.source}->${rel.target}`;\n      const edge: DomainEdge = {\n        source: rel.source,\n        target: rel.target,\n        weight: 1.0,\n        type: (rel.type as DomainEdge['type']) || 'dependency',\n        features: Array.from({ length: 32 }, () => Math.random()),\n        metadata: {\n          frequency: 1,\n          latency: 100,\n          reliability: 0.99,\n          bandwidth: 1000,\n          direction: 'unidirectional',\n        },\n      };\n      graph.edges.set(edgeId, edge);\n    });\n\n    return graph;\n  },\n\n  /**\n   * Generate synthetic training data for testing\n   */\n  generateSyntheticTrainingData: (size: number): TrainingData => {\n    const inputs = Array.from({ length: size }, () => ({\n      features: Array.from({ length: 64 }, () => Math.random()),\n    }));\n\n    const outputs = Array.from({ length: size }, () => \n      Array.from({ length: 4 }, () => Math.random())\n    );\n\n    return {\n      inputs,\n      outputs,\n      batchSize: Math.min(32, size),\n      epochs: Math.max(1, Math.min(50, size / 10)),\n    };\n  },\n\n  /**\n   * Calculate basic domain metrics\n   */\n  calculateBasicMetrics: (graph: DomainGraph) => {\n    const nodeCount = graph.nodes.size;\n    const edgeCount = graph.edges.size;\n    const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;\n\n    // Calculate in/out degree distributions\n    const inDegrees = new Map<string, number>();\n    const outDegrees = new Map<string, number>();\n\n    // Initialize degrees\n    for (const nodeId of graph.nodes.keys()) {\n      inDegrees.set(nodeId, 0);\n      outDegrees.set(nodeId, 0);\n    }\n\n    // Count degrees\n    for (const edge of graph.edges.values()) {\n      outDegrees.set(edge.source, (outDegrees.get(edge.source) || 0) + 1);\n      inDegrees.set(edge.target, (inDegrees.get(edge.target) || 0) + 1);\n    }\n\n    const avgInDegree = Array.from(inDegrees.values()).reduce((sum, deg) => sum + deg, 0) / nodeCount;\n    const avgOutDegree = Array.from(outDegrees.values()).reduce((sum, deg) => sum + deg, 0) / nodeCount;\n\n    return {\n      nodeCount,\n      edgeCount,\n      density,\n      avgInDegree,\n      avgOutDegree,\n      complexity: Math.log(nodeCount + 1) * density,\n    };\n  },\n\n  /**\n   * Validate domain graph structure\n   */\n  validateDomainGraph: (graph: DomainGraph): {\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  } => {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Check for empty graph\n    if (graph.nodes.size === 0) {\n      errors.push('Graph has no nodes');\n    }\n\n    // Check for orphaned edges\n    for (const edge of graph.edges.values()) {\n      if (!graph.nodes.has(edge.source)) {\n        errors.push(`Edge references non-existent source node: ${edge.source}`);\n      }\n      if (!graph.nodes.has(edge.target)) {\n        errors.push(`Edge references non-existent target node: ${edge.target}`);\n      }\n    }\n\n    // Check for isolated nodes\n    const connectedNodes = new Set<string>();\n    for (const edge of graph.edges.values()) {\n      connectedNodes.add(edge.source);\n      connectedNodes.add(edge.target);\n    }\n\n    for (const nodeId of graph.nodes.keys()) {\n      if (!connectedNodes.has(nodeId)) {\n        warnings.push(`Isolated node detected: ${nodeId}`);\n      }\n    }\n\n    // Check for very sparse or very dense graphs\n    const density = NeuralUtils.calculateBasicMetrics(graph).density;\n    if (density < 0.1) {\n      warnings.push('Graph is very sparse (density < 0.1)');\n    } else if (density > 0.8) {\n      warnings.push('Graph is very dense (density > 0.8)');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  },\n};\n\n/**\n * Example usage patterns\n */\nexport const Examples = {\n  /**\n   * Basic domain analysis example\n   */\n  basicAnalysis: async () => {\n    // Create a simple domain mapper\n    const mapper = new NeuralDomainMapper(DEFAULT_CONFIGS.SMALL_SCALE.training);\n\n    // Create a sample domain graph\n    const graph = NeuralUtils.createSimpleDomainGraph(\n      [\n        { id: 'user-service', name: 'User Service', type: 'api' },\n        { id: 'auth-service', name: 'Authentication Service', type: 'api' },\n        { id: 'user-db', name: 'User Database', type: 'data' },\n        { id: 'user-ui', name: 'User Interface', type: 'ui' },\n      ],\n      [\n        { source: 'user-service', target: 'auth-service', type: 'dependency' },\n        { source: 'user-service', target: 'user-db', type: 'data-flow' },\n        { source: 'user-ui', target: 'user-service', type: 'communication' },\n      ]\n    );\n\n    // Perform analysis\n    const analysis = await mapper.analyzeDomains(graph);\n    \n    return {\n      cohesionScore: analysis.cohesion.overallScore,\n      dependencyCount: analysis.dependencies.graph.size,\n      optimizationProposals: analysis.optimization.proposals.length,\n      recommendations: analysis.recommendations,\n    };\n  },\n\n  /**\n   * Training and prediction example\n   */\n  trainingExample: async () => {\n    const mapper = new NeuralDomainMapper(DEFAULT_CONFIGS.MEDIUM_SCALE.training);\n\n    // Generate synthetic training data\n    const trainingData = NeuralUtils.generateSyntheticTrainingData(100);\n    const validationData = NeuralUtils.generateSyntheticTrainingData(20);\n\n    // Train the model\n    const trainingResult = await mapper.train(trainingData, validationData);\n\n    // Make a prediction\n    const prediction = await mapper.predict({\n      features: Array.from({ length: 64 }, () => Math.random()),\n    });\n\n    return {\n      finalAccuracy: trainingResult.finalAccuracy,\n      trainingEpochs: trainingResult.trainingHistory.length,\n      predictionConfidence: prediction.confidence,\n      alternativeCount: prediction.alternatives.length,\n    };\n  },\n\n  /**\n   * Integration with hooks system example\n   */\n  integrationExample: async () => {\n    // Create integrated domain mapper\n    const integration = await createDomainMapperIntegration(\n      DEFAULT_CONFIGS.MEDIUM_SCALE.integration\n    );\n\n    // Set up event listeners\n    integration.on('domain-analysis-completed', (result: DomainAnalysisResult) => {\n      console.log(`Analysis completed: ${result.cohesion.overallScore} cohesion score`);\n    });\n\n    integration.on('optimization-suggestions-generated', (result: any) => {\n      console.log(`${result.prioritizedActions.length} optimization suggestions generated`);\n    });\n\n    // Get integration statistics\n    const stats = integration.getIntegrationStats();\n\n    return {\n      initialized: true,\n      stats,\n    };\n  },\n};\n\n// Default export for convenience\nexport default {\n  NeuralDomainMapper,\n  NeuralDomainMapperIntegration,\n  createDomainMapperIntegration,\n  DEFAULT_CONFIGS,\n  NeuralUtils,\n  Examples,\n  NEURAL_MODULE_VERSION,\n};"],"names":["NeuralDomainMapper","NeuralDomainMapperIntegration","createDomainMapperIntegration","NEURAL_MODULE_VERSION","DEFAULT_CONFIGS","SMALL_SCALE","training","learningRate","batchSize","epochs","optimizer","lossFunction","regularization","l1","l2","dropout","earlyStoping","enabled","patience","minDelta","validationSplit","integration","enableAutoAnalysis","enableOptimizationSuggestions","enableContinuousLearning","confidenceThreshold","analysisInterval","maxOptimizationProposals","MEDIUM_SCALE","LARGE_SCALE","REAL_TIME","NeuralUtils","createSimpleDomainGraph","domains","relationships","graph","nodes","Map","edges","metadata","created","Date","now","lastTraining","version","cohesionScore","totalNodes","length","totalEdges","forEach","domain","node","id","name","type","features","Array","from","Math","random","size","complexity","stability","dependencies","lastUpdated","activation","embedding","set","rel","edgeId","source","target","edge","weight","frequency","latency","reliability","bandwidth","direction","generateSyntheticTrainingData","inputs","outputs","min","max","calculateBasicMetrics","nodeCount","edgeCount","density","inDegrees","outDegrees","nodeId","keys","values","get","avgInDegree","reduce","sum","deg","avgOutDegree","log","validateDomainGraph","errors","warnings","push","has","connectedNodes","Set","add","valid","Examples","basicAnalysis","mapper","analysis","analyzeDomains","cohesion","overallScore","dependencyCount","optimizationProposals","optimization","proposals","recommendations","trainingExample","trainingData","validationData","trainingResult","train","prediction","predict","finalAccuracy","trainingEpochs","trainingHistory","predictionConfidence","confidence","alternativeCount","alternatives","integrationExample","on","result","console","prioritizedActions","stats","getIntegrationStats","initialized"],"mappings":"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"}