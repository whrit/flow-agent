{"version":3,"sources":["../../../src/neural/integration.ts"],"sourcesContent":["/**\n * Neural Domain Mapper Integration Module\n * \n * Provides integration between NeuralDomainMapper and the existing\n * Claude Flow neural hooks system, enabling seamless domain analysis\n * and optimization within the broader orchestration framework.\n * \n * @author Claude Flow Neural Team\n * @version 2.0.0\n */\n\nimport { EventEmitter } from 'events';\nimport { NeuralDomainMapper, type DomainGraph, type CohesionAnalysis, type DependencyAnalysis, type BoundaryOptimization } from './NeuralDomainMapper.js';\nimport type {\n  AgenticHookContext,\n  NeuralHookPayload,\n  Pattern,\n  TrainingData,\n  Prediction,\n  SideEffect,\n} from '../services/agentic-flow-hooks/types.js';\nimport { agenticHookManager } from '../services/agentic-flow-hooks/hook-manager.js';\n\n/**\n * Domain mapping integration configuration\n */\nexport interface DomainMapperIntegrationConfig {\n  /** Enable automatic domain analysis on pattern detection */\n  enableAutoAnalysis: boolean;\n  /** Enable domain boundary optimization suggestions */\n  enableOptimizationSuggestions: boolean;\n  /** Enable continuous learning from domain changes */\n  enableContinuousLearning: boolean;\n  /** Minimum confidence threshold for suggestions */\n  confidenceThreshold: number;\n  /** Analysis frequency in milliseconds */\n  analysisInterval: number;\n  /** Maximum number of optimization proposals */\n  maxOptimizationProposals: number;\n}\n\n/**\n * Domain analysis result with context\n */\nexport interface DomainAnalysisResult {\n  /** Analysis timestamp */\n  timestamp: number;\n  /** Session correlation ID */\n  correlationId: string;\n  /** Domain graph analyzed */\n  graph: DomainGraph;\n  /** Cohesion analysis results */\n  cohesion: CohesionAnalysis;\n  /** Dependency analysis results */\n  dependencies: DependencyAnalysis;\n  /** Boundary optimization suggestions */\n  optimization: BoundaryOptimization;\n  /** Generated patterns from analysis */\n  patterns: Pattern[];\n  /** Performance metrics */\n  metrics: {\n    analysisTime: number;\n    nodesAnalyzed: number;\n    edgesAnalyzed: number;\n    patternsDetected: number;\n  };\n}\n\n/**\n * Neural Domain Mapper Integration Class\n * \n * This class provides seamless integration between the NeuralDomainMapper\n * and the existing Claude Flow neural hooks system. It automatically\n * analyzes domain structures, generates optimization suggestions, and\n * learns from domain relationship patterns.\n */\nexport class NeuralDomainMapperIntegration extends EventEmitter {\n  private domainMapper: NeuralDomainMapper;\n  private config: DomainMapperIntegrationConfig;\n  private analysisHistory: DomainAnalysisResult[] = [];\n  private activeAnalysis: Map<string, Promise<DomainAnalysisResult>> = new Map();\n  private learningPatterns: Pattern[] = [];\n  private isInitialized: boolean = false;\n\n  constructor(\n    domainMapper?: NeuralDomainMapper,\n    config: Partial<DomainMapperIntegrationConfig> = {}\n  ) {\n    super();\n\n    this.config = {\n      enableAutoAnalysis: true,\n      enableOptimizationSuggestions: true,\n      enableContinuousLearning: true,\n      confidenceThreshold: 0.7,\n      analysisInterval: 30000, // 30 seconds\n      maxOptimizationProposals: 10,\n      ...config,\n    };\n\n    this.domainMapper = domainMapper || new NeuralDomainMapper();\n    \n    // Set up event listeners\n    this.setupEventListeners();\n  }\n\n  /**\n   * Initialize the integration system\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    // Register neural hooks for domain analysis\n    this.registerDomainAnalysisHooks();\n\n    // Set up periodic analysis if enabled\n    if (this.config.enableAutoAnalysis) {\n      this.setupPeriodicAnalysis();\n    }\n\n    this.isInitialized = true;\n    this.emit('integration-initialized');\n  }\n\n  /**\n   * Analyze domains and integrate with neural hooks system\n   */\n  public async analyzeDomains(\n    domains: DomainGraph,\n    context: AgenticHookContext\n  ): Promise<DomainAnalysisResult> {\n    const correlationId = context.correlationId;\n    \n    // Check if analysis is already in progress for this correlation ID\n    if (this.activeAnalysis.has(correlationId)) {\n      return await this.activeAnalysis.get(correlationId)!;\n    }\n\n    const analysisPromise = this.performDomainAnalysis(domains, context);\n    this.activeAnalysis.set(correlationId, analysisPromise);\n\n    try {\n      const result = await analysisPromise;\n      \n      // Store analysis history\n      this.analysisHistory.push(result);\n      \n      // Keep only last 100 analyses\n      if (this.analysisHistory.length > 100) {\n        this.analysisHistory.shift();\n      }\n\n      // Generate side effects for the hooks system\n      await this.generateHookSideEffects(result, context);\n\n      // Learn from the analysis if continuous learning is enabled\n      if (this.config.enableContinuousLearning) {\n        await this.learnFromAnalysis(result, context);\n      }\n\n      this.emit('domain-analysis-completed', result);\n      return result;\n\n    } finally {\n      this.activeAnalysis.delete(correlationId);\n    }\n  }\n\n  /**\n   * Train the domain mapper on historical patterns\n   */\n  public async trainOnPatterns(\n    patterns: Pattern[],\n    context: AgenticHookContext\n  ): Promise<{\n    trainingAccuracy: number;\n    patternsProcessed: number;\n    newInsights: string[];\n  }> {\n    // Convert patterns to training data\n    const trainingData = this.convertPatternsToTrainingData(patterns);\n    \n    if (trainingData.inputs.length === 0) {\n      return {\n        trainingAccuracy: 0,\n        patternsProcessed: 0,\n        newInsights: ['No suitable training data found in patterns'],\n      };\n    }\n\n    // Train the domain mapper\n    const trainingResult = await this.domainMapper.train(trainingData);\n    \n    // Analyze what was learned\n    const newInsights = this.extractTrainingInsights(trainingResult, patterns);\n\n    // Store learning patterns for future reference\n    this.learningPatterns.push(...patterns.slice(-50)); // Keep last 50 patterns\n\n    const result = {\n      trainingAccuracy: trainingResult.finalAccuracy,\n      patternsProcessed: patterns.length,\n      newInsights,\n    };\n\n    this.emit('training-completed', result);\n    return result;\n  }\n\n  /**\n   * Get optimization suggestions based on current domain state\n   */\n  public async getOptimizationSuggestions(\n    context: AgenticHookContext\n  ): Promise<{\n    suggestions: BoundaryOptimization;\n    applicability: number;\n    prioritizedActions: Array<{\n      action: string;\n      priority: 'low' | 'medium' | 'high' | 'critical';\n      impact: number;\n      effort: number;\n    }>;\n  }> {\n    // Get current optimization suggestions\n    const optimization = await this.domainMapper.provideBoundaryOptimization();\n    \n    // Calculate applicability based on context\n    const applicability = this.calculateOptimizationApplicability(optimization, context);\n    \n    // Generate prioritized actions\n    const prioritizedActions = this.generatePrioritizedActions(optimization);\n\n    const result = {\n      suggestions: optimization,\n      applicability,\n      prioritizedActions,\n    };\n\n    this.emit('optimization-suggestions-generated', result);\n    return result;\n  }\n\n  /**\n   * Predict domain relationship outcomes\n   */\n  public async predictDomainRelationships(\n    proposedChanges: {\n      newDomains?: Array<{ id: string; name: string; type: string }>;\n      removedDomains?: string[];\n      newRelationships?: Array<{ source: string; target: string; type: string }>;\n      removedRelationships?: Array<{ source: string; target: string }>;\n    },\n    context: AgenticHookContext\n  ): Promise<{\n    predictions: Prediction[];\n    riskAssessment: {\n      overallRisk: number;\n      riskFactors: Array<{\n        factor: string;\n        risk: number;\n        mitigation: string;\n      }>;\n    };\n    recommendations: string[];\n  }> {\n    // Create prediction input from proposed changes\n    const predictionInput = this.createPredictionInput(proposedChanges);\n    \n    // Make predictions\n    const predictions = await Promise.all(\n      predictionInput.map(input => this.domainMapper.predict(input))\n    );\n\n    // Assess risks\n    const riskAssessment = this.assessChangeRisks(proposedChanges, predictions);\n\n    // Generate recommendations\n    const recommendations = this.generateChangeRecommendations(\n      proposedChanges,\n      predictions,\n      riskAssessment\n    );\n\n    const result = {\n      predictions,\n      riskAssessment,\n      recommendations,\n    };\n\n    this.emit('domain-predictions-generated', result);\n    return result;\n  }\n\n  /**\n   * Get integration statistics\n   */\n  public getIntegrationStats(): {\n    analysesPerformed: number;\n    averageAnalysisTime: number;\n    patternsLearned: number;\n    optimizationsSuggested: number;\n    accuracyTrend: number[];\n    lastAnalysis: number;\n  } {\n    const totalAnalyses = this.analysisHistory.length;\n    const avgTime = totalAnalyses > 0 \n      ? this.analysisHistory.reduce((sum, a) => sum + a.metrics.analysisTime, 0) / totalAnalyses \n      : 0;\n    \n    const optimizationsSuggested = this.analysisHistory.reduce(\n      (sum, a) => sum + a.optimization.proposals.length, 0\n    );\n\n    const accuracyTrend = this.analysisHistory\n      .slice(-10)\n      .map(a => a.cohesion.overallScore);\n\n    return {\n      analysesPerformed: totalAnalyses,\n      averageAnalysisTime: avgTime,\n      patternsLearned: this.learningPatterns.length,\n      optimizationsSuggested,\n      accuracyTrend,\n      lastAnalysis: totalAnalyses > 0 ? this.analysisHistory[totalAnalyses - 1].timestamp : 0,\n    };\n  }\n\n  // ===== Private Methods =====\n\n  private setupEventListeners(): void {\n    this.domainMapper.on('graph-updated', (graph: DomainGraph) => {\n      this.emit('graph-updated', graph);\n    });\n\n    this.domainMapper.on('cohesion-calculated', (analysis: CohesionAnalysis) => {\n      this.emit('cohesion-calculated', analysis);\n    });\n\n    this.domainMapper.on('dependencies-analyzed', (analysis: DependencyAnalysis) => {\n      this.emit('dependencies-analyzed', analysis);\n    });\n\n    this.domainMapper.on('optimization-generated', (optimization: BoundaryOptimization) => {\n      this.emit('optimization-generated', optimization);\n    });\n\n    this.domainMapper.on('training-completed', (result: any) => {\n      this.emit('mapper-training-completed', result);\n    });\n  }\n\n  private registerDomainAnalysisHooks(): void {\n    // Register hook for neural pattern detection\n    agenticHookManager.register({\n      id: 'domain-mapper-pattern-analysis',\n      type: 'neural-pattern-detected',\n      priority: 80,\n      handler: async (payload: NeuralHookPayload, context: AgenticHookContext) => {\n        if (!this.config.enableAutoAnalysis || !payload.patterns?.length) {\n          return { continue: true };\n        }\n\n        // Check if patterns are domain-related\n        const domainPatterns = payload.patterns.filter(p => \n          this.isDomainRelatedPattern(p)\n        );\n\n        if (domainPatterns.length === 0) {\n          return { continue: true };\n        }\n\n        const sideEffects: SideEffect[] = [];\n\n        // Trigger domain analysis based on patterns\n        try {\n          const domainGraph = await this.extractDomainGraphFromPatterns(domainPatterns);\n          if (domainGraph) {\n            const analysisResult = await this.analyzeDomains(domainGraph, context);\n            \n            // Generate suggestions if confidence is high enough\n            if (analysisResult.optimization.optimizationScore >= this.config.confidenceThreshold) {\n              sideEffects.push({\n                type: 'notification',\n                action: 'emit',\n                data: {\n                  event: 'domain:optimization-suggested',\n                  data: analysisResult.optimization,\n                },\n              });\n            }\n\n            // Store analysis results\n            sideEffects.push({\n              type: 'memory',\n              action: 'store',\n              data: {\n                key: `domain:analysis:${context.correlationId}`,\n                value: analysisResult,\n                ttl: 3600, // 1 hour\n              },\n            });\n          }\n        } catch (error) {\n          sideEffects.push({\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'error',\n              message: 'Domain analysis failed',\n              error: error.message,\n            },\n          });\n        }\n\n        return {\n          continue: true,\n          sideEffects,\n        };\n      },\n    });\n\n    // Register hook for neural training completion\n    agenticHookManager.register({\n      id: 'domain-mapper-training-integration',\n      type: 'post-neural-train',\n      priority: 90,\n      handler: async (payload: NeuralHookPayload, context: AgenticHookContext) => {\n        if (!this.config.enableContinuousLearning) {\n          return { continue: true };\n        }\n\n        // Extract domain-relevant training data\n        if (payload.trainingData) {\n          const domainTrainingData = this.extractDomainTrainingData(payload.trainingData);\n          if (domainTrainingData.inputs.length > 0) {\n            // Retrain domain mapper with new data\n            try {\n              await this.domainMapper.train(domainTrainingData);\n              \n              return {\n                continue: true,\n                sideEffects: [{\n                  type: 'log',\n                  action: 'write',\n                  data: {\n                    level: 'info',\n                    message: 'Domain mapper updated with new training data',\n                    dataSize: domainTrainingData.inputs.length,\n                  },\n                }],\n              };\n            } catch (error) {\n              return {\n                continue: true,\n                sideEffects: [{\n                  type: 'log',\n                  action: 'write',\n                  data: {\n                    level: 'warning',\n                    message: 'Failed to update domain mapper',\n                    error: error.message,\n                  },\n                }],\n              };\n            }\n          }\n        }\n\n        return { continue: true };\n      },\n    });\n  }\n\n  private setupPeriodicAnalysis(): void {\n    setInterval(async () => {\n      try {\n        // Check if there are recent patterns to analyze\n        const recentPatterns = context.neural.patterns.getByType('behavior')\n          .filter(p => Date.now() - (p.context.timestamp || 0) < this.config.analysisInterval * 2);\n\n        if (recentPatterns.length > 0) {\n          const mockContext: AgenticHookContext = {\n            sessionId: 'periodic-analysis',\n            timestamp: Date.now(),\n            correlationId: `periodic-${Date.now()}`,\n            metadata: { source: 'periodic-analysis' },\n            memory: {\n              namespace: 'domain-analysis',\n              provider: 'default',\n              cache: new Map(),\n            },\n            neural: {\n              modelId: 'domain-mapper',\n              patterns: context.neural.patterns,\n              training: context.neural.training,\n            },\n            performance: {\n              metrics: new Map(),\n              bottlenecks: [],\n              optimizations: [],\n            },\n          };\n\n          // Perform periodic analysis\n          await this.trainOnPatterns(recentPatterns, mockContext);\n        }\n      } catch (error) {\n        this.emit('error', { type: 'periodic-analysis', error });\n      }\n    }, this.config.analysisInterval);\n  }\n\n  private async performDomainAnalysis(\n    domains: DomainGraph,\n    context: AgenticHookContext\n  ): Promise<DomainAnalysisResult> {\n    const startTime = Date.now();\n\n    // Perform comprehensive domain analysis\n    const analysis = await this.domainMapper.analyzeDomains(domains);\n\n    // Extract patterns from analysis results\n    const patterns = this.extractPatternsFromAnalysis(analysis, context);\n\n    const analysisTime = Date.now() - startTime;\n\n    return {\n      timestamp: Date.now(),\n      correlationId: context.correlationId,\n      graph: domains,\n      cohesion: analysis.cohesion,\n      dependencies: analysis.dependencies,\n      optimization: analysis.optimization,\n      patterns,\n      metrics: {\n        analysisTime,\n        nodesAnalyzed: domains.nodes.size,\n        edgesAnalyzed: domains.edges.size,\n        patternsDetected: patterns.length,\n      },\n    };\n  }\n\n  private async generateHookSideEffects(\n    result: DomainAnalysisResult,\n    context: AgenticHookContext\n  ): Promise<void> {\n    const sideEffects: SideEffect[] = [];\n\n    // Generate optimization notifications if applicable\n    if (result.optimization.optimizationScore >= this.config.confidenceThreshold) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'domain:optimization-available',\n          data: {\n            score: result.optimization.optimizationScore,\n            priority: result.optimization.priority,\n            proposalCount: result.optimization.proposals.length,\n          },\n        },\n      });\n    }\n\n    // Store detected patterns\n    for (const pattern of result.patterns) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'store-pattern',\n        data: { pattern },\n      });\n    }\n\n    // Store performance metrics\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: 'domain.analysis.time',\n        value: result.metrics.analysisTime,\n      },\n    });\n\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: 'domain.cohesion.score',\n        value: result.cohesion.overallScore,\n      },\n    });\n\n    // Execute side effects through the hook system\n    for (const effect of sideEffects) {\n      try {\n        await this.executeSideEffect(effect, context);\n      } catch (error) {\n        this.emit('error', { type: 'side-effect', effect, error });\n      }\n    }\n  }\n\n  private async learnFromAnalysis(\n    result: DomainAnalysisResult,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Convert analysis results to training data\n    const learningData = this.convertAnalysisToTrainingData(result);\n    \n    if (learningData.inputs.length > 0) {\n      try {\n        await this.domainMapper.train(learningData);\n        this.emit('continuous-learning-completed', {\n          dataSize: learningData.inputs.length,\n          correlationId: context.correlationId,\n        });\n      } catch (error) {\n        this.emit('error', { type: 'continuous-learning', error });\n      }\n    }\n  }\n\n  private convertPatternsToTrainingData(patterns: Pattern[]): TrainingData {\n    const inputs: any[] = [];\n    const outputs: any[] = [];\n    const labels: string[] = [];\n\n    for (const pattern of patterns) {\n      if (this.isDomainRelatedPattern(pattern)) {\n        // Extract features from pattern context\n        const features = this.extractFeaturesFromPattern(pattern);\n        if (features.length > 0) {\n          inputs.push({ features });\n          \n          // Create target based on pattern type and confidence\n          const target = this.createTargetFromPattern(pattern);\n          outputs.push(target);\n          labels.push(pattern.type);\n        }\n      }\n    }\n\n    return {\n      inputs,\n      outputs,\n      labels,\n      batchSize: Math.min(32, inputs.length),\n      epochs: Math.max(1, Math.min(10, inputs.length / 10)),\n    };\n  }\n\n  private isDomainRelatedPattern(pattern: Pattern): boolean {\n    // Check if pattern context contains domain-related information\n    return !!(\n      pattern.context.domain ||\n      pattern.context.domainId ||\n      pattern.context.relationship ||\n      pattern.context.boundary ||\n      pattern.type === 'behavior' && pattern.context.component\n    );\n  }\n\n  private extractFeaturesFromPattern(pattern: Pattern): number[] {\n    const features: number[] = [];\n    \n    // Pattern type encoding\n    const types = ['success', 'failure', 'optimization', 'behavior'];\n    features.push(...types.map(t => t === pattern.type ? 1 : 0));\n    \n    // Confidence and occurrence features\n    features.push(pattern.confidence, Math.log(pattern.occurrences + 1) / 10);\n    \n    // Context features (simplified)\n    features.push(\n      pattern.context.complexity || 0.5,\n      pattern.context.size || 1,\n      pattern.context.frequency || 1,\n    );\n\n    // Pad to consistent size\n    while (features.length < 32) {\n      features.push(0);\n    }\n\n    return features.slice(0, 32);\n  }\n\n  private createTargetFromPattern(pattern: Pattern): number[] {\n    // Create target vector based on pattern characteristics\n    const target = [\n      pattern.confidence, // Quality score\n      pattern.type === 'success' ? 1 : 0, // Success indicator\n      pattern.type === 'failure' ? 1 : 0, // Failure indicator\n      Math.min(pattern.occurrences / 100, 1), // Frequency score\n    ];\n\n    return target;\n  }\n\n  private extractTrainingInsights(trainingResult: any, patterns: Pattern[]): string[] {\n    const insights: string[] = [];\n\n    if (trainingResult.finalAccuracy > 0.8) {\n      insights.push('High accuracy achieved - domain patterns are well understood');\n    } else if (trainingResult.finalAccuracy > 0.6) {\n      insights.push('Moderate accuracy - some domain patterns may need more data');\n    } else {\n      insights.push('Low accuracy - domain patterns are complex or insufficient data');\n    }\n\n    // Analyze pattern types\n    const patternTypes = new Map<string, number>();\n    patterns.forEach(p => {\n      patternTypes.set(p.type, (patternTypes.get(p.type) || 0) + 1);\n    });\n\n    const dominantType = Array.from(patternTypes.entries())\n      .sort((a, b) => b[1] - a[1])[0];\n\n    if (dominantType) {\n      insights.push(`Primary learning focus: ${dominantType[0]} patterns (${dominantType[1]} samples)`);\n    }\n\n    return insights;\n  }\n\n  // Additional helper methods would be implemented here for the remaining functionality\n  // These are simplified stubs for the core functionality\n\n  private async extractDomainGraphFromPatterns(patterns: Pattern[]): Promise<DomainGraph | null> {\n    // Extract domain structure from patterns - simplified implementation\n    return null;\n  }\n\n  private extractDomainTrainingData(trainingData: TrainingData): TrainingData {\n    // Filter and extract domain-relevant training data\n    return {\n      inputs: [],\n      outputs: [],\n      batchSize: 1,\n      epochs: 1,\n    };\n  }\n\n  private extractPatternsFromAnalysis(analysis: any, context: AgenticHookContext): Pattern[] {\n    // Extract patterns from analysis results\n    return [];\n  }\n\n  private async executeSideEffect(effect: SideEffect, context: AgenticHookContext): Promise<void> {\n    // Execute side effect through appropriate system\n  }\n\n  private convertAnalysisToTrainingData(result: DomainAnalysisResult): TrainingData {\n    // Convert analysis results to training data for continuous learning\n    return {\n      inputs: [],\n      outputs: [],\n      batchSize: 1,\n      epochs: 1,\n    };\n  }\n\n  private calculateOptimizationApplicability(optimization: BoundaryOptimization, context: AgenticHookContext): number {\n    return optimization.optimizationScore;\n  }\n\n  private generatePrioritizedActions(optimization: BoundaryOptimization): Array<{\n    action: string;\n    priority: 'low' | 'medium' | 'high' | 'critical';\n    impact: number;\n    effort: number;\n  }> {\n    return optimization.proposals.map(p => ({\n      action: `${p.type} domains: ${p.domains.join(', ')}`,\n      priority: p.confidence > 0.8 ? 'high' : p.confidence > 0.6 ? 'medium' : 'low',\n      impact: p.metrics.cohesionImprovement + p.metrics.couplingReduction,\n      effort: p.metrics.performanceImpact,\n    }));\n  }\n\n  private createPredictionInput(proposedChanges: any): any[] {\n    return [];\n  }\n\n  private assessChangeRisks(proposedChanges: any, predictions: Prediction[]): {\n    overallRisk: number;\n    riskFactors: Array<{ factor: string; risk: number; mitigation: string }>;\n  } {\n    return {\n      overallRisk: 0.5,\n      riskFactors: [],\n    };\n  }\n\n  private generateChangeRecommendations(\n    proposedChanges: any,\n    predictions: Prediction[],\n    riskAssessment: any\n  ): string[] {\n    return ['Consider gradual implementation', 'Monitor domain cohesion metrics'];\n  }\n}\n\n/**\n * Factory function to create and initialize a domain mapper integration\n */\nexport async function createDomainMapperIntegration(\n  config: Partial<DomainMapperIntegrationConfig> = {}\n): Promise<NeuralDomainMapperIntegration> {\n  const integration = new NeuralDomainMapperIntegration(undefined, config);\n  await integration.initialize();\n  return integration;\n}\n\n/**\n * Export types for external use\n */\nexport type {\n  DomainMapperIntegrationConfig,\n  DomainAnalysisResult,\n};"],"names":["EventEmitter","NeuralDomainMapper","agenticHookManager","NeuralDomainMapperIntegration","domainMapper","config","analysisHistory","activeAnalysis","Map","learningPatterns","isInitialized","enableAutoAnalysis","enableOptimizationSuggestions","enableContinuousLearning","confidenceThreshold","analysisInterval","maxOptimizationProposals","setupEventListeners","initialize","registerDomainAnalysisHooks","setupPeriodicAnalysis","emit","analyzeDomains","domains","context","correlationId","has","get","analysisPromise","performDomainAnalysis","set","result","push","length","shift","generateHookSideEffects","learnFromAnalysis","delete","trainOnPatterns","patterns","trainingData","convertPatternsToTrainingData","inputs","trainingAccuracy","patternsProcessed","newInsights","trainingResult","train","extractTrainingInsights","slice","finalAccuracy","getOptimizationSuggestions","optimization","provideBoundaryOptimization","applicability","calculateOptimizationApplicability","prioritizedActions","generatePrioritizedActions","suggestions","predictDomainRelationships","proposedChanges","predictionInput","createPredictionInput","predictions","Promise","all","map","input","predict","riskAssessment","assessChangeRisks","recommendations","generateChangeRecommendations","getIntegrationStats","totalAnalyses","avgTime","reduce","sum","a","metrics","analysisTime","optimizationsSuggested","proposals","accuracyTrend","cohesion","overallScore","analysesPerformed","averageAnalysisTime","patternsLearned","lastAnalysis","timestamp","on","graph","analysis","register","id","type","priority","handler","payload","continue","domainPatterns","filter","p","isDomainRelatedPattern","sideEffects","domainGraph","extractDomainGraphFromPatterns","analysisResult","optimizationScore","action","data","event","key","value","ttl","error","level","message","domainTrainingData","extractDomainTrainingData","dataSize","setInterval","recentPatterns","neural","getByType","Date","now","mockContext","sessionId","metadata","source","memory","namespace","provider","cache","modelId","training","performance","bottlenecks","optimizations","startTime","extractPatternsFromAnalysis","dependencies","nodesAnalyzed","nodes","size","edgesAnalyzed","edges","patternsDetected","score","proposalCount","pattern","name","effect","executeSideEffect","learningData","convertAnalysisToTrainingData","outputs","labels","features","extractFeaturesFromPattern","target","createTargetFromPattern","batchSize","Math","min","epochs","max","domain","domainId","relationship","boundary","component","types","t","confidence","log","occurrences","complexity","frequency","insights","patternTypes","forEach","dominantType","Array","from","entries","sort","b","join","impact","cohesionImprovement","couplingReduction","effort","performanceImpact","overallRisk","riskFactors","createDomainMapperIntegration","integration","undefined"],"mappings":"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"}