{"version":3,"sources":["../../../src/terminal/vscode-bridge.ts"],"sourcesContent":["import { getErrorMessage } from '../utils/error-handler.js';\n/**\n * VSCode Extension Bridge for Terminal Integration\n *\n * This file provides the bridge between Claude-Flow and VSCode extension API\n * for terminal management and output capture.\n *\n * NOTE: This file is only used when Claude-Flow is packaged as a VS Code extension.\n * It is excluded from the main CLI build. If you need to use this in a VS Code\n * extension context, install @types/vscode as a devDependency.\n */\n\nimport * as vscode from 'vscode';\n\n/**\n * Terminal output processors registry\n */\nconst terminalOutputProcessors = new Map<string, (data: string) => void>();\n\n/**\n * Active terminals registry\n */\nconst activeTerminals = new Map<string, vscode.Terminal>();\n\n/**\n * Terminal write emulators for output capture\n */\nconst terminalWriteEmulators = new Map<vscode.Terminal, vscode.EventEmitter<string>>();\n\n/**\n * Initialize the VSCode terminal bridge\n */\nexport function initializeTerminalBridge(context: vscode.ExtensionContext): void {\n  // Inject VSCode API into global scope for Claude-Flow\n  (globalThis as any).vscode = vscode;\n\n  // Register terminal output processor function\n  (globalThis as any).registerTerminalOutputProcessor = (\n    terminalId: string,\n    processor: (data: string) => void,\n  ) => {\n    terminalOutputProcessors.set(terminalId, processor);\n  };\n\n  // Override terminal creation to capture output\n  const originalCreateTerminal = vscode.window.createTerminal;\n  (vscode.window as any).createTerminal = function (options: vscode.TerminalOptions) {\n    const terminal = originalCreateTerminal.call(vscode.window, options) as vscode.Terminal;\n\n    // Create write emulator for this terminal\n    const writeEmulator = new vscode.EventEmitter<string>();\n    terminalWriteEmulators.set(terminal, writeEmulator);\n\n    // Find terminal ID from name\n    const match = options.name?.match(/Claude-Flow Terminal ([\\w-]+)/);\n    if (match) {\n      const terminalId = match[1];\n      activeTerminals.set(terminalId, terminal);\n\n      // Set up output capture\n      captureTerminalOutput(terminal, terminalId);\n    }\n\n    return terminal;\n  };\n\n  // Clean up on terminal close\n  context.subscriptions.push(\n    vscode.window.onDidCloseTerminal((terminal: vscode.Terminal) => {\n      // Find and remove from registries\n      for (const [id, term] of activeTerminals.entries()) {\n        if (term === terminal) {\n          activeTerminals.delete(id);\n          terminalOutputProcessors.delete(id);\n          break;\n        }\n      }\n\n      // Clean up write emulator\n      const emulator = terminalWriteEmulators.get(terminal);\n      if (emulator) {\n        emulator.dispose();\n        terminalWriteEmulators.delete(terminal);\n      }\n    }),\n  );\n}\n\n/**\n * Capture terminal output using various methods\n */\nfunction captureTerminalOutput(terminal: vscode.Terminal, terminalId: string): void {\n  // Method 1: Use terminal.sendText override to capture commands\n  const originalSendText = terminal.sendText;\n  (terminal as any).sendText = function (text: string, addNewLine?: boolean) {\n    // Call original method\n    originalSendText.call(terminal, text, addNewLine);\n\n    // Process command\n    const processor = terminalOutputProcessors.get(terminalId);\n    if (processor && text) {\n      // Simulate command echo\n      processor(text + (addNewLine !== false ? '\\n' : ''));\n    }\n  };\n\n  // Method 2: Use proposed API if available\n  if ('onDidWriteData' in terminal) {\n    const writeDataEvent = (terminal as any).onDidWriteData;\n    if (writeDataEvent) {\n      writeDataEvent((data: string) => {\n        const processor = terminalOutputProcessors.get(terminalId);\n        if (processor) {\n          processor(data);\n        }\n      });\n    }\n  }\n\n  // Method 3: Use terminal renderer if available\n  setupTerminalRenderer(terminal, terminalId);\n}\n\n/**\n * Set up terminal renderer for output capture\n */\nfunction setupTerminalRenderer(terminal: vscode.Terminal, terminalId: string): void {\n  // Check if terminal renderer API is available\n  if (vscode.window.registerTerminalProfileProvider) {\n    // This is a more advanced method that requires additional setup\n    // It would involve creating a custom terminal profile that captures output\n\n    // For now, we'll use a simpler approach with periodic output checking\n    let lastOutput = '';\n    const checkOutput = setInterval(() => {\n      // This is a placeholder - actual implementation would depend on\n      // available VSCode APIs for reading terminal content\n\n      // Check if terminal is still active\n      if (!activeTerminals.has(terminalId)) {\n        clearInterval(checkOutput);\n      }\n    }, 100);\n  }\n}\n\n/**\n * Create a terminal with output capture\n */\nexport async function createCapturedTerminal(\n  name: string,\n  shellPath?: string,\n  shellArgs?: string[],\n): Promise<{\n  terminal: vscode.Terminal;\n  onData: vscode.Event<string>;\n}> {\n  const writeEmulator = new vscode.EventEmitter<string>();\n\n  const terminal = vscode.window.createTerminal({\n    name,\n    shellPath,\n    shellArgs,\n  });\n\n  terminalWriteEmulators.set(terminal, writeEmulator);\n\n  return {\n    terminal,\n    onData: writeEmulator.event,\n  };\n}\n\n/**\n * Send command to terminal and capture output\n */\nexport async function executeTerminalCommand(\n  terminal: vscode.Terminal,\n  command: string,\n  timeout: number = 30000,\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const writeEmulator = terminalWriteEmulators.get(terminal);\n    if (!writeEmulator) {\n      reject(new Error('No write emulator for terminal'));\n      return;\n    }\n\n    let output = '';\n    const marker = `__COMMAND_COMPLETE_${Date.now()}__`;\n\n    // Set up output listener\n    const disposable = writeEmulator.event((data: string) => {\n      output += data;\n\n      if (output.includes(marker)) {\n        // Command completed\n        disposable.dispose();\n        const result = output.substring(0, output.indexOf(marker));\n        resolve(result);\n      }\n    });\n\n    // Set timeout\n    const timer = setTimeout(() => {\n      disposable.dispose();\n      reject(new Error('Command timeout'));\n    }, timeout);\n\n    // Execute command with marker\n    terminal.sendText(`${command} && echo \"${marker}\"`);\n\n    // Clear timeout on success\n    writeEmulator.event(() => {\n      if (output.includes(marker)) {\n        clearTimeout(timer);\n      }\n    });\n  });\n}\n\n/**\n * Get terminal by ID\n */\nexport function getTerminalById(terminalId: string): vscode.Terminal | undefined {\n  return activeTerminals.get(terminalId);\n}\n\n/**\n * Dispose all terminal resources\n */\nexport function disposeTerminalBridge(): void {\n  // Clean up all terminals\n  for (const terminal of activeTerminals.values()) {\n    terminal.dispose();\n  }\n  activeTerminals.clear();\n\n  // Clean up processors\n  terminalOutputProcessors.clear();\n\n  // Clean up write emulators\n  for (const emulator of terminalWriteEmulators.values()) {\n    emulator.dispose();\n  }\n  terminalWriteEmulators.clear();\n}\n"],"names":["vscode","terminalOutputProcessors","Map","activeTerminals","terminalWriteEmulators","initializeTerminalBridge","context","globalThis","registerTerminalOutputProcessor","terminalId","processor","set","originalCreateTerminal","window","createTerminal","options","terminal","call","writeEmulator","EventEmitter","match","name","captureTerminalOutput","subscriptions","push","onDidCloseTerminal","id","term","entries","delete","emulator","get","dispose","originalSendText","sendText","text","addNewLine","writeDataEvent","onDidWriteData","data","setupTerminalRenderer","registerTerminalProfileProvider","lastOutput","checkOutput","setInterval","has","clearInterval","createCapturedTerminal","shellPath","shellArgs","onData","event","executeTerminalCommand","command","timeout","Promise","resolve","reject","Error","output","marker","Date","now","disposable","includes","result","substring","indexOf","timer","setTimeout","clearTimeout","getTerminalById","disposeTerminalBridge","values","clear"],"mappings":"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"}