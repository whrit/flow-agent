{"version":3,"sources":["../../../src/terminal/manager.ts"],"sourcesContent":["import * as process from 'node:process';\n/**\n * Terminal manager interface and implementation\n */\n\nimport type { AgentProfile, AgentSession, TerminalConfig } from '../utils/types.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TerminalError, TerminalSpawnError } from '../utils/errors.js';\nimport type { ITerminalAdapter } from './adapters/base.js';\nimport { VSCodeAdapter } from './adapters/vscode.js';\nimport { NativeAdapter } from './adapters/native.js';\nimport { TerminalPool } from './pool.js';\nimport { TerminalSession } from './session.js';\n\nexport interface ITerminalManager {\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n  spawnTerminal(profile: AgentProfile): Promise<string>;\n  terminateTerminal(terminalId: string): Promise<void>;\n  executeCommand(terminalId: string, command: string): Promise<string>;\n  getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }>;\n  performMaintenance(): Promise<void>;\n}\n\n/**\n * Terminal manager implementation\n */\nexport class TerminalManager implements ITerminalManager {\n  private adapter: ITerminalAdapter;\n  private pool: TerminalPool;\n  private sessions = new Map<string, TerminalSession>();\n  private initialized = false;\n\n  constructor(\n    private config: TerminalConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger,\n  ) {\n    // Select adapter based on configuration\n    this.adapter = this.createAdapter();\n\n    // Create terminal pool\n    this.pool = new TerminalPool(\n      this.config.poolSize,\n      this.config.recycleAfter,\n      this.adapter,\n      this.logger,\n    );\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    this.logger.info('Initializing terminal manager...');\n\n    try {\n      // Initialize adapter\n      await this.adapter.initialize();\n\n      // Initialize pool\n      await this.pool.initialize();\n\n      this.initialized = true;\n      this.logger.info('Terminal manager initialized');\n    } catch (error) {\n      this.logger.error('Failed to initialize terminal manager', error);\n      throw new TerminalError('Terminal manager initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down terminal manager...');\n\n    try {\n      // Terminate all sessions\n      const sessionIds = Array.from(this.sessions.keys());\n      await Promise.all(sessionIds.map((id) => this.terminateTerminal(id)));\n\n      // Shutdown pool\n      await this.pool.shutdown();\n\n      // Shutdown adapter\n      await this.adapter.shutdown();\n\n      this.initialized = false;\n      this.logger.info('Terminal manager shutdown complete');\n    } catch (error) {\n      this.logger.error('Error during terminal manager shutdown', error);\n      throw error;\n    }\n  }\n\n  async spawnTerminal(profile: AgentProfile): Promise<string> {\n    if (!this.initialized) {\n      throw new TerminalError('Terminal manager not initialized');\n    }\n\n    this.logger.debug('Spawning terminal', { agentId: profile.id });\n\n    try {\n      // Get terminal from pool\n      const terminal = await this.pool.acquire();\n\n      // Create session\n      const session = new TerminalSession(\n        terminal,\n        profile,\n        this.config.commandTimeout,\n        this.logger,\n      );\n\n      // Initialize session\n      await session.initialize();\n\n      // Store session\n      this.sessions.set(session.id, session);\n\n      this.logger.info('Terminal spawned', {\n        terminalId: session.id,\n        agentId: profile.id,\n      });\n\n      return session.id;\n    } catch (error) {\n      this.logger.error('Failed to spawn terminal', error);\n      throw new TerminalSpawnError('Failed to spawn terminal', { error });\n    }\n  }\n\n  async terminateTerminal(terminalId: string): Promise<void> {\n    const session = this.sessions.get(terminalId);\n    if (!session) {\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\n    }\n\n    this.logger.debug('Terminating terminal', { terminalId });\n\n    try {\n      // Cleanup session\n      await session.cleanup();\n\n      // Return terminal to pool\n      await this.pool.release(session.terminal);\n\n      // Remove session\n      this.sessions.delete(terminalId);\n\n      this.logger.info('Terminal terminated', { terminalId });\n    } catch (error) {\n      this.logger.error('Failed to terminate terminal', error);\n      throw error;\n    }\n  }\n\n  async executeCommand(terminalId: string, command: string): Promise<string> {\n    const session = this.sessions.get(terminalId);\n    if (!session) {\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\n    }\n\n    return await session.executeCommand(command);\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const poolHealth = await this.pool.getHealthStatus();\n      const activeSessions = this.sessions.size;\n      const healthySessions = Array.from(this.sessions.values()).filter((session) =>\n        session.isHealthy(),\n      ).length;\n\n      const metrics = {\n        activeSessions,\n        healthySessions,\n        poolSize: poolHealth.size,\n        availableTerminals: poolHealth.available,\n        recycledTerminals: poolHealth.recycled,\n      };\n\n      const healthy = poolHealth.healthy && healthySessions === activeSessions;\n\n      if (healthy) {\n        return {\n          healthy,\n          metrics,\n        };\n      } else {\n        return {\n          healthy,\n          metrics,\n          error: 'Some terminals are unhealthy',\n        };\n      }\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  async performMaintenance(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.logger.debug('Performing terminal manager maintenance');\n\n    try {\n      // Clean up dead sessions\n      const deadSessions = Array.from(this.sessions.entries()).filter(\n        ([_, session]) => !session.isHealthy(),\n      );\n\n      for (const [terminalId, _] of deadSessions) {\n        this.logger.warn('Cleaning up dead terminal session', { terminalId });\n        await this.terminateTerminal(terminalId).catch((error) =>\n          this.logger.error('Failed to clean up terminal', { terminalId, error }),\n        );\n      }\n\n      // Perform pool maintenance\n      await this.pool.performMaintenance();\n\n      // Emit maintenance event\n      this.eventBus.emit('terminal:maintenance', {\n        deadSessions: deadSessions.length,\n        activeSessions: this.sessions.size,\n        poolStatus: await this.pool.getHealthStatus(),\n      });\n\n      this.logger.debug('Terminal manager maintenance completed');\n    } catch (error) {\n      this.logger.error('Error during terminal manager maintenance', error);\n    }\n  }\n\n  /**\n   * Get all active sessions\n   */\n  getActiveSessions(): AgentSession[] {\n    return Array.from(this.sessions.values()).map((session) => ({\n      id: session.id,\n      agentId: session.profile.id,\n      terminalId: session.terminal.id,\n      startTime: session.startTime,\n      status: session.isHealthy() ? 'active' : 'error',\n      lastActivity: session.lastActivity,\n      memoryBankId: '', // TODO: Link to memory bank\n    }));\n  }\n\n  /**\n   * Get session by ID\n   */\n  getSession(sessionId: string): TerminalSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  /**\n   * Stream terminal output\n   */\n  async streamOutput(terminalId: string, callback: (output: string) => void): Promise<() => void> {\n    const session = this.sessions.get(terminalId);\n    if (!session) {\n      throw new TerminalError(`Terminal not found: ${terminalId}`);\n    }\n\n    return session.streamOutput(callback);\n  }\n\n  private createAdapter(): ITerminalAdapter {\n    switch (this.config.type) {\n      case 'vscode':\n        return new VSCodeAdapter(this.logger);\n      case 'native':\n        return new NativeAdapter(this.logger);\n      case 'auto':\n        // Detect environment and choose appropriate adapter\n        if (this.isVSCodeEnvironment()) {\n          this.logger.info('Detected VSCode environment, using VSCode adapter');\n          return new VSCodeAdapter(this.logger);\n        } else {\n          this.logger.info('Using native terminal adapter');\n          return new NativeAdapter(this.logger);\n        }\n      default:\n        throw new TerminalError(`Unknown terminal type: ${this.config.type}`);\n    }\n  }\n\n  private isVSCodeEnvironment(): boolean {\n    // Check for VSCode-specific environment variables\n    return (\n      process.env.TERM_PROGRAM === 'vscode' ||\n      process.env.VSCODE_PID !== undefined ||\n      process.env.VSCODE_IPC_HOOK !== undefined\n    );\n  }\n}\n"],"names":["process","TerminalError","TerminalSpawnError","VSCodeAdapter","NativeAdapter","TerminalPool","TerminalSession","TerminalManager","adapter","pool","sessions","Map","initialized","config","eventBus","logger","createAdapter","poolSize","recycleAfter","initialize","info","error","shutdown","sessionIds","Array","from","keys","Promise","all","map","id","terminateTerminal","spawnTerminal","profile","debug","agentId","terminal","acquire","session","commandTimeout","set","terminalId","get","cleanup","release","delete","executeCommand","command","getHealthStatus","poolHealth","activeSessions","size","healthySessions","values","filter","isHealthy","length","metrics","availableTerminals","available","recycledTerminals","recycled","healthy","Error","message","performMaintenance","deadSessions","entries","_","warn","catch","emit","poolStatus","getActiveSessions","startTime","status","lastActivity","memoryBankId","getSession","sessionId","streamOutput","callback","type","isVSCodeEnvironment","env","TERM_PROGRAM","VSCODE_PID","undefined","VSCODE_IPC_HOOK"],"mappings":"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"}