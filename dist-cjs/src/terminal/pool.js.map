{"version":3,"sources":["../../../src/terminal/pool.ts"],"sourcesContent":["/**\n * Terminal pool management\n */\n\nimport type { Terminal, ITerminalAdapter } from './adapters/base.js';\nimport type { ILogger } from '../core/logger.js';\nimport { TerminalError } from '../utils/errors.js';\nimport { delay } from '../utils/helpers.js';\n\ninterface PooledTerminal {\n  terminal: Terminal;\n  useCount: number;\n  lastUsed: Date;\n  inUse: boolean;\n}\n\n/**\n * Terminal pool for efficient resource management\n */\nexport class TerminalPool {\n  private terminals = new Map<string, PooledTerminal>();\n  private availableQueue: string[] = [];\n  private initializationPromise?: Promise<void>;\n\n  constructor(\n    private maxSize: number,\n    private recycleAfter: number,\n    private adapter: ITerminalAdapter,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n\n    this.initializationPromise = this.doInitialize();\n    return this.initializationPromise;\n  }\n\n  private async doInitialize(): Promise<void> {\n    this.logger.info('Initializing terminal pool', {\n      maxSize: this.maxSize,\n      recycleAfter: this.recycleAfter,\n    });\n\n    // Pre-create some terminals\n    const preCreateCount = Math.min(2, this.maxSize);\n    const promises: Promise<void>[] = [];\n\n    for (let i = 0; i < preCreateCount; i++) {\n      promises.push(this.createPooledTerminal());\n    }\n\n    await Promise.all(promises);\n\n    this.logger.info('Terminal pool initialized', {\n      created: preCreateCount,\n    });\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down terminal pool');\n\n    // Destroy all terminals\n    const terminals = Array.from(this.terminals.values());\n    await Promise.all(terminals.map(({ terminal }) => this.adapter.destroyTerminal(terminal)));\n\n    this.terminals.clear();\n    this.availableQueue = [];\n  }\n\n  async acquire(): Promise<Terminal> {\n    // Try to get an available terminal\n    while (this.availableQueue.length > 0) {\n      const terminalId = this.availableQueue.shift()!;\n      const pooled = this.terminals.get(terminalId);\n\n      if (pooled && pooled.terminal.isAlive()) {\n        pooled.inUse = true;\n        pooled.lastUsed = new Date();\n\n        this.logger.debug('Terminal acquired from pool', {\n          terminalId,\n          useCount: pooled.useCount,\n        });\n\n        return pooled.terminal;\n      }\n\n      // Terminal is dead, remove it\n      if (pooled) {\n        this.terminals.delete(terminalId);\n      }\n    }\n\n    // No available terminals, create new one if under limit\n    if (this.terminals.size < this.maxSize) {\n      await this.createPooledTerminal();\n      return this.acquire(); // Recursive call to get the newly created terminal\n    }\n\n    // Pool is full, wait for a terminal to become available\n    this.logger.info('Terminal pool full, waiting for available terminal');\n\n    const startTime = Date.now();\n    const timeout = 30000; // 30 seconds\n\n    while (Date.now() - startTime < timeout) {\n      await delay(100);\n\n      // Check if any terminal became available\n      const available = Array.from(this.terminals.values()).find(\n        (pooled) => !pooled.inUse && pooled.terminal.isAlive(),\n      );\n\n      if (available) {\n        available.inUse = true;\n        available.lastUsed = new Date();\n        return available.terminal;\n      }\n    }\n\n    throw new TerminalError('No terminal available in pool (timeout)');\n  }\n\n  async release(terminal: Terminal): Promise<void> {\n    const pooled = this.terminals.get(terminal.id);\n    if (!pooled) {\n      this.logger.warn('Attempted to release unknown terminal', {\n        terminalId: terminal.id,\n      });\n      return;\n    }\n\n    pooled.useCount++;\n    pooled.inUse = false;\n\n    // Check if terminal should be recycled\n    if (pooled.useCount >= this.recycleAfter || !terminal.isAlive()) {\n      this.logger.info('Recycling terminal', {\n        terminalId: terminal.id,\n        useCount: pooled.useCount,\n      });\n\n      // Destroy old terminal\n      this.terminals.delete(terminal.id);\n      await this.adapter.destroyTerminal(terminal);\n\n      // Create replacement if under limit\n      if (this.terminals.size < this.maxSize) {\n        await this.createPooledTerminal();\n      }\n    } else {\n      // Return to available queue\n      this.availableQueue.push(terminal.id);\n\n      this.logger.debug('Terminal returned to pool', {\n        terminalId: terminal.id,\n        useCount: pooled.useCount,\n      });\n    }\n  }\n\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    size: number;\n    available: number;\n    recycled: number;\n  }> {\n    const aliveTerminals = Array.from(this.terminals.values()).filter((pooled) =>\n      pooled.terminal.isAlive(),\n    );\n\n    const available = aliveTerminals.filter((pooled) => !pooled.inUse).length;\n    const recycled = Array.from(this.terminals.values()).filter(\n      (pooled) => pooled.useCount >= this.recycleAfter,\n    ).length;\n\n    return {\n      healthy: aliveTerminals.length > 0,\n      size: this.terminals.size,\n      available,\n      recycled,\n    };\n  }\n\n  async performMaintenance(): Promise<void> {\n    this.logger.debug('Performing terminal pool maintenance');\n\n    // Remove dead terminals\n    const deadTerminals: string[] = [];\n    for (const [id, pooled] of this.terminals.entries()) {\n      if (!pooled.terminal.isAlive()) {\n        deadTerminals.push(id);\n      }\n    }\n\n    // Clean up dead terminals\n    for (const id of deadTerminals) {\n      this.logger.warn('Removing dead terminal from pool', { terminalId: id });\n      this.terminals.delete(id);\n      const index = this.availableQueue.indexOf(id);\n      if (index !== -1) {\n        this.availableQueue.splice(index, 1);\n      }\n    }\n\n    // Ensure minimum pool size\n    const currentSize = this.terminals.size;\n    const minSize = Math.min(2, this.maxSize);\n\n    if (currentSize < minSize) {\n      const toCreate = minSize - currentSize;\n      this.logger.info('Replenishing terminal pool', {\n        currentSize,\n        minSize,\n        creating: toCreate,\n      });\n\n      const promises: Promise<void>[] = [];\n      for (let i = 0; i < toCreate; i++) {\n        promises.push(this.createPooledTerminal());\n      }\n\n      await Promise.all(promises);\n    }\n\n    // Check for stale terminals that should be recycled\n    const now = Date.now();\n    const staleTimeout = 300000; // 5 minutes\n\n    for (const [id, pooled] of this.terminals.entries()) {\n      if (!pooled.inUse && pooled.terminal.isAlive()) {\n        const idleTime = now - pooled.lastUsed.getTime();\n        if (idleTime > staleTimeout) {\n          this.logger.info('Recycling stale terminal', {\n            terminalId: id,\n            idleTime,\n          });\n\n          // Mark for recycling\n          pooled.useCount = this.recycleAfter;\n        }\n      }\n    }\n  }\n\n  private async createPooledTerminal(): Promise<void> {\n    try {\n      const terminal = await this.adapter.createTerminal();\n\n      const pooled: PooledTerminal = {\n        terminal,\n        useCount: 0,\n        lastUsed: new Date(),\n        inUse: false,\n      };\n\n      this.terminals.set(terminal.id, pooled);\n      this.availableQueue.push(terminal.id);\n\n      this.logger.debug('Created pooled terminal', { terminalId: terminal.id });\n    } catch (error) {\n      this.logger.error('Failed to create pooled terminal', error);\n      throw error;\n    }\n  }\n}\n"],"names":["TerminalError","delay","TerminalPool","terminals","Map","availableQueue","initializationPromise","maxSize","recycleAfter","adapter","logger","initialize","doInitialize","info","preCreateCount","Math","min","promises","i","push","createPooledTerminal","Promise","all","created","shutdown","Array","from","values","map","terminal","destroyTerminal","clear","acquire","length","terminalId","shift","pooled","get","isAlive","inUse","lastUsed","Date","debug","useCount","delete","size","startTime","now","timeout","available","find","release","id","warn","getHealthStatus","aliveTerminals","filter","recycled","healthy","performMaintenance","deadTerminals","entries","index","indexOf","splice","currentSize","minSize","toCreate","creating","staleTimeout","idleTime","getTime","createTerminal","set","error"],"mappings":"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"}