{"version":3,"sources":["../../../src/task/engine.ts"],"sourcesContent":["/**\n * Task Engine Core - Comprehensive task management with orchestration features\n * Integrates with TodoWrite/TodoRead for coordination and Memory for persistence\n */\n\nimport { EventEmitter } from 'events';\nimport type { Task, TaskStatus, AgentProfile, Resource } from '../utils/types.js';\nimport type { TaskMetadata } from './types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface TaskDependency {\n  taskId: string;\n  type: 'finish-to-start' | 'start-to-start' | 'finish-to-finish' | 'start-to-finish';\n  lag?: number; // delay in milliseconds\n}\n\nexport interface ResourceRequirement {\n  resourceId: string;\n  type: 'cpu' | 'memory' | 'disk' | 'network' | 'custom';\n  amount: number;\n  unit: string;\n  exclusive?: boolean;\n  priority?: number;\n}\n\nexport interface TaskSchedule {\n  startTime?: Date;\n  endTime?: Date;\n  deadline?: Date;\n  recurring?: {\n    interval: 'daily' | 'weekly' | 'monthly';\n    count?: number;\n    until?: Date;\n  };\n  timezone?: string;\n}\n\nexport interface WorkflowTask extends Omit<Task, 'dependencies' | 'metadata'> {\n  dependencies: TaskDependency[];\n  resourceRequirements: ResourceRequirement[];\n  schedule?: TaskSchedule;\n  retryPolicy?: {\n    maxAttempts: number;\n    backoffMs: number;\n    backoffMultiplier: number;\n  };\n  timeout?: number;\n  tags: string[];\n  estimatedDurationMs?: number;\n  actualDurationMs?: number;\n  progressPercentage: number;\n  checkpoints: TaskCheckpoint[];\n  rollbackStrategy?: 'previous-checkpoint' | 'initial-state' | 'custom';\n  customRollbackHandler?: string;\n  metadata: TaskMetadata;\n}\n\nexport interface TaskCheckpoint {\n  id: string;\n  timestamp: Date;\n  description: string;\n  state: Record<string, unknown>;\n  artifacts: string[];\n}\n\nexport interface TaskExecution {\n  id: string;\n  taskId: string;\n  agentId: string;\n  startedAt: Date;\n  completedAt?: Date;\n  status: TaskStatus;\n  progress: number;\n  metrics: TaskMetrics;\n  logs: TaskLog[];\n}\n\nexport interface TaskMetrics {\n  cpuUsage: number;\n  memoryUsage: number;\n  diskIO: number;\n  networkIO: number;\n  customMetrics: Record<string, number>;\n}\n\nexport interface TaskLog {\n  timestamp: Date;\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface Workflow {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  tasks: WorkflowTask[];\n  variables: Record<string, unknown>;\n  parallelism: {\n    maxConcurrent: number;\n    strategy: 'breadth-first' | 'depth-first' | 'priority-based';\n  };\n  errorHandling: {\n    strategy: 'fail-fast' | 'continue-on-error' | 'retry-failed';\n    maxRetries: number;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n  createdBy: string;\n}\n\nexport interface TaskFilter {\n  status?: TaskStatus[];\n  assignedAgent?: string[];\n  priority?: { min?: number; max?: number };\n  tags?: string[];\n  createdAfter?: Date;\n  createdBefore?: Date;\n  dueBefore?: Date;\n  search?: string;\n}\n\nexport interface TaskSort {\n  field: 'createdAt' | 'priority' | 'deadline' | 'status' | 'estimatedDuration';\n  direction: 'asc' | 'desc';\n}\n\nexport class TaskEngine extends EventEmitter {\n  private tasks = new Map<string, WorkflowTask>();\n  private executions = new Map<string, TaskExecution>();\n  private workflows = new Map<string, Workflow>();\n  private resources = new Map<string, Resource>();\n  private dependencyGraph = new Map<string, Set<string>>();\n  private readyQueue: string[] = [];\n  private runningTasks = new Set<string>();\n  private cancelledTasks = new Set<string>();\n  private taskState = new Map<string, Record<string, unknown>>();\n\n  constructor(\n    private maxConcurrent: number = 10,\n    private memoryManager?: any, // Memory interface for persistence\n  ) {\n    super();\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.on('task:created', this.handleTaskCreated.bind(this));\n    this.on('task:completed', this.handleTaskCompleted.bind(this));\n    this.on('task:failed', this.handleTaskFailed.bind(this));\n    this.on('task:cancelled', this.handleTaskCancelled.bind(this));\n  }\n\n  /**\n   * Create a new task with comprehensive options\n   */\n  async createTask(taskData: Partial<WorkflowTask>): Promise<WorkflowTask> {\n    const task: WorkflowTask = {\n      id: taskData.id || generateId('task'),\n      type: taskData.type || 'general',\n      description: taskData.description || '',\n      priority: taskData.priority || 0,\n      status: 'pending',\n      input: taskData.input || {},\n      createdAt: new Date(),\n      dependencies: taskData.dependencies || [],\n      resourceRequirements: taskData.resourceRequirements || [],\n      schedule: taskData.schedule,\n      retryPolicy: taskData.retryPolicy || {\n        maxAttempts: 3,\n        backoffMs: 1000,\n        backoffMultiplier: 2,\n      },\n      timeout: taskData.timeout || 300000, // 5 minutes default\n      tags: taskData.tags || [],\n      estimatedDurationMs: taskData.estimatedDurationMs,\n      progressPercentage: 0,\n      checkpoints: [],\n      rollbackStrategy: taskData.rollbackStrategy || 'previous-checkpoint',\n      metadata: taskData.metadata || {},\n    };\n\n    this.tasks.set(task.id, task);\n    this.updateDependencyGraph(task);\n\n    // Store in memory if manager available\n    if (this.memoryManager) {\n      await this.memoryManager.store(`task:${task.id}`, task);\n    }\n\n    this.emit('task:created', { task });\n    this.scheduleTask(task);\n\n    return task;\n  }\n\n  /**\n   * List tasks with filtering and sorting\n   */\n  async listTasks(\n    filter?: TaskFilter,\n    sort?: TaskSort,\n    limit?: number,\n    offset?: number,\n  ): Promise<{ tasks: WorkflowTask[]; total: number; hasMore: boolean }> {\n    let filteredTasks = Array.from(this.tasks.values());\n\n    // Apply filters\n    if (filter) {\n      filteredTasks = filteredTasks.filter((task) => {\n        if (filter.status && !filter.status.includes(task.status)) return false;\n        if (filter.assignedAgent && !filter.assignedAgent.includes(task.assignedAgent || ''))\n          return false;\n        if (filter.priority) {\n          if (filter.priority.min !== undefined && task.priority < filter.priority.min)\n            return false;\n          if (filter.priority.max !== undefined && task.priority > filter.priority.max)\n            return false;\n        }\n        if (filter.tags && !filter.tags.some((tag) => task.tags.includes(tag))) return false;\n        if (filter.createdAfter && task.createdAt < filter.createdAfter) return false;\n        if (filter.createdBefore && task.createdAt > filter.createdBefore) return false;\n        if (\n          filter.dueBefore &&\n          task.schedule?.deadline &&\n          task.schedule.deadline > filter.dueBefore\n        )\n          return false;\n        if (filter.search && !this.matchesSearch(task, filter.search)) return false;\n        return true;\n      });\n    }\n\n    // Apply sorting\n    if (sort) {\n      filteredTasks.sort((a, b) => {\n        const direction = sort.direction === 'desc' ? -1 : 1;\n        switch (sort.field) {\n          case 'createdAt':\n            return direction * (a.createdAt.getTime() - b.createdAt.getTime());\n          case 'priority':\n            return direction * (a.priority - b.priority);\n          case 'deadline':\n            const aDeadline = a.schedule?.deadline?.getTime() || 0;\n            const bDeadline = b.schedule?.deadline?.getTime() || 0;\n            return direction * (aDeadline - bDeadline);\n          case 'estimatedDuration':\n            return direction * ((a.estimatedDurationMs || 0) - (b.estimatedDurationMs || 0));\n          default:\n            return 0;\n        }\n      });\n    }\n\n    const total = filteredTasks.length;\n    const startIndex = offset || 0;\n    const endIndex = limit ? startIndex + limit : filteredTasks.length;\n    const tasks = filteredTasks.slice(startIndex, endIndex);\n\n    return {\n      tasks,\n      total,\n      hasMore: endIndex < total,\n    };\n  }\n\n  /**\n   * Get detailed task status with progress and metrics\n   */\n  async getTaskStatus(taskId: string): Promise<{\n    task: WorkflowTask;\n    execution?: TaskExecution;\n    dependencies: { task: WorkflowTask; satisfied: boolean }[];\n    dependents: WorkflowTask[];\n    resourceStatus: { required: ResourceRequirement; available: boolean; allocated: boolean }[];\n  } | null> {\n    const task = this.tasks.get(taskId);\n    if (!task) return null;\n\n    const execution = this.executions.get(taskId);\n\n    // Get dependency status\n    const dependencies = await Promise.all(\n      task.dependencies.map(async (dep) => {\n        const depTask = this.tasks.get(dep.taskId);\n        if (!depTask) throw new Error(`Dependency task ${dep.taskId} not found`);\n        const satisfied = this.isDependencySatisfied(dep, depTask);\n        return { task: depTask, satisfied };\n      }),\n    );\n\n    // Get dependent tasks\n    const dependents = Array.from(this.tasks.values()).filter((t) =>\n      t.dependencies.some((dep) => dep.taskId === taskId),\n    );\n\n    // Get resource status\n    const resourceStatus = task.resourceRequirements.map((req) => {\n      const resource = this.resources.get(req.resourceId);\n      return {\n        required: req,\n        available: !!resource,\n        allocated: resource?.lockedBy === taskId,\n      };\n    });\n\n    return {\n      task,\n      execution,\n      dependencies,\n      dependents,\n      resourceStatus,\n    };\n  }\n\n  /**\n   * Cancel task with rollback and cleanup\n   */\n  async cancelTask(\n    taskId: string,\n    reason: string = 'User requested',\n    rollback: boolean = true,\n  ): Promise<void> {\n    const task = this.tasks.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} not found`);\n\n    if (task.status === 'completed') {\n      throw new Error(`Cannot cancel completed task ${taskId}`);\n    }\n\n    this.cancelledTasks.add(taskId);\n\n    // Stop running execution\n    if (this.runningTasks.has(taskId)) {\n      this.runningTasks.delete(taskId);\n      const execution = this.executions.get(taskId);\n      if (execution) {\n        execution.status = 'cancelled';\n        execution.completedAt = new Date();\n      }\n    }\n\n    // Release resources\n    await this.releaseTaskResources(taskId);\n\n    // Perform rollback if requested\n    if (rollback && task.checkpoints.length > 0) {\n      await this.rollbackTask(task);\n    }\n\n    // Update task status\n    task.status = 'cancelled';\n    task.metadata = {\n      ...task.metadata,\n      cancellationReason: reason,\n      cancelledAt: new Date(),\n    };\n\n    // Update memory\n    if (this.memoryManager) {\n      await this.memoryManager.store(`task:${taskId}`, task);\n    }\n\n    this.emit('task:cancelled', { taskId, reason });\n\n    // Cancel dependent tasks if configured\n    const dependents = Array.from(this.tasks.values()).filter((t) =>\n      t.dependencies.some((dep) => dep.taskId === taskId),\n    );\n\n    for (const dependent of dependents) {\n      if (dependent.status === 'pending' || dependent.status === 'queued') {\n        await this.cancelTask(dependent.id, `Dependency ${taskId} was cancelled`);\n      }\n    }\n  }\n\n  /**\n   * Execute workflow with parallel processing\n   */\n  async executeWorkflow(workflow: Workflow): Promise<void> {\n    this.workflows.set(workflow.id, workflow);\n\n    // Add all workflow tasks\n    for (const task of workflow.tasks) {\n      this.tasks.set(task.id, task);\n      this.updateDependencyGraph(task);\n    }\n\n    // Start execution with parallel processing\n    await this.processWorkflow(workflow);\n  }\n\n  /**\n   * Create workflow from tasks\n   */\n  async createWorkflow(workflowData: Partial<Workflow>): Promise<Workflow> {\n    const workflow: Workflow = {\n      id: workflowData.id || generateId('workflow'),\n      name: workflowData.name || 'Unnamed Workflow',\n      description: workflowData.description || '',\n      version: workflowData.version || '1.0.0',\n      tasks: workflowData.tasks || [],\n      variables: workflowData.variables || {},\n      parallelism: workflowData.parallelism || {\n        maxConcurrent: this.maxConcurrent,\n        strategy: 'priority-based',\n      },\n      errorHandling: workflowData.errorHandling || {\n        strategy: 'fail-fast',\n        maxRetries: 3,\n      },\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      createdBy: workflowData.createdBy || 'system',\n    };\n\n    this.workflows.set(workflow.id, workflow);\n\n    if (this.memoryManager) {\n      await this.memoryManager.store(`workflow:${workflow.id}`, workflow);\n    }\n\n    return workflow;\n  }\n\n  /**\n   * Get dependency visualization\n   */\n  getDependencyGraph(): { nodes: any[]; edges: any[] } {\n    const nodes = Array.from(this.tasks.values()).map((task) => ({\n      id: task.id,\n      label: task.description,\n      status: task.status,\n      priority: task.priority,\n      progress: task.progressPercentage,\n      estimatedDuration: task.estimatedDurationMs,\n      tags: task.tags,\n    }));\n\n    const edges: any[] = [];\n    for (const task of Array.from(this.tasks.values())) {\n      for (const dep of task.dependencies) {\n        edges.push({\n          from: dep.taskId,\n          to: task.id,\n          type: dep.type,\n          lag: dep.lag,\n        });\n      }\n    }\n\n    return { nodes, edges };\n  }\n\n  // Private helper methods\n\n  private updateDependencyGraph(task: WorkflowTask): void {\n    if (!this.dependencyGraph.has(task.id)) {\n      this.dependencyGraph.set(task.id, new Set());\n    }\n\n    for (const dep of task.dependencies) {\n      if (!this.dependencyGraph.has(dep.taskId)) {\n        this.dependencyGraph.set(dep.taskId, new Set());\n      }\n      this.dependencyGraph.get(dep.taskId)!.add(task.id);\n    }\n  }\n\n  private scheduleTask(task: WorkflowTask): void {\n    if (this.areTaskDependenciesSatisfied(task)) {\n      this.readyQueue.push(task.id);\n      this.processReadyQueue();\n    }\n  }\n\n  private areTaskDependenciesSatisfied(task: WorkflowTask): boolean {\n    return task.dependencies.every((dep) => {\n      const depTask = this.tasks.get(dep.taskId);\n      return depTask && this.isDependencySatisfied(dep, depTask);\n    });\n  }\n\n  private isDependencySatisfied(dependency: TaskDependency, depTask: WorkflowTask): boolean {\n    switch (dependency.type) {\n      case 'finish-to-start':\n        return depTask.status === 'completed';\n      case 'start-to-start':\n        return depTask.status !== 'pending';\n      case 'finish-to-finish':\n        return depTask.status === 'completed';\n      case 'start-to-finish':\n        return depTask.status !== 'pending';\n      default:\n        return depTask.status === 'completed';\n    }\n  }\n\n  private async processReadyQueue(): Promise<void> {\n    while (this.readyQueue.length > 0 && this.runningTasks.size < this.maxConcurrent) {\n      const taskId = this.readyQueue.shift()!;\n      if (this.cancelledTasks.has(taskId)) continue;\n\n      const task = this.tasks.get(taskId);\n      if (!task) continue;\n\n      await this.executeTask(task);\n    }\n  }\n\n  private async executeTask(task: WorkflowTask): Promise<void> {\n    if (!(await this.acquireTaskResources(task))) {\n      // Resources not available, put back in queue\n      this.readyQueue.unshift(task.id);\n      return;\n    }\n\n    const execution: TaskExecution = {\n      id: generateId('execution'),\n      taskId: task.id,\n      agentId: task.assignedAgent || 'system',\n      startedAt: new Date(),\n      status: 'running',\n      progress: 0,\n      metrics: {\n        cpuUsage: 0,\n        memoryUsage: 0,\n        diskIO: 0,\n        networkIO: 0,\n        customMetrics: {},\n      },\n      logs: [],\n    };\n\n    this.executions.set(task.id, execution);\n    this.runningTasks.add(task.id);\n    task.status = 'running';\n    task.startedAt = new Date();\n\n    this.emit('task:started', { taskId: task.id, agentId: execution.agentId });\n\n    try {\n      // Simulate task execution - in real implementation, this would delegate to agents\n      await this.simulateTaskExecution(task, execution);\n\n      task.status = 'completed';\n      task.completedAt = new Date();\n      task.progressPercentage = 100;\n      execution.status = 'completed';\n      execution.completedAt = new Date();\n\n      this.emit('task:completed', { taskId: task.id, result: task.output });\n    } catch (error) {\n      task.status = 'failed';\n      task.error = error as Error;\n      execution.status = 'failed';\n      execution.completedAt = new Date();\n\n      this.emit('task:failed', { taskId: task.id, error });\n    } finally {\n      this.runningTasks.delete(task.id);\n      await this.releaseTaskResources(task.id);\n\n      if (this.memoryManager) {\n        await this.memoryManager.store(`task:${task.id}`, task);\n        await this.memoryManager.store(`execution:${execution.id}`, execution);\n      }\n    }\n  }\n\n  private async simulateTaskExecution(task: WorkflowTask, execution: TaskExecution): Promise<void> {\n    // Simulate work with progress updates\n    const steps = 10;\n    for (let i = 0; i <= steps; i++) {\n      if (this.cancelledTasks.has(task.id)) {\n        throw new Error('Task was cancelled');\n      }\n\n      task.progressPercentage = (i / steps) * 100;\n      execution.progress = task.progressPercentage;\n\n      // Create checkpoint every 25%\n      if (i % Math.ceil(steps / 4) === 0) {\n        await this.createCheckpoint(task, `Step ${i} completed`);\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n\n    task.output = { result: 'Task completed successfully', timestamp: new Date() };\n  }\n\n  private async createCheckpoint(task: WorkflowTask, description: string): Promise<void> {\n    const checkpoint: TaskCheckpoint = {\n      id: generateId('checkpoint'),\n      timestamp: new Date(),\n      description,\n      state: { ...(this.taskState.get(task.id) || {}) },\n      artifacts: [],\n    };\n\n    task.checkpoints.push(checkpoint);\n\n    if (this.memoryManager) {\n      await this.memoryManager.store(`checkpoint:${checkpoint.id}`, checkpoint);\n    }\n  }\n\n  private async rollbackTask(task: WorkflowTask): Promise<void> {\n    if (task.checkpoints.length === 0) return;\n\n    const targetCheckpoint =\n      task.rollbackStrategy === 'initial-state'\n        ? task.checkpoints[0]\n        : task.checkpoints[task.checkpoints.length - 1];\n\n    // Restore state from checkpoint\n    this.taskState.set(task.id, { ...targetCheckpoint.state });\n\n    // Remove checkpoints after the target\n    const targetIndex = task.checkpoints.findIndex((cp) => cp.id === targetCheckpoint.id);\n    task.checkpoints = task.checkpoints.slice(0, targetIndex + 1);\n\n    task.progressPercentage = Math.max(0, task.progressPercentage - 25);\n  }\n\n  private async acquireTaskResources(task: WorkflowTask): Promise<boolean> {\n    for (const requirement of task.resourceRequirements) {\n      const resource = this.resources.get(requirement.resourceId);\n      if (!resource) return false;\n\n      if (resource.locked && requirement.exclusive) return false;\n\n      resource.locked = true;\n      resource.lockedBy = task.id;\n      resource.lockedAt = new Date();\n    }\n    return true;\n  }\n\n  private async releaseTaskResources(taskId: string): Promise<void> {\n    for (const resource of Array.from(this.resources.values())) {\n      if (resource.lockedBy === taskId) {\n        resource.locked = false;\n        resource.lockedBy = undefined;\n        resource.lockedAt = undefined;\n      }\n    }\n  }\n\n  private matchesSearch(task: WorkflowTask, search: string): boolean {\n    const searchLower = search.toLowerCase();\n    return (\n      task.description.toLowerCase().includes(searchLower) ||\n      task.type.toLowerCase().includes(searchLower) ||\n      task.tags.some((tag) => tag.toLowerCase().includes(searchLower)) ||\n      (task.assignedAgent ? task.assignedAgent.toLowerCase().includes(searchLower) : false)\n    );\n  }\n\n  private async processWorkflow(workflow: Workflow): Promise<void> {\n    // Implementation would manage workflow execution based on parallelism settings\n    // This is a simplified version\n    for (const task of workflow.tasks) {\n      this.scheduleTask(task);\n    }\n  }\n\n  private handleTaskCreated(data: { task: WorkflowTask }): void {\n    // Handle task creation events\n  }\n\n  private handleTaskCompleted(data: { taskId: string; result: unknown }): void {\n    // Schedule dependent tasks\n    const dependents = Array.from(this.tasks.values()).filter((task) =>\n      task.dependencies.some((dep) => dep.taskId === data.taskId),\n    );\n\n    for (const dependent of dependents) {\n      if (this.areTaskDependenciesSatisfied(dependent)) {\n        this.readyQueue.push(dependent.id);\n      }\n    }\n\n    this.processReadyQueue();\n  }\n\n  private handleTaskFailed(data: { taskId: string; error: Error }): void {\n    // Handle task failure, potentially retry or fail dependents\n    const task = this.tasks.get(data.taskId);\n    if (!task) return;\n\n    // Implement retry logic based on retryPolicy\n    if (task.retryPolicy && (task.metadata.retryCount || 0) < task.retryPolicy.maxAttempts) {\n      const currentRetryCount = task.metadata.retryCount || 0;\n      task.metadata = {\n        ...task.metadata,\n        retryCount: currentRetryCount + 1,\n        lastRetryAt: new Date(),\n      };\n      task.status = 'pending';\n\n      // Schedule retry with backoff\n      setTimeout(\n        () => {\n          this.scheduleTask(task);\n        },\n        task.retryPolicy!.backoffMs *\n          Math.pow(task.retryPolicy!.backoffMultiplier, currentRetryCount),\n      );\n    }\n  }\n\n  private handleTaskCancelled(data: { taskId: string; reason: string }): void {\n    // Handle task cancellation\n  }\n}\n"],"names":["EventEmitter","generateId","TaskEngine","tasks","Map","executions","workflows","resources","dependencyGraph","readyQueue","runningTasks","Set","cancelledTasks","taskState","maxConcurrent","memoryManager","setupEventHandlers","on","handleTaskCreated","bind","handleTaskCompleted","handleTaskFailed","handleTaskCancelled","createTask","taskData","task","id","type","description","priority","status","input","createdAt","Date","dependencies","resourceRequirements","schedule","retryPolicy","maxAttempts","backoffMs","backoffMultiplier","timeout","tags","estimatedDurationMs","progressPercentage","checkpoints","rollbackStrategy","metadata","set","updateDependencyGraph","store","emit","scheduleTask","listTasks","filter","sort","limit","offset","filteredTasks","Array","from","values","includes","assignedAgent","min","undefined","max","some","tag","createdAfter","createdBefore","dueBefore","deadline","search","matchesSearch","a","b","direction","field","getTime","aDeadline","bDeadline","total","length","startIndex","endIndex","slice","hasMore","getTaskStatus","taskId","get","execution","Promise","all","map","dep","depTask","Error","satisfied","isDependencySatisfied","dependents","t","resourceStatus","req","resource","resourceId","required","available","allocated","lockedBy","cancelTask","reason","rollback","add","has","delete","completedAt","releaseTaskResources","rollbackTask","cancellationReason","cancelledAt","dependent","executeWorkflow","workflow","processWorkflow","createWorkflow","workflowData","name","version","variables","parallelism","strategy","errorHandling","maxRetries","updatedAt","createdBy","getDependencyGraph","nodes","label","progress","estimatedDuration","edges","push","to","lag","areTaskDependenciesSatisfied","processReadyQueue","every","dependency","size","shift","executeTask","acquireTaskResources","unshift","agentId","startedAt","metrics","cpuUsage","memoryUsage","diskIO","networkIO","customMetrics","logs","simulateTaskExecution","result","output","error","steps","i","Math","ceil","createCheckpoint","resolve","setTimeout","timestamp","checkpoint","state","artifacts","targetCheckpoint","targetIndex","findIndex","cp","requirement","locked","exclusive","lockedAt","searchLower","toLowerCase","data","retryCount","currentRetryCount","lastRetryAt","pow"],"mappings":"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"}