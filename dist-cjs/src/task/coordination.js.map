{"version":3,"sources":["../../../src/task/coordination.ts"],"sourcesContent":["/**\n * Task Coordination Layer - Integrates with TodoWrite/TodoRead and Memory for orchestration\n * Provides seamless coordination between task management and Claude Code batch tools\n */\n\nimport { EventEmitter } from 'events';\nimport type { TaskEngine, WorkflowTask, TaskExecution } from './engine.js';\nimport type { TodoItem, MemoryEntry, CoordinationContext } from './types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport class TaskCoordinator extends EventEmitter {\n  private todoItems = new Map<string, TodoItem>();\n  private memoryStore = new Map<string, MemoryEntry>();\n  private coordinationSessions = new Map<string, CoordinationContext>();\n  private batchOperations = new Map<string, BatchOperation>();\n  private agentCoordination = new Map<string, AgentCoordinationState>();\n\n  constructor(\n    private taskEngine: TaskEngine,\n    private memoryManager?: any,\n  ) {\n    super();\n    this.setupCoordinationHandlers();\n  }\n\n  private setupCoordinationHandlers(): void {\n    this.taskEngine.on('task:created', this.handleTaskCreated.bind(this));\n    this.taskEngine.on('task:started', this.handleTaskStarted.bind(this));\n    this.taskEngine.on('task:completed', this.handleTaskCompleted.bind(this));\n    this.taskEngine.on('task:failed', this.handleTaskFailed.bind(this));\n    this.taskEngine.on('task:cancelled', this.handleTaskCancelled.bind(this));\n  }\n\n  /**\n   * Create TodoWrite-style task breakdown for complex operations\n   */\n  async createTaskTodos(\n    objective: string,\n    context: CoordinationContext,\n    options: {\n      strategy?:\n        | 'research'\n        | 'development'\n        | 'analysis'\n        | 'testing'\n        | 'optimization'\n        | 'maintenance';\n      maxTasks?: number;\n      batchOptimized?: boolean;\n      parallelExecution?: boolean;\n      memoryCoordination?: boolean;\n    } = {},\n  ): Promise<TodoItem[]> {\n    const sessionId = context.sessionId;\n    this.coordinationSessions.set(sessionId, context);\n\n    // AI-powered task breakdown based on objective and strategy\n    const todos = await this.generateTaskBreakdown(objective, options);\n\n    // Store todos in coordination system\n    for (const todo of todos) {\n      this.todoItems.set(todo.id, todo);\n\n      // Store in memory for cross-agent coordination\n      if (options.memoryCoordination && this.memoryManager) {\n        await this.storeInMemory(`todo:${todo.id}`, todo, {\n          namespace: 'task_coordination',\n          tags: ['todo', 'task_breakdown', sessionId],\n        });\n      }\n    }\n\n    // Emit coordination event\n    this.emit('todos:created', { sessionId, todos, context });\n\n    return todos;\n  }\n\n  /**\n   * Update TodoRead-style progress tracking\n   */\n  async updateTodoProgress(\n    todoId: string,\n    status: 'pending' | 'in_progress' | 'completed',\n    metadata?: Record<string, unknown>,\n  ): Promise<void> {\n    const todo = this.todoItems.get(todoId);\n    if (!todo) {\n      throw new Error(`Todo ${todoId} not found`);\n    }\n\n    const previousStatus = todo.status;\n    todo.status = status;\n    todo.metadata = { ...todo.metadata, ...metadata, updatedAt: new Date() };\n\n    // Update in memory for coordination\n    if (this.memoryManager) {\n      await this.storeInMemory(`todo:${todoId}`, todo, {\n        namespace: 'task_coordination',\n        tags: ['todo', 'progress_update'],\n      });\n    }\n\n    // Create corresponding task if moving to in_progress\n    if (status === 'in_progress' && previousStatus === 'pending') {\n      await this.createTaskFromTodo(todo);\n    }\n\n    this.emit('todo:updated', { todoId, status, previousStatus, todo });\n  }\n\n  /**\n   * Read all todos for coordination (TodoRead equivalent)\n   */\n  async readTodos(\n    sessionId?: string,\n    filter?: {\n      status?: TodoItem['status'][];\n      priority?: TodoItem['priority'][];\n      assignedAgent?: string;\n      tags?: string[];\n      batchOptimized?: boolean;\n    },\n  ): Promise<TodoItem[]> {\n    let todos = Array.from(this.todoItems.values());\n\n    // Filter by session if provided\n    if (sessionId) {\n      const sessionTodos = await this.getSessionTodos(sessionId);\n      todos = todos.filter((todo) => sessionTodos.some((st) => st.id === todo.id));\n    }\n\n    // Apply filters\n    if (filter) {\n      if (filter.status) {\n        todos = todos.filter((todo) => filter.status!.includes(todo.status));\n      }\n      if (filter.priority) {\n        todos = todos.filter((todo) => filter.priority!.includes(todo.priority));\n      }\n      if (filter.assignedAgent) {\n        todos = todos.filter((todo) => todo.assignedAgent === filter.assignedAgent);\n      }\n      if (filter.tags) {\n        todos = todos.filter((todo) => todo.tags?.some((tag) => filter.tags!.includes(tag)));\n      }\n      if (filter.batchOptimized !== undefined) {\n        todos = todos.filter((todo) => todo.batchOptimized === filter.batchOptimized);\n      }\n    }\n\n    return todos;\n  }\n\n  /**\n   * Store data in Memory for cross-agent coordination\n   */\n  async storeInMemory(\n    key: string,\n    value: any,\n    options: {\n      namespace?: string;\n      tags?: string[];\n      expiresAt?: Date;\n    } = {},\n  ): Promise<void> {\n    const entry: MemoryEntry = {\n      key,\n      value,\n      timestamp: new Date(),\n      namespace: options.namespace,\n      tags: options.tags,\n      expiresAt: options.expiresAt,\n    };\n\n    this.memoryStore.set(key, entry);\n\n    // Store in external memory manager if available\n    if (this.memoryManager) {\n      const memoryKey = options.namespace ? `${options.namespace}:${key}` : key;\n      await this.memoryManager.store(memoryKey, value, {\n        tags: options.tags,\n        expiresAt: options.expiresAt,\n      });\n    }\n\n    this.emit('memory:stored', { key, entry });\n  }\n\n  /**\n   * Retrieve data from Memory for coordination\n   */\n  async retrieveFromMemory(key: string, namespace?: string): Promise<any | null> {\n    const memoryKey = namespace ? `${namespace}:${key}` : key;\n\n    // Try external memory manager first\n    if (this.memoryManager) {\n      try {\n        const value = await this.memoryManager.retrieve(memoryKey);\n        if (value !== null) return value;\n      } catch (error) {\n        // Fall back to local store\n      }\n    }\n\n    // Use local store\n    const entry = this.memoryStore.get(key);\n    if (!entry) return null;\n\n    // Check expiration\n    if (entry.expiresAt && entry.expiresAt < new Date()) {\n      this.memoryStore.delete(key);\n      return null;\n    }\n\n    return entry.value;\n  }\n\n  /**\n   * Query Memory with filters for coordination\n   */\n  async queryMemory(query: {\n    namespace?: string;\n    tags?: string[];\n    keyPattern?: string;\n    since?: Date;\n    limit?: number;\n  }): Promise<MemoryEntry[]> {\n    let entries = Array.from(this.memoryStore.values());\n\n    // Apply filters\n    if (query.namespace) {\n      entries = entries.filter((entry) => entry.namespace === query.namespace);\n    }\n    if (query.tags) {\n      entries = entries.filter((entry) => entry.tags?.some((tag) => query.tags!.includes(tag)));\n    }\n    if (query.keyPattern) {\n      const pattern = new RegExp(query.keyPattern);\n      entries = entries.filter((entry) => pattern.test(entry.key));\n    }\n    if (query.since) {\n      entries = entries.filter((entry) => entry.timestamp >= query.since!);\n    }\n\n    // Sort by timestamp (newest first)\n    entries.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    // Apply limit\n    if (query.limit) {\n      entries = entries.slice(0, query.limit);\n    }\n\n    return entries;\n  }\n\n  /**\n   * Launch parallel agents using Task tool pattern\n   */\n  async launchParallelAgents(\n    tasks: Array<{\n      agentType: string;\n      objective: string;\n      mode?: string;\n      configuration?: Record<string, unknown>;\n      memoryKey?: string;\n      batchOptimized?: boolean;\n    }>,\n    coordinationContext: CoordinationContext,\n  ): Promise<string[]> {\n    const batchId = generateId('batch');\n    const agentIds: string[] = [];\n\n    const batchOperation: BatchOperation = {\n      id: batchId,\n      type: 'parallel_agents',\n      tasks,\n      startedAt: new Date(),\n      status: 'running',\n      results: new Map(),\n      errors: new Map(),\n    };\n\n    this.batchOperations.set(batchId, batchOperation);\n\n    // Store batch operation in memory for coordination\n    await this.storeInMemory(`batch:${batchId}`, batchOperation, {\n      namespace: 'coordination',\n      tags: ['batch_operation', 'parallel_agents'],\n    });\n\n    // Launch each agent\n    for (const task of tasks) {\n      try {\n        const agentId = await this.launchAgent(task, coordinationContext, batchId);\n        agentIds.push(agentId);\n\n        // Store agent coordination state\n        this.agentCoordination.set(agentId, {\n          agentId,\n          batchId,\n          objective: task.objective,\n          status: 'running',\n          startedAt: new Date(),\n          memoryKey: task.memoryKey,\n          coordinationContext,\n        });\n      } catch (error) {\n        batchOperation.errors.set(task.agentType, error as Error);\n      }\n    }\n\n    this.emit('agents:launched', { batchId, agentIds, tasks });\n\n    return agentIds;\n  }\n\n  /**\n   * Coordinate batch operations for maximum efficiency\n   */\n  async coordinateBatchOperations(\n    operations: Array<{\n      type: 'read' | 'write' | 'edit' | 'search' | 'analyze';\n      targets: string[];\n      configuration?: Record<string, unknown>;\n    }>,\n    context: CoordinationContext,\n  ): Promise<Map<string, any>> {\n    const batchId = generateId('batch_ops');\n    const results = new Map<string, any>();\n\n    // Group operations by type for maximum efficiency\n    const groupedOps = new Map<string, Array<any>>();\n\n    for (const op of operations) {\n      if (!groupedOps.has(op.type)) {\n        groupedOps.set(op.type, []);\n      }\n      groupedOps.get(op.type)!.push(op);\n    }\n\n    // Store batch coordination info\n    await this.storeInMemory(\n      `batch_ops:${batchId}`,\n      {\n        operations,\n        groupedOps: Object.fromEntries(groupedOps),\n        context,\n        startedAt: new Date(),\n      },\n      {\n        namespace: 'coordination',\n        tags: ['batch_operations', 'efficiency'],\n      },\n    );\n\n    // Execute operations in parallel by type\n    const promises: Promise<void>[] = [];\n\n    for (const [type, ops] of Array.from(groupedOps.entries())) {\n      promises.push(this.executeBatchOperationType(type, ops, batchId, results));\n    }\n\n    await Promise.all(promises);\n\n    this.emit('batch:completed', { batchId, results, context });\n\n    return results;\n  }\n\n  /**\n   * Swarm coordination patterns based on mode\n   */\n  async coordinateSwarm(\n    objective: string,\n    context: CoordinationContext,\n    agents: Array<{\n      type: string;\n      role: string;\n      capabilities: string[];\n    }>,\n  ): Promise<void> {\n    const swarmId = generateId('swarm');\n\n    // Store swarm configuration\n    await this.storeInMemory(\n      `swarm:${swarmId}`,\n      {\n        objective,\n        context,\n        agents,\n        startedAt: new Date(),\n        coordinationPattern: context.coordinationMode,\n      },\n      {\n        namespace: 'swarm_coordination',\n        tags: ['swarm', context.coordinationMode],\n      },\n    );\n\n    switch (context.coordinationMode) {\n      case 'centralized':\n        await this.coordinateCentralizedSwarm(swarmId, objective, agents);\n        break;\n      case 'distributed':\n        await this.coordinateDistributedSwarm(swarmId, objective, agents);\n        break;\n      case 'hierarchical':\n        await this.coordinateHierarchicalSwarm(swarmId, objective, agents);\n        break;\n      case 'mesh':\n        await this.coordinateMeshSwarm(swarmId, objective, agents);\n        break;\n      case 'hybrid':\n        await this.coordinateHybridSwarm(swarmId, objective, agents);\n        break;\n    }\n  }\n\n  // Private helper methods\n\n  private async generateTaskBreakdown(objective: string, options: any): Promise<TodoItem[]> {\n    // AI-powered task breakdown based on strategy\n    const strategy = options.strategy || 'development';\n    const todos: TodoItem[] = [];\n\n    // Strategy-specific task patterns\n    switch (strategy) {\n      case 'research':\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: 'Gather initial information and sources',\n            status: 'pending',\n            priority: 'high',\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'research_sources',\n            tags: ['research', 'information_gathering'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Analyze and synthesize findings',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['research_sources'],\n            batchOptimized: true,\n            memoryKey: 'research_analysis',\n            tags: ['research', 'analysis'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n        break;\n\n      case 'development':\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: 'Design system architecture',\n            status: 'pending',\n            priority: 'high',\n            memoryKey: 'system_architecture',\n            tags: ['development', 'architecture'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Implement core functionality',\n            status: 'pending',\n            priority: 'high',\n            dependencies: ['system_architecture'],\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'core_implementation',\n            tags: ['development', 'implementation'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Write comprehensive tests',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['core_implementation'],\n            batchOptimized: true,\n            memoryKey: 'test_suite',\n            tags: ['development', 'testing'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n        break;\n\n      case 'analysis':\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: 'Collect and preprocess data',\n            status: 'pending',\n            priority: 'high',\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'analysis_data',\n            tags: ['analysis', 'data_collection'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Perform statistical analysis',\n            status: 'pending',\n            priority: 'high',\n            dependencies: ['analysis_data'],\n            batchOptimized: true,\n            memoryKey: 'statistical_results',\n            tags: ['analysis', 'statistics'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: 'Generate insights and reports',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['statistical_results'],\n            memoryKey: 'analysis_insights',\n            tags: ['analysis', 'reporting'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n        break;\n\n      default:\n        // Generic breakdown\n        todos.push(\n          {\n            id: generateId('todo'),\n            content: `Analyze requirements for: ${objective}`,\n            status: 'pending',\n            priority: 'high',\n            memoryKey: 'requirements_analysis',\n            tags: ['generic', 'requirements'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: `Execute main tasks for: ${objective}`,\n            status: 'pending',\n            priority: 'high',\n            dependencies: ['requirements_analysis'],\n            batchOptimized: true,\n            parallelExecution: true,\n            memoryKey: 'main_execution',\n            tags: ['generic', 'execution'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n          {\n            id: generateId('todo'),\n            content: `Validate and finalize results`,\n            status: 'pending',\n            priority: 'medium',\n            dependencies: ['main_execution'],\n            memoryKey: 'validation_results',\n            tags: ['generic', 'validation'],\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          },\n        );\n    }\n\n    return todos;\n  }\n\n  private async createTaskFromTodo(todo: TodoItem): Promise<WorkflowTask> {\n    const taskData = {\n      type: todo.tags?.[0] || 'general',\n      description: todo.content,\n      priority: this.priorityToNumber(todo.priority),\n      assignedAgent: todo.assignedAgent,\n      tags: todo.tags || [],\n      metadata: {\n        todoId: todo.id,\n        batchOptimized: todo.batchOptimized,\n        parallelExecution: todo.parallelExecution,\n        memoryKey: todo.memoryKey,\n      },\n    };\n\n    return await this.taskEngine.createTask(taskData);\n  }\n\n  private priorityToNumber(priority: 'high' | 'medium' | 'low' | 'critical'): number {\n    switch (priority) {\n      case 'critical':\n        return 90;\n      case 'high':\n        return 80;\n      case 'medium':\n        return 50;\n      case 'low':\n        return 20;\n      default:\n        return 50;\n    }\n  }\n\n  private async launchAgent(\n    task: any,\n    context: CoordinationContext,\n    batchId: string,\n  ): Promise<string> {\n    const agentId = generateId('agent');\n\n    // Store agent launch info in memory\n    await this.storeInMemory(\n      `agent:${agentId}`,\n      {\n        ...task,\n        agentId,\n        batchId,\n        context,\n        launchedAt: new Date(),\n      },\n      {\n        namespace: 'agent_coordination',\n        tags: ['agent_launch', task.agentType],\n      },\n    );\n\n    return agentId;\n  }\n\n  private async executeBatchOperationType(\n    type: string,\n    operations: any[],\n    batchId: string,\n    results: Map<string, any>,\n  ): Promise<void> {\n    // Simulate batch operation execution\n    // In real implementation, this would use actual tools\n\n    for (const op of operations) {\n      try {\n        const result = await this.simulateBatchOperation(type, op);\n        results.set(`${type}_${op.targets.join('_')}`, result);\n      } catch (error) {\n        results.set(`${type}_${op.targets.join('_')}_error`, error);\n      }\n    }\n  }\n\n  private async simulateBatchOperation(type: string, operation: any): Promise<any> {\n    // Simulate operation based on type\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    return {\n      type,\n      targets: operation.targets,\n      result: `Simulated ${type} operation completed`,\n      timestamp: new Date(),\n    };\n  }\n\n  // Swarm coordination patterns\n\n  private async coordinateCentralizedSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Single coordinator manages all agents\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'centralized',\n      coordinator: 'main',\n      agentAssignments: agents.map((agent) => ({\n        agentId: agent.type,\n        role: agent.role,\n        coordinator: 'main',\n      })),\n    });\n  }\n\n  private async coordinateDistributedSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Multiple coordinators for different aspects\n    const coordinators = ['research_coord', 'impl_coord', 'test_coord'];\n\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'distributed',\n      coordinators,\n      agentAssignments: agents.map((agent, index) => ({\n        agentId: agent.type,\n        role: agent.role,\n        coordinator: coordinators[index % coordinators.length],\n      })),\n    });\n  }\n\n  private async coordinateHierarchicalSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Tree structure with team leads\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'hierarchical',\n      hierarchy: {\n        master: 'main_coordinator',\n        teamLeads: ['frontend_lead', 'backend_lead', 'devops_lead'],\n        teams: {\n          frontend_lead: agents.filter((a) => a.type.includes('frontend')),\n          backend_lead: agents.filter((a) => a.type.includes('backend')),\n          devops_lead: agents.filter((a) => a.type.includes('devops')),\n        },\n      },\n    });\n  }\n\n  private async coordinateMeshSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Peer-to-peer coordination\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'mesh',\n      peerConnections: agents.map((agent) => ({\n        agentId: agent.type,\n        peers: agents.filter((a) => a.type !== agent.type).map((a) => a.type),\n      })),\n    });\n  }\n\n  private async coordinateHybridSwarm(\n    swarmId: string,\n    objective: string,\n    agents: any[],\n  ): Promise<void> {\n    // Mixed patterns based on requirements\n    await this.storeInMemory(`swarm:${swarmId}:pattern`, {\n      type: 'hybrid',\n      phases: [\n        { phase: 'planning', pattern: 'centralized' },\n        { phase: 'execution', pattern: 'distributed' },\n        { phase: 'integration', pattern: 'hierarchical' },\n      ],\n    });\n  }\n\n  private async getSessionTodos(sessionId: string): Promise<TodoItem[]> {\n    const entries = await this.queryMemory({\n      namespace: 'task_coordination',\n      tags: ['todo', sessionId],\n    });\n\n    return entries.map((entry) => entry.value as TodoItem);\n  }\n\n  // Event handlers\n\n  private async handleTaskCreated(data: { task: WorkflowTask }): Promise<void> {\n    // Update corresponding todo if exists\n    const todoId = data.task.metadata?.todoId;\n    if (todoId) {\n      await this.updateTodoProgress(todoId as string, 'in_progress', {\n        taskId: data.task.id,\n        createdAt: data.task.createdAt,\n      });\n    }\n  }\n\n  private async handleTaskStarted(data: { taskId: string; agentId: string }): Promise<void> {\n    // Store task start in memory for coordination\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'started',\n        agentId: data.agentId,\n        startedAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_start', data.agentId],\n      },\n    );\n  }\n\n  private async handleTaskCompleted(data: { taskId: string; result: unknown }): Promise<void> {\n    // Update todo and store results\n    const task = (await this.taskEngine.getTaskStatus(data.taskId))?.task;\n    const todoId = task?.metadata?.todoId;\n\n    if (todoId) {\n      await this.updateTodoProgress(todoId as string, 'completed', {\n        completedAt: new Date(),\n        result: data.result,\n      });\n    }\n\n    // Store completion in memory\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'completed',\n        result: data.result,\n        completedAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_completion'],\n      },\n    );\n  }\n\n  private async handleTaskFailed(data: { taskId: string; error: Error }): Promise<void> {\n    // Store failure info\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'failed',\n        error: data.error.message,\n        failedAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_failure'],\n      },\n    );\n  }\n\n  private async handleTaskCancelled(data: { taskId: string; reason: string }): Promise<void> {\n    // Store cancellation info\n    await this.storeInMemory(\n      `task_execution:${data.taskId}`,\n      {\n        status: 'cancelled',\n        reason: data.reason,\n        cancelledAt: new Date(),\n      },\n      {\n        namespace: 'task_execution',\n        tags: ['task_cancellation'],\n      },\n    );\n  }\n}\n\n// Supporting interfaces\n\ninterface BatchOperation {\n  id: string;\n  type: string;\n  tasks: any[];\n  startedAt: Date;\n  completedAt?: Date;\n  status: 'running' | 'completed' | 'failed';\n  results: Map<string, any>;\n  errors: Map<string, Error>;\n}\n\ninterface AgentCoordinationState {\n  agentId: string;\n  batchId?: string;\n  objective: string;\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\n  startedAt: Date;\n  completedAt?: Date;\n  memoryKey?: string;\n  coordinationContext: CoordinationContext;\n  lastHeartbeat?: Date;\n}\n"],"names":["EventEmitter","generateId","TaskCoordinator","todoItems","Map","memoryStore","coordinationSessions","batchOperations","agentCoordination","taskEngine","memoryManager","setupCoordinationHandlers","on","handleTaskCreated","bind","handleTaskStarted","handleTaskCompleted","handleTaskFailed","handleTaskCancelled","createTaskTodos","objective","context","options","sessionId","set","todos","generateTaskBreakdown","todo","id","memoryCoordination","storeInMemory","namespace","tags","emit","updateTodoProgress","todoId","status","metadata","get","Error","previousStatus","updatedAt","Date","createTaskFromTodo","readTodos","filter","Array","from","values","sessionTodos","getSessionTodos","some","st","includes","priority","assignedAgent","tag","batchOptimized","undefined","key","value","entry","timestamp","expiresAt","memoryKey","store","retrieveFromMemory","retrieve","error","delete","queryMemory","query","entries","keyPattern","pattern","RegExp","test","since","sort","a","b","getTime","limit","slice","launchParallelAgents","tasks","coordinationContext","batchId","agentIds","batchOperation","type","startedAt","results","errors","task","agentId","launchAgent","push","agentType","coordinateBatchOperations","operations","groupedOps","op","has","Object","fromEntries","promises","ops","executeBatchOperationType","Promise","all","coordinateSwarm","agents","swarmId","coordinationPattern","coordinationMode","coordinateCentralizedSwarm","coordinateDistributedSwarm","coordinateHierarchicalSwarm","coordinateMeshSwarm","coordinateHybridSwarm","strategy","content","parallelExecution","createdAt","dependencies","taskData","description","priorityToNumber","createTask","launchedAt","result","simulateBatchOperation","targets","join","operation","resolve","setTimeout","coordinator","agentAssignments","map","agent","role","coordinators","index","length","hierarchy","master","teamLeads","teams","frontend_lead","backend_lead","devops_lead","peerConnections","peers","phases","phase","data","taskId","getTaskStatus","completedAt","message","failedAt","reason","cancelledAt"],"mappings":"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"}