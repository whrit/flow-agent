{"version":3,"sources":["../../../../src/swarm/workers/copy-worker.ts"],"sourcesContent":["import { parentPort, workerData } from 'worker_threads';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { createHash } from 'crypto';\n\ninterface WorkerData {\n  files: Array<{\n    sourcePath: string;\n    destPath: string;\n    permissions?: number;\n    verify?: boolean;\n  }>;\n  workerId: number;\n}\n\ninterface WorkerResult {\n  success: boolean;\n  file: string;\n  error?: string;\n  hash?: string;\n}\n\nasync function copyFile(file: WorkerData['files'][0]): Promise<WorkerResult> {\n  try {\n    // Ensure destination directory exists\n    const destDir = path.dirname(file.destPath);\n    await fs.mkdir(destDir, { recursive: true });\n\n    // Copy the file\n    await fs.copyFile(file.sourcePath, file.destPath);\n\n    // Preserve permissions if requested\n    if (file.permissions) {\n      await fs.chmod(file.destPath, file.permissions);\n    }\n\n    let hash: string | undefined;\n\n    // Calculate hash if verification is requested\n    if (file.verify) {\n      const content = await fs.readFile(file.destPath);\n      hash = createHash('sha256').update(content).digest('hex');\n    }\n\n    return {\n      success: true,\n      file: file.sourcePath,\n      hash,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      file: file.sourcePath,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\nasync function main() {\n  const data = workerData as WorkerData;\n\n  if (!parentPort) {\n    throw new Error('This script must be run as a worker thread');\n  }\n\n  for (const file of data.files) {\n    const result = await copyFile(file);\n    parentPort.postMessage(result);\n  }\n}\n\n// Run the worker\nmain().catch((error) => {\n  if (parentPort) {\n    parentPort.postMessage({\n      success: false,\n      file: 'worker',\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n});\n"],"names":["parentPort","workerData","fs","path","createHash","copyFile","file","destDir","dirname","destPath","mkdir","recursive","sourcePath","permissions","chmod","hash","verify","content","readFile","update","digest","success","error","Error","message","String","main","data","files","result","postMessage","catch"],"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,QAAQ,iBAAiB;AACxD,YAAYC,QAAQ,cAAc;AAClC,YAAYC,UAAU,OAAO;AAC7B,SAASC,UAAU,QAAQ,SAAS;AAmBpC,eAAeC,SAASC,IAA4B;IAClD,IAAI;QAEF,MAAMC,UAAUJ,KAAKK,OAAO,CAACF,KAAKG,QAAQ;QAC1C,MAAMP,GAAGQ,KAAK,CAACH,SAAS;YAAEI,WAAW;QAAK;QAG1C,MAAMT,GAAGG,QAAQ,CAACC,KAAKM,UAAU,EAAEN,KAAKG,QAAQ;QAGhD,IAAIH,KAAKO,WAAW,EAAE;YACpB,MAAMX,GAAGY,KAAK,CAACR,KAAKG,QAAQ,EAAEH,KAAKO,WAAW;QAChD;QAEA,IAAIE;QAGJ,IAAIT,KAAKU,MAAM,EAAE;YACf,MAAMC,UAAU,MAAMf,GAAGgB,QAAQ,CAACZ,KAAKG,QAAQ;YAC/CM,OAAOX,WAAW,UAAUe,MAAM,CAACF,SAASG,MAAM,CAAC;QACrD;QAEA,OAAO;YACLC,SAAS;YACTf,MAAMA,KAAKM,UAAU;YACrBG;QACF;IACF,EAAE,OAAOO,OAAO;QACd,OAAO;YACLD,SAAS;YACTf,MAAMA,KAAKM,UAAU;YACrBU,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;QACzD;IACF;AACF;AAEA,eAAeI;IACb,MAAMC,OAAO1B;IAEb,IAAI,CAACD,YAAY;QACf,MAAM,IAAIuB,MAAM;IAClB;IAEA,KAAK,MAAMjB,QAAQqB,KAAKC,KAAK,CAAE;QAC7B,MAAMC,SAAS,MAAMxB,SAASC;QAC9BN,WAAW8B,WAAW,CAACD;IACzB;AACF;AAGAH,OAAOK,KAAK,CAAC,CAACT;IACZ,IAAItB,YAAY;QACdA,WAAW8B,WAAW,CAAC;YACrBT,SAAS;YACTf,MAAM;YACNgB,OAAOA,iBAAiBC,QAAQD,MAAME,OAAO,GAAGC,OAAOH;QACzD;IACF;AACF"}