{"version":3,"sources":["../../../../src/swarm/optimizations/circular-buffer.ts"],"sourcesContent":["/**\n * Circular Buffer Implementation\n * Fixed-size buffer that overwrites oldest entries when full\n */\n\nexport class CircularBuffer<T> {\n  private buffer: (T | undefined)[];\n  private writeIndex = 0;\n  private size = 0;\n  private totalItemsWritten = 0;\n\n  constructor(private capacity: number) {\n    if (capacity <= 0) {\n      throw new Error('Capacity must be greater than 0');\n    }\n    this.buffer = new Array(capacity);\n  }\n\n  push(item: T): void {\n    this.buffer[this.writeIndex] = item;\n    this.writeIndex = (this.writeIndex + 1) % this.capacity;\n    this.size = Math.min(this.size + 1, this.capacity);\n    this.totalItemsWritten++;\n  }\n\n  pushMany(items: T[]): void {\n    for (const item of items) {\n      this.push(item);\n    }\n  }\n\n  get(index: number): T | undefined {\n    if (index < 0 || index >= this.size) {\n      return undefined;\n    }\n\n    // Calculate actual buffer index based on current state\n    const actualIndex =\n      this.size < this.capacity ? index : (this.writeIndex + index) % this.capacity;\n\n    return this.buffer[actualIndex];\n  }\n\n  getRecent(count: number): T[] {\n    const result: T[] = [];\n    const itemsToReturn = Math.min(count, this.size);\n\n    // Calculate starting position for most recent items\n    const start =\n      this.size < this.capacity\n        ? Math.max(0, this.size - itemsToReturn)\n        : (this.writeIndex - itemsToReturn + this.capacity) % this.capacity;\n\n    for (let i = 0; i < itemsToReturn; i++) {\n      const index = (start + i) % this.capacity;\n      const item = this.buffer[index];\n      if (item !== undefined) {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n\n  getAll(): T[] {\n    const result: T[] = [];\n\n    if (this.size < this.capacity) {\n      // Buffer not full yet, return items in order\n      for (let i = 0; i < this.size; i++) {\n        const item = this.buffer[i];\n        if (item !== undefined) {\n          result.push(item);\n        }\n      }\n    } else {\n      // Buffer is full, start from oldest item\n      for (let i = 0; i < this.capacity; i++) {\n        const index = (this.writeIndex + i) % this.capacity;\n        const item = this.buffer[index];\n        if (item !== undefined) {\n          result.push(item);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  find(predicate: (item: T) => boolean): T | undefined {\n    const all = this.getAll();\n    return all.find(predicate);\n  }\n\n  filter(predicate: (item: T) => boolean): T[] {\n    const all = this.getAll();\n    return all.filter(predicate);\n  }\n\n  clear(): void {\n    this.buffer = new Array(this.capacity);\n    this.writeIndex = 0;\n    this.size = 0;\n  }\n\n  isEmpty(): boolean {\n    return this.size === 0;\n  }\n\n  isFull(): boolean {\n    return this.size === this.capacity;\n  }\n\n  getSize(): number {\n    return this.size;\n  }\n\n  getCapacity(): number {\n    return this.capacity;\n  }\n\n  getTotalItemsWritten(): number {\n    return this.totalItemsWritten;\n  }\n\n  getOverwrittenCount(): number {\n    return Math.max(0, this.totalItemsWritten - this.capacity);\n  }\n\n  /**\n   * Get estimated memory usage of the buffer\n   */\n  getMemoryUsage(): number {\n    if (this.size === 0) return 0;\n\n    // Sample first item to estimate size\n    const sample = this.buffer[0];\n    if (sample === undefined) return 0;\n\n    try {\n      // Rough estimation based on JSON serialization\n      const sampleSize = JSON.stringify(sample).length * 2; // 2 bytes per character\n      return sampleSize * this.size;\n    } catch {\n      // If serialization fails, return a default estimate\n      return this.size * 1024; // 1KB per item default\n    }\n  }\n\n  /**\n   * Create a snapshot of the current buffer state\n   */\n  snapshot(): {\n    items: T[];\n    capacity: number;\n    size: number;\n    totalItemsWritten: number;\n    overwrittenCount: number;\n    memoryUsage: number;\n  } {\n    return {\n      items: this.getAll(),\n      capacity: this.capacity,\n      size: this.size,\n      totalItemsWritten: this.totalItemsWritten,\n      overwrittenCount: this.getOverwrittenCount(),\n      memoryUsage: this.getMemoryUsage(),\n    };\n  }\n\n  /**\n   * Resize the buffer (creates a new buffer with the new capacity)\n   */\n  resize(newCapacity: number): void {\n    if (newCapacity <= 0) {\n      throw new Error('New capacity must be greater than 0');\n    }\n\n    const items = this.getAll();\n    this.capacity = newCapacity;\n    this.buffer = new Array(newCapacity);\n    this.writeIndex = 0;\n    this.size = 0;\n\n    // Re-add items (newest items will be kept if newCapacity < items.length)\n    const itemsToKeep = items.slice(-newCapacity);\n    this.pushMany(itemsToKeep);\n  }\n}\n"],"names":["CircularBuffer","buffer","writeIndex","size","totalItemsWritten","capacity","Error","Array","push","item","Math","min","pushMany","items","get","index","undefined","actualIndex","getRecent","count","result","itemsToReturn","start","max","i","getAll","find","predicate","all","filter","clear","isEmpty","isFull","getSize","getCapacity","getTotalItemsWritten","getOverwrittenCount","getMemoryUsage","sample","sampleSize","JSON","stringify","length","snapshot","overwrittenCount","memoryUsage","resize","newCapacity","itemsToKeep","slice"],"mappings":"AAKA,OAAO,MAAMA;;IACHC,OAA0B;IAC1BC,aAAa,EAAE;IACfC,OAAO,EAAE;IACTC,oBAAoB,EAAE;IAE9B,YAAY,AAAQC,QAAgB,CAAE;aAAlBA,WAAAA;QAClB,IAAIA,YAAY,GAAG;YACjB,MAAM,IAAIC,MAAM;QAClB;QACA,IAAI,CAACL,MAAM,GAAG,IAAIM,MAAMF;IAC1B;IAEAG,KAAKC,IAAO,EAAQ;QAClB,IAAI,CAACR,MAAM,CAAC,IAAI,CAACC,UAAU,CAAC,GAAGO;QAC/B,IAAI,CAACP,UAAU,GAAG,AAAC,CAAA,IAAI,CAACA,UAAU,GAAG,CAAA,IAAK,IAAI,CAACG,QAAQ;QACvD,IAAI,CAACF,IAAI,GAAGO,KAAKC,GAAG,CAAC,IAAI,CAACR,IAAI,GAAG,GAAG,IAAI,CAACE,QAAQ;QACjD,IAAI,CAACD,iBAAiB;IACxB;IAEAQ,SAASC,KAAU,EAAQ;QACzB,KAAK,MAAMJ,QAAQI,MAAO;YACxB,IAAI,CAACL,IAAI,CAACC;QACZ;IACF;IAEAK,IAAIC,KAAa,EAAiB;QAChC,IAAIA,QAAQ,KAAKA,SAAS,IAAI,CAACZ,IAAI,EAAE;YACnC,OAAOa;QACT;QAGA,MAAMC,cACJ,IAAI,CAACd,IAAI,GAAG,IAAI,CAACE,QAAQ,GAAGU,QAAQ,AAAC,CAAA,IAAI,CAACb,UAAU,GAAGa,KAAI,IAAK,IAAI,CAACV,QAAQ;QAE/E,OAAO,IAAI,CAACJ,MAAM,CAACgB,YAAY;IACjC;IAEAC,UAAUC,KAAa,EAAO;QAC5B,MAAMC,SAAc,EAAE;QACtB,MAAMC,gBAAgBX,KAAKC,GAAG,CAACQ,OAAO,IAAI,CAAChB,IAAI;QAG/C,MAAMmB,QACJ,IAAI,CAACnB,IAAI,GAAG,IAAI,CAACE,QAAQ,GACrBK,KAAKa,GAAG,CAAC,GAAG,IAAI,CAACpB,IAAI,GAAGkB,iBACxB,AAAC,CAAA,IAAI,CAACnB,UAAU,GAAGmB,gBAAgB,IAAI,CAAChB,QAAQ,AAAD,IAAK,IAAI,CAACA,QAAQ;QAEvE,IAAK,IAAImB,IAAI,GAAGA,IAAIH,eAAeG,IAAK;YACtC,MAAMT,QAAQ,AAACO,CAAAA,QAAQE,CAAAA,IAAK,IAAI,CAACnB,QAAQ;YACzC,MAAMI,OAAO,IAAI,CAACR,MAAM,CAACc,MAAM;YAC/B,IAAIN,SAASO,WAAW;gBACtBI,OAAOZ,IAAI,CAACC;YACd;QACF;QAEA,OAAOW;IACT;IAEAK,SAAc;QACZ,MAAML,SAAc,EAAE;QAEtB,IAAI,IAAI,CAACjB,IAAI,GAAG,IAAI,CAACE,QAAQ,EAAE;YAE7B,IAAK,IAAImB,IAAI,GAAGA,IAAI,IAAI,CAACrB,IAAI,EAAEqB,IAAK;gBAClC,MAAMf,OAAO,IAAI,CAACR,MAAM,CAACuB,EAAE;gBAC3B,IAAIf,SAASO,WAAW;oBACtBI,OAAOZ,IAAI,CAACC;gBACd;YACF;QACF,OAAO;YAEL,IAAK,IAAIe,IAAI,GAAGA,IAAI,IAAI,CAACnB,QAAQ,EAAEmB,IAAK;gBACtC,MAAMT,QAAQ,AAAC,CAAA,IAAI,CAACb,UAAU,GAAGsB,CAAAA,IAAK,IAAI,CAACnB,QAAQ;gBACnD,MAAMI,OAAO,IAAI,CAACR,MAAM,CAACc,MAAM;gBAC/B,IAAIN,SAASO,WAAW;oBACtBI,OAAOZ,IAAI,CAACC;gBACd;YACF;QACF;QAEA,OAAOW;IACT;IAEAM,KAAKC,SAA+B,EAAiB;QACnD,MAAMC,MAAM,IAAI,CAACH,MAAM;QACvB,OAAOG,IAAIF,IAAI,CAACC;IAClB;IAEAE,OAAOF,SAA+B,EAAO;QAC3C,MAAMC,MAAM,IAAI,CAACH,MAAM;QACvB,OAAOG,IAAIC,MAAM,CAACF;IACpB;IAEAG,QAAc;QACZ,IAAI,CAAC7B,MAAM,GAAG,IAAIM,MAAM,IAAI,CAACF,QAAQ;QACrC,IAAI,CAACH,UAAU,GAAG;QAClB,IAAI,CAACC,IAAI,GAAG;IACd;IAEA4B,UAAmB;QACjB,OAAO,IAAI,CAAC5B,IAAI,KAAK;IACvB;IAEA6B,SAAkB;QAChB,OAAO,IAAI,CAAC7B,IAAI,KAAK,IAAI,CAACE,QAAQ;IACpC;IAEA4B,UAAkB;QAChB,OAAO,IAAI,CAAC9B,IAAI;IAClB;IAEA+B,cAAsB;QACpB,OAAO,IAAI,CAAC7B,QAAQ;IACtB;IAEA8B,uBAA+B;QAC7B,OAAO,IAAI,CAAC/B,iBAAiB;IAC/B;IAEAgC,sBAA8B;QAC5B,OAAO1B,KAAKa,GAAG,CAAC,GAAG,IAAI,CAACnB,iBAAiB,GAAG,IAAI,CAACC,QAAQ;IAC3D;IAKAgC,iBAAyB;QACvB,IAAI,IAAI,CAAClC,IAAI,KAAK,GAAG,OAAO;QAG5B,MAAMmC,SAAS,IAAI,CAACrC,MAAM,CAAC,EAAE;QAC7B,IAAIqC,WAAWtB,WAAW,OAAO;QAEjC,IAAI;YAEF,MAAMuB,aAAaC,KAAKC,SAAS,CAACH,QAAQI,MAAM,GAAG;YACnD,OAAOH,aAAa,IAAI,CAACpC,IAAI;QAC/B,EAAE,OAAM;YAEN,OAAO,IAAI,CAACA,IAAI,GAAG;QACrB;IACF;IAKAwC,WAOE;QACA,OAAO;YACL9B,OAAO,IAAI,CAACY,MAAM;YAClBpB,UAAU,IAAI,CAACA,QAAQ;YACvBF,MAAM,IAAI,CAACA,IAAI;YACfC,mBAAmB,IAAI,CAACA,iBAAiB;YACzCwC,kBAAkB,IAAI,CAACR,mBAAmB;YAC1CS,aAAa,IAAI,CAACR,cAAc;QAClC;IACF;IAKAS,OAAOC,WAAmB,EAAQ;QAChC,IAAIA,eAAe,GAAG;YACpB,MAAM,IAAIzC,MAAM;QAClB;QAEA,MAAMO,QAAQ,IAAI,CAACY,MAAM;QACzB,IAAI,CAACpB,QAAQ,GAAG0C;QAChB,IAAI,CAAC9C,MAAM,GAAG,IAAIM,MAAMwC;QACxB,IAAI,CAAC7C,UAAU,GAAG;QAClB,IAAI,CAACC,IAAI,GAAG;QAGZ,MAAM6C,cAAcnC,MAAMoC,KAAK,CAAC,CAACF;QACjC,IAAI,CAACnC,QAAQ,CAACoC;IAChB;AACF"}