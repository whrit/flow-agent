{"version":3,"sources":["../../../src/swarm/prompt-copier-enhanced.ts"],"sourcesContent":["import { dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { Worker } from 'worker_threads';\nimport { PromptCopier } from './prompt-copier.js';\nimport type { CopyOptions, CopyResult, FileInfo } from './prompt-copier.js';\nimport { logger } from '../core/logger.js';\n\ninterface WorkerPool {\n  workers: Worker[];\n  busy: Set<number>;\n  queue: Array<() => void>;\n}\n\nexport class EnhancedPromptCopier extends PromptCopier {\n  private workerPool?: WorkerPool;\n  private workerResults: Map<string, any> = new Map();\n\n  constructor(options: CopyOptions) {\n    super(options);\n  }\n\n  public async copyFilesParallel(): Promise<void> {\n    const workerCount = Math.min((this as any).options.maxWorkers, (this as any).fileQueue.length);\n\n    // Initialize worker pool\n    this.workerPool = await this.initializeWorkerPool(workerCount);\n\n    try {\n      // Process files using worker pool\n      await this.processWithWorkerPool();\n    } finally {\n      // Cleanup workers\n      await this.terminateWorkers();\n    }\n  }\n\n  private async initializeWorkerPool(workerCount: number): Promise<WorkerPool> {\n    const workers: Worker[] = [];\n    const pool: WorkerPool = {\n      workers,\n      busy: new Set(),\n      queue: [],\n    };\n\n    // Create workers\n    for (let i = 0; i < workerCount; i++) {\n      const worker = new Worker(path.join(__dirname, 'workers', 'copy-worker.js'), {\n        workerData: { workerId: i },\n      });\n\n      // Setup worker message handler\n      worker.on('message', (result) => {\n        this.handleWorkerResult(result, i, pool);\n      });\n\n      worker.on('error', (error) => {\n        logger.error(`Worker ${i} error:`, error);\n        (this as any).errors.push({\n          file: 'worker',\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'write',\n        });\n      });\n\n      workers.push(worker);\n    }\n\n    return pool;\n  }\n\n  private async processWithWorkerPool(): Promise<void> {\n    const chunkSize = Math.max(\n      1,\n      Math.floor((this as any).fileQueue.length / this.workerPool!.workers.length / 2),\n    );\n    const chunks: FileInfo[][] = [];\n\n    // Create chunks for better distribution\n    for (let i = 0; i < (this as any).fileQueue.length; i += chunkSize) {\n      chunks.push((this as any).fileQueue.slice(i, i + chunkSize));\n    }\n\n    // Process chunks\n    const promises: Promise<void>[] = [];\n\n    for (const chunk of chunks) {\n      promises.push(this.processChunkWithWorker(chunk));\n    }\n\n    await Promise.all(promises);\n  }\n\n  private async processChunkWithWorker(chunk: FileInfo[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const pool = this.workerPool!;\n\n      const tryAssignWork = () => {\n        // Find available worker\n        const availableWorkerIndex = pool.workers.findIndex((_, index) => !pool.busy.has(index));\n\n        if (availableWorkerIndex === -1) {\n          // No workers available, queue the work\n          pool.queue.push(tryAssignWork);\n          return;\n        }\n\n        // Mark worker as busy\n        pool.busy.add(availableWorkerIndex);\n\n        // Prepare worker data\n        const workerData = {\n          files: chunk.map((file) => ({\n            sourcePath: file.path,\n            destPath: path.join((this as any).options.destination, file.relativePath),\n            permissions: (this as any).options.preservePermissions ? file.permissions : undefined,\n            verify: (this as any).options.verify,\n          })),\n          workerId: availableWorkerIndex,\n        };\n\n        let remainingFiles = chunk.length;\n        const chunkResults: any[] = [];\n\n        // Setup temporary message handler for this chunk\n        const messageHandler = (result: any) => {\n          chunkResults.push(result);\n          remainingFiles--;\n\n          if (remainingFiles === 0) {\n            // Chunk complete\n            pool.workers[availableWorkerIndex].off('message', messageHandler);\n            pool.busy.delete(availableWorkerIndex);\n\n            // Process next queued work\n            if (pool.queue.length > 0) {\n              const nextWork = pool.queue.shift()!;\n              nextWork();\n            }\n\n            // Process results\n            this.processChunkResults(chunk, chunkResults);\n            resolve();\n          }\n        };\n\n        pool.workers[availableWorkerIndex].on('message', messageHandler);\n        pool.workers[availableWorkerIndex].postMessage(workerData);\n      };\n\n      tryAssignWork();\n    });\n  }\n\n  private processChunkResults(chunk: FileInfo[], results: any[]): void {\n    for (const result of results) {\n      if (result.success) {\n        (this as any).copiedFiles.add(result.file);\n        if (result.hash) {\n          this.workerResults.set(result.file, { hash: result.hash });\n        }\n      } else {\n        (this as any).errors.push({\n          file: result.file,\n          error: result.error,\n          phase: 'write',\n        });\n      }\n    }\n\n    // Report progress through the callback if available\n    if ((this as any).options.progressCallback) {\n      (this as any).options.progressCallback(\n        (this as any).copiedFiles.size,\n        (this as any).totalFiles,\n      );\n    }\n  }\n\n  private handleWorkerResult(result: any, workerId: number, pool: WorkerPool): void {\n    // This is a fallback handler, actual handling happens in processChunkWithWorker\n    logger.debug(`Worker ${workerId} result:`, result);\n  }\n\n  private async terminateWorkers(): Promise<void> {\n    if (!this.workerPool) return;\n\n    const terminationPromises = this.workerPool.workers.map((worker) => worker.terminate());\n\n    await Promise.all(terminationPromises);\n    this.workerPool = undefined;\n  }\n\n  // Override verification to use worker results\n  protected override async verifyFiles(): Promise<void> {\n    logger.info('Verifying copied files...');\n\n    for (const file of (this as any).fileQueue) {\n      if (!(this as any).copiedFiles.has(file.path)) continue;\n\n      try {\n        const destPath = path.join((this as any).options.destination, file.relativePath);\n\n        // Verify file exists\n        if (!(await (this as any).fileExists(destPath))) {\n          throw new Error('Destination file not found');\n        }\n\n        // Verify size\n        const destStats = await fs.stat(destPath);\n        const sourceStats = await fs.stat(file.path);\n\n        if (destStats.size !== sourceStats.size) {\n          throw new Error(`Size mismatch: ${destStats.size} != ${sourceStats.size}`);\n        }\n\n        // Use hash from worker if available\n        const workerResult = this.workerResults.get(file.path);\n        if (workerResult?.hash) {\n          const sourceHash = await (this as any).calculateFileHash(file.path);\n          if (sourceHash !== workerResult.hash) {\n            throw new Error(`Hash mismatch: ${sourceHash} != ${workerResult.hash}`);\n          }\n        }\n      } catch (error) {\n        (this as any).errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'verify',\n        });\n      }\n    }\n  }\n}\n\n// Export enhanced copy function\nexport async function copyPromptsEnhanced(options: CopyOptions): Promise<CopyResult> {\n  const copier = new EnhancedPromptCopier(options);\n  return copier.copy();\n}\n"],"names":["dirname","fileURLToPath","__dirname","url","fs","path","Worker","PromptCopier","logger","EnhancedPromptCopier","workerPool","workerResults","Map","options","copyFilesParallel","workerCount","Math","min","maxWorkers","fileQueue","length","initializeWorkerPool","processWithWorkerPool","terminateWorkers","workers","pool","busy","Set","queue","i","worker","join","workerData","workerId","on","result","handleWorkerResult","error","errors","push","file","Error","message","String","phase","chunkSize","max","floor","chunks","slice","promises","chunk","processChunkWithWorker","Promise","all","resolve","reject","tryAssignWork","availableWorkerIndex","findIndex","_","index","has","add","files","map","sourcePath","destPath","destination","relativePath","permissions","preservePermissions","undefined","verify","remainingFiles","chunkResults","messageHandler","off","delete","nextWork","shift","processChunkResults","postMessage","results","success","copiedFiles","hash","set","progressCallback","size","totalFiles","debug","terminationPromises","terminate","verifyFiles","info","fileExists","destStats","stat","sourceStats","workerResult","get","sourceHash","calculateFileHash","copyPromptsEnhanced","copier","copy"],"mappings":"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"}