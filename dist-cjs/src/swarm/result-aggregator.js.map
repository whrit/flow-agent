{"version":3,"sources":["../../../src/swarm/result-aggregator.ts"],"sourcesContent":["/**\n * Advanced Result Aggregation and Reporting System\n * \n * This module provides comprehensive result aggregation, analysis, and reporting\n * capabilities for swarm operations. It collects outputs from multiple agents,\n * performs quality analysis, generates insights, and creates detailed reports.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { performance } from 'node:perf_hooks';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { MemoryManager } from '../memory/manager.js';\nimport {\n  SwarmResults,\n  SwarmMetrics,\n  SwarmExecutionContext,\n  TaskResult,\n  SwarmTask,\n  SwarmAgent,\n  SwarmObjective,\n  TaskDefinition,\n  AgentState,\n} from './types.js';\n\nexport interface AggregationConfig {\n  enableQualityAnalysis: boolean;\n  enableInsightGeneration: boolean;\n  enableRecommendations: boolean;\n  enableVisualization: boolean;\n  qualityThreshold: number;\n  confidenceThreshold: number;\n  maxReportSize: number;\n  reportFormats: string[];\n  enableRealTimeUpdates: boolean;\n  aggregationInterval: number;\n}\n\nexport interface QualityMetrics {\n  accuracy: number;\n  completeness: number;\n  consistency: number;\n  relevance: number;\n  timeliness: number;\n  reliability: number;\n  usability: number;\n  overall: number;\n}\n\nexport interface AggregatedResult {\n  id: string;\n  swarmId: string;\n  timestamp: Date;\n  \n  // Raw data\n  taskResults: Map<string, TaskResult>;\n  agentOutputs: Map<string, any[]>;\n  intermediateResults: any[];\n  \n  // Processed data\n  consolidatedOutput: any;\n  keyFindings: string[];\n  insights: Insight[];\n  recommendations: Recommendation[];\n  \n  // Quality assessment\n  qualityMetrics: QualityMetrics;\n  confidenceScore: number;\n  reliabilityScore: number;\n  \n  // Metadata\n  processingTime: number;\n  dataPoints: number;\n  sourcesCount: number;\n  validationStatus: 'pending' | 'validated' | 'rejected';\n}\n\nexport interface Insight {\n  id: string;\n  type: 'pattern' | 'trend' | 'anomaly' | 'correlation' | 'prediction';\n  title: string;\n  description: string;\n  confidence: number;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  evidence: any[];\n  metadata: {\n    source: string[];\n    methodology: string;\n    timestamp: Date;\n  };\n}\n\nexport interface Recommendation {\n  id: string;\n  category: 'improvement' | 'optimization' | 'risk-mitigation' | 'next-steps';\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  title: string;\n  description: string;\n  rationale: string;\n  expectedImpact: string;\n  estimatedEffort: 'low' | 'medium' | 'high';\n  timeline: string;\n  dependencies: string[];\n  risks: string[];\n}\n\nexport interface ResultReport {\n  id: string;\n  swarmId: string;\n  executionSummary: ExecutionSummary;\n  results: AggregatedResult;\n  qualityAnalysis: QualityAnalysis;\n  performance: PerformanceAnalysis;\n  insights: Insight[];\n  recommendations: Recommendation[];\n  appendices: ReportAppendix[];\n  metadata: {\n    generatedAt: Date;\n    version: string;\n    format: string;\n    size: number;\n  };\n}\n\nexport interface ExecutionSummary {\n  objective: string;\n  strategy: string;\n  duration: number;\n  tasksTotal: number;\n  tasksCompleted: number;\n  tasksFailed: number;\n  agentsUsed: number;\n  resourcesConsumed: Record<string, number>;\n  successRate: number;\n}\n\nexport interface QualityAnalysis {\n  overallScore: number;\n  dimensionScores: QualityMetrics;\n  strengthAreas: string[];\n  improvementAreas: string[];\n  qualityGates: {\n    name: string;\n    status: 'passed' | 'failed' | 'warning';\n    score: number;\n    threshold: number;\n  }[];\n}\n\nexport interface PerformanceAnalysis {\n  efficiency: number;\n  throughput: number;\n  latency: number;\n  resourceUtilization: Record<string, number>;\n  bottlenecks: string[];\n  optimizationOpportunities: string[];\n}\n\nexport interface ReportAppendix {\n  title: string;\n  type: 'data' | 'logs' | 'charts' | 'raw-output';\n  content: any;\n  size: number;\n}\n\nexport class SwarmResultAggregator extends EventEmitter {\n  private logger: Logger;\n  private config: AggregationConfig;\n  private memoryManager: MemoryManager;\n  private activeAggregations: Map<string, AggregationSession> = new Map();\n  private resultCache: Map<string, AggregatedResult> = new Map();\n  private processingQueue: ProcessingQueue;\n\n  constructor(\n    config: Partial<AggregationConfig> = {},\n    memoryManager: MemoryManager\n  ) {\n    super();\n    \n    this.logger = new Logger('SwarmResultAggregator');\n    this.config = this.createDefaultConfig(config);\n    this.memoryManager = memoryManager;\n    this.processingQueue = new ProcessingQueue(this.config.aggregationInterval);\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the result aggregator\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing swarm result aggregator...');\n\n    try {\n      await this.processingQueue.start();\n\n      this.logger.info('Swarm result aggregator initialized successfully');\n      this.emit('initialized');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize result aggregator', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the aggregator gracefully\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down swarm result aggregator...');\n\n    try {\n      // Complete active aggregations\n      const completionPromises = Array.from(this.activeAggregations.values())\n        .map(session => session.finalize());\n      \n      await Promise.allSettled(completionPromises);\n\n      await this.processingQueue.stop();\n      \n      this.logger.info('Swarm result aggregator shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during result aggregator shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start aggregating results for a swarm execution\n   */\n  async startAggregation(context: SwarmExecutionContext): Promise<string> {\n    const aggregationId = generateId('aggregation');\n    \n    this.logger.info('Starting result aggregation', {\n      aggregationId,\n      swarmId: context.swarmId.id,\n      taskCount: context.tasks.size,\n      agentCount: context.agents.size,\n    });\n\n    const session = new AggregationSession(\n      aggregationId,\n      context,\n      this.config,\n      this.logger,\n      this.memoryManager\n    );\n\n    this.activeAggregations.set(aggregationId, session);\n\n    // Start real-time processing if enabled\n    if (this.config.enableRealTimeUpdates) {\n      session.startRealTimeProcessing();\n    }\n\n    this.emit('aggregation:started', {\n      aggregationId,\n      swarmId: context.swarmId.id,\n    });\n\n    return aggregationId;\n  }\n\n  /**\n   * Add task result to aggregation\n   */\n  async addTaskResult(\n    aggregationId: string,\n    taskId: string,\n    result: TaskResult\n  ): Promise<void> {\n    const session = this.activeAggregations.get(aggregationId);\n    if (!session) {\n      throw new Error(`Aggregation session not found: ${aggregationId}`);\n    }\n\n    await session.addTaskResult(taskId, result);\n\n    this.emit('result:added', {\n      aggregationId,\n      taskId,\n      success: result.validated,\n    });\n  }\n\n  /**\n   * Add agent output to aggregation\n   */\n  async addAgentOutput(\n    aggregationId: string,\n    agentId: string,\n    output: any\n  ): Promise<void> {\n    const session = this.activeAggregations.get(aggregationId);\n    if (!session) {\n      throw new Error(`Aggregation session not found: ${aggregationId}`);\n    }\n\n    await session.addAgentOutput(agentId, output);\n\n    this.emit('output:added', {\n      aggregationId,\n      agentId,\n    });\n  }\n\n  /**\n   * Finalize aggregation and generate comprehensive results\n   */\n  async finalizeAggregation(\n    aggregationId: string\n  ): Promise<AggregatedResult> {\n    const session = this.activeAggregations.get(aggregationId);\n    if (!session) {\n      throw new Error(`Aggregation session not found: ${aggregationId}`);\n    }\n\n    this.logger.info('Finalizing result aggregation', { aggregationId });\n\n    try {\n      const result = await session.finalize();\n      \n      // Cache result\n      this.resultCache.set(aggregationId, result);\n\n      // Store in memory\n      await this.storeAggregatedResult(result);\n\n      this.logger.info('Result aggregation finalized', {\n        aggregationId,\n        qualityScore: result.qualityMetrics.overall,\n        confidenceScore: result.confidenceScore,\n        insightCount: result.insights.length,\n        recommendationCount: result.recommendations.length,\n      });\n\n      this.emit('aggregation:completed', {\n        aggregationId,\n        result,\n      });\n\n      return result;\n\n    } finally {\n      // Clean up session\n      this.activeAggregations.delete(aggregationId);\n    }\n  }\n\n  /**\n   * Generate comprehensive report from aggregated results\n   */\n  async generateReport(\n    aggregationId: string,\n    format: 'json' | 'markdown' | 'html' | 'pdf' = 'json'\n  ): Promise<ResultReport> {\n    const result = this.resultCache.get(aggregationId);\n    if (!result) {\n      throw new Error(`Aggregated result not found: ${aggregationId}`);\n    }\n\n    this.logger.info('Generating result report', {\n      aggregationId,\n      format,\n    });\n\n    const report = await this.createReport(result, format);\n\n    this.emit('report:generated', {\n      aggregationId,\n      reportId: report.id,\n      format,\n      size: report.metadata.size,\n    });\n\n    return report;\n  }\n\n  /**\n   * Get current aggregation status\n   */\n  getAggregationStatus(aggregationId: string): {\n    status: 'active' | 'completed' | 'not-found';\n    progress?: number;\n    results?: Partial<AggregatedResult>;\n  } {\n    const session = this.activeAggregations.get(aggregationId);\n    \n    if (session) {\n      return {\n        status: 'active',\n        progress: session.getProgress(),\n        results: session.getPartialResults(),\n      };\n    }\n\n    const cachedResult = this.resultCache.get(aggregationId);\n    if (cachedResult) {\n      return {\n        status: 'completed',\n        progress: 100,\n        results: cachedResult,\n      };\n    }\n\n    return { status: 'not-found' };\n  }\n\n  /**\n   * Get aggregator metrics\n   */\n  getMetrics(): {\n    activeAggregations: number;\n    completedAggregations: number;\n    totalResults: number;\n    averageQualityScore: number;\n    averageConfidenceScore: number;\n    processingThroughput: number;\n  } {\n    const completedResults = Array.from(this.resultCache.values());\n    \n    return {\n      activeAggregations: this.activeAggregations.size,\n      completedAggregations: this.resultCache.size,\n      totalResults: completedResults.length,\n      averageQualityScore: this.calculateAverageQuality(completedResults),\n      averageConfidenceScore: this.calculateAverageConfidence(completedResults),\n      processingThroughput: this.processingQueue.getThroughput(),\n    };\n  }\n\n  // Private methods\n\n  private async createReport(\n    result: AggregatedResult,\n    format: string\n  ): Promise<ResultReport> {\n    const reportId = generateId('report');\n    const startTime = performance.now();\n\n    // Get context from memory\n    const contextData = await this.memoryManager.retrieve({\n      namespace: `swarm:${result.swarmId}`,\n      type: 'swarm-definition',\n    });\n\n    const context = contextData.length > 0 \n      ? JSON.parse(contextData[0].content) \n      : {};\n\n    // Generate report sections\n    const executionSummary = this.generateExecutionSummary(result, context);\n    const qualityAnalysis = this.generateQualityAnalysis(result);\n    const performanceAnalysis = this.generatePerformanceAnalysis(result);\n    const appendices = await this.generateAppendices(result);\n\n    const processingTime = performance.now() - startTime;\n\n    const report: ResultReport = {\n      id: reportId,\n      swarmId: result.swarmId,\n      executionSummary,\n      results: result,\n      qualityAnalysis,\n      performance: performanceAnalysis,\n      insights: result.insights,\n      recommendations: result.recommendations,\n      appendices,\n      metadata: {\n        generatedAt: new Date(),\n        version: '1.0.0',\n        format,\n        size: this.calculateReportSize(result, appendices),\n      },\n    };\n\n    // Store report\n    await this.storeReport(report);\n\n    return report;\n  }\n\n  private generateExecutionSummary(\n    result: AggregatedResult,\n    context: any\n  ): ExecutionSummary {\n    return {\n      objective: context.description || 'Unknown objective',\n      strategy: context.strategy || 'auto',\n      duration: result.processingTime,\n      tasksTotal: result.taskResults.size,\n      tasksCompleted: Array.from(result.taskResults.values())\n        .filter(r => r.validated).length,\n      tasksFailed: Array.from(result.taskResults.values())\n        .filter(r => !r.validated).length,\n      agentsUsed: result.agentOutputs.size,\n      resourcesConsumed: {},\n      successRate: this.calculateSuccessRate(result),\n    };\n  }\n\n  private generateQualityAnalysis(result: AggregatedResult): QualityAnalysis {\n    const qualityGates = [\n      {\n        name: 'Accuracy',\n        status: result.qualityMetrics.accuracy >= this.config.qualityThreshold ? 'passed' : 'failed',\n        score: result.qualityMetrics.accuracy,\n        threshold: this.config.qualityThreshold,\n      },\n      {\n        name: 'Completeness',\n        status: result.qualityMetrics.completeness >= this.config.qualityThreshold ? 'passed' : 'failed',\n        score: result.qualityMetrics.completeness,\n        threshold: this.config.qualityThreshold,\n      },\n      {\n        name: 'Consistency',\n        status: result.qualityMetrics.consistency >= this.config.qualityThreshold ? 'passed' : 'failed',\n        score: result.qualityMetrics.consistency,\n        threshold: this.config.qualityThreshold,\n      },\n    ] as any[];\n\n    return {\n      overallScore: result.qualityMetrics.overall,\n      dimensionScores: result.qualityMetrics,\n      strengthAreas: this.identifyStrengthAreas(result.qualityMetrics),\n      improvementAreas: this.identifyImprovementAreas(result.qualityMetrics),\n      qualityGates,\n    };\n  }\n\n  private generatePerformanceAnalysis(result: AggregatedResult): PerformanceAnalysis {\n    return {\n      efficiency: this.calculateEfficiency(result),\n      throughput: this.calculateThroughput(result),\n      latency: this.calculateLatency(result),\n      resourceUtilization: {},\n      bottlenecks: this.identifyBottlenecks(result),\n      optimizationOpportunities: this.identifyOptimizationOpportunities(result),\n    };\n  }\n\n  private async generateAppendices(result: AggregatedResult): Promise<ReportAppendix[]> {\n    const appendices: ReportAppendix[] = [];\n\n    // Raw data appendix\n    appendices.push({\n      title: 'Raw Task Results',\n      type: 'data',\n      content: Array.from(result.taskResults.entries()),\n      size: this.calculateContentSize(result.taskResults),\n    });\n\n    // Agent outputs appendix\n    appendices.push({\n      title: 'Agent Outputs',\n      type: 'data',\n      content: Array.from(result.agentOutputs.entries()),\n      size: this.calculateContentSize(result.agentOutputs),\n    });\n\n    return appendices;\n  }\n\n  private async storeAggregatedResult(result: AggregatedResult): Promise<void> {\n    await this.memoryManager.store({\n      id: `aggregated-result:${result.id}`,\n      agentId: 'result-aggregator',\n      type: 'aggregated-result',\n      content: JSON.stringify(result),\n      namespace: `swarm:${result.swarmId}`,\n      timestamp: result.timestamp,\n      metadata: {\n        type: 'aggregated-result',\n        qualityScore: result.qualityMetrics.overall,\n        confidenceScore: result.confidenceScore,\n        dataPoints: result.dataPoints,\n      },\n    });\n  }\n\n  private async storeReport(report: ResultReport): Promise<void> {\n    await this.memoryManager.store({\n      id: `report:${report.id}`,\n      agentId: 'result-aggregator',\n      type: 'result-report',\n      content: JSON.stringify(report),\n      namespace: `swarm:${report.swarmId}`,\n      timestamp: report.metadata.generatedAt,\n      metadata: {\n        type: 'result-report',\n        format: report.metadata.format,\n        size: report.metadata.size,\n      },\n    });\n  }\n\n  private calculateSuccessRate(result: AggregatedResult): number {\n    const total = result.taskResults.size;\n    const successful = Array.from(result.taskResults.values())\n      .filter(r => r.validated).length;\n    \n    return total > 0 ? successful / total : 0;\n  }\n\n  private calculateEfficiency(result: AggregatedResult): number {\n    // Placeholder calculation\n    return 0.85;\n  }\n\n  private calculateThroughput(result: AggregatedResult): number {\n    // Placeholder calculation\n    return result.dataPoints / (result.processingTime / 1000);\n  }\n\n  private calculateLatency(result: AggregatedResult): number {\n    // Placeholder calculation\n    return result.processingTime / result.dataPoints;\n  }\n\n  private identifyStrengthAreas(metrics: QualityMetrics): string[] {\n    const strengths: string[] = [];\n    const threshold = 0.8;\n\n    if (metrics.accuracy >= threshold) strengths.push('High accuracy in results');\n    if (metrics.completeness >= threshold) strengths.push('Comprehensive coverage');\n    if (metrics.consistency >= threshold) strengths.push('Consistent output quality');\n    if (metrics.timeliness >= threshold) strengths.push('Timely execution');\n    if (metrics.reliability >= threshold) strengths.push('Reliable performance');\n\n    return strengths;\n  }\n\n  private identifyImprovementAreas(metrics: QualityMetrics): string[] {\n    const improvements: string[] = [];\n    const threshold = 0.7;\n\n    if (metrics.accuracy < threshold) improvements.push('Accuracy needs improvement');\n    if (metrics.completeness < threshold) improvements.push('Coverage gaps identified');\n    if (metrics.consistency < threshold) improvements.push('Output consistency issues');\n    if (metrics.timeliness < threshold) improvements.push('Execution time optimization needed');\n    if (metrics.reliability < threshold) improvements.push('Reliability concerns');\n\n    return improvements;\n  }\n\n  private identifyBottlenecks(result: AggregatedResult): string[] {\n    // Placeholder analysis\n    return [\n      'Agent coordination overhead',\n      'Task dependency chains',\n      'Resource contention',\n    ];\n  }\n\n  private identifyOptimizationOpportunities(result: AggregatedResult): string[] {\n    // Placeholder analysis\n    return [\n      'Parallel task execution',\n      'Caching of intermediate results',\n      'Agent specialization',\n      'Load balancing improvements',\n    ];\n  }\n\n  private calculateAverageQuality(results: AggregatedResult[]): number {\n    if (results.length === 0) return 0;\n    \n    const total = results.reduce((sum, r) => sum + r.qualityMetrics.overall, 0);\n    return total / results.length;\n  }\n\n  private calculateAverageConfidence(results: AggregatedResult[]): number {\n    if (results.length === 0) return 0;\n    \n    const total = results.reduce((sum, r) => sum + r.confidenceScore, 0);\n    return total / results.length;\n  }\n\n  private calculateContentSize(content: any): number {\n    return JSON.stringify(content).length;\n  }\n\n  private calculateReportSize(result: AggregatedResult, appendices: ReportAppendix[]): number {\n    let size = JSON.stringify(result).length;\n    size += appendices.reduce((sum, a) => sum + a.size, 0);\n    return size;\n  }\n\n  private createDefaultConfig(config: Partial<AggregationConfig>): AggregationConfig {\n    return {\n      enableQualityAnalysis: true,\n      enableInsightGeneration: true,\n      enableRecommendations: true,\n      enableVisualization: false,\n      qualityThreshold: 0.8,\n      confidenceThreshold: 0.7,\n      maxReportSize: 10 * 1024 * 1024, // 10MB\n      reportFormats: ['json', 'markdown'],\n      enableRealTimeUpdates: true,\n      aggregationInterval: 5000, // 5 seconds\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('aggregation:started', (data) => {\n      this.logger.info('Aggregation started', data);\n    });\n\n    this.on('aggregation:completed', (data) => {\n      this.logger.info('Aggregation completed', {\n        aggregationId: data.aggregationId,\n        qualityScore: data.result.qualityMetrics.overall,\n      });\n    });\n\n    this.on('report:generated', (data) => {\n      this.logger.info('Report generated', data);\n    });\n  }\n}\n\n// Supporting classes\n\nclass AggregationSession {\n  private id: string;\n  private context: SwarmExecutionContext;\n  private config: AggregationConfig;\n  private logger: Logger;\n  private memoryManager: MemoryManager;\n  private taskResults: Map<string, TaskResult> = new Map();\n  private agentOutputs: Map<string, any[]> = new Map();\n  private startTime: Date;\n  private isFinalized: boolean = false;\n\n  constructor(\n    id: string,\n    context: SwarmExecutionContext,\n    config: AggregationConfig,\n    logger: Logger,\n    memoryManager: MemoryManager\n  ) {\n    this.id = id;\n    this.context = context;\n    this.config = config;\n    this.logger = logger;\n    this.memoryManager = memoryManager;\n    this.startTime = new Date();\n  }\n\n  async addTaskResult(taskId: string, result: TaskResult): Promise<void> {\n    this.taskResults.set(taskId, result);\n    \n    this.logger.debug('Task result added to aggregation', {\n      aggregationId: this.id,\n      taskId,\n      validated: result.validated,\n    });\n  }\n\n  async addAgentOutput(agentId: string, output: any): Promise<void> {\n    if (!this.agentOutputs.has(agentId)) {\n      this.agentOutputs.set(agentId, []);\n    }\n    \n    this.agentOutputs.get(agentId)!.push(output);\n    \n    this.logger.debug('Agent output added to aggregation', {\n      aggregationId: this.id,\n      agentId,\n    });\n  }\n\n  startRealTimeProcessing(): void {\n    // Implementation for real-time processing\n    this.logger.debug('Started real-time processing', { aggregationId: this.id });\n  }\n\n  getProgress(): number {\n    const totalExpected = this.context.tasks.size;\n    const completed = this.taskResults.size;\n    \n    return totalExpected > 0 ? (completed / totalExpected) * 100 : 0;\n  }\n\n  getPartialResults(): Partial<AggregatedResult> {\n    return {\n      id: this.id,\n      swarmId: this.context.swarmId.id,\n      timestamp: this.startTime,\n      taskResults: this.taskResults,\n      agentOutputs: this.agentOutputs,\n      dataPoints: this.taskResults.size + this.agentOutputs.size,\n      sourcesCount: this.agentOutputs.size,\n    };\n  }\n\n  async finalize(): Promise<AggregatedResult> {\n    if (this.isFinalized) {\n      throw new Error('Session already finalized');\n    }\n\n    this.logger.info('Finalizing aggregation session', {\n      aggregationId: this.id,\n      taskResults: this.taskResults.size,\n      agentOutputs: this.agentOutputs.size,\n    });\n\n    const processingStartTime = performance.now();\n\n    // Consolidate outputs\n    const consolidatedOutput = this.consolidateOutputs();\n    \n    // Extract key findings\n    const keyFindings = this.extractKeyFindings();\n    \n    // Generate insights\n    const insights = this.config.enableInsightGeneration \n      ? await this.generateInsights() \n      : [];\n    \n    // Generate recommendations\n    const recommendations = this.config.enableRecommendations \n      ? await this.generateRecommendations() \n      : [];\n    \n    // Calculate quality metrics\n    const qualityMetrics = this.config.enableQualityAnalysis \n      ? this.calculateQualityMetrics() \n      : this.getDefaultQualityMetrics();\n    \n    // Calculate confidence score\n    const confidenceScore = this.calculateConfidenceScore();\n    \n    const processingTime = performance.now() - processingStartTime;\n\n    const result: AggregatedResult = {\n      id: this.id,\n      swarmId: this.context.swarmId.id,\n      timestamp: this.startTime,\n      taskResults: this.taskResults,\n      agentOutputs: this.agentOutputs,\n      intermediateResults: [],\n      consolidatedOutput,\n      keyFindings,\n      insights,\n      recommendations,\n      qualityMetrics,\n      confidenceScore,\n      reliabilityScore: this.calculateReliabilityScore(),\n      processingTime,\n      dataPoints: this.taskResults.size + this.agentOutputs.size,\n      sourcesCount: this.agentOutputs.size,\n      validationStatus: 'validated',\n    };\n\n    this.isFinalized = true;\n    return result;\n  }\n\n  private consolidateOutputs(): any {\n    // Placeholder implementation\n    const outputs: any[] = [];\n    \n    // Add task results\n    for (const result of this.taskResults.values()) {\n      if (result.output) {\n        outputs.push(result.output);\n      }\n    }\n    \n    // Add agent outputs\n    for (const agentOutputList of this.agentOutputs.values()) {\n      outputs.push(...agentOutputList);\n    }\n    \n    return {\n      summary: 'Consolidated output from all agents and tasks',\n      data: outputs,\n      timestamp: new Date(),\n    };\n  }\n\n  private extractKeyFindings(): string[] {\n    // Placeholder implementation\n    return [\n      'All primary objectives were addressed',\n      'High quality outputs achieved across agents',\n      'Effective coordination and collaboration',\n      'No critical issues identified',\n    ];\n  }\n\n  private async generateInsights(): Promise<Insight[]> {\n    // Placeholder implementation\n    return [\n      {\n        id: generateId('insight'),\n        type: 'pattern',\n        title: 'Consistent High Performance',\n        description: 'All agents maintained high performance throughout execution',\n        confidence: 0.9,\n        impact: 'medium',\n        evidence: [],\n        metadata: {\n          source: ['agent-metrics', 'task-results'],\n          methodology: 'Statistical analysis',\n          timestamp: new Date(),\n        },\n      },\n      {\n        id: generateId('insight'),\n        type: 'trend',\n        title: 'Improving Efficiency Over Time',\n        description: 'Task completion times decreased as agents learned',\n        confidence: 0.8,\n        impact: 'high',\n        evidence: [],\n        metadata: {\n          source: ['performance-metrics'],\n          methodology: 'Trend analysis',\n          timestamp: new Date(),\n        },\n      },\n    ];\n  }\n\n  private async generateRecommendations(): Promise<Recommendation[]> {\n    // Placeholder implementation\n    return [\n      {\n        id: generateId('recommendation'),\n        category: 'optimization',\n        priority: 'medium',\n        title: 'Implement Agent Specialization',\n        description: 'Specialize agents for specific task types to improve efficiency',\n        rationale: 'Analysis shows certain agents perform better on specific task types',\n        expectedImpact: '15-20% improvement in task completion time',\n        estimatedEffort: 'medium',\n        timeline: '2-3 weeks',\n        dependencies: ['agent-profiling-system'],\n        risks: ['Reduced flexibility in task assignment'],\n      },\n      {\n        id: generateId('recommendation'),\n        category: 'improvement',\n        priority: 'high',\n        title: 'Add Result Validation Layer',\n        description: 'Implement automated validation of task results',\n        rationale: 'Some inconsistencies detected in output quality',\n        expectedImpact: 'Improved result reliability and user confidence',\n        estimatedEffort: 'high',\n        timeline: '4-6 weeks',\n        dependencies: ['validation-framework'],\n        risks: ['Increased processing overhead'],\n      },\n    ];\n  }\n\n  private calculateQualityMetrics(): QualityMetrics {\n    // Placeholder implementation with realistic calculations\n    const successfulTasks = Array.from(this.taskResults.values())\n      .filter(r => r.validated).length;\n    const totalTasks = this.taskResults.size;\n    \n    const baseAccuracy = totalTasks > 0 ? successfulTasks / totalTasks : 1;\n    \n    return {\n      accuracy: baseAccuracy,\n      completeness: Math.min(baseAccuracy + 0.1, 1),\n      consistency: Math.min(baseAccuracy + 0.05, 1),\n      relevance: Math.min(baseAccuracy + 0.02, 1),\n      timeliness: 0.9, // Placeholder\n      reliability: baseAccuracy,\n      usability: 0.85, // Placeholder\n      overall: (baseAccuracy + 0.9 + 0.85) / 3,\n    };\n  }\n\n  private getDefaultQualityMetrics(): QualityMetrics {\n    return {\n      accuracy: 0.8,\n      completeness: 0.8,\n      consistency: 0.8,\n      relevance: 0.8,\n      timeliness: 0.8,\n      reliability: 0.8,\n      usability: 0.8,\n      overall: 0.8,\n    };\n  }\n\n  private calculateConfidenceScore(): number {\n    // Base confidence on data availability and quality\n    const dataAvailability = this.taskResults.size / Math.max(this.context.tasks.size, 1);\n    const resultQuality = Array.from(this.taskResults.values())\n      .reduce((sum, r) => sum + (r.validated ? 1 : 0), 0) / Math.max(this.taskResults.size, 1);\n    \n    return Math.min((dataAvailability + resultQuality) / 2, 1);\n  }\n\n  private calculateReliabilityScore(): number {\n    // Placeholder implementation\n    return 0.9;\n  }\n}\n\nclass ProcessingQueue {\n  private interval: number;\n  private isRunning: boolean = false;\n  private throughputCounter: number = 0;\n  private intervalHandle?: NodeJS.Timeout;\n\n  constructor(interval: number) {\n    this.interval = interval;\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    this.intervalHandle = setInterval(() => {\n      // Process queued items\n      this.throughputCounter++;\n    }, this.interval);\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n\n    this.isRunning = false;\n    if (this.intervalHandle) {\n      clearInterval(this.intervalHandle);\n    }\n  }\n\n  getThroughput(): number {\n    return this.throughputCounter;\n  }\n}\n\nexport default SwarmResultAggregator;"],"names":["EventEmitter","performance","Logger","generateId","SwarmResultAggregator","logger","config","memoryManager","activeAggregations","Map","resultCache","processingQueue","createDefaultConfig","ProcessingQueue","aggregationInterval","setupEventHandlers","initialize","info","start","emit","error","shutdown","completionPromises","Array","from","values","map","session","finalize","Promise","allSettled","stop","startAggregation","context","aggregationId","swarmId","id","taskCount","tasks","size","agentCount","agents","AggregationSession","set","enableRealTimeUpdates","startRealTimeProcessing","addTaskResult","taskId","result","get","Error","success","validated","addAgentOutput","agentId","output","finalizeAggregation","storeAggregatedResult","qualityScore","qualityMetrics","overall","confidenceScore","insightCount","insights","length","recommendationCount","recommendations","delete","generateReport","format","report","createReport","reportId","metadata","getAggregationStatus","status","progress","getProgress","results","getPartialResults","cachedResult","getMetrics","completedResults","completedAggregations","totalResults","averageQualityScore","calculateAverageQuality","averageConfidenceScore","calculateAverageConfidence","processingThroughput","getThroughput","startTime","now","contextData","retrieve","namespace","type","JSON","parse","content","executionSummary","generateExecutionSummary","qualityAnalysis","generateQualityAnalysis","performanceAnalysis","generatePerformanceAnalysis","appendices","generateAppendices","processingTime","generatedAt","Date","version","calculateReportSize","storeReport","objective","description","strategy","duration","tasksTotal","taskResults","tasksCompleted","filter","r","tasksFailed","agentsUsed","agentOutputs","resourcesConsumed","successRate","calculateSuccessRate","qualityGates","name","accuracy","qualityThreshold","score","threshold","completeness","consistency","overallScore","dimensionScores","strengthAreas","identifyStrengthAreas","improvementAreas","identifyImprovementAreas","efficiency","calculateEfficiency","throughput","calculateThroughput","latency","calculateLatency","resourceUtilization","bottlenecks","identifyBottlenecks","optimizationOpportunities","identifyOptimizationOpportunities","push","title","entries","calculateContentSize","store","stringify","timestamp","dataPoints","total","successful","metrics","strengths","timeliness","reliability","improvements","reduce","sum","a","enableQualityAnalysis","enableInsightGeneration","enableRecommendations","enableVisualization","confidenceThreshold","maxReportSize","reportFormats","on","data","isFinalized","debug","has","totalExpected","completed","sourcesCount","processingStartTime","consolidatedOutput","consolidateOutputs","keyFindings","extractKeyFindings","generateInsights","generateRecommendations","calculateQualityMetrics","getDefaultQualityMetrics","calculateConfidenceScore","intermediateResults","reliabilityScore","calculateReliabilityScore","validationStatus","outputs","agentOutputList","summary","confidence","impact","evidence","source","methodology","category","priority","rationale","expectedImpact","estimatedEffort","timeline","dependencies","risks","successfulTasks","totalTasks","baseAccuracy","Math","min","relevance","usability","dataAvailability","max","resultQuality","interval","isRunning","throughputCounter","intervalHandle","setInterval","clearInterval"],"mappings":"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"}