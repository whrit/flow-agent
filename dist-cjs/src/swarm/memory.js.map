{"version":3,"sources":["../../../src/swarm/memory.ts"],"sourcesContent":["/**\n * Distributed Memory System with Cross-Agent Sharing\n */\n\nimport { EventEmitter } from 'node:events';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\nimport * as crypto from 'node:crypto';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport {\n  MemoryEntry,\n  MemoryPartition,\n  SwarmMemory,\n  AccessLevel,\n  ConsistencyLevel,\n  MemoryType,\n  MemoryPermissions,\n  AgentId,\n  SwarmEvent,\n  SWARM_CONSTANTS,\n} from './types.js';\n\nexport interface MemoryQuery {\n  namespace?: string;\n  partition?: string;\n  key?: string;\n  tags?: string[];\n  type?: MemoryType;\n  owner?: AgentId;\n  accessLevel?: AccessLevel;\n  createdAfter?: Date;\n  createdBefore?: Date;\n  expiresAfter?: Date;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'createdAt' | 'updatedAt' | 'key' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface MemorySearchOptions {\n  query: string;\n  searchFields?: string[];\n  fuzzyMatch?: boolean;\n  maxResults?: number;\n  threshold?: number;\n  includeContent?: boolean;\n}\n\nexport interface MemoryStatistics {\n  totalEntries: number;\n  totalSize: number;\n  partitionCount: number;\n  entriesByType: Record<MemoryType, number>;\n  entriesByAccess: Record<AccessLevel, number>;\n  averageSize: number;\n  oldestEntry: Date;\n  newestEntry: Date;\n  expiringEntries: number;\n}\n\nexport interface MemoryBackup {\n  timestamp: Date;\n  version: string;\n  checksum: string;\n  metadata: Record<string, any>;\n  entries: MemoryEntry[];\n  partitions: MemoryPartition[];\n}\n\nexport interface MemoryConfig {\n  namespace: string;\n  persistencePath: string;\n  maxMemorySize: number;\n  maxEntrySize: number;\n  defaultTtl: number;\n  enableCompression: boolean;\n  enableEncryption: boolean;\n  encryptionKey?: string;\n  consistencyLevel: ConsistencyLevel;\n  syncInterval: number;\n  backupInterval: number;\n  maxBackups: number;\n  enableDistribution: boolean;\n  distributionNodes: string[];\n  replicationFactor: number;\n  enableCaching: boolean;\n  cacheSize: number;\n  cacheTtl: number;\n}\n\nexport class SwarmMemoryManager extends EventEmitter {\n  private logger: Logger;\n  private config: MemoryConfig;\n  private memory: SwarmMemory;\n  private partitions: Map<string, MemoryPartition> = new Map();\n  private entries: Map<string, MemoryEntry> = new Map();\n  private index: MemoryIndex;\n  private cache: MemoryCache;\n  private replication: MemoryReplication;\n  private persistence: MemoryPersistence;\n  private encryption: MemoryEncryption;\n  private isInitialized = false;\n\n  // Background processes\n  private syncTimer?: NodeJS.Timeout;\n  private backupTimer?: NodeJS.Timeout;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  constructor(config: Partial<MemoryConfig & { logging?: any }> = {}) {\n    super();\n\n    // Configure logger based on config or default to quiet mode\n    const logLevel = config.logging?.level || 'error';\n    const logFormat = config.logging?.format || 'text';\n    const logDestination = config.logging?.destination || 'console';\n\n    this.logger = new Logger(\n      { level: logLevel, format: logFormat, destination: logDestination },\n      { component: 'SwarmMemoryManager' },\n    );\n    this.config = this.mergeWithDefaults(config);\n\n    // Initialize memory structure\n    this.memory = {\n      namespace: this.config.namespace,\n      partitions: [],\n      permissions: {\n        read: 'swarm',\n        write: 'team',\n        delete: 'private',\n        share: 'team',\n      },\n      persistent: true,\n      backupEnabled: true,\n      distributed: this.config.enableDistribution,\n      consistency: this.config.consistencyLevel,\n      cacheEnabled: this.config.enableCaching,\n      compressionEnabled: this.config.enableCompression,\n    };\n\n    // Initialize subsystems\n    this.index = new MemoryIndex();\n    this.cache = new MemoryCache(this.config.cacheSize, this.config.cacheTtl);\n    this.replication = new MemoryReplication(this.config);\n    this.persistence = new MemoryPersistence(this.config);\n    this.encryption = new MemoryEncryption(this.config);\n\n    this.setupEventHandlers();\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    this.logger.info('Initializing swarm memory manager...');\n\n    try {\n      // Initialize subsystems\n      await this.persistence.initialize();\n      await this.encryption.initialize();\n      await this.replication.initialize();\n      await this.index.initialize();\n\n      // Load existing data\n      await this.loadMemoryState();\n\n      // Create default partitions\n      await this.createDefaultPartitions();\n\n      // Start background processes\n      this.startBackgroundProcesses();\n\n      this.isInitialized = true;\n\n      this.emit('memory:initialized', {\n        namespace: this.config.namespace,\n        entriesLoaded: this.entries.size,\n        partitionsLoaded: this.partitions.size,\n      });\n\n      this.logger.info('Swarm memory manager initialized', {\n        namespace: this.config.namespace,\n        entries: this.entries.size,\n        partitions: this.partitions.size,\n      });\n    } catch (error) {\n      this.logger.error('Failed to initialize memory manager', { error });\n      throw error;\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    this.logger.info('Shutting down swarm memory manager...');\n\n    try {\n      // Stop background processes\n      this.stopBackgroundProcesses();\n\n      // Save final state\n      await this.saveMemoryState();\n\n      // Shutdown subsystems\n      await this.replication.shutdown();\n      await this.persistence.shutdown();\n      await this.encryption.shutdown();\n\n      this.isInitialized = false;\n\n      this.emit('memory:shutdown');\n      this.logger.info('Swarm memory manager shut down');\n    } catch (error) {\n      this.logger.error('Error during memory manager shutdown', { error });\n    }\n  }\n\n  // ===== MEMORY OPERATIONS =====\n\n  async store(\n    key: string,\n    value: any,\n    options: Partial<{\n      partition: string;\n      type: MemoryType;\n      tags: string[];\n      owner: AgentId;\n      accessLevel: AccessLevel;\n      ttl: number;\n      metadata: Record<string, any>;\n    }> = {},\n  ): Promise<string> {\n    this.ensureInitialized();\n\n    const entryId = generateId('mem');\n    const now = new Date();\n\n    // Validate access permissions\n    if (options.owner) {\n      await this.validateAccess(options.owner, 'write', options.partition);\n    }\n\n    // Determine partition\n    const partitionName = options.partition || 'default';\n    const partition = await this.getOrCreatePartition(partitionName);\n\n    // Create memory entry\n    const entry: MemoryEntry = {\n      id: entryId,\n      key,\n      value: await this.serializeValue(value),\n      type: options.type || 'knowledge',\n      tags: options.tags || [],\n      owner: options.owner || { id: 'system', swarmId: '', type: 'coordinator', instance: 0 },\n      accessLevel: options.accessLevel || 'team',\n      createdAt: now,\n      updatedAt: now,\n      expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n      version: 1,\n      references: [],\n      dependencies: [],\n    };\n\n    // Validate entry size\n    const entrySize = this.calculateEntrySize(entry);\n    if (entrySize > this.config.maxEntrySize) {\n      throw new Error(`Entry size ${entrySize} exceeds maximum ${this.config.maxEntrySize}`);\n    }\n\n    // Check memory limits\n    await this.enforceMemoryLimits(entrySize);\n\n    // Store entry\n    this.entries.set(entryId, entry);\n    partition.entries.push(entry);\n\n    // Update index\n    await this.index.addEntry(entry);\n\n    // Update cache\n    if (this.config.enableCaching) {\n      this.cache.set(key, entry);\n    }\n\n    // Replicate if enabled\n    if (this.config.enableDistribution) {\n      await this.replication.replicate(entry);\n    }\n\n    // Emit event\n    this.emit('memory:stored', {\n      entryId,\n      key,\n      partition: partitionName,\n      type: entry.type,\n      size: entrySize,\n    });\n\n    this.logger.debug('Stored memory entry', {\n      entryId,\n      key,\n      partition: partitionName,\n      type: entry.type,\n      size: entrySize,\n    });\n\n    return entryId;\n  }\n\n  async retrieve(\n    key: string,\n    options: Partial<{\n      partition: string;\n      requester: AgentId;\n      includeMetadata: boolean;\n    }> = {},\n  ): Promise<any> {\n    this.ensureInitialized();\n\n    // Try cache first\n    if (this.config.enableCaching) {\n      const cached = this.cache.get(key);\n      if (cached && !this.isExpired(cached)) {\n        if (options.requester) {\n          await this.validateAccess(options.requester, 'read', options.partition);\n        }\n        return options.includeMetadata ? cached : await this.deserializeValue(cached.value);\n      }\n    }\n\n    // Find entry\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      return null;\n    }\n\n    // Check expiration\n    if (this.isExpired(entry)) {\n      await this.deleteEntry(entry.id);\n      return null;\n    }\n\n    // Validate access\n    if (options.requester) {\n      await this.validateAccess(options.requester, 'read', options.partition);\n    }\n\n    // Update cache\n    if (this.config.enableCaching) {\n      this.cache.set(key, entry);\n    }\n\n    // Emit event\n    this.emit('memory:retrieved', {\n      entryId: entry.id,\n      key,\n      requester: options.requester?.id,\n    });\n\n    return options.includeMetadata ? entry : await this.deserializeValue(entry.value);\n  }\n\n  async update(\n    key: string,\n    value: any,\n    options: Partial<{\n      partition: string;\n      updater: AgentId;\n      metadata: Record<string, any>;\n      incrementVersion: boolean;\n    }> = {},\n  ): Promise<boolean> {\n    this.ensureInitialized();\n\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      return false;\n    }\n\n    // Validate access\n    if (options.updater) {\n      await this.validateAccess(options.updater, 'write', options.partition);\n    }\n\n    // Create backup of old version\n    if (options.incrementVersion !== false) {\n      entry.previousVersions = entry.previousVersions || [];\n      entry.previousVersions.push({ ...entry });\n\n      // Limit version history\n      if (entry.previousVersions.length > 10) {\n        entry.previousVersions = entry.previousVersions.slice(-10);\n      }\n    }\n\n    // Update entry\n    entry.value = await this.serializeValue(value);\n    entry.updatedAt = new Date();\n    if (options.incrementVersion !== false) {\n      entry.version++;\n    }\n\n    // Update index\n    await this.index.updateEntry(entry);\n\n    // Update cache\n    if (this.config.enableCaching) {\n      this.cache.set(key, entry);\n    }\n\n    // Replicate if enabled\n    if (this.config.enableDistribution) {\n      await this.replication.replicate(entry);\n    }\n\n    this.emit('memory:updated', {\n      entryId: entry.id,\n      key,\n      version: entry.version,\n      updater: options.updater?.id,\n    });\n\n    return true;\n  }\n\n  async delete(\n    key: string,\n    options: Partial<{\n      partition: string;\n      deleter: AgentId;\n      force: boolean;\n    }> = {},\n  ): Promise<boolean> {\n    this.ensureInitialized();\n\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      return false;\n    }\n\n    // Validate access\n    if (options.deleter && !options.force) {\n      await this.validateAccess(options.deleter, 'delete', options.partition);\n    }\n\n    return await this.deleteEntry(entry.id);\n  }\n\n  async query(query: MemoryQuery): Promise<MemoryEntry[]> {\n    this.ensureInitialized();\n\n    let results = Array.from(this.entries.values());\n\n    // Apply filters\n    if (query.partition) {\n      const partition = this.partitions.get(query.partition);\n      if (partition) {\n        const entryIds = new Set(partition.entries.map((e) => e.id));\n        results = results.filter((e) => entryIds.has(e.id));\n      } else {\n        return [];\n      }\n    }\n\n    if (query.key) {\n      results = results.filter((e) => e.key === query.key);\n    }\n\n    if (query.type) {\n      results = results.filter((e) => e.type === query.type);\n    }\n\n    if (query.owner) {\n      results = results.filter((e) => e.owner.id === query.owner!.id);\n    }\n\n    if (query.accessLevel) {\n      results = results.filter((e) => e.accessLevel === query.accessLevel);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter((e) => query.tags!.some((tag) => e.tags.includes(tag)));\n    }\n\n    if (query.createdAfter) {\n      results = results.filter((e) => e.createdAt >= query.createdAfter!);\n    }\n\n    if (query.createdBefore) {\n      results = results.filter((e) => e.createdAt <= query.createdBefore!);\n    }\n\n    if (query.expiresAfter) {\n      results = results.filter((e) => e.expiresAt && e.expiresAt >= query.expiresAfter!);\n    }\n\n    // Filter out expired entries\n    results = results.filter((e) => !this.isExpired(e));\n\n    // Sort results\n    if (query.sortBy) {\n      results.sort((a, b) => {\n        let compareValue = 0;\n\n        switch (query.sortBy) {\n          case 'createdAt':\n            compareValue = a.createdAt.getTime() - b.createdAt.getTime();\n            break;\n          case 'updatedAt':\n            compareValue = a.updatedAt.getTime() - b.updatedAt.getTime();\n            break;\n          case 'key':\n            compareValue = a.key.localeCompare(b.key);\n            break;\n          default:\n            compareValue = 0;\n        }\n\n        return query.sortOrder === 'desc' ? -compareValue : compareValue;\n      });\n    }\n\n    // Apply pagination\n    const offset = query.offset || 0;\n    const limit = query.limit || results.length;\n    results = results.slice(offset, offset + limit);\n\n    return results;\n  }\n\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\n    this.ensureInitialized();\n    return await this.index.search(options);\n  }\n\n  // ===== SHARING AND COLLABORATION =====\n\n  async shareMemory(\n    key: string,\n    targetAgent: AgentId,\n    options: Partial<{\n      partition: string;\n      sharer: AgentId;\n      accessLevel: AccessLevel;\n      expiresAt: Date;\n    }> = {},\n  ): Promise<string> {\n    this.ensureInitialized();\n\n    const entry = await this.findEntry(key, options.partition);\n    if (!entry) {\n      throw new Error(`Memory entry not found: ${key}`);\n    }\n\n    // Validate sharing permissions\n    if (options.sharer) {\n      await this.validateAccess(options.sharer, 'share', options.partition);\n    }\n\n    // Create shared copy\n    const sharedEntryId = generateId('shared-mem');\n    const sharedEntry: MemoryEntry = {\n      ...entry,\n      id: sharedEntryId,\n      owner: targetAgent,\n      accessLevel: options.accessLevel || entry.accessLevel,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      expiresAt: options.expiresAt,\n      references: [...entry.references, entry.id],\n    };\n\n    // Store shared entry\n    this.entries.set(sharedEntryId, sharedEntry);\n    await this.index.addEntry(sharedEntry);\n\n    // Add to target agent's partition\n    const targetPartition = await this.getOrCreatePartition(`agent_${targetAgent.id}`);\n    targetPartition.entries.push(sharedEntry);\n\n    this.emit('memory:shared', {\n      originalId: entry.id,\n      sharedId: sharedEntryId,\n      key,\n      sharer: options.sharer?.id,\n      target: targetAgent.id,\n    });\n\n    this.logger.info('Shared memory entry', {\n      key,\n      from: options.sharer?.id,\n      to: targetAgent.id,\n      sharedId: sharedEntryId,\n    });\n\n    return sharedEntryId;\n  }\n\n  async broadcastMemory(\n    key: string,\n    targetAgents: AgentId[],\n    options: Partial<{\n      partition: string;\n      broadcaster: AgentId;\n      accessLevel: AccessLevel;\n    }> = {},\n  ): Promise<string[]> {\n    this.ensureInitialized();\n\n    const sharedIds: string[] = [];\n\n    for (const targetAgent of targetAgents) {\n      try {\n        const sharedId = await this.shareMemory(key, targetAgent, {\n          ...options,\n          sharer: options.broadcaster,\n        });\n        sharedIds.push(sharedId);\n      } catch (error) {\n        this.logger.warn('Failed to share memory with agent', {\n          key,\n          targetAgent: targetAgent.id,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    this.emit('memory:broadcasted', {\n      key,\n      broadcaster: options.broadcaster?.id,\n      targets: targetAgents.map((a) => a.id),\n      sharedCount: sharedIds.length,\n    });\n\n    return sharedIds;\n  }\n\n  async synchronizeWith(\n    targetNode: string,\n    options: Partial<{\n      partition: string;\n      direction: 'pull' | 'push' | 'bidirectional';\n      filter: MemoryQuery;\n    }> = {},\n  ): Promise<void> {\n    this.ensureInitialized();\n\n    if (!this.config.enableDistribution) {\n      throw new Error('Distribution not enabled');\n    }\n\n    await this.replication.synchronizeWith(targetNode, options);\n\n    this.emit('memory:synchronized', {\n      targetNode,\n      direction: options.direction || 'bidirectional',\n      partition: options.partition,\n    });\n  }\n\n  // ===== PARTITION MANAGEMENT =====\n\n  async createPartition(\n    name: string,\n    options: Partial<{\n      type: MemoryType;\n      maxSize: number;\n      ttl: number;\n      readOnly: boolean;\n      shared: boolean;\n      indexed: boolean;\n      compressed: boolean;\n    }> = {},\n    skipInitCheck: boolean = false,\n  ): Promise<string> {\n    if (!skipInitCheck) {\n      this.ensureInitialized();\n    }\n\n    if (this.partitions.has(name)) {\n      throw new Error(`Partition already exists: ${name}`);\n    }\n\n    const partition: MemoryPartition = {\n      id: generateId('partition'),\n      name,\n      type: options.type || 'knowledge',\n      entries: [],\n      maxSize: options.maxSize || this.config.maxMemorySize,\n      ttl: options.ttl,\n      readOnly: options.readOnly || false,\n      shared: options.shared || true,\n      indexed: options.indexed !== false,\n      compressed: options.compressed || this.config.enableCompression,\n    };\n\n    this.partitions.set(name, partition);\n    this.memory.partitions.push(partition);\n\n    this.emit('memory:partition-created', {\n      partitionId: partition.id,\n      name,\n      type: partition.type,\n    });\n\n    this.logger.info('Created memory partition', {\n      name,\n      type: partition.type,\n      maxSize: partition.maxSize,\n    });\n\n    return partition.id;\n  }\n\n  async deletePartition(name: string, force: boolean = false): Promise<boolean> {\n    this.ensureInitialized();\n\n    const partition = this.partitions.get(name);\n    if (!partition) {\n      return false;\n    }\n\n    if (partition.entries.length > 0 && !force) {\n      throw new Error(`Partition ${name} contains entries. Use force=true to delete.`);\n    }\n\n    // Delete all entries in partition\n    for (const entry of partition.entries) {\n      await this.deleteEntry(entry.id);\n    }\n\n    this.partitions.delete(name);\n    this.memory.partitions = this.memory.partitions.filter((p) => p.id !== partition.id);\n\n    this.emit('memory:partition-deleted', {\n      partitionId: partition.id,\n      name,\n    });\n\n    return true;\n  }\n\n  getPartition(name: string): MemoryPartition | undefined {\n    return this.partitions.get(name);\n  }\n\n  getPartitions(): MemoryPartition[] {\n    return Array.from(this.partitions.values());\n  }\n\n  // ===== BACKUP AND RECOVERY =====\n\n  async createBackup(): Promise<string> {\n    this.ensureInitialized();\n\n    const backup: MemoryBackup = {\n      timestamp: new Date(),\n      version: '1.0.0',\n      checksum: '',\n      metadata: {\n        namespace: this.config.namespace,\n        entryCount: this.entries.size,\n        partitionCount: this.partitions.size,\n      },\n      entries: Array.from(this.entries.values()),\n      partitions: Array.from(this.partitions.values()),\n    };\n\n    // Calculate checksum\n    backup.checksum = this.calculateChecksum(backup);\n\n    const backupId = generateId('backup');\n    await this.persistence.saveBackup(backupId, backup);\n\n    this.emit('memory:backup-created', {\n      backupId,\n      entryCount: backup.entries.length,\n      size: JSON.stringify(backup).length,\n    });\n\n    return backupId;\n  }\n\n  async restoreFromBackup(backupId: string): Promise<void> {\n    this.ensureInitialized();\n\n    const backup = await this.persistence.loadBackup(backupId);\n    if (!backup) {\n      throw new Error(`Backup not found: ${backupId}`);\n    }\n\n    // Verify checksum\n    const calculatedChecksum = this.calculateChecksum(backup);\n    if (calculatedChecksum !== backup.checksum) {\n      throw new Error('Backup checksum verification failed');\n    }\n\n    // Clear current state\n    this.entries.clear();\n    this.partitions.clear();\n    await this.index.clear();\n\n    // Restore entries\n    for (const entry of backup.entries) {\n      this.entries.set(entry.id, entry);\n      await this.index.addEntry(entry);\n    }\n\n    // Restore partitions\n    for (const partition of backup.partitions) {\n      this.partitions.set(partition.name, partition);\n    }\n\n    this.memory.partitions = backup.partitions;\n\n    this.emit('memory:backup-restored', {\n      backupId,\n      entryCount: backup.entries.length,\n      partitionCount: backup.partitions.length,\n    });\n\n    this.logger.info('Restored from backup', {\n      backupId,\n      entries: backup.entries.length,\n      partitions: backup.partitions.length,\n    });\n  }\n\n  // ===== STATISTICS AND MONITORING =====\n\n  getStatistics(): MemoryStatistics {\n    const entries = Array.from(this.entries.values());\n    const validEntries = entries.filter((e) => !this.isExpired(e));\n\n    const entriesByType: Record<MemoryType, number> = {\n      knowledge: 0,\n      state: 0,\n      cache: 0,\n      logs: 0,\n      results: 0,\n      communication: 0,\n      configuration: 0,\n      metrics: 0,\n    };\n\n    const entriesByAccess: Record<AccessLevel, number> = {\n      private: 0,\n      team: 0,\n      swarm: 0,\n      public: 0,\n      system: 0,\n    };\n\n    let totalSize = 0;\n    let oldestEntry = new Date();\n    let newestEntry = new Date(0);\n    let expiringEntries = 0;\n\n    for (const entry of validEntries) {\n      entriesByType[entry.type]++;\n      entriesByAccess[entry.accessLevel]++;\n\n      const entrySize = this.calculateEntrySize(entry);\n      totalSize += entrySize;\n\n      if (entry.createdAt < oldestEntry) {\n        oldestEntry = entry.createdAt;\n      }\n\n      if (entry.createdAt > newestEntry) {\n        newestEntry = entry.createdAt;\n      }\n\n      if (entry.expiresAt && entry.expiresAt.getTime() - Date.now() < 24 * 60 * 60 * 1000) {\n        expiringEntries++;\n      }\n    }\n\n    return {\n      totalEntries: validEntries.length,\n      totalSize,\n      partitionCount: this.partitions.size,\n      entriesByType,\n      entriesByAccess,\n      averageSize: validEntries.length > 0 ? totalSize / validEntries.length : 0,\n      oldestEntry,\n      newestEntry,\n      expiringEntries,\n    };\n  }\n\n  async exportMemory(\n    options: Partial<{\n      format: 'json' | 'csv';\n      includeExpired: boolean;\n      filter: MemoryQuery;\n    }> = {},\n  ): Promise<string> {\n    this.ensureInitialized();\n\n    let entries = Array.from(this.entries.values());\n\n    if (!options.includeExpired) {\n      entries = entries.filter((e) => !this.isExpired(e));\n    }\n\n    if (options.filter) {\n      const filteredResults = await this.query(options.filter);\n      const filteredIds = new Set(filteredResults.map((e) => e.id));\n      entries = entries.filter((e) => filteredIds.has(e.id));\n    }\n\n    if (options.format === 'csv') {\n      return this.entriesToCSV(entries);\n    } else {\n      return JSON.stringify(\n        {\n          exported: new Date().toISOString(),\n          namespace: this.config.namespace,\n          entryCount: entries.length,\n          entries: entries.map((e) => ({\n            ...e,\n            value: e.value, // Value is already serialized\n          })),\n        },\n        null,\n        2,\n      );\n    }\n  }\n\n  // ===== PRIVATE METHODS =====\n\n  private ensureInitialized(): void {\n    if (!this.isInitialized) {\n      throw new Error('Memory manager not initialized');\n    }\n  }\n\n  private async findEntry(key: string, partition?: string): Promise<MemoryEntry | null> {\n    for (const entry of this.entries.values()) {\n      if (entry.key === key) {\n        if (partition) {\n          const part = this.partitions.get(partition);\n          if (part && part.entries.find((e) => e.id === entry.id)) {\n            return entry;\n          }\n        } else {\n          return entry;\n        }\n      }\n    }\n    return null;\n  }\n\n  private async deleteEntry(entryId: string): Promise<boolean> {\n    const entry = this.entries.get(entryId);\n    if (!entry) {\n      return false;\n    }\n\n    // Remove from entries\n    this.entries.delete(entryId);\n\n    // Remove from partitions\n    for (const partition of this.partitions.values()) {\n      partition.entries = partition.entries.filter((e) => e.id !== entryId);\n    }\n\n    // Remove from index\n    await this.index.removeEntry(entryId);\n\n    // Remove from cache\n    if (this.config.enableCaching) {\n      this.cache.delete(entry.key);\n    }\n\n    this.emit('memory:deleted', {\n      entryId,\n      key: entry.key,\n    });\n\n    return true;\n  }\n\n  private isExpired(entry: MemoryEntry): boolean {\n    return entry.expiresAt ? entry.expiresAt <= new Date() : false;\n  }\n\n  private async validateAccess(\n    agent: AgentId,\n    operation: 'read' | 'write' | 'delete' | 'share',\n    partition?: string,\n  ): Promise<void> {\n    // Implement access control logic here\n    // For now, allow all operations\n    return;\n  }\n\n  private async getOrCreatePartition(name: string): Promise<MemoryPartition> {\n    let partition = this.partitions.get(name);\n    if (!partition) {\n      await this.createPartition(name, {}, !this.isInitialized);\n      partition = this.partitions.get(name)!;\n    }\n    return partition;\n  }\n\n  private async serializeValue(value: any): Promise<any> {\n    // Apply compression and encryption if enabled\n    let serialized = JSON.stringify(value);\n\n    if (this.config.enableCompression) {\n      // Compression would be implemented here\n      // For now, just return the serialized value\n    }\n\n    if (this.config.enableEncryption) {\n      serialized = await this.encryption.encrypt(serialized);\n    }\n\n    return serialized;\n  }\n\n  private async deserializeValue(value: any): Promise<any> {\n    let deserialized = value;\n\n    if (this.config.enableEncryption) {\n      deserialized = await this.encryption.decrypt(deserialized);\n    }\n\n    if (this.config.enableCompression) {\n      // Decompression would be implemented here\n      // For now, just use the deserialized value\n    }\n\n    return JSON.parse(deserialized);\n  }\n\n  private calculateEntrySize(entry: MemoryEntry): number {\n    return JSON.stringify(entry).length;\n  }\n\n  private async enforceMemoryLimits(newEntrySize: number): Promise<void> {\n    const stats = this.getStatistics();\n    const projectedSize = stats.totalSize + newEntrySize;\n\n    if (projectedSize > this.config.maxMemorySize) {\n      // Remove expired entries first\n      await this.cleanupExpiredEntries();\n\n      // If still over limit, remove oldest entries\n      const updatedStats = this.getStatistics();\n      if (updatedStats.totalSize + newEntrySize > this.config.maxMemorySize) {\n        await this.evictOldEntries(newEntrySize);\n      }\n    }\n  }\n\n  private async cleanupExpiredEntries(): Promise<void> {\n    const expiredEntries = Array.from(this.entries.values()).filter((e) => this.isExpired(e));\n\n    for (const entry of expiredEntries) {\n      await this.deleteEntry(entry.id);\n    }\n\n    if (expiredEntries.length > 0) {\n      this.logger.info('Cleaned up expired entries', { count: expiredEntries.length });\n    }\n  }\n\n  private async evictOldEntries(requiredSpace: number): Promise<void> {\n    const entries = Array.from(this.entries.values())\n      .filter((e) => !this.isExpired(e))\n      .sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n\n    let freedSpace = 0;\n    let evictedCount = 0;\n\n    for (const entry of entries) {\n      if (freedSpace >= requiredSpace) {\n        break;\n      }\n\n      if (entry.accessLevel !== 'system') {\n        // Don't evict system entries\n        const entrySize = this.calculateEntrySize(entry);\n        await this.deleteEntry(entry.id);\n        freedSpace += entrySize;\n        evictedCount++;\n      }\n    }\n\n    this.logger.warn('Evicted old entries for space', {\n      evictedCount,\n      freedSpace,\n      requiredSpace,\n    });\n  }\n\n  private calculateChecksum(backup: MemoryBackup): string {\n    const content = JSON.stringify({\n      entries: backup.entries,\n      partitions: backup.partitions,\n    });\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  private entriesToCSV(entries: MemoryEntry[]): string {\n    const headers = ['id', 'key', 'type', 'accessLevel', 'createdAt', 'updatedAt', 'owner', 'tags'];\n    const rows = entries.map((entry) => [\n      entry.id,\n      entry.key,\n      entry.type,\n      entry.accessLevel,\n      entry.createdAt.toISOString(),\n      entry.updatedAt.toISOString(),\n      entry.owner.id,\n      entry.tags.join(';'),\n    ]);\n\n    return [headers, ...rows].map((row) => row.join(',')).join('\\n');\n  }\n\n  private async loadMemoryState(): Promise<void> {\n    try {\n      const state = await this.persistence.loadState();\n      if (state) {\n        // Load entries\n        for (const entry of state.entries || []) {\n          this.entries.set(entry.id, entry);\n          await this.index.addEntry(entry);\n        }\n\n        // Load partitions\n        for (const partition of state.partitions || []) {\n          this.partitions.set(partition.name, partition);\n        }\n\n        this.memory.partitions = state.partitions || [];\n\n        this.logger.info('Loaded memory state', {\n          entries: this.entries.size,\n          partitions: this.partitions.size,\n        });\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load memory state', { error });\n    }\n  }\n\n  private async saveMemoryState(): Promise<void> {\n    try {\n      const state = {\n        namespace: this.config.namespace,\n        timestamp: new Date(),\n        entries: Array.from(this.entries.values()),\n        partitions: Array.from(this.partitions.values()),\n      };\n\n      await this.persistence.saveState(state);\n    } catch (error) {\n      this.logger.error('Failed to save memory state', { error });\n    }\n  }\n\n  private async createDefaultPartitions(): Promise<void> {\n    const defaultPartitions = [\n      { name: 'default', type: 'knowledge' as MemoryType },\n      { name: 'system', type: 'configuration' as MemoryType },\n      { name: 'cache', type: 'cache' as MemoryType },\n      { name: 'logs', type: 'logs' as MemoryType },\n    ];\n\n    for (const partition of defaultPartitions) {\n      if (!this.partitions.has(partition.name)) {\n        await this.createPartition(partition.name, { type: partition.type }, true);\n      }\n    }\n  }\n\n  private mergeWithDefaults(config: Partial<MemoryConfig>): MemoryConfig {\n    return {\n      namespace: 'default',\n      persistencePath: './swarm-memory',\n      maxMemorySize: 100 * 1024 * 1024, // 100MB\n      maxEntrySize: 10 * 1024 * 1024, // 10MB\n      defaultTtl: 24 * 60 * 60 * 1000, // 24 hours\n      enableCompression: false,\n      enableEncryption: false,\n      consistencyLevel: 'eventual',\n      syncInterval: 60000, // 1 minute\n      backupInterval: 3600000, // 1 hour\n      maxBackups: 24,\n      enableDistribution: false,\n      distributionNodes: [],\n      replicationFactor: 1,\n      enableCaching: true,\n      cacheSize: 1000,\n      cacheTtl: 300000, // 5 minutes\n      ...config,\n    };\n  }\n\n  private startBackgroundProcesses(): void {\n    // Sync process\n    if (this.config.syncInterval > 0) {\n      this.syncTimer = setInterval(() => {\n        this.performSync();\n      }, this.config.syncInterval);\n    }\n\n    // Backup process\n    if (this.config.backupInterval > 0) {\n      this.backupTimer = setInterval(() => {\n        this.createBackup().catch((error) => {\n          this.logger.error('Background backup failed', { error });\n        });\n      }, this.config.backupInterval);\n    }\n\n    // Cleanup process\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 60000); // Every minute\n  }\n\n  private stopBackgroundProcesses(): void {\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = undefined;\n    }\n\n    if (this.backupTimer) {\n      clearInterval(this.backupTimer);\n      this.backupTimer = undefined;\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n  }\n\n  private async performSync(): Promise<void> {\n    try {\n      await this.saveMemoryState();\n\n      if (this.config.enableDistribution) {\n        await this.replication.sync();\n      }\n    } catch (error) {\n      this.logger.error('Background sync failed', { error });\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Handle replication events\n    this.replication.on('entry-received', async (data: any) => {\n      const entry = data.entry as MemoryEntry;\n      this.entries.set(entry.id, entry);\n      await this.index.addEntry(entry);\n\n      this.emit('memory:replicated', {\n        entryId: entry.id,\n        key: entry.key,\n        source: data.source,\n      });\n    });\n  }\n}\n\n// ===== SUPPORTING CLASSES =====\n\nclass MemoryIndex {\n  private index: Map<string, Set<string>> = new Map();\n\n  async initialize(): Promise<void> {\n    // Initialize search index\n  }\n\n  async addEntry(entry: MemoryEntry): Promise<void> {\n    // Add entry to search index\n    this.indexTerms(entry.id, [entry.key, ...entry.tags, entry.type]);\n  }\n\n  async updateEntry(entry: MemoryEntry): Promise<void> {\n    await this.removeEntry(entry.id);\n    await this.addEntry(entry);\n  }\n\n  async removeEntry(entryId: string): Promise<void> {\n    // Remove from all index terms\n    for (const termSet of this.index.values()) {\n      termSet.delete(entryId);\n    }\n  }\n\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\n    // Implement search logic\n    return [];\n  }\n\n  async clear(): Promise<void> {\n    this.index.clear();\n  }\n\n  private indexTerms(entryId: string, terms: string[]): void {\n    for (const term of terms) {\n      const normalizedTerm = term.toLowerCase();\n      if (!this.index.has(normalizedTerm)) {\n        this.index.set(normalizedTerm, new Set());\n      }\n      this.index.get(normalizedTerm)!.add(entryId);\n    }\n  }\n}\n\nclass MemoryCache {\n  private cache: Map<string, { entry: MemoryEntry; expiry: number }> = new Map();\n  private maxSize: number;\n  private ttl: number;\n\n  constructor(maxSize: number, ttl: number) {\n    this.maxSize = maxSize;\n    this.ttl = ttl;\n  }\n\n  set(key: string, entry: MemoryEntry): void {\n    // Evict if at capacity\n    if (this.cache.size >= this.maxSize) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n\n    this.cache.set(key, {\n      entry,\n      expiry: Date.now() + this.ttl,\n    });\n  }\n\n  get(key: string): MemoryEntry | null {\n    const cached = this.cache.get(key);\n    if (!cached) {\n      return null;\n    }\n\n    if (Date.now() > cached.expiry) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return cached.entry;\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n}\n\nclass MemoryReplication extends EventEmitter {\n  private config: MemoryConfig;\n\n  constructor(config: MemoryConfig) {\n    super();\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    // Initialize replication\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown replication\n  }\n\n  async replicate(entry: MemoryEntry): Promise<void> {\n    // Replicate entry to other nodes\n  }\n\n  async synchronizeWith(targetNode: string, options: any): Promise<void> {\n    // Synchronize with target node\n  }\n\n  async sync(): Promise<void> {\n    // Perform background sync\n  }\n}\n\nclass MemoryPersistence {\n  private config: MemoryConfig;\n\n  constructor(config: MemoryConfig) {\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    await fs.mkdir(this.config.persistencePath, { recursive: true });\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown persistence\n  }\n\n  async saveState(state: any): Promise<void> {\n    const statePath = path.join(this.config.persistencePath, 'state.json');\n    await fs.writeFile(statePath, JSON.stringify(state, null, 2));\n  }\n\n  async loadState(): Promise<any> {\n    try {\n      const statePath = path.join(this.config.persistencePath, 'state.json');\n      const content = await fs.readFile(statePath, 'utf-8');\n      return JSON.parse(content);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async saveBackup(backupId: string, backup: MemoryBackup): Promise<void> {\n    const backupPath = path.join(this.config.persistencePath, 'backups', `${backupId}.json`);\n    await fs.mkdir(path.dirname(backupPath), { recursive: true });\n    await fs.writeFile(backupPath, JSON.stringify(backup, null, 2));\n  }\n\n  async loadBackup(backupId: string): Promise<MemoryBackup | null> {\n    try {\n      const backupPath = path.join(this.config.persistencePath, 'backups', `${backupId}.json`);\n      const content = await fs.readFile(backupPath, 'utf-8');\n      return JSON.parse(content);\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\nclass MemoryEncryption {\n  private config: MemoryConfig;\n\n  constructor(config: MemoryConfig) {\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    // Initialize encryption\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown encryption\n  }\n\n  async encrypt(data: string): Promise<string> {\n    // Implement encryption\n    return data;\n  }\n\n  async decrypt(data: string): Promise<string> {\n    // Implement decryption\n    return data;\n  }\n}\n\nexport default SwarmMemoryManager;\n"],"names":["EventEmitter","fs","path","crypto","Logger","generateId","SwarmMemoryManager","logger","config","memory","partitions","Map","entries","index","cache","replication","persistence","encryption","isInitialized","syncTimer","backupTimer","cleanupTimer","logLevel","logging","level","logFormat","format","logDestination","destination","component","mergeWithDefaults","namespace","permissions","read","write","delete","share","persistent","backupEnabled","distributed","enableDistribution","consistency","consistencyLevel","cacheEnabled","enableCaching","compressionEnabled","enableCompression","MemoryIndex","MemoryCache","cacheSize","cacheTtl","MemoryReplication","MemoryPersistence","MemoryEncryption","setupEventHandlers","initialize","info","loadMemoryState","createDefaultPartitions","startBackgroundProcesses","emit","entriesLoaded","size","partitionsLoaded","error","shutdown","stopBackgroundProcesses","saveMemoryState","store","key","value","options","ensureInitialized","entryId","now","Date","owner","validateAccess","partition","partitionName","getOrCreatePartition","entry","id","serializeValue","type","tags","swarmId","instance","accessLevel","createdAt","updatedAt","expiresAt","ttl","getTime","undefined","version","references","dependencies","entrySize","calculateEntrySize","maxEntrySize","Error","enforceMemoryLimits","set","push","addEntry","replicate","debug","retrieve","cached","get","isExpired","requester","includeMetadata","deserializeValue","findEntry","deleteEntry","update","updater","incrementVersion","previousVersions","length","slice","updateEntry","deleter","force","query","results","Array","from","values","entryIds","Set","map","e","filter","has","some","tag","includes","createdAfter","createdBefore","expiresAfter","sortBy","sort","a","b","compareValue","localeCompare","sortOrder","offset","limit","search","shareMemory","targetAgent","sharer","sharedEntryId","sharedEntry","targetPartition","originalId","sharedId","target","to","broadcastMemory","targetAgents","sharedIds","broadcaster","warn","message","String","targets","sharedCount","synchronizeWith","targetNode","direction","createPartition","name","skipInitCheck","maxSize","maxMemorySize","readOnly","shared","indexed","compressed","partitionId","deletePartition","p","getPartition","getPartitions","createBackup","backup","timestamp","checksum","metadata","entryCount","partitionCount","calculateChecksum","backupId","saveBackup","JSON","stringify","restoreFromBackup","loadBackup","calculatedChecksum","clear","getStatistics","validEntries","entriesByType","knowledge","state","logs","communication","configuration","metrics","entriesByAccess","private","team","swarm","public","system","totalSize","oldestEntry","newestEntry","expiringEntries","totalEntries","averageSize","exportMemory","includeExpired","filteredResults","filteredIds","entriesToCSV","exported","toISOString","part","find","removeEntry","agent","operation","serialized","enableEncryption","encrypt","deserialized","decrypt","parse","newEntrySize","stats","projectedSize","cleanupExpiredEntries","updatedStats","evictOldEntries","expiredEntries","count","requiredSpace","freedSpace","evictedCount","content","createHash","digest","headers","rows","join","row","loadState","saveState","defaultPartitions","persistencePath","defaultTtl","syncInterval","backupInterval","maxBackups","distributionNodes","replicationFactor","setInterval","performSync","catch","clearInterval","sync","on","data","source","indexTerms","termSet","terms","term","normalizedTerm","toLowerCase","add","oldestKey","keys","next","expiry","mkdir","recursive","statePath","writeFile","readFile","backupPath","dirname"],"mappings":"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"}