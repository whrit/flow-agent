{"version":3,"sources":["../../../../src/swarm/strategies/auto.ts"],"sourcesContent":["// Extended TaskType for auto strategy (extends base TaskType)\nexport type ExtendedTaskType =\n  | 'data-analysis'\n  | 'performance-analysis'\n  | 'statistical-analysis'\n  | 'visualization'\n  | 'predictive-modeling'\n  | 'anomaly-detection'\n  | 'trend-analysis'\n  | 'business-intelligence'\n  | 'quality-analysis'\n  | 'system-design'\n  | 'architecture-review'\n  | 'api-design'\n  | 'cloud-architecture'\n  | 'microservices-design'\n  | 'security-architecture'\n  | 'scalability-design'\n  | 'database-architecture'\n  | 'code-generation'\n  | 'code-review'\n  | 'refactoring'\n  | 'debugging'\n  | 'api-development'\n  | 'database-design'\n  | 'performance-optimization'\n  | 'task-orchestration'\n  | 'progress-tracking'\n  | 'resource-allocation'\n  | 'workflow-management'\n  | 'team-coordination'\n  | 'status-reporting'\n  | 'fact-check'\n  | 'literature-review'\n  | 'market-analysis'\n  | 'unit-testing'\n  | 'integration-testing'\n  | 'e2e-testing'\n  | 'performance-testing'\n  | 'security-testing'\n  | 'api-testing'\n  | 'test-automation'\n  | 'test-analysis';\n\n/**\n * Optimized AUTO Strategy Implementation\n * Uses machine learning-inspired heuristics and intelligent task decomposition\n */\n\nimport { BaseStrategy } from './base.js';\nimport type { DecompositionResult, TaskBatch, AgentAllocation, TaskPattern } from './base.js';\nimport type {\n  SwarmObjective,\n  TaskDefinition,\n  AgentState,\n  TaskType,\n  TaskPriority,\n  TaskId,\n  AgentType,\n} from '../types.js';\nimport { generateId } from '../../utils/helpers.js';\n\ninterface MLHeuristics {\n  taskTypeWeights: Record<string, number>;\n  agentPerformanceHistory: Map<string, number>;\n  complexityFactors: Record<string, number>;\n  parallelismOpportunities: string[];\n}\n\ninterface PredictiveSchedule {\n  timeline: ScheduleSlot[];\n  resourceUtilization: Record<string, number>;\n  bottlenecks: string[];\n  optimizationSuggestions: string[];\n}\n\ninterface ScheduleSlot {\n  startTime: number;\n  endTime: number;\n  tasks: string[];\n  agents: string[];\n  dependencies: string[];\n}\n\nexport class AutoStrategy extends BaseStrategy {\n  private mlHeuristics: MLHeuristics;\n  private decompositionCache: Map<string, DecompositionResult>;\n  private patternCache: Map<string, TaskPattern[]>;\n  private performanceHistory: Map<string, number[]>;\n\n  constructor(config: any) {\n    super(config);\n    this.mlHeuristics = this.initializeMLHeuristics();\n    this.decompositionCache = new Map();\n    this.patternCache = new Map();\n    this.performanceHistory = new Map();\n  }\n\n  /**\n   * Enhanced objective decomposition with async processing and intelligent batching\n   */\n  override async decomposeObjective(objective: SwarmObjective): Promise<DecompositionResult> {\n    const startTime = Date.now();\n    const cacheKey = this.getCacheKey(objective);\n\n    // Check cache first\n    if (this.decompositionCache.has(cacheKey)) {\n      this.metrics.cacheHitRate = (this.metrics.cacheHitRate + 1) / 2;\n      return this.decompositionCache.get(cacheKey)!;\n    }\n\n    // Parallel pattern detection and task type analysis\n    const [detectedPatterns, taskTypes, complexity] = await Promise.all([\n      this.detectPatternsAsync(objective.description),\n      this.analyzeTaskTypesAsync(objective.description),\n      this.estimateComplexityAsync(objective.description),\n    ]);\n\n    // Generate tasks based on detected patterns and strategy\n    const tasks = await this.generateTasksWithBatching(\n      objective,\n      detectedPatterns,\n      taskTypes,\n      complexity,\n    );\n\n    // Analyze dependencies and create batches\n    const dependencies = this.analyzeDependencies(tasks);\n    const batchGroups = this.createTaskBatches(tasks, dependencies);\n\n    // Estimate total duration with parallel processing consideration\n    const estimatedDuration = this.calculateOptimizedDuration(batchGroups);\n\n    const result: DecompositionResult = {\n      tasks,\n      dependencies,\n      estimatedDuration,\n      recommendedStrategy: this.selectOptimalStrategy(objective, complexity),\n      complexity,\n      batchGroups,\n      timestamp: new Date(),\n      ttl: 1800000, // 30 minutes\n      accessCount: 0,\n      lastAccessed: new Date(),\n      data: { objectiveId: objective.id, strategy: 'auto' },\n    };\n\n    // Cache the result\n    this.decompositionCache.set(cacheKey, result);\n    this.updateMetrics(result, Date.now() - startTime);\n\n    return result;\n  }\n\n  /**\n   * ML-inspired agent selection with performance history consideration\n   */\n  override async selectAgentForTask(\n    task: TaskDefinition,\n    availableAgents: AgentState[],\n  ): Promise<string | null> {\n    if (availableAgents.length === 0) return null;\n\n    // Score agents using ML heuristics\n    const scoredAgents = await Promise.all(\n      availableAgents.map(async (agent) => ({\n        agent,\n        score: await this.calculateAgentScore(agent, task),\n      })),\n    );\n\n    // Sort by score and select best agent\n    scoredAgents.sort((a, b) => b.score - a.score);\n\n    // Update performance history\n    const selectedAgent = scoredAgents[0].agent;\n    this.updateAgentPerformanceHistory(selectedAgent.id.id, scoredAgents[0].score);\n\n    return selectedAgent.id.id;\n  }\n\n  /**\n   * Predictive task scheduling with dynamic agent allocation\n   */\n  override async optimizeTaskSchedule(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n  ): Promise<AgentAllocation[]> {\n    const schedule = await this.createPredictiveSchedule(tasks, agents);\n\n    return this.allocateAgentsOptimally(tasks, agents, schedule);\n  }\n\n  // Private implementation methods\n\n  private initializeMLHeuristics(): MLHeuristics {\n    return {\n      taskTypeWeights: {\n        development: 1.0,\n        testing: 0.8,\n        analysis: 0.9,\n        documentation: 0.6,\n        optimization: 1.1,\n        research: 0.7,\n      },\n      agentPerformanceHistory: new Map(),\n      complexityFactors: {\n        integration: 1.5,\n        system: 1.3,\n        api: 1.2,\n        database: 1.4,\n        ui: 1.1,\n        algorithm: 1.6,\n      },\n      parallelismOpportunities: [\n        'independent modules',\n        'separate components',\n        'different layers',\n        'parallel testing',\n        'concurrent analysis',\n      ],\n    };\n  }\n\n  private async detectPatternsAsync(description: string): Promise<TaskPattern[]> {\n    const cacheKey = `patterns-${description.slice(0, 50)}`;\n\n    if (this.patternCache.has(cacheKey)) {\n      return this.patternCache.get(cacheKey)!;\n    }\n\n    // Simulate async pattern detection with enhanced matching\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const patterns = this.taskPatterns.filter((pattern) => pattern.pattern.test(description));\n\n        // Add dynamic patterns based on content analysis\n        const dynamicPatterns = this.generateDynamicPatterns(description);\n        const allPatterns = [...patterns, ...dynamicPatterns];\n\n        this.patternCache.set(cacheKey, allPatterns);\n        resolve(allPatterns);\n      }, 10); // Simulate async processing\n    });\n  }\n\n  private async analyzeTaskTypesAsync(description: string): Promise<string[]> {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        const types = [];\n\n        // Enhanced task type detection\n        if (/create|build|implement|develop|code/i.test(description)) {\n          types.push('development');\n        }\n        if (/test|verify|validate|check/i.test(description)) {\n          types.push('testing');\n        }\n        if (/analyze|research|investigate|study/i.test(description)) {\n          types.push('analysis');\n        }\n        if (/document|write|explain|describe/i.test(description)) {\n          types.push('documentation');\n        }\n        if (/optimize|improve|enhance|refactor/i.test(description)) {\n          types.push('optimization');\n        }\n        if (/deploy|install|configure|setup/i.test(description)) {\n          types.push('deployment');\n        }\n\n        resolve(types.length > 0 ? types : ['generic']);\n      }, 5);\n    });\n  }\n\n  private async estimateComplexityAsync(description: string): Promise<number> {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        let complexity = this.estimateComplexity(description);\n\n        // Apply ML heuristics for complexity adjustment\n        for (const [factor, weight] of Object.entries(this.mlHeuristics.complexityFactors)) {\n          if (description.toLowerCase().includes(factor)) {\n            complexity *= weight;\n          }\n        }\n\n        resolve(Math.min(Math.round(complexity), 5));\n      }, 5);\n    });\n  }\n\n  private generateDynamicPatterns(description: string): TaskPattern[] {\n    const patterns: TaskPattern[] = [];\n\n    // Generate patterns based on specific keywords and context\n    if (description.includes('API') || description.includes('endpoint')) {\n      patterns.push({\n        pattern: /api|endpoint|service/i,\n        type: 'api-development',\n        complexity: 3,\n        estimatedDuration: 20 * 60 * 1000,\n        requiredAgents: 2,\n        priority: 2,\n      });\n    }\n\n    if (description.includes('database') || description.includes('data')) {\n      patterns.push({\n        pattern: /database|data|storage/i,\n        type: 'data-management',\n        complexity: 3,\n        estimatedDuration: 18 * 60 * 1000,\n        requiredAgents: 2,\n        priority: 2,\n      });\n    }\n\n    return patterns;\n  }\n\n  private async generateTasksWithBatching(\n    objective: SwarmObjective,\n    patterns: TaskPattern[],\n    taskTypes: string[],\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n\n    // Determine strategy-specific task generation\n    if (objective.strategy === 'development') {\n      tasks.push(...(await this.generateDevelopmentTasks(objective, complexity)));\n    } else if (objective.strategy === 'analysis') {\n      tasks.push(...(await this.generateAnalysisTasks(objective, complexity)));\n    } else {\n      // Auto strategy - intelligent task generation based on patterns\n      tasks.push(...(await this.generateAutoTasks(objective, patterns, taskTypes, complexity)));\n    }\n\n    return tasks;\n  }\n\n  private async generateDevelopmentTasks(\n    objective: SwarmObjective,\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n    const baseId = generateId('task');\n\n    // Analysis and Planning Phase\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-analysis`,\n        type: 'analysis' as TaskType,\n        name: 'Requirements Analysis and Planning',\n        description: `Analyze requirements and create implementation plan for: ${objective.description}`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(5 * 60 * 1000, complexity * 3 * 60 * 1000),\n        capabilities: ['analysis', 'documentation', 'research'],\n      }),\n    );\n\n    // Implementation Phase (can be parallelized)\n    const implementationTasks = this.createParallelImplementationTasks(\n      objective,\n      complexity,\n      baseId,\n    );\n    tasks.push(...implementationTasks);\n\n    // Testing Phase\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-testing`,\n        type: 'testing' as TaskType,\n        name: 'Comprehensive Testing',\n        description: `Create and execute tests for the implementation`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(8 * 60 * 1000, complexity * 4 * 60 * 1000),\n        capabilities: ['testing', 'code-generation'],\n        dependencies: implementationTasks.map((t) => t.id.id),\n      }),\n    );\n\n    // Documentation Phase\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-documentation`,\n        type: 'documentation' as TaskType,\n        name: 'Documentation Creation',\n        description: `Create comprehensive documentation`,\n        priority: 'medium' as TaskPriority,\n        estimatedDuration: Math.max(5 * 60 * 1000, complexity * 2 * 60 * 1000),\n        capabilities: ['documentation'],\n        dependencies: implementationTasks.map((t) => t.id.id),\n      }),\n    );\n\n    return tasks;\n  }\n\n  private createParallelImplementationTasks(\n    objective: SwarmObjective,\n    complexity: number,\n    baseId: string,\n  ): TaskDefinition[] {\n    const tasks: TaskDefinition[] = [];\n\n    // Determine if we can split implementation into parallel tasks\n    const canParallelize = this.canParallelizeImplementation(objective.description);\n\n    if (canParallelize && complexity >= 3) {\n      // Create multiple parallel implementation tasks\n      const components = this.identifyComponents(objective.description);\n\n      components.forEach((component, index) => {\n        tasks.push(\n          this.createTaskDefinition({\n            id: `${baseId}-impl-${index}`,\n            type: 'coding' as TaskType,\n            name: `Implement ${component}`,\n            description: `Implement ${component} component for: ${objective.description}`,\n            priority: 'high' as TaskPriority,\n            estimatedDuration: Math.max(10 * 60 * 1000, complexity * 5 * 60 * 1000),\n            capabilities: ['code-generation', 'file-system'],\n            dependencies: [`${baseId}-analysis`],\n          }),\n        );\n      });\n    } else {\n      // Single implementation task\n      tasks.push(\n        this.createTaskDefinition({\n          id: `${baseId}-implementation`,\n          type: 'coding' as TaskType,\n          name: 'Core Implementation',\n          description: `Implement the solution for: ${objective.description}`,\n          priority: 'high' as TaskPriority,\n          estimatedDuration: Math.max(15 * 60 * 1000, complexity * 8 * 60 * 1000),\n          capabilities: ['code-generation', 'file-system'],\n          dependencies: [`${baseId}-analysis`],\n        }),\n      );\n    }\n\n    return tasks;\n  }\n\n  private async generateAnalysisTasks(\n    objective: SwarmObjective,\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n    const baseId = generateId('task');\n\n    // Data Collection\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-collection`,\n        type: 'research' as TaskType,\n        name: 'Data Collection and Research',\n        description: `Collect and research data for: ${objective.description}`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(8 * 60 * 1000, complexity * 4 * 60 * 1000),\n        capabilities: ['research', 'analysis', 'web-search'],\n      }),\n    );\n\n    // Analysis\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-analysis`,\n        type: 'analysis' as TaskType,\n        name: 'Data Analysis',\n        description: `Analyze collected data and generate insights`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(10 * 60 * 1000, complexity * 5 * 60 * 1000),\n        capabilities: ['analysis', 'documentation'],\n        dependencies: [`${baseId}-collection`],\n      }),\n    );\n\n    // Reporting\n    tasks.push(\n      this.createTaskDefinition({\n        id: `${baseId}-reporting`,\n        type: 'documentation' as TaskType,\n        name: 'Analysis Report',\n        description: `Create comprehensive analysis report`,\n        priority: 'medium' as TaskPriority,\n        estimatedDuration: Math.max(6 * 60 * 1000, complexity * 3 * 60 * 1000),\n        capabilities: ['documentation', 'analysis'],\n        dependencies: [`${baseId}-analysis`],\n      }),\n    );\n\n    return tasks;\n  }\n\n  private async generateAutoTasks(\n    objective: SwarmObjective,\n    patterns: TaskPattern[],\n    taskTypes: string[],\n    complexity: number,\n  ): Promise<TaskDefinition[]> {\n    const tasks: TaskDefinition[] = [];\n    const baseId = generateId('task');\n\n    // Use ML heuristics to determine optimal task structure\n    const optimalStructure = this.determineOptimalTaskStructure(patterns, taskTypes, complexity);\n\n    if (optimalStructure.requiresAnalysis) {\n      tasks.push(\n        this.createTaskDefinition({\n          id: `${baseId}-analysis`,\n          type: 'analysis' as TaskType,\n          name: 'Intelligent Analysis',\n          description: `Analyze and understand: ${objective.description}`,\n          priority: 'high' as TaskPriority,\n          estimatedDuration: optimalStructure.analysisDuration,\n          capabilities: ['analysis', 'research'],\n        }),\n      );\n    }\n\n    if (optimalStructure.requiresImplementation) {\n      const implTasks = this.createOptimalImplementationTasks(objective, optimalStructure, baseId);\n      tasks.push(...implTasks);\n    }\n\n    if (optimalStructure.requiresTesting) {\n      tasks.push(\n        this.createTaskDefinition({\n          id: `${baseId}-testing`,\n          type: 'testing' as TaskType,\n          name: 'Intelligent Testing',\n          description: `Test and validate the solution`,\n          priority: 'high' as TaskPriority,\n          estimatedDuration: optimalStructure.testingDuration,\n          capabilities: ['testing', 'validation'],\n          dependencies: tasks.filter((t) => t.type === 'coding').map((t) => t.id.id),\n        }),\n      );\n    }\n\n    return tasks;\n  }\n\n  private createTaskDefinition(params: {\n    id: string;\n    type: TaskType;\n    name: string;\n    description: string;\n    priority: TaskPriority;\n    estimatedDuration: number;\n    capabilities: string[];\n    dependencies?: string[];\n  }): TaskDefinition {\n    const taskId: TaskId = {\n      id: params.id,\n      swarmId: 'auto-strategy',\n      sequence: 1,\n      priority: 1,\n    };\n\n    return {\n      id: taskId,\n      type: params.type,\n      name: params.name,\n      description: params.description,\n      instructions: params.description,\n      requirements: {\n        capabilities: params.capabilities,\n        tools: this.getRequiredTools(params.type),\n        permissions: ['read', 'write', 'execute'],\n      },\n      constraints: {\n        dependencies: (params.dependencies || []).map((dep) => ({\n          id: dep,\n          swarmId: 'auto-strategy',\n          sequence: 1,\n          priority: 1,\n        })),\n        dependents: [],\n        conflicts: [],\n        maxRetries: 3,\n        timeoutAfter: params.estimatedDuration,\n      },\n      priority: params.priority,\n      input: { description: params.description },\n      context: {},\n      examples: [],\n      status: 'created',\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      attempts: [],\n      statusHistory: [\n        {\n          timestamp: new Date(),\n          from: 'created',\n          to: 'created',\n          reason: 'Task created by AutoStrategy',\n          triggeredBy: 'system',\n        },\n      ],\n    };\n  }\n\n  private getRequiredTools(type: TaskType): string[] {\n    const toolMap: Record<string, string[]> = {\n      coding: ['file-system', 'terminal', 'editor'],\n      testing: ['test-runner', 'file-system', 'terminal'],\n      analysis: ['analyst', 'file-system', 'web-search'],\n      documentation: ['editor', 'file-system'],\n      research: ['web-search', 'analyst', 'file-system'],\n      review: ['analyst', 'file-system'],\n      deployment: ['terminal', 'file-system', 'deployment-tools'],\n      monitoring: ['monitoring-tools', 'analyst'],\n      coordination: ['communication-tools'],\n      communication: ['communication-tools'],\n      maintenance: ['file-system', 'terminal', 'monitoring-tools'],\n      optimization: ['analyst', 'profiler', 'file-system'],\n      validation: ['validator', 'test-runner'],\n      integration: ['integration-tools', 'file-system', 'terminal'],\n      custom: ['file-system'],\n    };\n\n    return toolMap[type] || ['file-system'];\n  }\n\n  // Additional helper methods would continue here...\n  // (Truncated for brevity - the full implementation would include all helper methods)\n\n  private canParallelizeImplementation(description: string): boolean {\n    const parallelKeywords = ['components', 'modules', 'services', 'layers', 'parts'];\n    return parallelKeywords.some((keyword) => description.toLowerCase().includes(keyword));\n  }\n\n  private identifyComponents(description: string): string[] {\n    // Simple component identification - in a real implementation this would be more sophisticated\n    const components = ['Core Logic', 'User Interface', 'Data Layer'];\n\n    if (description.toLowerCase().includes('api')) {\n      components.push('API Layer');\n    }\n    if (description.toLowerCase().includes('database')) {\n      components.push('Database Integration');\n    }\n\n    return components.slice(0, 3); // Limit to 3 parallel components\n  }\n\n  private determineOptimalTaskStructure(\n    patterns: TaskPattern[],\n    taskTypes: string[],\n    complexity: number,\n  ) {\n    return {\n      requiresAnalysis: complexity >= 2 || taskTypes.includes('analysis'),\n      requiresImplementation: taskTypes.includes('development') || taskTypes.includes('coding'),\n      requiresTesting: complexity >= 2 || taskTypes.includes('testing'),\n      analysisDuration: Math.max(5 * 60 * 1000, complexity * 3 * 60 * 1000),\n      testingDuration: Math.max(5 * 60 * 1000, complexity * 4 * 60 * 1000),\n    };\n  }\n\n  private createOptimalImplementationTasks(\n    objective: SwarmObjective,\n    structure: any,\n    baseId: string,\n  ): TaskDefinition[] {\n    return [\n      this.createTaskDefinition({\n        id: `${baseId}-implementation`,\n        type: 'coding' as TaskType,\n        name: 'Optimal Implementation',\n        description: `Implement solution for: ${objective.description}`,\n        priority: 'high' as TaskPriority,\n        estimatedDuration: Math.max(15 * 60 * 1000, structure.complexity * 8 * 60 * 1000),\n        capabilities: ['code-generation', 'file-system'],\n        dependencies: structure.requiresAnalysis ? [`${baseId}-analysis`] : [],\n      }),\n    ];\n  }\n\n  private analyzeDependencies(tasks: TaskDefinition[]): Map<string, string[]> {\n    const dependencies = new Map<string, string[]>();\n\n    tasks.forEach((task) => {\n      if (task.constraints.dependencies.length > 0) {\n        dependencies.set(\n          task.id.id,\n          task.constraints.dependencies.map((dep) => dep.id),\n        );\n      }\n    });\n\n    return dependencies;\n  }\n\n  private createTaskBatches(\n    tasks: TaskDefinition[],\n    dependencies: Map<string, string[]>,\n  ): TaskBatch[] {\n    const batches: TaskBatch[] = [];\n    const processed = new Set<string>();\n    let batchIndex = 0;\n\n    while (processed.size < tasks.length) {\n      const batchTasks = tasks.filter(\n        (task) =>\n          !processed.has(task.id.id) &&\n          task.constraints.dependencies.every((dep) => processed.has(dep.id)),\n      );\n\n      if (batchTasks.length === 0) break; // Prevent infinite loop\n\n      const batch: TaskBatch = {\n        id: `batch-${batchIndex++}`,\n        tasks: batchTasks,\n        canRunInParallel: batchTasks.length > 1,\n        estimatedDuration: Math.max(...batchTasks.map((t) => t.constraints.timeoutAfter || 0)),\n        requiredResources: this.calculateBatchResources(batchTasks),\n      };\n\n      batches.push(batch);\n      batchTasks.forEach((task) => processed.add(task.id.id));\n    }\n\n    return batches;\n  }\n\n  private calculateBatchResources(tasks: TaskDefinition[]): Record<string, number> {\n    return {\n      agents: tasks.length,\n      memory: tasks.length * 512, // MB\n      cpu: tasks.length * 0.5, // CPU cores\n    };\n  }\n\n  private calculateOptimizedDuration(batches: TaskBatch[]): number {\n    return batches.reduce((total, batch) => total + batch.estimatedDuration, 0);\n  }\n\n  private selectOptimalStrategy(objective: SwarmObjective, complexity: number): string {\n    if (complexity >= 4) return 'development';\n    if (objective.description.toLowerCase().includes('analyze')) return 'analysis';\n    if (objective.description.toLowerCase().includes('test')) return 'testing';\n    return 'auto';\n  }\n\n  private async calculateAgentScore(agent: AgentState, task: TaskDefinition): Promise<number> {\n    let score = 0;\n\n    // Capability matching (40%)\n    const capabilityMatch = this.calculateCapabilityMatch(agent, task);\n    score += capabilityMatch * 0.4;\n\n    // Performance history (30%)\n    const performanceScore = this.getAgentPerformanceScore(agent.id.id);\n    score += performanceScore * 0.3;\n\n    // Current workload (20%)\n    const workloadScore = 1 - agent.workload;\n    score += workloadScore * 0.2;\n\n    // ML heuristics adjustment (10%)\n    const mlScore = this.applyMLHeuristics(agent, task);\n    score += mlScore * 0.1;\n\n    return score;\n  }\n\n  private calculateCapabilityMatch(agent: AgentState, task: TaskDefinition): number {\n    const requiredCaps = task.requirements.capabilities;\n    let matches = 0;\n\n    for (const cap of requiredCaps) {\n      if (this.agentHasCapability(agent, cap)) {\n        matches++;\n      }\n    }\n\n    return requiredCaps.length > 0 ? matches / requiredCaps.length : 1.0;\n  }\n\n  private agentHasCapability(agent: AgentState, capability: string): boolean {\n    const caps = agent.capabilities;\n\n    switch (capability) {\n      case 'code-generation':\n        return caps.codeGeneration;\n      case 'code-review':\n        return caps.codeReview;\n      case 'testing':\n        return caps.testing;\n      case 'documentation':\n        return caps.documentation;\n      case 'research':\n        return caps.research;\n      case 'analysis':\n        return caps.analysis;\n      case 'web-search':\n        return caps.webSearch;\n      case 'api-integration':\n        return caps.apiIntegration;\n      case 'file-system':\n        return caps.fileSystem;\n      case 'terminal-access':\n        return caps.terminalAccess;\n      default:\n        return (\n          caps.domains.includes(capability) ||\n          caps.languages.includes(capability) ||\n          caps.frameworks.includes(capability) ||\n          caps.tools.includes(capability)\n        );\n    }\n  }\n\n  private getAgentPerformanceScore(agentId: string): number {\n    const history = this.performanceHistory.get(agentId);\n    if (!history || history.length === 0) return 0.8; // Default score\n\n    const average = history.reduce((sum, score) => sum + score, 0) / history.length;\n    return Math.min(average, 1.0);\n  }\n\n  private applyMLHeuristics(agent: AgentState, task: TaskDefinition): number {\n    const taskType = this.detectTaskType(task.description);\n    const weight = this.mlHeuristics.taskTypeWeights[taskType] || 1.0;\n\n    // Apply agent type bonus\n    let bonus = 0;\n    if (agent.type === 'coder' && taskType === 'development') bonus = 0.2;\n    if (agent.type === 'tester' && taskType === 'testing') bonus = 0.2;\n    if (agent.type === 'analyst' && taskType === 'analysis') bonus = 0.2;\n\n    return Math.min(weight + bonus, 1.0);\n  }\n\n  private updateAgentPerformanceHistory(agentId: string, score: number): void {\n    if (!this.performanceHistory.has(agentId)) {\n      this.performanceHistory.set(agentId, []);\n    }\n\n    const history = this.performanceHistory.get(agentId)!;\n    history.push(score);\n\n    // Keep only last 10 scores\n    if (history.length > 10) {\n      history.shift();\n    }\n  }\n\n  private async createPredictiveSchedule(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n  ): Promise<PredictiveSchedule> {\n    // Simplified predictive scheduling implementation\n    const timeline: ScheduleSlot[] = [];\n    let currentTime = Date.now();\n\n    for (const task of tasks) {\n      const duration = task.constraints.timeoutAfter || 300000; // 5 min default\n      timeline.push({\n        startTime: currentTime,\n        endTime: currentTime + duration,\n        tasks: [task.id.id],\n        agents: [], // To be filled by allocation\n        dependencies: task.constraints.dependencies.map((dep) => dep.id),\n      });\n      currentTime += duration;\n    }\n\n    return {\n      timeline,\n      resourceUtilization: { cpu: 0.7, memory: 0.6 },\n      bottlenecks: [],\n      optimizationSuggestions: ['Consider parallel execution for independent tasks'],\n    };\n  }\n\n  private allocateAgentsOptimally(\n    tasks: TaskDefinition[],\n    agents: AgentState[],\n    schedule: PredictiveSchedule,\n  ): AgentAllocation[] {\n    const allocations: AgentAllocation[] = [];\n\n    agents.forEach((agent) => {\n      const suitableTasks = tasks.filter(\n        (task) => this.calculateCapabilityMatch(agent, task) > 0.5,\n      );\n\n      if (suitableTasks.length > 0) {\n        allocations.push({\n          agentId: agent.id.id,\n          tasks: suitableTasks.slice(0, 3).map((t) => t.id.id), // Limit to 3 tasks per agent\n          estimatedWorkload: suitableTasks.length * 0.3,\n          capabilities: Object.keys(agent.capabilities).filter(\n            (cap) => (agent.capabilities as any)[cap] === true,\n          ),\n        });\n      }\n    });\n\n    return allocations;\n  }\n}\n"],"names":["BaseStrategy","generateId","AutoStrategy","mlHeuristics","decompositionCache","patternCache","performanceHistory","config","initializeMLHeuristics","Map","decomposeObjective","objective","startTime","Date","now","cacheKey","getCacheKey","has","metrics","cacheHitRate","get","detectedPatterns","taskTypes","complexity","Promise","all","detectPatternsAsync","description","analyzeTaskTypesAsync","estimateComplexityAsync","tasks","generateTasksWithBatching","dependencies","analyzeDependencies","batchGroups","createTaskBatches","estimatedDuration","calculateOptimizedDuration","result","recommendedStrategy","selectOptimalStrategy","timestamp","ttl","accessCount","lastAccessed","data","objectiveId","id","strategy","set","updateMetrics","selectAgentForTask","task","availableAgents","length","scoredAgents","map","agent","score","calculateAgentScore","sort","a","b","selectedAgent","updateAgentPerformanceHistory","optimizeTaskSchedule","agents","schedule","createPredictiveSchedule","allocateAgentsOptimally","taskTypeWeights","development","testing","analysis","documentation","optimization","research","agentPerformanceHistory","complexityFactors","integration","system","api","database","ui","algorithm","parallelismOpportunities","slice","resolve","setTimeout","patterns","taskPatterns","filter","pattern","test","dynamicPatterns","generateDynamicPatterns","allPatterns","types","push","estimateComplexity","factor","weight","Object","entries","toLowerCase","includes","Math","min","round","type","requiredAgents","priority","generateDevelopmentTasks","generateAnalysisTasks","generateAutoTasks","baseId","createTaskDefinition","name","max","capabilities","implementationTasks","createParallelImplementationTasks","t","canParallelize","canParallelizeImplementation","components","identifyComponents","forEach","component","index","optimalStructure","determineOptimalTaskStructure","requiresAnalysis","analysisDuration","requiresImplementation","implTasks","createOptimalImplementationTasks","requiresTesting","testingDuration","params","taskId","swarmId","sequence","instructions","requirements","tools","getRequiredTools","permissions","constraints","dep","dependents","conflicts","maxRetries","timeoutAfter","input","context","examples","status","createdAt","updatedAt","attempts","statusHistory","from","to","reason","triggeredBy","toolMap","coding","review","deployment","monitoring","coordination","communication","maintenance","validation","custom","parallelKeywords","some","keyword","structure","batches","processed","Set","batchIndex","size","batchTasks","every","batch","canRunInParallel","requiredResources","calculateBatchResources","add","memory","cpu","reduce","total","capabilityMatch","calculateCapabilityMatch","performanceScore","getAgentPerformanceScore","workloadScore","workload","mlScore","applyMLHeuristics","requiredCaps","matches","cap","agentHasCapability","capability","caps","codeGeneration","codeReview","webSearch","apiIntegration","fileSystem","terminalAccess","domains","languages","frameworks","agentId","history","average","sum","taskType","detectTaskType","bonus","shift","timeline","currentTime","duration","endTime","resourceUtilization","bottlenecks","optimizationSuggestions","allocations","suitableTasks","estimatedWorkload","keys"],"mappings":"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"}