{"version":3,"sources":["../../../src/swarm/mcp-integration-wrapper.ts"],"sourcesContent":["/**\n * MCP Integration Wrapper for Swarm System\n * \n * This module provides a comprehensive wrapper around MCP tools to enable\n * seamless integration with the swarm orchestration system. It handles\n * tool discovery, execution, error handling, and result aggregation.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { createClaudeFlowTools } from '../mcp/claude-flow-tools.js';\nimport { createRuvSwarmTools } from '../mcp/ruv-swarm-tools.js';\nimport type { MCPTool, MCPContext } from '../utils/types.js';\nimport type { AdvancedSwarmOrchestrator } from './advanced-orchestrator.js';\nimport {\n  SwarmAgent,\n  SwarmTask,\n  TaskResult,\n  SwarmExecutionContext,\n  AgentState,\n  TaskDefinition,\n} from './types.js';\n\nexport interface MCPToolExecutionResult {\n  success: boolean;\n  result?: any;\n  error?: string;\n  duration: number;\n  toolName: string;\n  agentId: string;\n  taskId?: string;\n  metadata: {\n    timestamp: Date;\n    executionId: string;\n    attempts: number;\n    resourcesUsed?: any;\n  };\n}\n\nexport interface MCPToolRegistry {\n  tools: Map<string, MCPTool>;\n  categories: Map<string, string[]>;\n  capabilities: Map<string, string[]>;\n  permissions: Map<string, string[]>;\n}\n\nexport interface MCPExecutionContext extends MCPContext {\n  orchestrator: AdvancedSwarmOrchestrator;\n  agent: SwarmAgent;\n  task?: SwarmTask;\n  swarmId: string;\n  executionId: string;\n  timeout: number;\n  maxRetries: number;\n}\n\nexport interface MCPIntegrationConfig {\n  enableClaudeFlowTools: boolean;\n  enableRuvSwarmTools: boolean;\n  enableCustomTools: boolean;\n  toolTimeout: number;\n  maxRetries: number;\n  enableCaching: boolean;\n  cacheTimeout: number;\n  enableMetrics: boolean;\n  enableLogging: boolean;\n  enableErrorRecovery: boolean;\n  parallelExecution: boolean;\n  maxConcurrentTools: number;\n}\n\nexport class MCPIntegrationWrapper extends EventEmitter {\n  private logger: Logger;\n  private config: MCPIntegrationConfig;\n  private toolRegistry: MCPToolRegistry;\n  private executionCache: Map<string, MCPToolExecutionResult> = new Map();\n  private activeExecutions: Map<string, AbortController> = new Map();\n  private metrics: MCPIntegrationMetrics;\n\n  constructor(config: Partial<MCPIntegrationConfig> = {}) {\n    super();\n    \n    this.logger = new Logger('MCPIntegrationWrapper');\n    this.config = this.createDefaultConfig(config);\n    this.toolRegistry = this.initializeToolRegistry();\n    this.metrics = this.initializeMetrics();\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the MCP integration wrapper\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing MCP integration wrapper...');\n\n    try {\n      // Register Claude Flow tools\n      if (this.config.enableClaudeFlowTools) {\n        await this.registerClaudeFlowTools();\n      }\n\n      // Register ruv-swarm tools\n      if (this.config.enableRuvSwarmTools) {\n        await this.registerRuvSwarmTools();\n      }\n\n      // Start cache cleanup if enabled\n      if (this.config.enableCaching) {\n        this.startCacheCleanup();\n      }\n\n      this.logger.info('MCP integration wrapper initialized successfully', {\n        totalTools: this.toolRegistry.tools.size,\n        categories: this.toolRegistry.categories.size,\n        capabilities: this.toolRegistry.capabilities.size,\n      });\n\n      this.emit('initialized', {\n        toolCount: this.toolRegistry.tools.size,\n        config: this.config,\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to initialize MCP integration wrapper', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the wrapper gracefully\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down MCP integration wrapper...');\n\n    try {\n      // Cancel all active executions\n      for (const [executionId, controller] of this.activeExecutions) {\n        controller.abort();\n        this.logger.debug('Cancelled execution', { executionId });\n      }\n      this.activeExecutions.clear();\n\n      // Clear cache if needed\n      this.executionCache.clear();\n\n      this.logger.info('MCP integration wrapper shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during MCP wrapper shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute an MCP tool within a swarm context\n   */\n  async executeTool(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext\n  ): Promise<MCPToolExecutionResult> {\n    const executionId = generateId('mcp-execution');\n    const startTime = performance.now();\n\n    this.logger.info('Executing MCP tool', {\n      toolName,\n      executionId,\n      agentId: context.agent.id,\n      taskId: context.task?.id,\n      swarmId: context.swarmId,\n    });\n\n    try {\n      // Check if tool exists\n      const tool = this.toolRegistry.tools.get(toolName);\n      if (!tool) {\n        throw new Error(`Tool not found: ${toolName}`);\n      }\n\n      // Check cache if enabled\n      if (this.config.enableCaching) {\n        const cached = await this.getCachedResult(toolName, input, context);\n        if (cached) {\n          this.logger.debug('Using cached result', { toolName, executionId });\n          return cached;\n        }\n      }\n\n      // Create abort controller for timeout\n      const abortController = new AbortController();\n      this.activeExecutions.set(executionId, abortController);\n\n      // Set up timeout\n      const timeoutHandle = setTimeout(() => {\n        abortController.abort();\n      }, context.timeout || this.config.toolTimeout);\n\n      try {\n        // Execute tool with retry logic\n        const result = await this.executeWithRetry(\n          tool,\n          input,\n          context,\n          executionId,\n          abortController.signal\n        );\n\n        clearTimeout(timeoutHandle);\n\n        const duration = performance.now() - startTime;\n        const executionResult: MCPToolExecutionResult = {\n          success: true,\n          result,\n          duration,\n          toolName,\n          agentId: context.agent.id,\n          taskId: context.task?.id,\n          metadata: {\n            timestamp: new Date(),\n            executionId,\n            attempts: 1,\n          },\n        };\n\n        // Cache result if enabled\n        if (this.config.enableCaching) {\n          await this.cacheResult(toolName, input, context, executionResult);\n        }\n\n        // Update metrics\n        this.updateMetrics(executionResult);\n\n        this.logger.info('MCP tool executed successfully', {\n          toolName,\n          executionId,\n          duration,\n        });\n\n        this.emit('tool:executed', executionResult);\n        return executionResult;\n\n      } finally {\n        clearTimeout(timeoutHandle);\n        this.activeExecutions.delete(executionId);\n      }\n\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      const executionResult: MCPToolExecutionResult = {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration,\n        toolName,\n        agentId: context.agent.id,\n        taskId: context.task?.id,\n        metadata: {\n          timestamp: new Date(),\n          executionId,\n          attempts: 1,\n        },\n      };\n\n      this.updateMetrics(executionResult);\n\n      this.logger.error('MCP tool execution failed', {\n        toolName,\n        executionId,\n        error: executionResult.error,\n        duration,\n      });\n\n      this.emit('tool:failed', executionResult);\n      return executionResult;\n    }\n  }\n\n  /**\n   * Execute multiple tools in parallel\n   */\n  async executeToolsParallel(\n    toolExecutions: Array<{\n      toolName: string;\n      input: any;\n      context: MCPExecutionContext;\n    }>\n  ): Promise<MCPToolExecutionResult[]> {\n    if (!this.config.parallelExecution) {\n      // Execute sequentially if parallel execution is disabled\n      const results: MCPToolExecutionResult[] = [];\n      for (const execution of toolExecutions) {\n        const result = await this.executeTool(\n          execution.toolName,\n          execution.input,\n          execution.context\n        );\n        results.push(result);\n      }\n      return results;\n    }\n\n    this.logger.info('Executing tools in parallel', {\n      toolCount: toolExecutions.length,\n      maxConcurrent: this.config.maxConcurrentTools,\n    });\n\n    // Limit concurrent executions\n    const semaphore = new Semaphore(this.config.maxConcurrentTools);\n    \n    const promises = toolExecutions.map(async (execution) => {\n      await semaphore.acquire();\n      try {\n        return await this.executeTool(\n          execution.toolName,\n          execution.input,\n          execution.context\n        );\n      } finally {\n        semaphore.release();\n      }\n    });\n\n    const results = await Promise.allSettled(promises);\n    \n    return results.map((result, index) => {\n      if (result.status === 'fulfilled') {\n        return result.value;\n      } else {\n        // Create error result\n        return {\n          success: false,\n          error: result.reason instanceof Error ? result.reason.message : String(result.reason),\n          duration: 0,\n          toolName: toolExecutions[index].toolName,\n          agentId: toolExecutions[index].context.agent.id,\n          taskId: toolExecutions[index].context.task?.id,\n          metadata: {\n            timestamp: new Date(),\n            executionId: generateId('failed-execution'),\n            attempts: 1,\n          },\n        };\n      }\n    });\n  }\n\n  /**\n   * Get available tools with filtering options\n   */\n  getAvailableTools(options: {\n    category?: string;\n    capability?: string;\n    agent?: SwarmAgent;\n  } = {}): MCPTool[] {\n    let tools = Array.from(this.toolRegistry.tools.values());\n\n    // Filter by category\n    if (options.category) {\n      const categoryTools = this.toolRegistry.categories.get(options.category) || [];\n      tools = tools.filter(tool => categoryTools.includes(tool.name));\n    }\n\n    // Filter by capability\n    if (options.capability) {\n      const capabilityTools = this.toolRegistry.capabilities.get(options.capability) || [];\n      tools = tools.filter(tool => capabilityTools.includes(tool.name));\n    }\n\n    // Filter by agent permissions\n    if (options.agent) {\n      tools = tools.filter(tool => this.hasPermission(tool, options.agent!));\n    }\n\n    return tools;\n  }\n\n  /**\n   * Get tool information\n   */\n  getToolInfo(toolName: string): MCPTool | null {\n    return this.toolRegistry.tools.get(toolName) || null;\n  }\n\n  /**\n   * Get integration metrics\n   */\n  getMetrics(): MCPIntegrationMetrics {\n    return {\n      ...this.metrics,\n      cacheHitRate: this.calculateCacheHitRate(),\n      averageExecutionTime: this.calculateAverageExecutionTime(),\n      toolUsageDistribution: this.calculateToolUsageDistribution(),\n    };\n  }\n\n  /**\n   * Create MCP execution context for swarm operations\n   */\n  createExecutionContext(\n    orchestrator: AdvancedSwarmOrchestrator,\n    agent: SwarmAgent,\n    swarmId: string,\n    task?: SwarmTask\n  ): MCPExecutionContext {\n    return {\n      sessionId: generateId('mcp-session'),\n      orchestrator,\n      agent,\n      task,\n      swarmId,\n      executionId: generateId('mcp-execution'),\n      timeout: this.config.toolTimeout,\n      maxRetries: this.config.maxRetries,\n    };\n  }\n\n  // Private methods\n\n  private async registerClaudeFlowTools(): Promise<void> {\n    this.logger.info('Registering Claude Flow tools...');\n    \n    const claudeFlowTools = createClaudeFlowTools(this.logger);\n    \n    for (const tool of claudeFlowTools) {\n      this.toolRegistry.tools.set(tool.name, tool);\n      \n      // Categorize tool\n      const category = this.categorizeClaudeFlowTool(tool.name);\n      if (!this.toolRegistry.categories.has(category)) {\n        this.toolRegistry.categories.set(category, []);\n      }\n      this.toolRegistry.categories.get(category)!.push(tool.name);\n      \n      // Add capabilities\n      const capabilities = this.extractCapabilities(tool);\n      for (const capability of capabilities) {\n        if (!this.toolRegistry.capabilities.has(capability)) {\n          this.toolRegistry.capabilities.set(capability, []);\n        }\n        this.toolRegistry.capabilities.get(capability)!.push(tool.name);\n      }\n    }\n\n    this.logger.info(`Registered ${claudeFlowTools.length} Claude Flow tools`);\n  }\n\n  private async registerRuvSwarmTools(): Promise<void> {\n    this.logger.info('Registering ruv-swarm tools...');\n    \n    const ruvSwarmTools = createRuvSwarmTools(this.logger);\n    \n    for (const tool of ruvSwarmTools) {\n      this.toolRegistry.tools.set(tool.name, tool);\n      \n      // Categorize tool\n      const category = this.categorizeRuvSwarmTool(tool.name);\n      if (!this.toolRegistry.categories.has(category)) {\n        this.toolRegistry.categories.set(category, []);\n      }\n      this.toolRegistry.categories.get(category)!.push(tool.name);\n      \n      // Add capabilities\n      const capabilities = this.extractCapabilities(tool);\n      for (const capability of capabilities) {\n        if (!this.toolRegistry.capabilities.has(capability)) {\n          this.toolRegistry.capabilities.set(capability, []);\n        }\n        this.toolRegistry.capabilities.get(capability)!.push(tool.name);\n      }\n    }\n\n    this.logger.info(`Registered ${ruvSwarmTools.length} ruv-swarm tools`);\n  }\n\n  private async executeWithRetry(\n    tool: MCPTool,\n    input: any,\n    context: MCPExecutionContext,\n    executionId: string,\n    signal: AbortSignal\n  ): Promise<any> {\n    let lastError: Error | null = null;\n    const maxRetries = context.maxRetries || this.config.maxRetries;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        // Check if execution was aborted\n        if (signal.aborted) {\n          throw new Error('Execution aborted');\n        }\n\n        this.logger.debug('Executing tool attempt', {\n          toolName: tool.name,\n          executionId,\n          attempt,\n          maxRetries,\n        });\n\n        const result = await tool.handler(input, context);\n        \n        if (attempt > 1) {\n          this.logger.info('Tool execution succeeded after retry', {\n            toolName: tool.name,\n            executionId,\n            attempt,\n          });\n        }\n\n        return result;\n\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        \n        this.logger.warn('Tool execution attempt failed', {\n          toolName: tool.name,\n          executionId,\n          attempt,\n          maxRetries,\n          error: lastError.message,\n        });\n\n        // Don't retry on certain errors\n        if (this.isNonRetryableError(lastError)) {\n          break;\n        }\n\n        // Wait before retry (exponential backoff)\n        if (attempt < maxRetries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError || new Error('Tool execution failed after all retries');\n  }\n\n  private isNonRetryableError(error: Error): boolean {\n    const nonRetryablePatterns = [\n      /not found/i,\n      /invalid input/i,\n      /permission denied/i,\n      /unauthorized/i,\n      /forbidden/i,\n    ];\n\n    return nonRetryablePatterns.some(pattern => pattern.test(error.message));\n  }\n\n  private async getCachedResult(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext\n  ): Promise<MCPToolExecutionResult | null> {\n    const cacheKey = this.generateCacheKey(toolName, input, context);\n    const cached = this.executionCache.get(cacheKey);\n    \n    if (cached) {\n      const age = Date.now() - cached.metadata.timestamp.getTime();\n      if (age < this.config.cacheTimeout) {\n        this.metrics.cacheHits++;\n        return cached;\n      } else {\n        // Remove expired entry\n        this.executionCache.delete(cacheKey);\n      }\n    }\n\n    this.metrics.cacheMisses++;\n    return null;\n  }\n\n  private async cacheResult(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext,\n    result: MCPToolExecutionResult\n  ): Promise<void> {\n    const cacheKey = this.generateCacheKey(toolName, input, context);\n    this.executionCache.set(cacheKey, result);\n  }\n\n  private generateCacheKey(\n    toolName: string,\n    input: any,\n    context: MCPExecutionContext\n  ): string {\n    const inputHash = this.hashObject(input);\n    const contextHash = this.hashObject({\n      agentId: context.agent.id,\n      swarmId: context.swarmId,\n      taskId: context.task?.id,\n    });\n    \n    return `${toolName}:${inputHash}:${contextHash}`;\n  }\n\n  private hashObject(obj: any): string {\n    // Simple hash function for caching\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash.toString(36);\n  }\n\n  private hasPermission(tool: MCPTool, agent: SwarmAgent): boolean {\n    // Check if agent has permission to use this tool\n    const toolPermissions = this.toolRegistry.permissions.get(tool.name) || [];\n    \n    // If no specific permissions defined, allow all\n    if (toolPermissions.length === 0) {\n      return true;\n    }\n\n    // Check agent capabilities against tool permissions\n    return agent.capabilities.some(capability => \n      toolPermissions.includes(capability)\n    );\n  }\n\n  private categorizeClaudeFlowTool(toolName: string): string {\n    if (toolName.includes('agents/')) return 'agent-management';\n    if (toolName.includes('tasks/')) return 'task-management';\n    if (toolName.includes('memory/')) return 'memory-management';\n    if (toolName.includes('system/')) return 'system-monitoring';\n    if (toolName.includes('config/')) return 'configuration';\n    if (toolName.includes('workflow/')) return 'workflow-management';\n    if (toolName.includes('terminal/')) return 'terminal-management';\n    return 'general';\n  }\n\n  private categorizeRuvSwarmTool(toolName: string): string {\n    if (toolName.includes('swarm_')) return 'swarm-lifecycle';\n    if (toolName.includes('agent_')) return 'agent-management';\n    if (toolName.includes('task_')) return 'task-orchestration';\n    if (toolName.includes('memory_')) return 'memory-persistence';\n    if (toolName.includes('neural_')) return 'neural-capabilities';\n    if (toolName.includes('benchmark_')) return 'performance-benchmarking';\n    return 'general';\n  }\n\n  private extractCapabilities(tool: MCPTool): string[] {\n    const capabilities: string[] = [];\n    \n    // Extract capabilities from tool name and description\n    const text = `${tool.name} ${tool.description}`.toLowerCase();\n    \n    const capabilityPatterns = [\n      'agent', 'task', 'memory', 'system', 'config', 'workflow',\n      'terminal', 'swarm', 'neural', 'benchmark', 'monitoring',\n      'orchestration', 'coordination', 'analysis', 'research',\n      'development', 'testing', 'documentation', 'optimization',\n    ];\n\n    for (const pattern of capabilityPatterns) {\n      if (text.includes(pattern)) {\n        capabilities.push(pattern);\n      }\n    }\n\n    return capabilities.length > 0 ? capabilities : ['general'];\n  }\n\n  private updateMetrics(result: MCPToolExecutionResult): void {\n    this.metrics.totalExecutions++;\n    \n    if (result.success) {\n      this.metrics.successfulExecutions++;\n    } else {\n      this.metrics.failedExecutions++;\n    }\n\n    this.metrics.totalExecutionTime += result.duration;\n\n    // Update tool-specific metrics\n    if (!this.metrics.toolExecutions.has(result.toolName)) {\n      this.metrics.toolExecutions.set(result.toolName, {\n        count: 0,\n        totalTime: 0,\n        successCount: 0,\n        failureCount: 0,\n      });\n    }\n\n    const toolStats = this.metrics.toolExecutions.get(result.toolName)!;\n    toolStats.count++;\n    toolStats.totalTime += result.duration;\n    \n    if (result.success) {\n      toolStats.successCount++;\n    } else {\n      toolStats.failureCount++;\n    }\n  }\n\n  private calculateCacheHitRate(): number {\n    const total = this.metrics.cacheHits + this.metrics.cacheMisses;\n    return total > 0 ? this.metrics.cacheHits / total : 0;\n  }\n\n  private calculateAverageExecutionTime(): number {\n    return this.metrics.totalExecutions > 0 \n      ? this.metrics.totalExecutionTime / this.metrics.totalExecutions \n      : 0;\n  }\n\n  private calculateToolUsageDistribution(): Record<string, number> {\n    const distribution: Record<string, number> = {};\n    \n    for (const [toolName, stats] of this.metrics.toolExecutions) {\n      distribution[toolName] = stats.count;\n    }\n\n    return distribution;\n  }\n\n  private startCacheCleanup(): void {\n    // Clean up expired cache entries every 5 minutes\n    setInterval(() => {\n      const now = Date.now();\n      const expired: string[] = [];\n\n      for (const [key, result] of this.executionCache) {\n        const age = now - result.metadata.timestamp.getTime();\n        if (age > this.config.cacheTimeout) {\n          expired.push(key);\n        }\n      }\n\n      expired.forEach(key => this.executionCache.delete(key));\n      \n      if (expired.length > 0) {\n        this.logger.debug('Cleaned up expired cache entries', { \n          count: expired.length \n        });\n      }\n    }, 300000); // 5 minutes\n  }\n\n  private initializeToolRegistry(): MCPToolRegistry {\n    return {\n      tools: new Map(),\n      categories: new Map(),\n      capabilities: new Map(),\n      permissions: new Map(),\n    };\n  }\n\n  private initializeMetrics(): MCPIntegrationMetrics {\n    return {\n      totalExecutions: 0,\n      successfulExecutions: 0,\n      failedExecutions: 0,\n      totalExecutionTime: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      toolExecutions: new Map(),\n      cacheHitRate: 0,\n      averageExecutionTime: 0,\n      toolUsageDistribution: {},\n    };\n  }\n\n  private createDefaultConfig(config: Partial<MCPIntegrationConfig>): MCPIntegrationConfig {\n    return {\n      enableClaudeFlowTools: true,\n      enableRuvSwarmTools: true,\n      enableCustomTools: true,\n      toolTimeout: 30000, // 30 seconds\n      maxRetries: 3,\n      enableCaching: true,\n      cacheTimeout: 300000, // 5 minutes\n      enableMetrics: true,\n      enableLogging: true,\n      enableErrorRecovery: true,\n      parallelExecution: true,\n      maxConcurrentTools: 5,\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('tool:executed', (result) => {\n      if (this.config.enableLogging) {\n        this.logger.debug('Tool execution completed', {\n          toolName: result.toolName,\n          success: result.success,\n          duration: result.duration,\n        });\n      }\n    });\n\n    this.on('tool:failed', (result) => {\n      if (this.config.enableLogging) {\n        this.logger.warn('Tool execution failed', {\n          toolName: result.toolName,\n          error: result.error,\n          duration: result.duration,\n        });\n      }\n    });\n  }\n}\n\n// Supporting interfaces and classes\n\ninterface MCPIntegrationMetrics {\n  totalExecutions: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  totalExecutionTime: number;\n  cacheHits: number;\n  cacheMisses: number;\n  toolExecutions: Map<string, {\n    count: number;\n    totalTime: number;\n    successCount: number;\n    failureCount: number;\n  }>;\n  cacheHitRate: number;\n  averageExecutionTime: number;\n  toolUsageDistribution: Record<string, number>;\n}\n\nclass Semaphore {\n  private permits: number;\n  private waitQueue: Array<() => void> = [];\n\n  constructor(permits: number) {\n    this.permits = permits;\n  }\n\n  async acquire(): Promise<void> {\n    if (this.permits > 0) {\n      this.permits--;\n      return Promise.resolve();\n    }\n\n    return new Promise<void>((resolve) => {\n      this.waitQueue.push(resolve);\n    });\n  }\n\n  release(): void {\n    if (this.waitQueue.length > 0) {\n      const resolve = this.waitQueue.shift()!;\n      resolve();\n    } else {\n      this.permits++;\n    }\n  }\n}\n\nexport default MCPIntegrationWrapper;"],"names":["EventEmitter","Logger","generateId","createClaudeFlowTools","createRuvSwarmTools","MCPIntegrationWrapper","logger","config","toolRegistry","executionCache","Map","activeExecutions","metrics","createDefaultConfig","initializeToolRegistry","initializeMetrics","setupEventHandlers","initialize","info","enableClaudeFlowTools","registerClaudeFlowTools","enableRuvSwarmTools","registerRuvSwarmTools","enableCaching","startCacheCleanup","totalTools","tools","size","categories","capabilities","emit","toolCount","error","shutdown","executionId","controller","abort","debug","clear","executeTool","toolName","input","context","startTime","performance","now","agentId","agent","id","taskId","task","swarmId","tool","get","Error","cached","getCachedResult","abortController","AbortController","set","timeoutHandle","setTimeout","timeout","toolTimeout","result","executeWithRetry","signal","clearTimeout","duration","executionResult","success","metadata","timestamp","Date","attempts","cacheResult","updateMetrics","delete","message","String","executeToolsParallel","toolExecutions","parallelExecution","results","execution","push","length","maxConcurrent","maxConcurrentTools","semaphore","Semaphore","promises","map","acquire","release","Promise","allSettled","index","status","value","reason","getAvailableTools","options","Array","from","values","category","categoryTools","filter","includes","name","capability","capabilityTools","hasPermission","getToolInfo","getMetrics","cacheHitRate","calculateCacheHitRate","averageExecutionTime","calculateAverageExecutionTime","toolUsageDistribution","calculateToolUsageDistribution","createExecutionContext","orchestrator","sessionId","maxRetries","claudeFlowTools","categorizeClaudeFlowTool","has","extractCapabilities","ruvSwarmTools","categorizeRuvSwarmTool","lastError","attempt","aborted","handler","warn","isNonRetryableError","delay","Math","min","pow","resolve","nonRetryablePatterns","some","pattern","test","cacheKey","generateCacheKey","age","getTime","cacheTimeout","cacheHits","cacheMisses","inputHash","hashObject","contextHash","obj","str","JSON","stringify","Object","keys","sort","hash","i","char","charCodeAt","toString","toolPermissions","permissions","text","description","toLowerCase","capabilityPatterns","totalExecutions","successfulExecutions","failedExecutions","totalExecutionTime","count","totalTime","successCount","failureCount","toolStats","total","distribution","stats","setInterval","expired","key","forEach","enableCustomTools","enableMetrics","enableLogging","enableErrorRecovery","on","permits","waitQueue","shift"],"mappings":"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"}