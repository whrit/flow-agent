{"version":3,"sources":["../../../src/swarm/prompt-utils.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { logger } from '../core/logger.js';\n\nexport interface PromptConfig {\n  sourceDirectories: string[];\n  destinationDirectory: string;\n  defaultOptions: {\n    backup: boolean;\n    verify: boolean;\n    parallel: boolean;\n    maxWorkers: number;\n    conflictResolution: 'skip' | 'overwrite' | 'backup' | 'merge';\n    includePatterns: string[];\n    excludePatterns: string[];\n  };\n  profiles: Record<string, Partial<PromptConfig['defaultOptions']>>;\n}\n\nexport const DEFAULT_CONFIG: PromptConfig = {\n  sourceDirectories: ['.roo', '.claude/commands', 'src/templates', 'templates'],\n  destinationDirectory: './project-prompts',\n  defaultOptions: {\n    backup: true,\n    verify: true,\n    parallel: true,\n    maxWorkers: 4,\n    conflictResolution: 'backup',\n    includePatterns: ['*.md', '*.txt', '*.prompt', '*.prompts', '*.json'],\n    excludePatterns: ['**/node_modules/**', '**/.git/**', '**/dist/**', '**/build/**'],\n  },\n  profiles: {\n    sparc: {\n      includePatterns: ['*.md', 'rules.md', 'sparc-*.md'],\n      excludePatterns: ['**/README.md', '**/CHANGELOG.md'],\n    },\n    templates: {\n      includePatterns: ['*.template', '*.tmpl', '*.hbs', '*.mustache'],\n      conflictResolution: 'merge',\n    },\n    safe: {\n      backup: true,\n      verify: true,\n      conflictResolution: 'skip',\n      parallel: false,\n    },\n    fast: {\n      backup: false,\n      verify: false,\n      parallel: true,\n      maxWorkers: 8,\n      conflictResolution: 'overwrite',\n    },\n  },\n};\n\nexport class PromptConfigManager {\n  private configPath: string;\n  private config: PromptConfig;\n\n  constructor(configPath?: string) {\n    this.configPath = configPath || path.join(process.cwd(), '.prompt-config.json');\n    this.config = { ...DEFAULT_CONFIG };\n  }\n\n  async loadConfig(): Promise<PromptConfig> {\n    try {\n      const configData = await fs.readFile(this.configPath, 'utf-8');\n      const userConfig = JSON.parse(configData) as Partial<PromptConfig>;\n\n      // Merge with defaults\n      this.config = this.mergeConfig(DEFAULT_CONFIG, userConfig);\n      logger.info(`Loaded config from ${this.configPath}`);\n    } catch (error) {\n      logger.info('Using default configuration');\n    }\n\n    return this.config;\n  }\n\n  async saveConfig(config?: Partial<PromptConfig>): Promise<void> {\n    if (config) {\n      this.config = this.mergeConfig(this.config, config);\n    }\n\n    await fs.writeFile(this.configPath, JSON.stringify(this.config, null, 2));\n    logger.info(`Saved config to ${this.configPath}`);\n  }\n\n  getConfig(): PromptConfig {\n    return this.config;\n  }\n\n  getProfile(profileName: string): PromptConfig['defaultOptions'] {\n    const profile = this.config.profiles[profileName];\n    if (!profile) {\n      throw new Error(`Profile '${profileName}' not found`);\n    }\n\n    return { ...this.config.defaultOptions, ...profile };\n  }\n\n  listProfiles(): string[] {\n    return Object.keys(this.config.profiles);\n  }\n\n  private mergeConfig(base: PromptConfig, override: Partial<PromptConfig>): PromptConfig {\n    return {\n      ...base,\n      ...override,\n      defaultOptions: {\n        ...base.defaultOptions,\n        ...override.defaultOptions,\n      },\n      profiles: {\n        ...base.profiles,\n        ...override.profiles,\n      },\n    };\n  }\n}\n\nexport class PromptPathResolver {\n  private basePath: string;\n\n  constructor(basePath: string = process.cwd()) {\n    this.basePath = basePath;\n  }\n\n  resolvePaths(\n    sourceDirectories: string[],\n    destinationDirectory: string,\n  ): {\n    sources: string[];\n    destination: string;\n  } {\n    const sources = sourceDirectories\n      .map((dir) => path.resolve(this.basePath, dir))\n      .filter((dir) => this.directoryExists(dir));\n\n    const destination = path.resolve(this.basePath, destinationDirectory);\n\n    return { sources, destination };\n  }\n\n  private directoryExists(dirPath: string): boolean {\n    try {\n      const stats = require('fs').statSync(dirPath);\n      return stats.isDirectory();\n    } catch {\n      return false;\n    }\n  }\n\n  // Discover prompt directories automatically\n  async discoverPromptDirectories(): Promise<string[]> {\n    const candidates = [\n      '.roo',\n      '.claude',\n      'prompts',\n      'templates',\n      'src/prompts',\n      'src/templates',\n      'docs/prompts',\n      'scripts/prompts',\n    ];\n\n    const discovered: string[] = [];\n\n    for (const candidate of candidates) {\n      const fullPath = path.resolve(this.basePath, candidate);\n      if (await this.containsPromptFiles(fullPath)) {\n        discovered.push(fullPath);\n      }\n    }\n\n    return discovered;\n  }\n\n  private async containsPromptFiles(dirPath: string): Promise<boolean> {\n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n      for (const entry of entries) {\n        if (entry.isFile()) {\n          const fileName = entry.name.toLowerCase();\n          if (\n            fileName.endsWith('.md') ||\n            fileName.endsWith('.txt') ||\n            fileName.endsWith('.prompt') ||\n            fileName.includes('prompt') ||\n            fileName.includes('template')\n          ) {\n            return true;\n          }\n        } else if (entry.isDirectory()) {\n          const subPath = path.join(dirPath, entry.name);\n          if (await this.containsPromptFiles(subPath)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport class PromptValidator {\n  static async validatePromptFile(filePath: string): Promise<{\n    valid: boolean;\n    issues: string[];\n    metadata?: any;\n  }> {\n    const issues: string[] = [];\n    let metadata: any = {};\n\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n\n      // Check for empty files\n      if (content.trim().length === 0) {\n        issues.push('File is empty');\n      }\n\n      // Check for common prompt markers\n      const hasPromptMarkers = [\n        '# ',\n        '## ',\n        '### ', // Markdown headers\n        'You are',\n        'Your task',\n        'Please', // Common prompt starters\n        '```',\n        '`', // Code blocks\n        '{{',\n        '}}', // Template variables\n      ].some((marker) => content.includes(marker));\n\n      if (!hasPromptMarkers) {\n        issues.push('File may not contain valid prompt content');\n      }\n\n      // Extract metadata from front matter\n      const frontMatterMatch = content.match(/^---\\n([\\s\\S]*?\\n)---/);\n      if (frontMatterMatch) {\n        try {\n          metadata = this.parseFrontMatter(frontMatterMatch[1]);\n        } catch (error) {\n          issues.push('Invalid front matter format');\n        }\n      }\n\n      // Check file size (warn if too large)\n      const stats = await fs.stat(filePath);\n      if (stats.size > 100 * 1024) {\n        // 100KB\n        issues.push('File is unusually large for a prompt');\n      }\n\n      return {\n        valid: issues.length === 0,\n        issues,\n        metadata,\n      };\n    } catch (error) {\n      return {\n        valid: false,\n        issues: [`Failed to read file: ${error instanceof Error ? error.message : String(error)}`],\n      };\n    }\n  }\n\n  private static parseFrontMatter(frontMatter: string): any {\n    // Simple YAML-like parser for basic key-value pairs\n    const metadata: any = {};\n    const lines = frontMatter.split('\\n');\n\n    for (const line of lines) {\n      const match = line.match(/^(\\w+):\\s*(.+)$/);\n      if (match) {\n        const [, key, value] = match;\n        metadata[key] = value.trim();\n      }\n    }\n\n    return metadata;\n  }\n}\n\nexport function createProgressBar(total: number): {\n  update: (current: number) => void;\n  complete: () => void;\n} {\n  const barLength = 40;\n\n  return {\n    update: (current: number) => {\n      const percentage = Math.round((current / total) * 100);\n      const filledLength = Math.round((current / total) * barLength);\n      const bar = '█'.repeat(filledLength) + '░'.repeat(barLength - filledLength);\n\n      process.stdout.write(`\\r[${bar}] ${percentage}% (${current}/${total})`);\n    },\n\n    complete: () => {\n      process.stdout.write('\\n');\n    },\n  };\n}\n\n// Utility function to format file sizes\nexport function formatFileSize(bytes: number): string {\n  const units = ['B', 'KB', 'MB', 'GB'];\n  let size = bytes;\n  let unitIndex = 0;\n\n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n\n  return `${size.toFixed(1)} ${units[unitIndex]}`;\n}\n\n// Utility function to format duration\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) return `${ms}ms`;\n  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;\n  return `${Math.floor(ms / 60000)}m ${Math.floor((ms % 60000) / 1000)}s`;\n}\n"],"names":["fs","path","logger","DEFAULT_CONFIG","sourceDirectories","destinationDirectory","defaultOptions","backup","verify","parallel","maxWorkers","conflictResolution","includePatterns","excludePatterns","profiles","sparc","templates","safe","fast","PromptConfigManager","configPath","config","join","process","cwd","loadConfig","configData","readFile","userConfig","JSON","parse","mergeConfig","info","error","saveConfig","writeFile","stringify","getConfig","getProfile","profileName","profile","Error","listProfiles","Object","keys","base","override","PromptPathResolver","basePath","resolvePaths","sources","map","dir","resolve","filter","directoryExists","destination","dirPath","stats","require","statSync","isDirectory","discoverPromptDirectories","candidates","discovered","candidate","fullPath","containsPromptFiles","push","entries","readdir","withFileTypes","entry","isFile","fileName","name","toLowerCase","endsWith","includes","subPath","PromptValidator","validatePromptFile","filePath","issues","metadata","content","trim","length","hasPromptMarkers","some","marker","frontMatterMatch","match","parseFrontMatter","stat","size","valid","message","String","frontMatter","lines","split","line","key","value","createProgressBar","total","barLength","update","current","percentage","Math","round","filledLength","bar","repeat","stdout","write","complete","formatFileSize","bytes","units","unitIndex","toFixed","formatDuration","ms","floor"],"mappings":"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"}