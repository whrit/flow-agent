{"version":3,"sources":["../../../src/swarm/hive-mind-integration.ts"],"sourcesContent":["/**\n * Hive-Mind System Integration Interface\n * \n * This module provides seamless integration with the existing hive-mind system,\n * enabling swarms to leverage collective intelligence, shared memory, and\n * distributed coordination capabilities while maintaining compatibility\n * with the current claude-flow architecture.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { MemoryManager } from '../memory/manager.js';\nimport type { AdvancedSwarmOrchestrator } from './advanced-orchestrator.js';\nimport {\n  SwarmExecutionContext,\n  SwarmAgent,\n  SwarmTask,\n  TaskResult,\n  SwarmObjective,\n  AgentState,\n  SwarmMetrics,\n} from './types.js';\n\nexport interface HiveMindConfig {\n  enableSharedIntelligence: boolean;\n  enableCollectiveMemory: boolean;\n  enableDistributedLearning: boolean;\n  enableKnowledgeSharing: boolean;\n  hiveMindEndpoint?: string;\n  syncInterval: number;\n  maxSharedMemorySize: number;\n  intelligencePoolSize: number;\n  learningRate: number;\n  knowledgeRetentionPeriod: number;\n}\n\nexport interface HiveMindSession {\n  id: string;\n  swarmId: string;\n  participants: string[];\n  sharedMemory: Map<string, any>;\n  collectiveIntelligence: CollectiveIntelligence;\n  knowledgeBase: KnowledgeBase;\n  distributedLearning: DistributedLearning;\n  status: 'active' | 'paused' | 'terminated';\n  startTime: Date;\n  lastSync: Date;\n}\n\nexport interface CollectiveIntelligence {\n  patterns: Map<string, Pattern>;\n  insights: Map<string, Insight>;\n  decisions: Map<string, CollectiveDecision>;\n  predictions: Map<string, Prediction>;\n}\n\nexport interface Pattern {\n  id: string;\n  type: 'behavioral' | 'performance' | 'error' | 'success';\n  description: string;\n  frequency: number;\n  confidence: number;\n  contexts: string[];\n  impact: 'low' | 'medium' | 'high';\n  discoveredBy: string[];\n  lastSeen: Date;\n}\n\nexport interface Insight {\n  id: string;\n  category: 'optimization' | 'coordination' | 'quality' | 'efficiency';\n  title: string;\n  description: string;\n  evidence: any[];\n  confidence: number;\n  applicability: string[];\n  contributingAgents: string[];\n  timestamp: Date;\n}\n\nexport interface CollectiveDecision {\n  id: string;\n  question: string;\n  options: DecisionOption[];\n  votingResults: Map<string, string>;\n  consensus: string;\n  confidence: number;\n  reasoning: string;\n  participants: string[];\n  timestamp: Date;\n}\n\nexport interface DecisionOption {\n  id: string;\n  description: string;\n  pros: string[];\n  cons: string[];\n  risk: 'low' | 'medium' | 'high';\n  effort: 'low' | 'medium' | 'high';\n  expectedOutcome: string;\n}\n\nexport interface Prediction {\n  id: string;\n  target: string;\n  predicted_value: any;\n  confidence: number;\n  timeframe: string;\n  methodology: string;\n  factors: string[];\n  accuracy?: number;\n  createdBy: string[];\n  timestamp: Date;\n}\n\nexport interface KnowledgeBase {\n  facts: Map<string, Fact>;\n  procedures: Map<string, Procedure>;\n  bestPractices: Map<string, BestPractice>;\n  lessons: Map<string, Lesson>;\n}\n\nexport interface Fact {\n  id: string;\n  statement: string;\n  category: string;\n  confidence: number;\n  sources: string[];\n  validatedBy: string[];\n  contexts: string[];\n  timestamp: Date;\n}\n\nexport interface Procedure {\n  id: string;\n  name: string;\n  description: string;\n  steps: ProcedureStep[];\n  preconditions: string[];\n  postconditions: string[];\n  successRate: number;\n  contexts: string[];\n  lastUsed: Date;\n}\n\nexport interface ProcedureStep {\n  order: number;\n  action: string;\n  parameters: Record<string, any>;\n  expectedResult: string;\n  alternatives: string[];\n}\n\nexport interface BestPractice {\n  id: string;\n  domain: string;\n  practice: string;\n  rationale: string;\n  benefits: string[];\n  applicableContexts: string[];\n  effectiveness: number;\n  adoptionRate: number;\n  validatedBy: string[];\n  timestamp: Date;\n}\n\nexport interface Lesson {\n  id: string;\n  title: string;\n  situation: string;\n  actions: string[];\n  outcome: string;\n  learning: string;\n  applicability: string[];\n  importance: 'low' | 'medium' | 'high' | 'critical';\n  learnedBy: string[];\n  timestamp: Date;\n}\n\nexport interface DistributedLearning {\n  models: Map<string, LearningModel>;\n  experiences: Map<string, Experience>;\n  adaptations: Map<string, Adaptation>;\n  performance: PerformanceTrends;\n}\n\nexport interface LearningModel {\n  id: string;\n  type: 'neural' | 'statistical' | 'heuristic' | 'ensemble';\n  purpose: string;\n  parameters: Record<string, any>;\n  performance: ModelPerformance;\n  trainingData: string[];\n  lastUpdated: Date;\n  version: string;\n}\n\nexport interface ModelPerformance {\n  accuracy: number;\n  precision: number;\n  recall: number;\n  f1Score: number;\n  validationResults: any[];\n  benchmarkResults: any[];\n}\n\nexport interface Experience {\n  id: string;\n  context: string;\n  situation: string;\n  actions: string[];\n  results: any[];\n  feedback: number;\n  tags: string[];\n  agentId: string;\n  timestamp: Date;\n}\n\nexport interface Adaptation {\n  id: string;\n  trigger: string;\n  change: string;\n  reason: string;\n  effectiveness: number;\n  rollbackPlan: string;\n  approvedBy: string[];\n  implementedAt: Date;\n}\n\nexport interface PerformanceTrends {\n  metrics: Map<string, number[]>;\n  improvements: string[];\n  degradations: string[];\n  stability: number;\n  trends: TrendAnalysis[];\n}\n\nexport interface TrendAnalysis {\n  metric: string;\n  direction: 'increasing' | 'decreasing' | 'stable' | 'volatile';\n  magnitude: number;\n  confidence: number;\n  timeframe: string;\n  factors: string[];\n}\n\nexport class HiveMindIntegration extends EventEmitter {\n  private logger: Logger;\n  private config: HiveMindConfig;\n  private memoryManager: MemoryManager;\n  private activeSessions: Map<string, HiveMindSession> = new Map();\n  private globalKnowledgeBase: KnowledgeBase;\n  private globalIntelligence: CollectiveIntelligence;\n  private syncInterval?: NodeJS.Timeout;\n  private isInitialized: boolean = false;\n\n  constructor(\n    config: Partial<HiveMindConfig> = {},\n    memoryManager: MemoryManager\n  ) {\n    super();\n    \n    this.logger = new Logger('HiveMindIntegration');\n    this.config = this.createDefaultConfig(config);\n    this.memoryManager = memoryManager;\n    this.globalKnowledgeBase = this.initializeKnowledgeBase();\n    this.globalIntelligence = this.initializeCollectiveIntelligence();\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the hive-mind integration\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      this.logger.warn('Hive-mind integration already initialized');\n      return;\n    }\n\n    this.logger.info('Initializing hive-mind integration...');\n\n    try {\n      // Load existing knowledge base from memory\n      await this.loadKnowledgeBase();\n\n      // Load collective intelligence data\n      await this.loadCollectiveIntelligence();\n\n      // Start synchronization if enabled\n      if (this.config.syncInterval > 0) {\n        this.startPeriodicSync();\n      }\n\n      this.isInitialized = true;\n      this.logger.info('Hive-mind integration initialized successfully');\n      this.emit('initialized');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize hive-mind integration', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the integration gracefully\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n\n    this.logger.info('Shutting down hive-mind integration...');\n\n    try {\n      // Stop synchronization\n      if (this.syncInterval) {\n        clearInterval(this.syncInterval);\n      }\n\n      // Save current state\n      await this.saveKnowledgeBase();\n      await this.saveCollectiveIntelligence();\n\n      // Terminate active sessions\n      const terminationPromises = Array.from(this.activeSessions.keys())\n        .map(sessionId => this.terminateSession(sessionId));\n      \n      await Promise.allSettled(terminationPromises);\n\n      this.isInitialized = false;\n      this.logger.info('Hive-mind integration shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during hive-mind integration shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new hive-mind session for a swarm\n   */\n  async createSession(\n    swarmId: string,\n    orchestrator: AdvancedSwarmOrchestrator\n  ): Promise<string> {\n    const sessionId = generateId('hive-session');\n    \n    this.logger.info('Creating hive-mind session', {\n      sessionId,\n      swarmId,\n    });\n\n    const session: HiveMindSession = {\n      id: sessionId,\n      swarmId,\n      participants: [],\n      sharedMemory: new Map(),\n      collectiveIntelligence: this.initializeCollectiveIntelligence(),\n      knowledgeBase: this.initializeKnowledgeBase(),\n      distributedLearning: this.initializeDistributedLearning(),\n      status: 'active',\n      startTime: new Date(),\n      lastSync: new Date(),\n    };\n\n    this.activeSessions.set(sessionId, session);\n\n    // Initialize session with global knowledge\n    await this.initializeSessionWithGlobalKnowledge(session);\n\n    this.emit('session:created', {\n      sessionId,\n      swarmId,\n    });\n\n    return sessionId;\n  }\n\n  /**\n   * Add an agent to a hive-mind session\n   */\n  async addAgentToSession(\n    sessionId: string,\n    agentId: string,\n    agent: SwarmAgent\n  ): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    if (!session.participants.includes(agentId)) {\n      session.participants.push(agentId);\n      \n      this.logger.info('Agent added to hive-mind session', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n\n      // Share relevant knowledge with the agent\n      await this.shareKnowledgeWithAgent(session, agentId, agent);\n\n      this.emit('agent:joined', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n    }\n  }\n\n  /**\n   * Remove an agent from a hive-mind session\n   */\n  async removeAgentFromSession(\n    sessionId: string,\n    agentId: string\n  ): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    const index = session.participants.indexOf(agentId);\n    if (index !== -1) {\n      session.participants.splice(index, 1);\n      \n      this.logger.info('Agent removed from hive-mind session', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n\n      this.emit('agent:left', {\n        sessionId,\n        agentId,\n        participantCount: session.participants.length,\n      });\n    }\n  }\n\n  /**\n   * Share knowledge or experience with the hive-mind\n   */\n  async shareWithHive(\n    sessionId: string,\n    agentId: string,\n    type: 'knowledge' | 'experience' | 'insight' | 'pattern',\n    data: any\n  ): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    this.logger.debug('Sharing with hive-mind', {\n      sessionId,\n      agentId,\n      type,\n    });\n\n    switch (type) {\n      case 'knowledge':\n        await this.addKnowledge(session, agentId, data);\n        break;\n      case 'experience':\n        await this.addExperience(session, agentId, data);\n        break;\n      case 'insight':\n        await this.addInsight(session, agentId, data);\n        break;\n      case 'pattern':\n        await this.addPattern(session, agentId, data);\n        break;\n    }\n\n    this.emit('knowledge:shared', {\n      sessionId,\n      agentId,\n      type,\n    });\n  }\n\n  /**\n   * Request collective decision making\n   */\n  async requestCollectiveDecision(\n    sessionId: string,\n    question: string,\n    options: DecisionOption[],\n    requesterAgentId: string\n  ): Promise<string> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    const decisionId = generateId('decision');\n    \n    this.logger.info('Requesting collective decision', {\n      sessionId,\n      decisionId,\n      question,\n      optionCount: options.length,\n      requesterAgentId,\n    });\n\n    const decision: CollectiveDecision = {\n      id: decisionId,\n      question,\n      options,\n      votingResults: new Map(),\n      consensus: '',\n      confidence: 0,\n      reasoning: '',\n      participants: [...session.participants],\n      timestamp: new Date(),\n    };\n\n    session.collectiveIntelligence.decisions.set(decisionId, decision);\n\n    // Initiate voting process\n    await this.initiateVoting(session, decision);\n\n    this.emit('decision:requested', {\n      sessionId,\n      decisionId,\n      question,\n    });\n\n    return decisionId;\n  }\n\n  /**\n   * Get collective decision result\n   */\n  getCollectiveDecision(sessionId: string, decisionId: string): CollectiveDecision | null {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return null;\n\n    return session.collectiveIntelligence.decisions.get(decisionId) || null;\n  }\n\n  /**\n   * Query the hive-mind knowledge base\n   */\n  async queryKnowledge(\n    sessionId: string,\n    query: {\n      type: 'fact' | 'procedure' | 'bestPractice' | 'lesson';\n      keywords?: string[];\n      context?: string;\n      category?: string;\n    }\n  ): Promise<any[]> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Hive-mind session not found: ${sessionId}`);\n    }\n\n    this.logger.debug('Querying hive-mind knowledge', {\n      sessionId,\n      query,\n    });\n\n    let results: any[] = [];\n\n    switch (query.type) {\n      case 'fact':\n        results = this.queryFacts(session, query);\n        break;\n      case 'procedure':\n        results = this.queryProcedures(session, query);\n        break;\n      case 'bestPractice':\n        results = this.queryBestPractices(session, query);\n        break;\n      case 'lesson':\n        results = this.queryLessons(session, query);\n        break;\n    }\n\n    this.emit('knowledge:queried', {\n      sessionId,\n      query,\n      resultCount: results.length,\n    });\n\n    return results;\n  }\n\n  /**\n   * Get collective insights for a swarm\n   */\n  getCollectiveInsights(sessionId: string): Insight[] {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return [];\n\n    return Array.from(session.collectiveIntelligence.insights.values());\n  }\n\n  /**\n   * Get identified patterns\n   */\n  getIdentifiedPatterns(sessionId: string): Pattern[] {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return [];\n\n    return Array.from(session.collectiveIntelligence.patterns.values());\n  }\n\n  /**\n   * Get performance predictions\n   */\n  getPerformancePredictions(sessionId: string): Prediction[] {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return [];\n\n    return Array.from(session.collectiveIntelligence.predictions.values());\n  }\n\n  /**\n   * Terminate a hive-mind session\n   */\n  async terminateSession(sessionId: string): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) return;\n\n    this.logger.info('Terminating hive-mind session', {\n      sessionId,\n      participantCount: session.participants.length,\n      duration: Date.now() - session.startTime.getTime(),\n    });\n\n    // Save session knowledge to global knowledge base\n    await this.consolidateSessionKnowledge(session);\n\n    // Update status and cleanup\n    session.status = 'terminated';\n    this.activeSessions.delete(sessionId);\n\n    this.emit('session:terminated', {\n      sessionId,\n      duration: Date.now() - session.startTime.getTime(),\n    });\n  }\n\n  /**\n   * Get hive-mind session status\n   */\n  getSessionStatus(sessionId: string): HiveMindSession | null {\n    return this.activeSessions.get(sessionId) || null;\n  }\n\n  /**\n   * Get integration metrics\n   */\n  getIntegrationMetrics(): {\n    activeSessions: number;\n    totalParticipants: number;\n    knowledgeItems: number;\n    insights: number;\n    patterns: number;\n    decisions: number;\n    predictions: number;\n    learningModels: number;\n  } {\n    const sessions = Array.from(this.activeSessions.values());\n    \n    return {\n      activeSessions: sessions.length,\n      totalParticipants: sessions.reduce((sum, s) => sum + s.participants.length, 0),\n      knowledgeItems: this.countKnowledgeItems(),\n      insights: this.globalIntelligence.insights.size,\n      patterns: this.globalIntelligence.patterns.size,\n      decisions: this.globalIntelligence.decisions.size,\n      predictions: this.globalIntelligence.predictions.size,\n      learningModels: sessions.reduce((sum, s) => sum + s.distributedLearning.models.size, 0),\n    };\n  }\n\n  // Private methods\n\n  private async loadKnowledgeBase(): Promise<void> {\n    try {\n      const knowledgeEntries = await this.memoryManager.retrieve({\n        namespace: 'hive-mind-knowledge',\n        type: 'knowledge-base',\n      });\n\n      for (const entry of knowledgeEntries) {\n        const data = JSON.parse(entry.content);\n        // Load facts, procedures, best practices, and lessons\n        this.loadKnowledgeData(data);\n      }\n\n      this.logger.debug('Knowledge base loaded', {\n        factsCount: this.globalKnowledgeBase.facts.size,\n        proceduresCount: this.globalKnowledgeBase.procedures.size,\n        bestPracticesCount: this.globalKnowledgeBase.bestPractices.size,\n        lessonsCount: this.globalKnowledgeBase.lessons.size,\n      });\n\n    } catch (error) {\n      this.logger.warn('Failed to load knowledge base, starting fresh', error);\n    }\n  }\n\n  private async loadCollectiveIntelligence(): Promise<void> {\n    try {\n      const intelligenceEntries = await this.memoryManager.retrieve({\n        namespace: 'hive-mind-intelligence',\n        type: 'collective-intelligence',\n      });\n\n      for (const entry of intelligenceEntries) {\n        const data = JSON.parse(entry.content);\n        this.loadIntelligenceData(data);\n      }\n\n      this.logger.debug('Collective intelligence loaded', {\n        patternsCount: this.globalIntelligence.patterns.size,\n        insightsCount: this.globalIntelligence.insights.size,\n        decisionsCount: this.globalIntelligence.decisions.size,\n        predictionsCount: this.globalIntelligence.predictions.size,\n      });\n\n    } catch (error) {\n      this.logger.warn('Failed to load collective intelligence, starting fresh', error);\n    }\n  }\n\n  private async saveKnowledgeBase(): Promise<void> {\n    try {\n      const knowledgeData = {\n        facts: Array.from(this.globalKnowledgeBase.facts.entries()),\n        procedures: Array.from(this.globalKnowledgeBase.procedures.entries()),\n        bestPractices: Array.from(this.globalKnowledgeBase.bestPractices.entries()),\n        lessons: Array.from(this.globalKnowledgeBase.lessons.entries()),\n      };\n\n      await this.memoryManager.store({\n        id: `knowledge-base-${Date.now()}`,\n        agentId: 'hive-mind-integration',\n        type: 'knowledge-base',\n        content: JSON.stringify(knowledgeData),\n        namespace: 'hive-mind-knowledge',\n        timestamp: new Date(),\n        metadata: {\n          type: 'knowledge-base-snapshot',\n          itemCount: this.countKnowledgeItems(),\n        },\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to save knowledge base', error);\n    }\n  }\n\n  private async saveCollectiveIntelligence(): Promise<void> {\n    try {\n      const intelligenceData = {\n        patterns: Array.from(this.globalIntelligence.patterns.entries()),\n        insights: Array.from(this.globalIntelligence.insights.entries()),\n        decisions: Array.from(this.globalIntelligence.decisions.entries()),\n        predictions: Array.from(this.globalIntelligence.predictions.entries()),\n      };\n\n      await this.memoryManager.store({\n        id: `collective-intelligence-${Date.now()}`,\n        agentId: 'hive-mind-integration',\n        type: 'collective-intelligence',\n        content: JSON.stringify(intelligenceData),\n        namespace: 'hive-mind-intelligence',\n        timestamp: new Date(),\n        metadata: {\n          type: 'intelligence-snapshot',\n          itemCount: this.globalIntelligence.patterns.size + \n                     this.globalIntelligence.insights.size +\n                     this.globalIntelligence.decisions.size +\n                     this.globalIntelligence.predictions.size,\n        },\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to save collective intelligence', error);\n    }\n  }\n\n  private startPeriodicSync(): void {\n    this.syncInterval = setInterval(async () => {\n      try {\n        await this.performPeriodicSync();\n      } catch (error) {\n        this.logger.error('Error during periodic sync', error);\n      }\n    }, this.config.syncInterval);\n  }\n\n  private async performPeriodicSync(): Promise<void> {\n    // Sync with external hive-mind endpoint if configured\n    if (this.config.hiveMindEndpoint) {\n      // Implementation would sync with external system\n      this.logger.debug('Performing external hive-mind sync');\n    }\n\n    // Update session knowledge bases\n    for (const session of this.activeSessions.values()) {\n      await this.syncSessionKnowledge(session);\n      session.lastSync = new Date();\n    }\n\n    this.emit('sync:completed', {\n      sessionsSynced: this.activeSessions.size,\n      timestamp: new Date(),\n    });\n  }\n\n  private async initializeSessionWithGlobalKnowledge(session: HiveMindSession): Promise<void> {\n    // Copy relevant global knowledge to session\n    for (const [id, fact] of this.globalKnowledgeBase.facts) {\n      session.knowledgeBase.facts.set(id, fact);\n    }\n\n    for (const [id, insight] of this.globalIntelligence.insights) {\n      session.collectiveIntelligence.insights.set(id, insight);\n    }\n\n    for (const [id, pattern] of this.globalIntelligence.patterns) {\n      session.collectiveIntelligence.patterns.set(id, pattern);\n    }\n  }\n\n  private async shareKnowledgeWithAgent(\n    session: HiveMindSession,\n    agentId: string,\n    agent: SwarmAgent\n  ): Promise<void> {\n    // Share relevant knowledge based on agent capabilities\n    const relevantKnowledge = this.getRelevantKnowledge(session, agent.capabilities);\n    \n    this.logger.debug('Sharing knowledge with agent', {\n      sessionId: session.id,\n      agentId,\n      knowledgeItems: relevantKnowledge.length,\n    });\n\n    // Implementation would send knowledge to agent through MCP tools\n  }\n\n  private getRelevantKnowledge(session: HiveMindSession, capabilities: string[]): any[] {\n    const relevantItems: any[] = [];\n\n    // Filter facts by capabilities\n    for (const fact of session.knowledgeBase.facts.values()) {\n      if (capabilities.some(cap => fact.category.includes(cap))) {\n        relevantItems.push(fact);\n      }\n    }\n\n    // Filter procedures by capabilities\n    for (const procedure of session.knowledgeBase.procedures.values()) {\n      if (capabilities.some(cap => procedure.contexts.includes(cap))) {\n        relevantItems.push(procedure);\n      }\n    }\n\n    return relevantItems;\n  }\n\n  private async addKnowledge(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    // Add new knowledge item to session\n    if (data.type === 'fact') {\n      const fact: Fact = {\n        id: generateId('fact'),\n        statement: data.statement,\n        category: data.category || 'general',\n        confidence: data.confidence || 0.8,\n        sources: [agentId],\n        validatedBy: [agentId],\n        contexts: data.contexts || [],\n        timestamp: new Date(),\n      };\n      \n      session.knowledgeBase.facts.set(fact.id, fact);\n    }\n    // Similar implementations for procedures, best practices, and lessons\n  }\n\n  private async addExperience(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    const experience: Experience = {\n      id: generateId('experience'),\n      context: data.context || 'general',\n      situation: data.situation,\n      actions: data.actions || [],\n      results: data.results || [],\n      feedback: data.feedback || 0,\n      tags: data.tags || [],\n      agentId,\n      timestamp: new Date(),\n    };\n\n    session.distributedLearning.experiences.set(experience.id, experience);\n  }\n\n  private async addInsight(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    const insight: Insight = {\n      id: generateId('insight'),\n      category: data.category || 'optimization',\n      title: data.title,\n      description: data.description,\n      evidence: data.evidence || [],\n      confidence: data.confidence || 0.7,\n      applicability: data.applicability || [],\n      contributingAgents: [agentId],\n      timestamp: new Date(),\n    };\n\n    session.collectiveIntelligence.insights.set(insight.id, insight);\n  }\n\n  private async addPattern(session: HiveMindSession, agentId: string, data: any): Promise<void> {\n    const pattern: Pattern = {\n      id: generateId('pattern'),\n      type: data.type || 'behavioral',\n      description: data.description,\n      frequency: data.frequency || 1,\n      confidence: data.confidence || 0.7,\n      contexts: data.contexts || [],\n      impact: data.impact || 'medium',\n      discoveredBy: [agentId],\n      lastSeen: new Date(),\n    };\n\n    session.collectiveIntelligence.patterns.set(pattern.id, pattern);\n  }\n\n  private async initiateVoting(session: HiveMindSession, decision: CollectiveDecision): Promise<void> {\n    // Implementation would send voting request to all participants\n    // For now, simulate consensus building\n    this.logger.debug('Initiating collective voting', {\n      sessionId: session.id,\n      decisionId: decision.id,\n      participantCount: decision.participants.length,\n    });\n\n    // Placeholder implementation - in reality, this would involve\n    // sophisticated consensus algorithms\n    setTimeout(() => {\n      this.processVotingResults(session, decision);\n    }, 5000);\n  }\n\n  private processVotingResults(session: HiveMindSession, decision: CollectiveDecision): void {\n    // Placeholder implementation\n    decision.consensus = decision.options[0].id;\n    decision.confidence = 0.8;\n    decision.reasoning = 'Consensus reached through collective voting';\n\n    this.emit('decision:completed', {\n      sessionId: session.id,\n      decisionId: decision.id,\n      consensus: decision.consensus,\n      confidence: decision.confidence,\n    });\n  }\n\n  private queryFacts(session: HiveMindSession, query: any): Fact[] {\n    const results: Fact[] = [];\n    \n    for (const fact of session.knowledgeBase.facts.values()) {\n      let matches = true;\n      \n      if (query.category && !fact.category.includes(query.category)) {\n        matches = false;\n      }\n      \n      if (query.keywords && !query.keywords.some(keyword => \n        fact.statement.toLowerCase().includes(keyword.toLowerCase()))) {\n        matches = false;\n      }\n      \n      if (query.context && !fact.contexts.includes(query.context)) {\n        matches = false;\n      }\n      \n      if (matches) {\n        results.push(fact);\n      }\n    }\n    \n    return results;\n  }\n\n  private queryProcedures(session: HiveMindSession, query: any): Procedure[] {\n    // Similar implementation to queryFacts but for procedures\n    return Array.from(session.knowledgeBase.procedures.values());\n  }\n\n  private queryBestPractices(session: HiveMindSession, query: any): BestPractice[] {\n    // Similar implementation to queryFacts but for best practices\n    return Array.from(session.knowledgeBase.bestPractices.values());\n  }\n\n  private queryLessons(session: HiveMindSession, query: any): Lesson[] {\n    // Similar implementation to queryFacts but for lessons\n    return Array.from(session.knowledgeBase.lessons.values());\n  }\n\n  private async consolidateSessionKnowledge(session: HiveMindSession): Promise<void> {\n    // Merge session knowledge into global knowledge base\n    for (const [id, fact] of session.knowledgeBase.facts) {\n      if (!this.globalKnowledgeBase.facts.has(id)) {\n        this.globalKnowledgeBase.facts.set(id, fact);\n      }\n    }\n\n    for (const [id, insight] of session.collectiveIntelligence.insights) {\n      if (!this.globalIntelligence.insights.has(id)) {\n        this.globalIntelligence.insights.set(id, insight);\n      }\n    }\n\n    // Similar consolidation for other knowledge types\n  }\n\n  private async syncSessionKnowledge(session: HiveMindSession): Promise<void> {\n    // Sync session with global knowledge base\n    // Implementation would handle bidirectional sync\n  }\n\n  private loadKnowledgeData(data: any): void {\n    // Load knowledge data from stored format\n    if (data.facts) {\n      for (const [id, fact] of data.facts) {\n        this.globalKnowledgeBase.facts.set(id, fact);\n      }\n    }\n    // Similar loading for other knowledge types\n  }\n\n  private loadIntelligenceData(data: any): void {\n    // Load intelligence data from stored format\n    if (data.patterns) {\n      for (const [id, pattern] of data.patterns) {\n        this.globalIntelligence.patterns.set(id, pattern);\n      }\n    }\n    // Similar loading for other intelligence types\n  }\n\n  private countKnowledgeItems(): number {\n    return this.globalKnowledgeBase.facts.size +\n           this.globalKnowledgeBase.procedures.size +\n           this.globalKnowledgeBase.bestPractices.size +\n           this.globalKnowledgeBase.lessons.size;\n  }\n\n  private initializeKnowledgeBase(): KnowledgeBase {\n    return {\n      facts: new Map(),\n      procedures: new Map(),\n      bestPractices: new Map(),\n      lessons: new Map(),\n    };\n  }\n\n  private initializeCollectiveIntelligence(): CollectiveIntelligence {\n    return {\n      patterns: new Map(),\n      insights: new Map(),\n      decisions: new Map(),\n      predictions: new Map(),\n    };\n  }\n\n  private initializeDistributedLearning(): DistributedLearning {\n    return {\n      models: new Map(),\n      experiences: new Map(),\n      adaptations: new Map(),\n      performance: {\n        metrics: new Map(),\n        improvements: [],\n        degradations: [],\n        stability: 1.0,\n        trends: [],\n      },\n    };\n  }\n\n  private createDefaultConfig(config: Partial<HiveMindConfig>): HiveMindConfig {\n    return {\n      enableSharedIntelligence: true,\n      enableCollectiveMemory: true,\n      enableDistributedLearning: true,\n      enableKnowledgeSharing: true,\n      syncInterval: 30000, // 30 seconds\n      maxSharedMemorySize: 100 * 1024 * 1024, // 100MB\n      intelligencePoolSize: 1000,\n      learningRate: 0.1,\n      knowledgeRetentionPeriod: 7 * 24 * 60 * 60 * 1000, // 7 days\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('session:created', (data) => {\n      this.logger.info('Hive-mind session created', data);\n    });\n\n    this.on('agent:joined', (data) => {\n      this.logger.info('Agent joined hive-mind', data);\n    });\n\n    this.on('knowledge:shared', (data) => {\n      this.logger.debug('Knowledge shared with hive-mind', data);\n    });\n\n    this.on('decision:completed', (data) => {\n      this.logger.info('Collective decision completed', data);\n    });\n  }\n}\n\nexport default HiveMindIntegration;"],"names":["EventEmitter","Logger","generateId","HiveMindIntegration","logger","config","memoryManager","activeSessions","Map","globalKnowledgeBase","globalIntelligence","syncInterval","isInitialized","createDefaultConfig","initializeKnowledgeBase","initializeCollectiveIntelligence","setupEventHandlers","initialize","warn","info","loadKnowledgeBase","loadCollectiveIntelligence","startPeriodicSync","emit","error","shutdown","clearInterval","saveKnowledgeBase","saveCollectiveIntelligence","terminationPromises","Array","from","keys","map","sessionId","terminateSession","Promise","allSettled","createSession","swarmId","orchestrator","session","id","participants","sharedMemory","collectiveIntelligence","knowledgeBase","distributedLearning","initializeDistributedLearning","status","startTime","Date","lastSync","set","initializeSessionWithGlobalKnowledge","addAgentToSession","agentId","agent","get","Error","includes","push","participantCount","length","shareKnowledgeWithAgent","removeAgentFromSession","index","indexOf","splice","shareWithHive","type","data","debug","addKnowledge","addExperience","addInsight","addPattern","requestCollectiveDecision","question","options","requesterAgentId","decisionId","optionCount","decision","votingResults","consensus","confidence","reasoning","timestamp","decisions","initiateVoting","getCollectiveDecision","queryKnowledge","query","results","queryFacts","queryProcedures","queryBestPractices","queryLessons","resultCount","getCollectiveInsights","insights","values","getIdentifiedPatterns","patterns","getPerformancePredictions","predictions","duration","now","getTime","consolidateSessionKnowledge","delete","getSessionStatus","getIntegrationMetrics","sessions","totalParticipants","reduce","sum","s","knowledgeItems","countKnowledgeItems","size","learningModels","models","knowledgeEntries","retrieve","namespace","entry","JSON","parse","content","loadKnowledgeData","factsCount","facts","proceduresCount","procedures","bestPracticesCount","bestPractices","lessonsCount","lessons","intelligenceEntries","loadIntelligenceData","patternsCount","insightsCount","decisionsCount","predictionsCount","knowledgeData","entries","store","stringify","metadata","itemCount","intelligenceData","setInterval","performPeriodicSync","hiveMindEndpoint","syncSessionKnowledge","sessionsSynced","fact","insight","pattern","relevantKnowledge","getRelevantKnowledge","capabilities","relevantItems","some","cap","category","procedure","contexts","statement","sources","validatedBy","experience","context","situation","actions","feedback","tags","experiences","title","description","evidence","applicability","contributingAgents","frequency","impact","discoveredBy","lastSeen","setTimeout","processVotingResults","matches","keywords","keyword","toLowerCase","has","adaptations","performance","metrics","improvements","degradations","stability","trends","enableSharedIntelligence","enableCollectiveMemory","enableDistributedLearning","enableKnowledgeSharing","maxSharedMemorySize","intelligencePoolSize","learningRate","knowledgeRetentionPeriod","on"],"mappings":"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"}