{"version":3,"sources":["../../../src/swarm/claude-code-interface.ts"],"sourcesContent":["/**\n * Claude Code Coordination Interface\n * \n * This module provides the interface layer for coordinating with Claude Code\n * instances, managing agent spawning through the claude CLI, handling process\n * lifecycle, and enabling seamless communication between the swarm system\n * and individual Claude agents.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { spawn, ChildProcess } from 'node:child_process';\nimport { performance } from 'node:perf_hooks';\nimport * as path from 'node:path';\nimport * as fs from 'node:fs/promises';\nimport { Logger } from '../core/logger.js';\nimport { generateId } from '../utils/helpers.js';\nimport { MemoryManager } from '../memory/manager.js';\nimport TaskExecutor, { \n  ClaudeExecutionOptions,\n  ExecutionResult,\n  ExecutionContext\n} from './executor.js';\nimport {\n  SwarmAgent,\n  SwarmTask,\n  TaskDefinition,\n  AgentState,\n  AgentCapabilities,\n  TaskResult,\n  SwarmExecutionContext,\n} from './types.js';\n\nexport interface ClaudeCodeConfig {\n  claudeExecutablePath: string;\n  defaultModel: string;\n  maxTokens: number;\n  temperature: number;\n  timeout: number;\n  maxConcurrentAgents: number;\n  enableStreaming: boolean;\n  enableLogging: boolean;\n  workingDirectory: string;\n  environmentVariables: Record<string, string>;\n  agentPoolSize: number;\n  processRecycling: boolean;\n  healthCheckInterval: number;\n}\n\nexport interface ClaudeAgent {\n  id: string;\n  processId: number;\n  process: ChildProcess;\n  type: string;\n  capabilities: string[];\n  status: 'initializing' | 'idle' | 'busy' | 'error' | 'terminated';\n  currentTask?: string;\n  spawnedAt: Date;\n  lastActivity: Date;\n  totalTasks: number;\n  totalDuration: number;\n  metrics: ClaudeAgentMetrics;\n}\n\nexport interface ClaudeAgentMetrics {\n  tasksCompleted: number;\n  tasksFailed: number;\n  averageResponseTime: number;\n  totalTokensUsed: number;\n  memoryUsage: number;\n  cpuUsage: number;\n  errorRate: number;\n  successRate: number;\n}\n\nexport interface ClaudeTaskExecution {\n  id: string;\n  taskId: string;\n  agentId: string;\n  startTime: Date;\n  endTime?: Date;\n  status: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled';\n  input: any;\n  output?: any;\n  error?: string;\n  duration?: number;\n  tokensUsed?: number;\n  retryCount: number;\n  maxRetries: number;\n}\n\nexport interface ClaudeSpawnOptions {\n  type: string;\n  name?: string;\n  capabilities?: string[];\n  systemPrompt?: string;\n  model?: string;\n  maxTokens?: number;\n  temperature?: number;\n  workingDirectory?: string;\n  environment?: Record<string, string>;\n  tools?: string[];\n  priority?: number;\n}\n\nexport interface ProcessPool {\n  idle: ClaudeAgent[];\n  busy: ClaudeAgent[];\n  failed: ClaudeAgent[];\n  totalSpawned: number;\n  totalTerminated: number;\n  recyclingEnabled: boolean;\n  maxAge: number;\n  maxTasks: number;\n}\n\nexport class ClaudeCodeInterface extends EventEmitter {\n  private logger: Logger;\n  private config: ClaudeCodeConfig;\n  private memoryManager: MemoryManager;\n  private processPool: ProcessPool;\n  private activeExecutions: Map<string, ClaudeTaskExecution> = new Map();\n  private agents: Map<string, ClaudeAgent> = new Map();\n  private taskExecutor: TaskExecutor;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private isInitialized: boolean = false;\n\n  constructor(\n    config: Partial<ClaudeCodeConfig> = {},\n    memoryManager: MemoryManager\n  ) {\n    super();\n    \n    this.logger = new Logger('ClaudeCodeInterface');\n    this.config = this.createDefaultConfig(config);\n    this.memoryManager = memoryManager;\n    this.processPool = this.initializeProcessPool();\n    \n    this.taskExecutor = new TaskExecutor({\n      timeoutMs: this.config.timeout,\n      enableMetrics: true,\n      captureOutput: true,\n      streamOutput: this.config.enableStreaming,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Initialize the Claude Code interface\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      this.logger.warn('Claude Code interface already initialized');\n      return;\n    }\n\n    this.logger.info('Initializing Claude Code interface...');\n\n    try {\n      // Verify Claude executable exists\n      await this.verifyClaudeExecutable();\n\n      // Initialize task executor\n      await this.taskExecutor.initialize();\n\n      // Pre-warm agent pool if configured\n      if (this.config.agentPoolSize > 0) {\n        await this.prewarmAgentPool();\n      }\n\n      // Start health checks\n      this.startHealthChecks();\n\n      this.isInitialized = true;\n      this.logger.info('Claude Code interface initialized successfully', {\n        poolSize: this.processPool.idle.length,\n        maxConcurrent: this.config.maxConcurrentAgents,\n      });\n\n      this.emit('initialized');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize Claude Code interface', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Shutdown the interface gracefully\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n\n    this.logger.info('Shutting down Claude Code interface...');\n\n    try {\n      // Stop health checks\n      if (this.healthCheckInterval) {\n        clearInterval(this.healthCheckInterval);\n      }\n\n      // Cancel active executions\n      const cancellationPromises = Array.from(this.activeExecutions.keys())\n        .map(executionId => this.cancelExecution(executionId, 'Interface shutdown'));\n      \n      await Promise.allSettled(cancellationPromises);\n\n      // Terminate all agents\n      await this.terminateAllAgents();\n\n      // Shutdown task executor\n      await this.taskExecutor.shutdown();\n\n      this.isInitialized = false;\n      this.logger.info('Claude Code interface shut down successfully');\n      this.emit('shutdown');\n\n    } catch (error) {\n      this.logger.error('Error during Claude Code interface shutdown', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Spawn a new Claude agent with specified configuration\n   */\n  async spawnAgent(options: ClaudeSpawnOptions): Promise<string> {\n    this.logger.info('Spawning Claude agent', {\n      type: options.type,\n      name: options.name,\n      capabilities: options.capabilities,\n    });\n\n    try {\n      // Check if we can spawn more agents\n      if (this.getTotalActiveAgents() >= this.config.maxConcurrentAgents) {\n        throw new Error('Maximum concurrent agents limit reached');\n      }\n\n      // Build Claude command\n      const command = this.buildClaudeCommand(options);\n      \n      // Spawn process\n      const process = spawn(command.executable, command.args, {\n        cwd: options.workingDirectory || this.config.workingDirectory,\n        env: {\n          ...process.env,\n          ...this.config.environmentVariables,\n          ...options.environment,\n        },\n        stdio: ['pipe', 'pipe', 'pipe'],\n        detached: false,\n      });\n\n      if (!process.pid) {\n        throw new Error('Failed to spawn Claude process');\n      }\n\n      // Create agent record\n      const agentId = generateId('claude-agent');\n      const agent: ClaudeAgent = {\n        id: agentId,\n        processId: process.pid,\n        process,\n        type: options.type,\n        capabilities: options.capabilities || [],\n        status: 'initializing',\n        spawnedAt: new Date(),\n        lastActivity: new Date(),\n        totalTasks: 0,\n        totalDuration: 0,\n        metrics: this.initializeAgentMetrics(),\n      };\n\n      this.agents.set(agentId, agent);\n      this.processPool.idle.push(agent);\n      this.processPool.totalSpawned++;\n\n      // Setup process event handlers\n      this.setupProcessEventHandlers(agent);\n\n      // Wait for agent to be ready\n      await this.waitForAgentReady(agent);\n\n      agent.status = 'idle';\n      agent.lastActivity = new Date();\n\n      this.logger.info('Claude agent spawned successfully', {\n        agentId,\n        processId: process.pid,\n        type: options.type,\n      });\n\n      this.emit('agent:spawned', {\n        agentId,\n        type: options.type,\n        processId: process.pid,\n      });\n\n      return agentId;\n\n    } catch (error) {\n      this.logger.error('Failed to spawn Claude agent', {\n        type: options.type,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a task using a Claude agent\n   */\n  async executeTask(\n    taskDefinition: TaskDefinition,\n    agentId?: string,\n    options: Partial<ClaudeExecutionOptions> = {}\n  ): Promise<ClaudeTaskExecution> {\n    const executionId = generateId('claude-execution');\n    \n    this.logger.info('Executing task with Claude agent', {\n      executionId,\n      taskId: taskDefinition.id.id,\n      agentId,\n    });\n\n    try {\n      // Get or select agent\n      const agent = agentId ? this.agents.get(agentId) : await this.selectOptimalAgent(taskDefinition);\n      \n      if (!agent) {\n        throw new Error(agentId ? `Agent not found: ${agentId}` : 'No suitable agent available');\n      }\n\n      if (agent.status !== 'idle') {\n        throw new Error(`Agent ${agent.id} is not available (status: ${agent.status})`);\n      }\n\n      // Create execution record\n      const execution: ClaudeTaskExecution = {\n        id: executionId,\n        taskId: taskDefinition.id.id,\n        agentId: agent.id,\n        startTime: new Date(),\n        status: 'queued',\n        input: {\n          task: taskDefinition,\n          options,\n        },\n        retryCount: 0,\n        maxRetries: options.maxRetries || 3,\n      };\n\n      this.activeExecutions.set(executionId, execution);\n\n      // Update agent status\n      agent.status = 'busy';\n      agent.currentTask = executionId;\n      agent.lastActivity = new Date();\n\n      // Move agent from idle to busy pool\n      this.moveAgentToBusyPool(agent);\n\n      // Execute task\n      execution.status = 'running';\n      const result = await this.executeTaskWithAgent(agent, taskDefinition, options);\n\n      // Update execution record\n      execution.endTime = new Date();\n      execution.duration = execution.endTime.getTime() - execution.startTime.getTime();\n      execution.output = result.result;\n      execution.tokensUsed = result.metadata?.tokensUsed;\n\n      if (result.success) {\n        execution.status = 'completed';\n        agent.metrics.tasksCompleted++;\n      } else {\n        execution.status = 'failed';\n        execution.error = result.error;\n        agent.metrics.tasksFailed++;\n      }\n\n      // Update agent metrics\n      this.updateAgentMetrics(agent, execution);\n\n      // Return agent to idle pool\n      this.returnAgentToIdlePool(agent);\n\n      this.logger.info('Task execution completed', {\n        executionId,\n        success: result.success,\n        duration: execution.duration,\n        tokensUsed: execution.tokensUsed,\n      });\n\n      this.emit('task:completed', {\n        executionId,\n        taskId: taskDefinition.id.id,\n        agentId: agent.id,\n        success: result.success,\n        duration: execution.duration,\n      });\n\n      return execution;\n\n    } catch (error) {\n      const execution = this.activeExecutions.get(executionId);\n      if (execution) {\n        execution.status = 'failed';\n        execution.error = error instanceof Error ? error.message : String(error);\n        execution.endTime = new Date();\n        execution.duration = execution.endTime.getTime() - execution.startTime.getTime();\n\n        // Return agent to pool if it was assigned\n        const agent = this.agents.get(execution.agentId);\n        if (agent) {\n          this.returnAgentToIdlePool(agent);\n        }\n      }\n\n      this.logger.error('Task execution failed', {\n        executionId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Cancel a running task execution\n   */\n  async cancelExecution(executionId: string, reason: string): Promise<void> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution) {\n      throw new Error(`Execution not found: ${executionId}`);\n    }\n\n    this.logger.info('Cancelling task execution', {\n      executionId,\n      reason,\n      taskId: execution.taskId,\n      agentId: execution.agentId,\n    });\n\n    try {\n      execution.status = 'cancelled';\n      execution.error = reason;\n      execution.endTime = new Date();\n      execution.duration = execution.endTime.getTime() - execution.startTime.getTime();\n\n      // Cancel agent task if running\n      const agent = this.agents.get(execution.agentId);\n      if (agent && agent.currentTask === executionId) {\n        await this.cancelAgentTask(agent);\n        this.returnAgentToIdlePool(agent);\n      }\n\n      this.emit('task:cancelled', {\n        executionId,\n        reason,\n        taskId: execution.taskId,\n        agentId: execution.agentId,\n      });\n\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Terminate a specific agent\n   */\n  async terminateAgent(agentId: string, reason: string = 'Manual termination'): Promise<void> {\n    const agent = this.agents.get(agentId);\n    if (!agent) {\n      throw new Error(`Agent not found: ${agentId}`);\n    }\n\n    this.logger.info('Terminating Claude agent', {\n      agentId,\n      processId: agent.processId,\n      reason,\n    });\n\n    try {\n      // Cancel current task if any\n      if (agent.currentTask) {\n        await this.cancelExecution(agent.currentTask, 'Agent termination');\n      }\n\n      // Update status\n      agent.status = 'terminated';\n\n      // Terminate process\n      await this.terminateProcess(agent.process);\n\n      // Remove from pools and agents map\n      this.removeAgentFromPools(agent);\n      this.agents.delete(agentId);\n      this.processPool.totalTerminated++;\n\n      this.logger.info('Claude agent terminated successfully', {\n        agentId,\n        reason,\n        totalTasks: agent.totalTasks,\n        totalDuration: agent.totalDuration,\n      });\n\n      this.emit('agent:terminated', {\n        agentId,\n        reason,\n        metrics: agent.metrics,\n      });\n\n    } catch (error) {\n      this.logger.error('Error terminating agent', {\n        agentId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get agent status and metrics\n   */\n  getAgentStatus(agentId: string): ClaudeAgent | null {\n    return this.agents.get(agentId) || null;\n  }\n\n  /**\n   * Get all active agents\n   */\n  getAllAgents(): ClaudeAgent[] {\n    return Array.from(this.agents.values());\n  }\n\n  /**\n   * Get execution status\n   */\n  getExecutionStatus(executionId: string): ClaudeTaskExecution | null {\n    return this.activeExecutions.get(executionId) || null;\n  }\n\n  /**\n   * Get comprehensive interface metrics\n   */\n  getInterfaceMetrics(): {\n    agents: {\n      total: number;\n      idle: number;\n      busy: number;\n      failed: number;\n      terminated: number;\n    };\n    executions: {\n      active: number;\n      completed: number;\n      failed: number;\n      cancelled: number;\n    };\n    performance: {\n      averageResponseTime: number;\n      totalTokensUsed: number;\n      successRate: number;\n      throughput: number;\n    };\n    pool: {\n      totalSpawned: number;\n      totalTerminated: number;\n      recyclingEnabled: boolean;\n      poolUtilization: number;\n    };\n  } {\n    const agents = Array.from(this.agents.values());\n    const executions = Array.from(this.activeExecutions.values());\n\n    const totalCompleted = agents.reduce((sum, a) => sum + a.metrics.tasksCompleted, 0);\n    const totalFailed = agents.reduce((sum, a) => sum + a.metrics.tasksFailed, 0);\n    const totalTokens = agents.reduce((sum, a) => sum + a.metrics.totalTokensUsed, 0);\n    const avgResponseTime = agents.length > 0 \n      ? agents.reduce((sum, a) => sum + a.metrics.averageResponseTime, 0) / agents.length \n      : 0;\n\n    return {\n      agents: {\n        total: agents.length,\n        idle: this.processPool.idle.length,\n        busy: this.processPool.busy.length,\n        failed: this.processPool.failed.length,\n        terminated: this.processPool.totalTerminated,\n      },\n      executions: {\n        active: executions.filter(e => e.status === 'running').length,\n        completed: totalCompleted,\n        failed: totalFailed,\n        cancelled: executions.filter(e => e.status === 'cancelled').length,\n      },\n      performance: {\n        averageResponseTime: avgResponseTime,\n        totalTokensUsed: totalTokens,\n        successRate: totalCompleted + totalFailed > 0 ? totalCompleted / (totalCompleted + totalFailed) : 0,\n        throughput: this.calculateThroughput(),\n      },\n      pool: {\n        totalSpawned: this.processPool.totalSpawned,\n        totalTerminated: this.processPool.totalTerminated,\n        recyclingEnabled: this.processPool.recyclingEnabled,\n        poolUtilization: this.calculatePoolUtilization(),\n      },\n    };\n  }\n\n  // Private methods\n\n  private async verifyClaudeExecutable(): Promise<void> {\n    try {\n      const { spawn } = await import('node:child_process');\n      const process = spawn(this.config.claudeExecutablePath, ['--version'], {\n        stdio: ['ignore', 'pipe', 'pipe'],\n      });\n\n      return new Promise((resolve, reject) => {\n        let output = '';\n        \n        process.stdout?.on('data', (data) => {\n          output += data.toString();\n        });\n\n        process.on('close', (code) => {\n          if (code === 0) {\n            this.logger.info('Claude executable verified', {\n              path: this.config.claudeExecutablePath,\n              version: output.trim(),\n            });\n            resolve();\n          } else {\n            reject(new Error(`Claude executable verification failed with code ${code}`));\n          }\n        });\n\n        process.on('error', reject);\n      });\n\n    } catch (error) {\n      throw new Error(`Claude executable not found: ${this.config.claudeExecutablePath}`);\n    }\n  }\n\n  private async prewarmAgentPool(): Promise<void> {\n    this.logger.info('Pre-warming agent pool', {\n      targetSize: this.config.agentPoolSize,\n    });\n\n    const promises: Promise<string>[] = [];\n    \n    for (let i = 0; i < this.config.agentPoolSize; i++) {\n      promises.push(this.spawnAgent({\n        type: 'general',\n        name: `pool-agent-${i}`,\n        capabilities: ['general'],\n      }));\n    }\n\n    const results = await Promise.allSettled(promises);\n    const successful = results.filter(r => r.status === 'fulfilled').length;\n    const failed = results.filter(r => r.status === 'rejected').length;\n\n    this.logger.info('Agent pool pre-warming completed', {\n      successful,\n      failed,\n      targetSize: this.config.agentPoolSize,\n    });\n  }\n\n  private buildClaudeCommand(options: ClaudeSpawnOptions): {\n    executable: string;\n    args: string[];\n  } {\n    const args: string[] = [];\n\n    // Add model\n    args.push('--model', options.model || this.config.defaultModel);\n\n    // Add max tokens\n    args.push('--max-tokens', String(options.maxTokens || this.config.maxTokens));\n\n    // Add temperature\n    args.push('--temperature', String(options.temperature || this.config.temperature));\n\n    // Add system prompt if provided\n    if (options.systemPrompt) {\n      args.push('--system', options.systemPrompt);\n    }\n\n    // Add tools if specified\n    if (options.tools && options.tools.length > 0) {\n      args.push('--allowedTools', options.tools.join(','));\n    }\n\n    // Enable streaming if configured\n    if (this.config.enableStreaming) {\n      args.push('--stream');\n    }\n\n    // Skip permissions for swarm execution\n    args.push('--dangerously-skip-permissions');\n\n    return {\n      executable: this.config.claudeExecutablePath,\n      args,\n    };\n  }\n\n  private setupProcessEventHandlers(agent: ClaudeAgent): void {\n    const { process } = agent;\n\n    process.on('exit', (code, signal) => {\n      this.logger.info('Claude agent process exited', {\n        agentId: agent.id,\n        processId: agent.processId,\n        code,\n        signal,\n      });\n\n      if (agent.status !== 'terminated') {\n        agent.status = 'error';\n        this.moveAgentToFailedPool(agent);\n      }\n\n      this.emit('agent:exited', {\n        agentId: agent.id,\n        code,\n        signal,\n      });\n    });\n\n    process.on('error', (error) => {\n      this.logger.error('Claude agent process error', {\n        agentId: agent.id,\n        processId: agent.processId,\n        error: error.message,\n      });\n\n      agent.status = 'error';\n      this.moveAgentToFailedPool(agent);\n\n      this.emit('agent:error', {\n        agentId: agent.id,\n        error: error.message,\n      });\n    });\n\n    // Handle stdout/stderr if needed\n    if (this.config.enableLogging) {\n      process.stdout?.on('data', (data) => {\n        this.logger.debug('Agent stdout', {\n          agentId: agent.id,\n          data: data.toString().trim(),\n        });\n      });\n\n      process.stderr?.on('data', (data) => {\n        this.logger.debug('Agent stderr', {\n          agentId: agent.id,\n          data: data.toString().trim(),\n        });\n      });\n    }\n  }\n\n  private async waitForAgentReady(agent: ClaudeAgent, timeout: number = 30000): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      const checkInterval = 1000; // 1 second\n\n      const checkReady = () => {\n        const elapsed = Date.now() - startTime;\n        \n        if (elapsed > timeout) {\n          reject(new Error(`Agent ${agent.id} failed to become ready within ${timeout}ms`));\n          return;\n        }\n\n        // Check if process is still running\n        if (agent.process.killed || agent.process.exitCode !== null) {\n          reject(new Error(`Agent ${agent.id} process terminated during initialization`));\n          return;\n        }\n\n        // For now, assume agent is ready after a short delay\n        // In a real implementation, you might check for specific output or response\n        if (elapsed > 2000) { // 2 seconds\n          resolve();\n        } else {\n          setTimeout(checkReady, checkInterval);\n        }\n      };\n\n      checkReady();\n    });\n  }\n\n  private async selectOptimalAgent(taskDefinition: TaskDefinition): Promise<ClaudeAgent | null> {\n    const availableAgents = this.processPool.idle.filter(agent => agent.status === 'idle');\n    \n    if (availableAgents.length === 0) {\n      // Try to spawn a new agent if under limit\n      if (this.getTotalActiveAgents() < this.config.maxConcurrentAgents) {\n        const agentId = await this.spawnAgent({\n          type: 'task-specific',\n          capabilities: taskDefinition.requirements.capabilities,\n        });\n        return this.agents.get(agentId) || null;\n      }\n      return null;\n    }\n\n    // Select agent based on capabilities and performance\n    const scoredAgents = availableAgents.map(agent => ({\n      agent,\n      score: this.calculateAgentScore(agent, taskDefinition),\n    }));\n\n    scoredAgents.sort((a, b) => b.score - a.score);\n    return scoredAgents[0].agent;\n  }\n\n  private calculateAgentScore(agent: ClaudeAgent, taskDefinition: TaskDefinition): number {\n    let score = 0;\n\n    // Capability match\n    const requiredCapabilities = taskDefinition.requirements.capabilities;\n    const matchingCapabilities = agent.capabilities.filter(cap => \n      requiredCapabilities.includes(cap)\n    );\n    score += (matchingCapabilities.length / requiredCapabilities.length) * 100;\n\n    // Performance metrics\n    score += agent.metrics.successRate * 50;\n    score += Math.max(0, 50 - agent.metrics.averageResponseTime / 1000) * 10; // Prefer faster agents\n\n    // Load balancing - prefer agents with fewer completed tasks\n    const maxTasks = Math.max(...this.processPool.idle.map(a => a.totalTasks), 1);\n    score += (1 - agent.totalTasks / maxTasks) * 20;\n\n    return score;\n  }\n\n  private async executeTaskWithAgent(\n    agent: ClaudeAgent,\n    taskDefinition: TaskDefinition,\n    options: Partial<ClaudeExecutionOptions>\n  ): Promise<ExecutionResult> {\n    const startTime = performance.now();\n\n    try {\n      // Create execution context for the agent\n      const context: ExecutionContext = {\n        task: taskDefinition,\n        agent: this.convertToAgentState(agent),\n        workingDirectory: options.workingDirectory || this.config.workingDirectory,\n        tempDirectory: path.join(this.config.workingDirectory, 'temp', agent.id),\n        logDirectory: path.join(this.config.workingDirectory, 'logs', agent.id),\n        environment: {\n          ...this.config.environmentVariables,\n          CLAUDE_AGENT_ID: agent.id,\n          CLAUDE_TASK_ID: taskDefinition.id.id,\n        },\n        resources: {\n          maxMemory: taskDefinition.requirements.memoryRequired || 512 * 1024 * 1024,\n          maxCpuTime: taskDefinition.requirements.maxDuration || 300000,\n          maxDiskSpace: 1024 * 1024 * 1024,\n          maxNetworkConnections: 10,\n          maxFileHandles: 100,\n          priority: 1,\n        },\n      };\n\n      // Execute using task executor\n      const result = await this.taskExecutor.executeClaudeTask(\n        taskDefinition,\n        context.agent,\n        {\n          model: options.model || this.config.defaultModel,\n          maxTokens: options.maxTokens || this.config.maxTokens,\n          temperature: options.temperature || this.config.temperature,\n          timeout: options.timeout || this.config.timeout,\n          claudePath: this.config.claudeExecutablePath,\n          ...options,\n        }\n      );\n\n      const duration = performance.now() - startTime;\n      \n      // Update agent activity\n      agent.lastActivity = new Date();\n      agent.totalTasks++;\n      agent.totalDuration += duration;\n\n      return result;\n\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      agent.totalDuration += duration;\n      \n      throw error;\n    }\n  }\n\n  private convertToAgentState(agent: ClaudeAgent): AgentState {\n    // Convert ClaudeAgent to AgentState for compatibility\n    return {\n      id: {\n        id: agent.id,\n        swarmId: 'claude-interface',\n        type: agent.type as any,\n        instance: 1,\n      },\n      name: `Claude-${agent.id}`,\n      type: agent.type as any,\n      status: agent.status as any,\n      capabilities: this.createAgentCapabilities(agent.capabilities),\n      metrics: {\n        tasksCompleted: agent.metrics.tasksCompleted,\n        tasksFailed: agent.metrics.tasksFailed,\n        averageExecutionTime: agent.metrics.averageResponseTime,\n        successRate: agent.metrics.successRate,\n        cpuUsage: agent.metrics.cpuUsage,\n        memoryUsage: agent.metrics.memoryUsage,\n        diskUsage: 0,\n        networkUsage: 0,\n        codeQuality: 0.8,\n        testCoverage: 0.7,\n        bugRate: 0.1,\n        userSatisfaction: 0.9,\n        totalUptime: Date.now() - agent.spawnedAt.getTime(),\n        lastActivity: agent.lastActivity,\n        responseTime: agent.metrics.averageResponseTime,\n      },\n      currentTask: agent.currentTask ? {\n        id: agent.currentTask,\n        swarmId: 'claude-interface',\n        sequence: 0,\n        priority: 1,\n      } : undefined,\n      workload: agent.status === 'busy' ? 1 : 0,\n      health: agent.status === 'error' ? 0 : 1,\n      config: {\n        autonomyLevel: 0.8,\n        learningEnabled: false,\n        adaptationEnabled: false,\n        maxTasksPerHour: 60,\n        maxConcurrentTasks: 1,\n        timeoutThreshold: this.config.timeout,\n        reportingInterval: 10000,\n        heartbeatInterval: 5000,\n        permissions: ['read', 'write', 'execute'],\n        trustedAgents: [],\n        expertise: {},\n        preferences: {},\n      },\n      environment: {\n        runtime: 'claude',\n        version: '1.0.0',\n        workingDirectory: this.config.workingDirectory,\n        tempDirectory: path.join(this.config.workingDirectory, 'temp', agent.id),\n        logDirectory: path.join(this.config.workingDirectory, 'logs', agent.id),\n        apiEndpoints: {},\n        credentials: {},\n        availableTools: agent.capabilities,\n        toolConfigs: {},\n      },\n      endpoints: [],\n      lastHeartbeat: agent.lastActivity,\n      taskHistory: [],\n      errorHistory: [],\n      parentAgent: undefined,\n      childAgents: [],\n      collaborators: [],\n    };\n  }\n\n  private createAgentCapabilities(capabilities: string[]): AgentCapabilities {\n    return {\n      codeGeneration: capabilities.includes('coding') || capabilities.includes('codeGeneration'),\n      codeReview: capabilities.includes('review') || capabilities.includes('codeReview'),\n      testing: capabilities.includes('testing'),\n      documentation: capabilities.includes('documentation'),\n      research: capabilities.includes('research'),\n      analysis: capabilities.includes('analysis'),\n      webSearch: capabilities.includes('webSearch'),\n      apiIntegration: capabilities.includes('apiIntegration'),\n      fileSystem: capabilities.includes('fileSystem'),\n      terminalAccess: capabilities.includes('terminal'),\n      languages: capabilities.filter(c => ['javascript', 'typescript', 'python', 'java'].includes(c)),\n      frameworks: capabilities.filter(c => ['react', 'node', 'express'].includes(c)),\n      domains: capabilities.filter(c => ['web', 'api', 'database'].includes(c)),\n      tools: capabilities.filter(c => ['bash', 'git', 'npm'].includes(c)),\n      maxConcurrentTasks: 1,\n      maxMemoryUsage: 512 * 1024 * 1024,\n      maxExecutionTime: this.config.timeout,\n      reliability: 0.9,\n      speed: 1.0,\n      quality: 0.8,\n    };\n  }\n\n  private async cancelAgentTask(agent: ClaudeAgent): Promise<void> {\n    if (agent.process && !agent.process.killed) {\n      // Send interrupt signal\n      agent.process.kill('SIGINT');\n      \n      // Wait briefly for graceful shutdown\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Force kill if still running\n      if (!agent.process.killed) {\n        agent.process.kill('SIGKILL');\n      }\n    }\n\n    agent.currentTask = undefined;\n    agent.status = 'idle';\n    agent.lastActivity = new Date();\n  }\n\n  private async terminateProcess(process: ChildProcess): Promise<void> {\n    if (process.killed || process.exitCode !== null) {\n      return;\n    }\n\n    // Send termination signal\n    process.kill('SIGTERM');\n    \n    // Wait for graceful shutdown\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    // Force kill if still running\n    if (!process.killed && process.exitCode === null) {\n      process.kill('SIGKILL');\n    }\n  }\n\n  private async terminateAllAgents(): Promise<void> {\n    const terminationPromises = Array.from(this.agents.keys())\n      .map(agentId => this.terminateAgent(agentId, 'Interface shutdown'));\n    \n    await Promise.allSettled(terminationPromises);\n  }\n\n  private moveAgentToBusyPool(agent: ClaudeAgent): void {\n    const idleIndex = this.processPool.idle.indexOf(agent);\n    if (idleIndex !== -1) {\n      this.processPool.idle.splice(idleIndex, 1);\n      this.processPool.busy.push(agent);\n    }\n  }\n\n  private returnAgentToIdlePool(agent: ClaudeAgent): void {\n    agent.status = 'idle';\n    agent.currentTask = undefined;\n    agent.lastActivity = new Date();\n\n    const busyIndex = this.processPool.busy.indexOf(agent);\n    if (busyIndex !== -1) {\n      this.processPool.busy.splice(busyIndex, 1);\n      this.processPool.idle.push(agent);\n    }\n  }\n\n  private moveAgentToFailedPool(agent: ClaudeAgent): void {\n    // Remove from other pools\n    this.removeAgentFromPools(agent);\n    this.processPool.failed.push(agent);\n  }\n\n  private removeAgentFromPools(agent: ClaudeAgent): void {\n    const idleIndex = this.processPool.idle.indexOf(agent);\n    if (idleIndex !== -1) {\n      this.processPool.idle.splice(idleIndex, 1);\n    }\n\n    const busyIndex = this.processPool.busy.indexOf(agent);\n    if (busyIndex !== -1) {\n      this.processPool.busy.splice(busyIndex, 1);\n    }\n\n    const failedIndex = this.processPool.failed.indexOf(agent);\n    if (failedIndex !== -1) {\n      this.processPool.failed.splice(failedIndex, 1);\n    }\n  }\n\n  private updateAgentMetrics(agent: ClaudeAgent, execution: ClaudeTaskExecution): void {\n    const metrics = agent.metrics;\n    \n    // Update averages\n    const totalTasks = metrics.tasksCompleted + metrics.tasksFailed;\n    if (execution.duration) {\n      metrics.averageResponseTime = totalTasks > 0 \n        ? ((metrics.averageResponseTime * (totalTasks - 1)) + execution.duration) / totalTasks\n        : execution.duration;\n    }\n\n    // Update success rate\n    metrics.successRate = totalTasks > 0 \n      ? metrics.tasksCompleted / totalTasks \n      : 0;\n\n    // Update error rate\n    metrics.errorRate = 1 - metrics.successRate;\n\n    // Update token usage if available\n    if (execution.tokensUsed) {\n      metrics.totalTokensUsed += execution.tokensUsed;\n    }\n  }\n\n  private getTotalActiveAgents(): number {\n    return this.processPool.idle.length + this.processPool.busy.length;\n  }\n\n  private calculateThroughput(): number {\n    const agents = Array.from(this.agents.values());\n    const totalTasks = agents.reduce((sum, a) => sum + a.totalTasks, 0);\n    const totalTime = agents.reduce((sum, a) => sum + a.totalDuration, 0);\n    \n    return totalTime > 0 ? (totalTasks / totalTime) * 60000 : 0; // tasks per minute\n  }\n\n  private calculatePoolUtilization(): number {\n    const total = this.getTotalActiveAgents();\n    const busy = this.processPool.busy.length;\n    \n    return total > 0 ? busy / total : 0;\n  }\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.healthCheckInterval);\n  }\n\n  private performHealthCheck(): void {\n    const now = Date.now();\n    \n    for (const agent of this.agents.values()) {\n      // Check for stalled agents\n      const inactiveTime = now - agent.lastActivity.getTime();\n      \n      if (agent.status === 'busy' && inactiveTime > this.config.timeout * 2) {\n        this.logger.warn('Agent appears stalled', {\n          agentId: agent.id,\n          inactiveTime,\n          currentTask: agent.currentTask,\n        });\n\n        // Try to recover the agent\n        this.recoverStalledAgent(agent);\n      }\n\n      // Check for failed processes\n      if (agent.process.killed || agent.process.exitCode !== null) {\n        if (agent.status !== 'terminated') {\n          this.logger.warn('Agent process died unexpectedly', {\n            agentId: agent.id,\n            exitCode: agent.process.exitCode,\n          });\n          \n          agent.status = 'error';\n          this.moveAgentToFailedPool(agent);\n        }\n      }\n    }\n  }\n\n  private async recoverStalledAgent(agent: ClaudeAgent): Promise<void> {\n    try {\n      if (agent.currentTask) {\n        await this.cancelExecution(agent.currentTask, 'Agent recovery');\n      }\n      \n      this.returnAgentToIdlePool(agent);\n      \n      this.logger.info('Agent recovered from stalled state', {\n        agentId: agent.id,\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to recover stalled agent', {\n        agentId: agent.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      \n      // Terminate the problematic agent\n      await this.terminateAgent(agent.id, 'Recovery failed');\n    }\n  }\n\n  private initializeProcessPool(): ProcessPool {\n    return {\n      idle: [],\n      busy: [],\n      failed: [],\n      totalSpawned: 0,\n      totalTerminated: 0,\n      recyclingEnabled: this.config.processRecycling,\n      maxAge: 3600000, // 1 hour\n      maxTasks: 100,\n    };\n  }\n\n  private initializeAgentMetrics(): ClaudeAgentMetrics {\n    return {\n      tasksCompleted: 0,\n      tasksFailed: 0,\n      averageResponseTime: 0,\n      totalTokensUsed: 0,\n      memoryUsage: 0,\n      cpuUsage: 0,\n      errorRate: 0,\n      successRate: 0,\n    };\n  }\n\n  private createDefaultConfig(config: Partial<ClaudeCodeConfig>): ClaudeCodeConfig {\n    return {\n      claudeExecutablePath: 'claude',\n      defaultModel: 'claude-3-5-sonnet-20241022',\n      maxTokens: 4096,\n      temperature: 0.7,\n      timeout: 300000, // 5 minutes\n      maxConcurrentAgents: 10,\n      enableStreaming: false,\n      enableLogging: true,\n      workingDirectory: process.cwd(),\n      environmentVariables: {},\n      agentPoolSize: 0,\n      processRecycling: true,\n      healthCheckInterval: 30000, // 30 seconds\n      ...config,\n    };\n  }\n\n  private setupEventHandlers(): void {\n    this.on('agent:spawned', (data) => {\n      this.logger.info('Agent spawned event', data);\n    });\n\n    this.on('agent:terminated', (data) => {\n      this.logger.info('Agent terminated event', data);\n    });\n\n    this.on('task:completed', (data) => {\n      this.logger.info('Task completed event', data);\n    });\n\n    this.on('task:cancelled', (data) => {\n      this.logger.warn('Task cancelled event', data);\n    });\n  }\n}\n\nexport default ClaudeCodeInterface;"],"names":["EventEmitter","spawn","performance","path","Logger","generateId","TaskExecutor","ClaudeCodeInterface","logger","config","memoryManager","processPool","activeExecutions","Map","agents","taskExecutor","healthCheckInterval","isInitialized","createDefaultConfig","initializeProcessPool","timeoutMs","timeout","enableMetrics","captureOutput","streamOutput","enableStreaming","setupEventHandlers","initialize","warn","info","verifyClaudeExecutable","agentPoolSize","prewarmAgentPool","startHealthChecks","poolSize","idle","length","maxConcurrent","maxConcurrentAgents","emit","error","shutdown","clearInterval","cancellationPromises","Array","from","keys","map","executionId","cancelExecution","Promise","allSettled","terminateAllAgents","spawnAgent","options","type","name","capabilities","getTotalActiveAgents","Error","command","buildClaudeCommand","process","executable","args","cwd","workingDirectory","env","environmentVariables","environment","stdio","detached","pid","agentId","agent","id","processId","status","spawnedAt","Date","lastActivity","totalTasks","totalDuration","metrics","initializeAgentMetrics","set","push","totalSpawned","setupProcessEventHandlers","waitForAgentReady","message","String","executeTask","taskDefinition","taskId","get","selectOptimalAgent","execution","startTime","input","task","retryCount","maxRetries","currentTask","moveAgentToBusyPool","result","executeTaskWithAgent","endTime","duration","getTime","output","tokensUsed","metadata","success","tasksCompleted","tasksFailed","updateAgentMetrics","returnAgentToIdlePool","delete","reason","cancelAgentTask","terminateAgent","terminateProcess","removeAgentFromPools","totalTerminated","getAgentStatus","getAllAgents","values","getExecutionStatus","getInterfaceMetrics","executions","totalCompleted","reduce","sum","a","totalFailed","totalTokens","totalTokensUsed","avgResponseTime","averageResponseTime","total","busy","failed","terminated","active","filter","e","completed","cancelled","successRate","throughput","calculateThroughput","pool","recyclingEnabled","poolUtilization","calculatePoolUtilization","claudeExecutablePath","resolve","reject","stdout","on","data","toString","code","version","trim","targetSize","promises","i","results","successful","r","model","defaultModel","maxTokens","temperature","systemPrompt","tools","join","signal","moveAgentToFailedPool","enableLogging","debug","stderr","now","checkInterval","checkReady","elapsed","killed","exitCode","setTimeout","availableAgents","requirements","scoredAgents","score","calculateAgentScore","sort","b","requiredCapabilities","matchingCapabilities","cap","includes","Math","max","maxTasks","context","convertToAgentState","tempDirectory","logDirectory","CLAUDE_AGENT_ID","CLAUDE_TASK_ID","resources","maxMemory","memoryRequired","maxCpuTime","maxDuration","maxDiskSpace","maxNetworkConnections","maxFileHandles","priority","executeClaudeTask","claudePath","swarmId","instance","createAgentCapabilities","averageExecutionTime","cpuUsage","memoryUsage","diskUsage","networkUsage","codeQuality","testCoverage","bugRate","userSatisfaction","totalUptime","responseTime","sequence","undefined","workload","health","autonomyLevel","learningEnabled","adaptationEnabled","maxTasksPerHour","maxConcurrentTasks","timeoutThreshold","reportingInterval","heartbeatInterval","permissions","trustedAgents","expertise","preferences","runtime","apiEndpoints","credentials","availableTools","toolConfigs","endpoints","lastHeartbeat","taskHistory","errorHistory","parentAgent","childAgents","collaborators","codeGeneration","codeReview","testing","documentation","research","analysis","webSearch","apiIntegration","fileSystem","terminalAccess","languages","c","frameworks","domains","maxMemoryUsage","maxExecutionTime","reliability","speed","quality","kill","terminationPromises","idleIndex","indexOf","splice","busyIndex","failedIndex","errorRate","totalTime","setInterval","performHealthCheck","inactiveTime","recoverStalledAgent","processRecycling","maxAge"],"mappings":"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"}