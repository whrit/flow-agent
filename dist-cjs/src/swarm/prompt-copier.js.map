{"version":3,"sources":["../../../src/swarm/prompt-copier.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { createHash } from 'crypto';\nimport type { Worker } from 'worker_threads';\nimport { EventEmitter } from 'events';\nimport { logger } from '../core/logger.js';\n\nexport interface CopyOptions {\n  source: string;\n  destination: string;\n  backup?: boolean;\n  overwrite?: boolean;\n  verify?: boolean;\n  preservePermissions?: boolean;\n  excludePatterns?: string[];\n  includePatterns?: string[];\n  parallel?: boolean;\n  maxWorkers?: number;\n  dryRun?: boolean;\n  conflictResolution?: 'skip' | 'overwrite' | 'backup' | 'merge';\n  progressCallback?: (progress: CopyProgress) => void;\n}\n\nexport interface CopyProgress {\n  total: number;\n  completed: number;\n  failed: number;\n  skipped: number;\n  currentFile?: string;\n  percentage: number;\n}\n\nexport interface CopyResult {\n  success: boolean;\n  totalFiles: number;\n  copiedFiles: number;\n  failedFiles: number;\n  skippedFiles: number;\n  backupLocation?: string;\n  errors: CopyError[];\n  duration: number;\n}\n\nexport interface CopyError {\n  file: string;\n  error: string;\n  phase: 'read' | 'write' | 'verify' | 'backup';\n}\n\nexport interface FileInfo {\n  path: string;\n  relativePath: string;\n  size: number;\n  hash?: string;\n  permissions?: number;\n}\n\nexport class PromptCopier extends EventEmitter {\n  private options: Required<CopyOptions>;\n  private fileQueue: FileInfo[] = [];\n  private copiedFiles: Set<string> = new Set();\n  private errors: CopyError[] = [];\n  private backupMap: Map<string, string> = new Map();\n  private rollbackStack: Array<() => Promise<void>> = [];\n\n  constructor(options: CopyOptions) {\n    super();\n    this.options = {\n      ...options,\n      backup: options.backup ?? true,\n      overwrite: options.overwrite ?? false,\n      verify: options.verify ?? true,\n      preservePermissions: options.preservePermissions ?? true,\n      excludePatterns: options.excludePatterns ?? [],\n      includePatterns: options.includePatterns ?? ['*.md', '*.txt', '*.prompt', '*.prompts'],\n      parallel: options.parallel ?? true,\n      maxWorkers: options.maxWorkers ?? 4,\n      dryRun: options.dryRun ?? false,\n      conflictResolution: options.conflictResolution ?? 'backup',\n      progressCallback: options.progressCallback ?? (() => {}),\n    };\n  }\n\n  async copy(): Promise<CopyResult> {\n    const startTime = Date.now();\n\n    try {\n      // Phase 1: Discovery\n      logger.info('Starting prompt discovery phase...');\n      await this.discoverFiles();\n\n      if (this.fileQueue.length === 0) {\n        return {\n          success: true,\n          totalFiles: 0,\n          copiedFiles: 0,\n          failedFiles: 0,\n          skippedFiles: 0,\n          duration: Date.now() - startTime,\n          errors: [],\n        };\n      }\n\n      // Phase 2: Pre-flight checks\n      if (!this.options.dryRun) {\n        await this.ensureDestinationDirectories();\n      }\n\n      // Phase 3: Copy files\n      logger.info(`Copying ${this.fileQueue.length} files...`);\n      if (this.options.parallel) {\n        await this.copyFilesParallel();\n      } else {\n        await this.copyFilesSequential();\n      }\n\n      // Phase 4: Verification\n      if (this.options.verify && !this.options.dryRun) {\n        await this.verifyFiles();\n      }\n\n      const duration = Date.now() - startTime;\n      const result: CopyResult = {\n        success: this.errors.length === 0,\n        totalFiles: this.fileQueue.length,\n        copiedFiles: this.copiedFiles.size,\n        failedFiles: this.errors.length,\n        skippedFiles: this.fileQueue.length - this.copiedFiles.size - this.errors.length,\n        errors: this.errors,\n        duration,\n      };\n\n      if (this.backupMap.size > 0) {\n        result.backupLocation = await this.createBackupManifest();\n      }\n\n      logger.info(`Copy completed in ${duration}ms`, result);\n      return result;\n    } catch (error) {\n      logger.error('Copy operation failed', error);\n\n      if (!this.options.dryRun) {\n        await this.rollback();\n      }\n\n      throw error;\n    }\n  }\n\n  private async discoverFiles(): Promise<void> {\n    const sourceStats = await fs.stat(this.options.source);\n\n    if (!sourceStats.isDirectory()) {\n      throw new Error(`Source path ${this.options.source} is not a directory`);\n    }\n\n    await this.scanDirectory(this.options.source, '');\n\n    // Sort by size for better parallel distribution\n    this.fileQueue.sort((a, b) => b.size - a.size);\n  }\n\n  private async scanDirectory(dirPath: string, relativePath: string): Promise<void> {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dirPath, entry.name);\n      const relPath = path.join(relativePath, entry.name);\n\n      if (entry.isDirectory()) {\n        await this.scanDirectory(fullPath, relPath);\n      } else if (entry.isFile() && this.shouldIncludeFile(relPath)) {\n        const stats = await fs.stat(fullPath);\n        this.fileQueue.push({\n          path: fullPath,\n          relativePath: relPath,\n          size: stats.size,\n          permissions: stats.mode,\n        });\n      }\n    }\n  }\n\n  private shouldIncludeFile(filePath: string): boolean {\n    // Check exclude patterns first\n    for (const pattern of this.options.excludePatterns) {\n      if (this.matchPattern(filePath, pattern)) {\n        return false;\n      }\n    }\n\n    // Check include patterns\n    if (this.options.includePatterns.length === 0) {\n      return true;\n    }\n\n    for (const pattern of this.options.includePatterns) {\n      if (this.matchPattern(filePath, pattern)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private matchPattern(filePath: string, pattern: string): boolean {\n    // Simple glob pattern matching\n    const regex = pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*').replace(/\\?/g, '.');\n\n    return new RegExp(regex).test(filePath);\n  }\n\n  private async ensureDestinationDirectories(): Promise<void> {\n    const directories = new Set<string>();\n\n    for (const file of this.fileQueue) {\n      const destDir = path.dirname(path.join(this.options.destination, file.relativePath));\n      directories.add(destDir);\n    }\n\n    // Create directories in order (parent first)\n    const sortedDirs = Array.from(directories).sort((a, b) => a.length - b.length);\n\n    for (const dir of sortedDirs) {\n      await fs.mkdir(dir, { recursive: true });\n    }\n  }\n\n  private async copyFilesSequential(): Promise<void> {\n    let completed = 0;\n\n    for (const file of this.fileQueue) {\n      try {\n        await this.copyFile(file);\n        completed++;\n        this.reportProgress(completed);\n      } catch (error) {\n        this.errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'write',\n        });\n      }\n    }\n  }\n\n  private async copyFilesParallel(): Promise<void> {\n    const workerCount = Math.min(this.options.maxWorkers, this.fileQueue.length);\n    const chunkSize = Math.ceil(this.fileQueue.length / workerCount);\n    const workers: Promise<void>[] = [];\n\n    for (let i = 0; i < workerCount; i++) {\n      const start = i * chunkSize;\n      const end = Math.min(start + chunkSize, this.fileQueue.length);\n      const chunk = this.fileQueue.slice(start, end);\n\n      if (chunk.length > 0) {\n        workers.push(this.processChunk(chunk, i));\n      }\n    }\n\n    await Promise.all(workers);\n  }\n\n  private async processChunk(files: FileInfo[], workerId: number): Promise<void> {\n    for (const file of files) {\n      try {\n        await this.copyFile(file);\n        this.copiedFiles.add(file.path);\n        this.reportProgress(this.copiedFiles.size);\n      } catch (error) {\n        this.errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'write',\n        });\n      }\n    }\n  }\n\n  private async copyFile(file: FileInfo): Promise<void> {\n    const destPath = path.join(this.options.destination, file.relativePath);\n\n    if (this.options.dryRun) {\n      logger.info(`[DRY RUN] Would copy ${file.path} to ${destPath}`);\n      return;\n    }\n\n    // Check for conflicts\n    const destExists = await this.fileExists(destPath);\n\n    if (destExists) {\n      switch (this.options.conflictResolution) {\n        case 'skip':\n          logger.info(`Skipping existing file: ${destPath}`);\n          return;\n\n        case 'backup':\n          await this.backupFile(destPath);\n          break;\n\n        case 'merge':\n          await this.mergeFiles(file.path, destPath);\n          return;\n\n        case 'overwrite':\n          // Continue with copy\n          break;\n      }\n    }\n\n    // Calculate source hash if verification is enabled\n    if (this.options.verify) {\n      file.hash = await this.calculateFileHash(file.path);\n    }\n\n    // Copy the file\n    await fs.copyFile(file.path, destPath);\n\n    // Preserve permissions if requested\n    if (this.options.preservePermissions && file.permissions) {\n      await fs.chmod(destPath, file.permissions);\n    }\n\n    // Add to rollback stack\n    this.rollbackStack.push(async () => {\n      if (destExists && this.backupMap.has(destPath)) {\n        // Restore from backup\n        const backupPath = this.backupMap.get(destPath)!;\n        await fs.copyFile(backupPath, destPath);\n      } else {\n        // Remove the copied file\n        await fs.unlink(destPath);\n      }\n    });\n\n    this.copiedFiles.add(file.path);\n  }\n\n  private async backupFile(filePath: string): Promise<void> {\n    const backupDir = path.join(this.options.destination, '.prompt-backups');\n    await fs.mkdir(backupDir, { recursive: true });\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupName = `${path.basename(filePath)}.${timestamp}.bak`;\n    const backupPath = path.join(backupDir, backupName);\n\n    await fs.copyFile(filePath, backupPath);\n    this.backupMap.set(filePath, backupPath);\n  }\n\n  private async mergeFiles(sourcePath: string, destPath: string): Promise<void> {\n    // Simple merge strategy: append source to destination with separator\n    const sourceContent = await fs.readFile(sourcePath, 'utf-8');\n    const destContent = await fs.readFile(destPath, 'utf-8');\n\n    const separator = '\\n\\n--- MERGED CONTENT ---\\n\\n';\n    const mergedContent = destContent + separator + sourceContent;\n\n    await this.backupFile(destPath);\n    await fs.writeFile(destPath, mergedContent, 'utf-8');\n  }\n\n  private async verifyFiles(): Promise<void> {\n    logger.info('Verifying copied files...');\n\n    for (const file of this.fileQueue) {\n      if (!this.copiedFiles.has(file.path)) continue;\n\n      try {\n        const destPath = path.join(this.options.destination, file.relativePath);\n\n        // Verify file exists\n        if (!(await this.fileExists(destPath))) {\n          throw new Error('Destination file not found');\n        }\n\n        // Verify size\n        const destStats = await fs.stat(destPath);\n        const sourceStats = await fs.stat(file.path);\n\n        if (destStats.size !== sourceStats.size) {\n          throw new Error(`Size mismatch: ${destStats.size} != ${sourceStats.size}`);\n        }\n\n        // Verify hash if available\n        if (file.hash) {\n          const destHash = await this.calculateFileHash(destPath);\n          if (destHash !== file.hash) {\n            throw new Error(`Hash mismatch: ${destHash} != ${file.hash}`);\n          }\n        }\n      } catch (error) {\n        this.errors.push({\n          file: file.path,\n          error: error instanceof Error ? error.message : String(error),\n          phase: 'verify',\n        });\n      }\n    }\n  }\n\n  private async calculateFileHash(filePath: string): Promise<string> {\n    const content = await fs.readFile(filePath);\n    return createHash('sha256').update(content).digest('hex');\n  }\n\n  private async fileExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async createBackupManifest(): Promise<string> {\n    const manifestPath = path.join(\n      this.options.destination,\n      '.prompt-backups',\n      `manifest-${Date.now()}.json`,\n    );\n\n    const manifest = {\n      timestamp: new Date().toISOString(),\n      source: this.options.source,\n      destination: this.options.destination,\n      backups: Array.from(this.backupMap.entries()).map(([original, backup]) => ({\n        original,\n        backup,\n      })),\n    };\n\n    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));\n    return manifestPath;\n  }\n\n  private async rollback(): Promise<void> {\n    logger.warn('Rolling back changes...');\n\n    // Execute rollback operations in reverse order\n    for (let i = this.rollbackStack.length - 1; i >= 0; i--) {\n      try {\n        await this.rollbackStack[i]();\n      } catch (error) {\n        logger.error(`Rollback operation ${i} failed:`, error);\n      }\n    }\n\n    // Clean up backup directory if empty\n    try {\n      const backupDir = path.join(this.options.destination, '.prompt-backups');\n      const entries = await fs.readdir(backupDir);\n      if (entries.length === 0) {\n        await fs.rmdir(backupDir);\n      }\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n\n  private reportProgress(completed: number): void {\n    const progress: CopyProgress = {\n      total: this.fileQueue.length,\n      completed,\n      failed: this.errors.length,\n      skipped: this.fileQueue.length - completed - this.errors.length,\n      percentage: Math.round((completed / this.fileQueue.length) * 100),\n    };\n\n    this.emit('progress', progress);\n    this.options.progressCallback(progress);\n  }\n\n  // Utility method to restore from backup\n  async restoreFromBackup(manifestPath: string): Promise<void> {\n    const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));\n\n    for (const { original, backup } of manifest.backups) {\n      try {\n        await fs.copyFile(backup, original);\n        logger.info(`Restored ${original} from ${backup}`);\n      } catch (error) {\n        logger.error(`Failed to restore ${original}:`, error);\n      }\n    }\n  }\n}\n\n// Export convenience function\nexport async function copyPrompts(options: CopyOptions): Promise<CopyResult> {\n  const copier = new PromptCopier(options);\n  return copier.copy();\n}\n"],"names":["fs","path","createHash","EventEmitter","logger","PromptCopier","options","fileQueue","copiedFiles","Set","errors","backupMap","Map","rollbackStack","backup","overwrite","verify","preservePermissions","excludePatterns","includePatterns","parallel","maxWorkers","dryRun","conflictResolution","progressCallback","copy","startTime","Date","now","info","discoverFiles","length","success","totalFiles","failedFiles","skippedFiles","duration","ensureDestinationDirectories","copyFilesParallel","copyFilesSequential","verifyFiles","result","size","backupLocation","createBackupManifest","error","rollback","sourceStats","stat","source","isDirectory","Error","scanDirectory","sort","a","b","dirPath","relativePath","entries","readdir","withFileTypes","entry","fullPath","join","name","relPath","isFile","shouldIncludeFile","stats","push","permissions","mode","filePath","pattern","matchPattern","regex","replace","RegExp","test","directories","file","destDir","dirname","destination","add","sortedDirs","Array","from","dir","mkdir","recursive","completed","copyFile","reportProgress","message","String","phase","workerCount","Math","min","chunkSize","ceil","workers","i","start","end","chunk","slice","processChunk","Promise","all","files","workerId","destPath","destExists","fileExists","backupFile","mergeFiles","hash","calculateFileHash","chmod","has","backupPath","get","unlink","backupDir","timestamp","toISOString","backupName","basename","set","sourcePath","sourceContent","readFile","destContent","separator","mergedContent","writeFile","destStats","destHash","content","update","digest","access","manifestPath","manifest","backups","map","original","JSON","stringify","warn","rmdir","progress","total","failed","skipped","percentage","round","emit","restoreFromBackup","parse","copyPrompts","copier"],"mappings":"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"}