{"version":3,"sources":["../../../../src/swarm/__tests__/prompt-copier.test.ts"],"sourcesContent":["import { getErrorMessage } from '../utils/error-handler.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { PromptCopier, copyPrompts } from '../prompt-copier.js';\nimport { EnhancedPromptCopier, copyPromptsEnhanced } from '../prompt-copier-enhanced.js';\nimport { PromptConfigManager, PromptValidator } from '../prompt-utils.js';\n\ndescribe('PromptCopier', () => {\n  let tempDir: string;\n  let sourceDir: string;\n  let destDir: string;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'prompt-test-'));\n    sourceDir = path.join(tempDir, 'source');\n    destDir = path.join(tempDir, 'dest');\n\n    await fs.mkdir(sourceDir, { recursive: true });\n    await fs.mkdir(destDir, { recursive: true });\n\n    // Create test files\n    await createTestFiles();\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  async function createTestFiles() {\n    const testFiles = [\n      { path: 'test1.md', content: '# Test Prompt 1\\nThis is a test prompt.' },\n      { path: 'test2.txt', content: 'Test prompt content' },\n      { path: 'subdir/test3.md', content: '## Nested Prompt\\nNested content' },\n      { path: 'large.md', content: 'Large content\\n'.repeat(1000) },\n      { path: 'empty.md', content: '' },\n      { path: 'rules.md', content: '# Rules\\nYou are an AI assistant.' },\n    ];\n\n    for (const file of testFiles) {\n      const filePath = path.join(sourceDir, file.path);\n      const dir = path.dirname(filePath);\n\n      await fs.mkdir(dir, { recursive: true });\n      await fs.writeFile(filePath, file.content);\n    }\n  }\n\n  describe('Basic copying functionality', () => {\n    test('should copy all matching files', async () => {\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.copiedFiles).toBe(6);\n      expect(result.failedFiles).toBe(0);\n\n      // Verify files exist\n      const destFiles = await fs.readdir(destDir, { recursive: true });\n      expect(destFiles).toHaveLength(6);\n    });\n\n    test('should respect include patterns', async () => {\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        includePatterns: ['*.md'],\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.copiedFiles).toBe(5); // Only .md files\n    });\n\n    test('should respect exclude patterns', async () => {\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        excludePatterns: ['**/subdir/**'],\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.copiedFiles).toBe(5); // Excluding subdir files\n    });\n  });\n\n  describe('Conflict resolution', () => {\n    test('should skip existing files when conflict resolution is skip', async () => {\n      // Create existing file\n      await fs.writeFile(path.join(destDir, 'test1.md'), 'Existing content');\n\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        conflictResolution: 'skip',\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.skippedFiles).toBeGreaterThan(0);\n\n      // Verify original content preserved\n      const content = await fs.readFile(path.join(destDir, 'test1.md'), 'utf-8');\n      expect(content).toBe('Existing content');\n    });\n\n    test('should backup existing files when conflict resolution is backup', async () => {\n      // Create existing file\n      await fs.writeFile(path.join(destDir, 'test1.md'), 'Existing content');\n\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        conflictResolution: 'backup',\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.backupLocation).toBeDefined();\n\n      // Verify backup directory exists\n      const backupDir = path.join(destDir, '.prompt-backups');\n      const backupExists = await fs\n        .access(backupDir)\n        .then(() => true)\n        .catch(() => false);\n      expect(backupExists).toBe(true);\n    });\n\n    test('should merge files when conflict resolution is merge', async () => {\n      // Create existing file\n      await fs.writeFile(path.join(destDir, 'test1.md'), 'Existing content');\n\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        conflictResolution: 'merge',\n      });\n\n      expect(result.success).toBe(true);\n\n      // Verify merged content\n      const content = await fs.readFile(path.join(destDir, 'test1.md'), 'utf-8');\n      expect(content).toContain('Existing content');\n      expect(content).toContain('MERGED CONTENT');\n      expect(content).toContain('# Test Prompt 1');\n    });\n  });\n\n  describe('Verification', () => {\n    test('should verify copied files when verification is enabled', async () => {\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        verify: true,\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.failedFiles).toBe(0);\n    });\n\n    test('should detect verification failures', async () => {\n      // Mock fs.stat to simulate size mismatch\n      const originalStat = fs.stat;\n      jest.spyOn(fs, 'stat').mockImplementation(async (filePath: any) => {\n        const stats = await originalStat(filePath);\n        if (filePath.includes('dest') && filePath.includes('test1.md')) {\n          return { ...stats, size: stats.size + 1 };\n        }\n        return stats;\n      });\n\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        verify: true,\n      });\n\n      expect(result.errors.length).toBeGreaterThan(0);\n      expect(result.errors[0].phase).toBe('verify');\n\n      (fs.stat as jest.Mock).mockRestore();\n    });\n  });\n\n  describe('Dry run mode', () => {\n    test('should not create files in dry run mode', async () => {\n      const result = await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        dryRun: true,\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.totalFiles).toBe(6);\n\n      // Verify no files were actually copied\n      const destFiles = await fs.readdir(destDir);\n      expect(destFiles).toHaveLength(0);\n    });\n  });\n\n  describe('Progress reporting', () => {\n    test('should report progress during copy', async () => {\n      const progressUpdates: any[] = [];\n\n      await copyPrompts({\n        source: sourceDir,\n        destination: destDir,\n        progressCallback: (progress) => {\n          progressUpdates.push(progress);\n        },\n      });\n\n      expect(progressUpdates.length).toBeGreaterThan(0);\n      expect(progressUpdates[progressUpdates.length - 1].percentage).toBe(100);\n    });\n  });\n});\n\ndescribe('EnhancedPromptCopier', () => {\n  let tempDir: string;\n  let sourceDir: string;\n  let destDir: string;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'enhanced-test-'));\n    sourceDir = path.join(tempDir, 'source');\n    destDir = path.join(tempDir, 'dest');\n\n    await fs.mkdir(sourceDir, { recursive: true });\n    await fs.mkdir(destDir, { recursive: true });\n\n    // Create test files\n    for (let i = 0; i < 20; i++) {\n      await fs.writeFile(path.join(sourceDir, `test${i}.md`), `# Test ${i}\\nContent for test ${i}`);\n    }\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  test('should copy files using worker threads', async () => {\n    const result = await copyPromptsEnhanced({\n      source: sourceDir,\n      destination: destDir,\n      parallel: true,\n      maxWorkers: 4,\n    });\n\n    expect(result.success).toBe(true);\n    expect(result.copiedFiles).toBe(20);\n    expect(result.failedFiles).toBe(0);\n\n    // Verify all files were copied\n    const destFiles = await fs.readdir(destDir);\n    expect(destFiles).toHaveLength(20);\n  }, 10000);\n});\n\ndescribe('PromptConfigManager', () => {\n  let tempDir: string;\n  let configPath: string;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'config-test-'));\n    configPath = path.join(tempDir, '.prompt-config.json');\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  test('should load default config when file does not exist', async () => {\n    const manager = new PromptConfigManager(configPath);\n    const config = await manager.loadConfig();\n\n    expect(config).toBeDefined();\n    expect(config.defaultOptions).toBeDefined();\n    expect(config.profiles).toBeDefined();\n  });\n\n  test('should save and load custom config', async () => {\n    const manager = new PromptConfigManager(configPath);\n\n    await manager.saveConfig({\n      destinationDirectory: './custom-prompts',\n    });\n\n    const config = await manager.loadConfig();\n    expect(config.destinationDirectory).toBe('./custom-prompts');\n  });\n\n  test('should get profile options', async () => {\n    const manager = new PromptConfigManager(configPath);\n    await manager.loadConfig();\n\n    const sparcProfile = manager.getProfile('sparc');\n    expect(sparcProfile).toBeDefined();\n    expect(sparcProfile.includePatterns).toContain('*.md');\n  });\n\n  test('should list available profiles', async () => {\n    const manager = new PromptConfigManager(configPath);\n    await manager.loadConfig();\n\n    const profiles = manager.listProfiles();\n    expect(profiles).toContain('sparc');\n    expect(profiles).toContain('templates');\n    expect(profiles).toContain('safe');\n    expect(profiles).toContain('fast');\n  });\n});\n\ndescribe('PromptValidator', () => {\n  let tempDir: string;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'validator-test-'));\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  test('should validate valid prompt file', async () => {\n    const filePath = path.join(tempDir, 'valid.md');\n    await fs.writeFile(filePath, '# Test Prompt\\nYou are an AI assistant.');\n\n    const result = await PromptValidator.validatePromptFile(filePath);\n\n    expect(result.valid).toBe(true);\n    expect(result.issues).toHaveLength(0);\n  });\n\n  test('should detect empty files', async () => {\n    const filePath = path.join(tempDir, 'empty.md');\n    await fs.writeFile(filePath, '');\n\n    const result = await PromptValidator.validatePromptFile(filePath);\n\n    expect(result.valid).toBe(false);\n    expect(result.issues).toContain('File is empty');\n  });\n\n  test('should extract front matter metadata', async () => {\n    const filePath = path.join(tempDir, 'with-metadata.md');\n    const content = `---\ntitle: Test Prompt\nversion: 1.0\n---\n\n# Test Prompt\nContent here`;\n\n    await fs.writeFile(filePath, content);\n\n    const result = await PromptValidator.validatePromptFile(filePath);\n\n    expect(result.metadata).toBeDefined();\n    expect(result.metadata.title).toBe('Test Prompt');\n    expect(result.metadata.version).toBe('1.0');\n  });\n\n  test('should warn about large files', async () => {\n    const filePath = path.join(tempDir, 'large.md');\n    const largeContent = '# Large Prompt\\n' + 'x'.repeat(200 * 1024); // 200KB\n\n    await fs.writeFile(filePath, largeContent);\n\n    const result = await PromptValidator.validatePromptFile(filePath);\n\n    expect(result.issues).toContain('File is unusually large for a prompt');\n  });\n});\n"],"names":["fs","path","os","copyPrompts","copyPromptsEnhanced","PromptConfigManager","PromptValidator","describe","tempDir","sourceDir","destDir","beforeEach","mkdtemp","join","tmpdir","mkdir","recursive","createTestFiles","afterEach","rm","force","testFiles","content","repeat","file","filePath","dir","dirname","writeFile","test","result","source","destination","expect","success","toBe","copiedFiles","failedFiles","destFiles","readdir","toHaveLength","includePatterns","excludePatterns","conflictResolution","skippedFiles","toBeGreaterThan","readFile","backupLocation","toBeDefined","backupDir","backupExists","access","then","catch","toContain","verify","originalStat","stat","jest","spyOn","mockImplementation","stats","includes","size","errors","length","phase","mockRestore","dryRun","totalFiles","progressUpdates","progressCallback","progress","push","percentage","i","parallel","maxWorkers","configPath","manager","config","loadConfig","defaultOptions","profiles","saveConfig","destinationDirectory","sparcProfile","getProfile","listProfiles","validatePromptFile","valid","issues","metadata","title","version","largeContent"],"mappings":"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"}