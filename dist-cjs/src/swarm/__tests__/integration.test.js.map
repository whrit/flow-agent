{"version":3,"sources":["../../../../src/swarm/__tests__/integration.test.ts"],"sourcesContent":["import { getErrorMessage } from '../utils/error-handler.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { PromptManager } from '../prompt-manager.js';\nimport { PromptConfigManager } from '../prompt-utils.js';\n\ndescribe('Prompt Copying Integration Tests', () => {\n  let tempDir: string;\n  let testManager: PromptManager;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'integration-test-'));\n\n    // Create test structure\n    const sourceDir = path.join(tempDir, 'source');\n    const destDir = path.join(tempDir, 'dest');\n\n    await fs.mkdir(sourceDir, { recursive: true });\n    await fs.mkdir(destDir, { recursive: true });\n\n    // Create test files\n    await createTestPromptStructure(sourceDir);\n\n    // Initialize manager\n    testManager = new PromptManager({\n      basePath: tempDir,\n      configPath: '.test-config.json',\n      autoDiscovery: false,\n    });\n\n    // Configure manager\n    await testManager.updateConfig({\n      sourceDirectories: ['source'],\n      destinationDirectory: 'dest',\n    });\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  async function createTestPromptStructure(sourceDir: string) {\n    const structure = {\n      'sparc/architect.md': '# Architect\\nSystem design expert.',\n      'sparc/tdd.md': '# TDD\\nTest-driven development.',\n      'sparc/code.md': '# Code\\nImplementation expert.',\n      'templates/api.md': '# API Template\\n{{endpoint}}',\n      'rules/general.md': '# Rules\\nGeneral guidelines.',\n      'invalid.md': '', // Empty file for validation testing\n      'large.md': 'Large content\\n'.repeat(100),\n    };\n\n    for (const [filePath, content] of Object.entries(structure)) {\n      const fullPath = path.join(sourceDir, filePath);\n      const dir = path.dirname(fullPath);\n\n      await fs.mkdir(dir, { recursive: true });\n      await fs.writeFile(fullPath, content);\n    }\n  }\n\n  test('should initialize and auto-discover prompt directories', async () => {\n    const discoveryManager = new PromptManager({\n      basePath: tempDir,\n      autoDiscovery: true,\n    });\n\n    await discoveryManager.initialize();\n\n    const config = discoveryManager.getConfig();\n    expect(config.sourceDirectories.length).toBeGreaterThan(0);\n  });\n\n  test('should copy prompts using different profiles', async () => {\n    await testManager.initialize();\n\n    // Test with safe profile\n    const safeResult = await testManager.copyPrompts({\n      conflictResolution: 'skip',\n      parallel: false,\n    });\n\n    expect(safeResult.success).toBe(true);\n    expect(safeResult.copiedFiles).toBeGreaterThan(0);\n\n    // Verify files exist\n    const destFiles = await fs.readdir(path.join(tempDir, 'dest'), { recursive: true });\n    expect(destFiles.length).toBeGreaterThan(0);\n  });\n\n  test('should validate prompts and generate reports', async () => {\n    await testManager.initialize();\n\n    // Copy files first\n    await testManager.copyPrompts();\n\n    // Validate prompts\n    const validation = await testManager.validatePrompts();\n\n    expect(validation.totalFiles).toBeGreaterThan(0);\n    expect(validation.validFiles).toBeGreaterThan(0);\n    expect(validation.invalidFiles).toBeGreaterThan(0); // Should find the empty file\n\n    // Check that empty file is flagged as invalid\n    const emptyFileIssue = validation.issues.find((issue) => issue.file.includes('invalid.md'));\n    expect(emptyFileIssue).toBeDefined();\n    expect(emptyFileIssue!.issues).toContain('File is empty');\n  });\n\n  test('should handle multiple sources', async () => {\n    // Create second source\n    const source2Dir = path.join(tempDir, 'source2');\n    await fs.mkdir(source2Dir, { recursive: true });\n    await fs.writeFile(path.join(source2Dir, 'extra.md'), '# Extra\\nExtra prompt.');\n\n    // Update config\n    await testManager.updateConfig({\n      sourceDirectories: ['source', 'source2'],\n    });\n\n    await testManager.initialize();\n\n    // Copy from multiple sources\n    const results = await testManager.copyFromMultipleSources();\n\n    expect(results.length).toBe(2);\n    expect(results.every((r) => r.success)).toBe(true);\n\n    // Verify files from both sources\n    const destFiles = await fs.readdir(path.join(tempDir, 'dest'), { recursive: true });\n    expect(destFiles).toContain('extra.md');\n  });\n\n  test('should generate comprehensive system report', async () => {\n    await testManager.initialize();\n    await testManager.copyPrompts();\n\n    const report = await testManager.generateReport();\n\n    expect(report.configuration).toBeDefined();\n    expect(report.sources).toBeDefined();\n    expect(report.sources.length).toBeGreaterThan(0);\n\n    // Check source analysis\n    const sourceInfo = report.sources[0];\n    expect(sourceInfo.exists).toBe(true);\n    expect(sourceInfo.fileCount).toBeGreaterThan(0);\n    expect(sourceInfo.totalSize).toBeGreaterThan(0);\n  });\n\n  test('should handle configuration persistence', async () => {\n    const configManager = new PromptConfigManager(path.join(tempDir, '.test-config.json'));\n\n    // Save custom config\n    await configManager.saveConfig({\n      destinationDirectory: './custom-dest',\n      defaultOptions: {\n        maxWorkers: 8,\n        conflictResolution: 'merge',\n      },\n    });\n\n    // Load config in new instance\n    const newConfigManager = new PromptConfigManager(path.join(tempDir, '.test-config.json'));\n\n    const config = await newConfigManager.loadConfig();\n\n    expect(config.destinationDirectory).toBe('./custom-dest');\n    expect(config.defaultOptions.maxWorkers).toBe(8);\n    expect(config.defaultOptions.conflictResolution).toBe('merge');\n  });\n\n  test('should handle errors gracefully', async () => {\n    // Test with invalid source directory\n    await testManager.updateConfig({\n      sourceDirectories: ['nonexistent'],\n    });\n\n    await testManager.initialize();\n\n    // Should not throw but return failed result\n    const result = await testManager.copyPrompts();\n\n    // The result should indicate failure or no files copied\n    expect(result.copiedFiles).toBe(0);\n  });\n\n  test('should support incremental sync', async () => {\n    await testManager.initialize();\n\n    // Initial copy\n    const firstResult = await testManager.copyPrompts();\n    expect(firstResult.success).toBe(true);\n\n    // Modify source file\n    const sourceFile = path.join(tempDir, 'source', 'sparc', 'architect.md');\n    await fs.writeFile(sourceFile, '# Modified Architect\\nUpdated content.');\n\n    // Sync should detect changes\n    const syncResult = await testManager.syncPrompts({\n      incrementalOnly: true,\n      compareHashes: true,\n    });\n\n    expect(syncResult.forward.success).toBe(true);\n  });\n\n  test('should respect include/exclude patterns', async () => {\n    await testManager.initialize();\n\n    // Copy only .md files from sparc directory\n    const result = await testManager.copyPrompts({\n      includePatterns: ['**/sparc/*.md'],\n      excludePatterns: ['**/tdd.md'],\n    });\n\n    expect(result.success).toBe(true);\n\n    // Check that only architect.md and code.md were copied\n    const sparcDir = path.join(tempDir, 'dest', 'sparc');\n    const sparcFiles = await fs.readdir(sparcDir).catch(() => []);\n\n    expect(sparcFiles).toContain('architect.md');\n    expect(sparcFiles).toContain('code.md');\n    expect(sparcFiles).not.toContain('tdd.md');\n  });\n\n  test('should handle concurrent operations', async () => {\n    await testManager.initialize();\n\n    // Start multiple copy operations\n    const operations = [\n      testManager.copyPrompts({ destination: path.join(tempDir, 'dest1') }),\n      testManager.copyPrompts({ destination: path.join(tempDir, 'dest2') }),\n      testManager.copyPrompts({ destination: path.join(tempDir, 'dest3') }),\n    ];\n\n    const results = await Promise.all(operations);\n\n    // All operations should succeed\n    expect(results.every((r) => r.success)).toBe(true);\n\n    // Verify all destinations have files\n    for (let i = 1; i <= 3; i++) {\n      const destDir = path.join(tempDir, `dest${i}`);\n      const files = await fs.readdir(destDir, { recursive: true });\n      expect(files.length).toBeGreaterThan(0);\n    }\n  });\n});\n"],"names":["fs","path","os","PromptManager","PromptConfigManager","describe","tempDir","testManager","beforeEach","mkdtemp","join","tmpdir","sourceDir","destDir","mkdir","recursive","createTestPromptStructure","basePath","configPath","autoDiscovery","updateConfig","sourceDirectories","destinationDirectory","afterEach","rm","force","structure","repeat","filePath","content","Object","entries","fullPath","dir","dirname","writeFile","test","discoveryManager","initialize","config","getConfig","expect","length","toBeGreaterThan","safeResult","copyPrompts","conflictResolution","parallel","success","toBe","copiedFiles","destFiles","readdir","validation","validatePrompts","totalFiles","validFiles","invalidFiles","emptyFileIssue","issues","find","issue","file","includes","toBeDefined","toContain","source2Dir","results","copyFromMultipleSources","every","r","report","generateReport","configuration","sources","sourceInfo","exists","fileCount","totalSize","configManager","saveConfig","defaultOptions","maxWorkers","newConfigManager","loadConfig","result","firstResult","sourceFile","syncResult","syncPrompts","incrementalOnly","compareHashes","forward","includePatterns","excludePatterns","sparcDir","sparcFiles","catch","not","operations","destination","Promise","all","i","files"],"mappings":"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"}