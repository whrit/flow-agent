{"version":3,"sources":["../../../src/swarm/prompt-manager.ts"],"sourcesContent":["import * as path from 'path';\nimport { EventEmitter } from 'events';\nimport { copyPromptsEnhanced, EnhancedPromptCopier } from './prompt-copier-enhanced.js';\nimport type { CopyOptions, CopyResult } from './prompt-copier.js';\nimport {\n  PromptConfigManager,\n  PromptPathResolver,\n  PromptValidator,\n  formatDuration,\n  formatFileSize,\n} from './prompt-utils.js';\nimport { logger } from '../core/logger.js';\n\nexport interface PromptManagerOptions {\n  configPath?: string;\n  basePath?: string;\n  autoDiscovery?: boolean;\n  defaultProfile?: string;\n}\n\nexport interface SyncOptions {\n  bidirectional?: boolean;\n  deleteOrphaned?: boolean;\n  compareHashes?: boolean;\n  incrementalOnly?: boolean;\n}\n\nexport interface ValidationReport {\n  totalFiles: number;\n  validFiles: number;\n  invalidFiles: number;\n  issues: Array<{\n    file: string;\n    issues: string[];\n    metadata?: any;\n  }>;\n}\n\nexport class PromptManager extends EventEmitter {\n  private configManager: PromptConfigManager;\n  private pathResolver: PromptPathResolver;\n  private options: Required<PromptManagerOptions>;\n\n  constructor(options: PromptManagerOptions = {}) {\n    super();\n\n    this.options = {\n      configPath: options.configPath || '.prompt-config.json',\n      basePath: options.basePath || process.cwd(),\n      autoDiscovery: options.autoDiscovery ?? true,\n      defaultProfile: options.defaultProfile || 'sparc',\n    };\n\n    this.configManager = new PromptConfigManager(\n      path.resolve(this.options.basePath, this.options.configPath),\n    );\n    this.pathResolver = new PromptPathResolver(this.options.basePath);\n  }\n\n  async initialize(): Promise<void> {\n    logger.info('Initializing PromptManager...');\n\n    // Load configuration\n    await this.configManager.loadConfig();\n\n    // Auto-discover prompt directories if enabled\n    if (this.options.autoDiscovery) {\n      const discovered = await this.pathResolver.discoverPromptDirectories();\n      if (discovered.length > 0) {\n        logger.info(`Auto-discovered ${discovered.length} prompt directories`);\n\n        // Update config with discovered directories\n        const config = this.configManager.getConfig();\n        const uniqueDirs = Array.from(\n          new Set([\n            ...config.sourceDirectories,\n            ...discovered.map((dir) => path.relative(this.options.basePath, dir)),\n          ]),\n        );\n\n        await this.configManager.saveConfig({\n          sourceDirectories: uniqueDirs,\n        });\n      }\n    }\n\n    this.emit('initialized');\n  }\n\n  async copyPrompts(options: Partial<CopyOptions> = {}): Promise<CopyResult> {\n    const config = this.configManager.getConfig();\n    const profile = this.options.defaultProfile;\n\n    // Resolve paths\n    const resolved = this.pathResolver.resolvePaths(\n      config.sourceDirectories,\n      config.destinationDirectory,\n    );\n\n    if (resolved.sources.length === 0) {\n      throw new Error('No valid source directories found');\n    }\n\n    // Build copy options\n    const copyOptions: CopyOptions = {\n      source: resolved.sources[0], // Use first available source\n      destination: resolved.destination,\n      ...this.configManager.getProfile(profile),\n      ...options,\n    };\n\n    logger.info('Starting prompt copy operation', {\n      source: copyOptions.source,\n      destination: copyOptions.destination,\n      profile,\n    });\n\n    this.emit('copyStart', copyOptions);\n\n    try {\n      const result = await (copyOptions.parallel\n        ? copyPromptsEnhanced(copyOptions)\n        : copyPrompts(copyOptions));\n\n      this.emit('copyComplete', result);\n      return result;\n    } catch (error) {\n      this.emit('copyError', error);\n      throw error;\n    }\n  }\n\n  async copyFromMultipleSources(options: Partial<CopyOptions> = {}): Promise<CopyResult[]> {\n    const config = this.configManager.getConfig();\n    const resolved = this.pathResolver.resolvePaths(\n      config.sourceDirectories,\n      config.destinationDirectory,\n    );\n\n    const results: CopyResult[] = [];\n\n    for (const source of resolved.sources) {\n      try {\n        const copyOptions: CopyOptions = {\n          source,\n          destination: resolved.destination,\n          ...this.configManager.getProfile(this.options.defaultProfile),\n          ...options,\n        };\n\n        logger.info(`Copying from source: ${source}`);\n        const result = await copyPrompts(copyOptions);\n        results.push(result);\n\n        this.emit('sourceComplete', { source, result });\n      } catch (error) {\n        logger.error(`Failed to copy from ${source}:`, error);\n        this.emit('sourceError', { source, error });\n\n        // Add error result\n        results.push({\n          success: false,\n          totalFiles: 0,\n          copiedFiles: 0,\n          failedFiles: 0,\n          skippedFiles: 0,\n          errors: [\n            {\n              file: source,\n              error: error instanceof Error ? error.message : String(error),\n              phase: 'read',\n            },\n          ],\n          duration: 0,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  async validatePrompts(sourcePath?: string): Promise<ValidationReport> {\n    const config = this.configManager.getConfig();\n    const sources = sourcePath ? [sourcePath] : config.sourceDirectories;\n\n    const resolved = this.pathResolver.resolvePaths(sources, config.destinationDirectory);\n\n    let totalFiles = 0;\n    let validFiles = 0;\n    let invalidFiles = 0;\n    const issues: ValidationReport['issues'] = [];\n\n    for (const source of resolved.sources) {\n      await this.validateDirectory(source, issues);\n    }\n\n    totalFiles = issues.length;\n    validFiles = issues.filter((issue) => issue.issues.length === 0).length;\n    invalidFiles = totalFiles - validFiles;\n\n    const report: ValidationReport = {\n      totalFiles,\n      validFiles,\n      invalidFiles,\n      issues: issues.filter((issue) => issue.issues.length > 0), // Only include files with issues\n    };\n\n    this.emit('validationComplete', report);\n    return report;\n  }\n\n  private async validateDirectory(\n    dirPath: string,\n    issues: ValidationReport['issues'],\n  ): Promise<void> {\n    const fs = require('fs').promises;\n\n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n\n        if (entry.isFile() && this.isPromptFile(entry.name)) {\n          const result = await PromptValidator.validatePromptFile(fullPath);\n\n          issues.push({\n            file: fullPath,\n            issues: result.issues,\n            metadata: result.metadata,\n          });\n        } else if (entry.isDirectory()) {\n          await this.validateDirectory(fullPath, issues);\n        }\n      }\n    } catch (error) {\n      logger.error(`Failed to validate directory ${dirPath}:`, error);\n    }\n  }\n\n  private isPromptFile(fileName: string): boolean {\n    const config = this.configManager.getConfig();\n    const patterns = config.defaultOptions.includePatterns;\n\n    return patterns.some((pattern) => {\n      const regex = pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*');\n      return new RegExp(regex).test(fileName);\n    });\n  }\n\n  async syncPrompts(options: SyncOptions = {}): Promise<{\n    forward: CopyResult;\n    backward?: CopyResult;\n  }> {\n    const config = this.configManager.getConfig();\n    const resolved = this.pathResolver.resolvePaths(\n      config.sourceDirectories,\n      config.destinationDirectory,\n    );\n\n    const syncOptions: SyncOptions = {\n      bidirectional: false,\n      deleteOrphaned: false,\n      compareHashes: true,\n      incrementalOnly: true,\n      ...options,\n    };\n\n    // Forward sync (source to destination)\n    const forwardResult = await this.performIncrementalSync(\n      resolved.sources[0],\n      resolved.destination,\n      syncOptions,\n    );\n\n    let backwardResult: CopyResult | undefined;\n\n    // Backward sync if bidirectional\n    if (syncOptions.bidirectional) {\n      backwardResult = await this.performIncrementalSync(\n        resolved.destination,\n        resolved.sources[0],\n        syncOptions,\n      );\n    }\n\n    return {\n      forward: forwardResult,\n      backward: backwardResult,\n    };\n  }\n\n  private async performIncrementalSync(\n    source: string,\n    destination: string,\n    options: SyncOptions,\n  ): Promise<CopyResult> {\n    // This would implement incremental sync logic\n    // For now, we'll use the regular copy with overwrite\n    return copyPrompts({\n      source,\n      destination,\n      conflictResolution: 'overwrite',\n      verify: options.compareHashes,\n    });\n  }\n\n  async generateReport(): Promise<{\n    configuration: any;\n    sources: Array<{\n      path: string;\n      exists: boolean;\n      fileCount?: number;\n      totalSize?: number;\n    }>;\n    validation?: ValidationReport;\n    lastOperation?: {\n      type: string;\n      timestamp: Date;\n      result: any;\n    };\n  }> {\n    const config = this.configManager.getConfig();\n    const resolved = this.pathResolver.resolvePaths(\n      config.sourceDirectories,\n      config.destinationDirectory,\n    );\n\n    // Analyze sources\n    const sources = await Promise.all(\n      resolved.sources.map(async (sourcePath) => {\n        try {\n          const fs = require('fs').promises;\n          const stats = await fs.stat(sourcePath);\n\n          if (!stats.isDirectory()) {\n            return { path: sourcePath, exists: false };\n          }\n\n          // Count files and calculate total size\n          let fileCount = 0;\n          let totalSize = 0;\n\n          const scanDir = async (dir: string) => {\n            const entries = await fs.readdir(dir, { withFileTypes: true });\n\n            for (const entry of entries) {\n              const fullPath = path.join(dir, entry.name);\n\n              if (entry.isFile() && this.isPromptFile(entry.name)) {\n                const fileStats = await fs.stat(fullPath);\n                fileCount++;\n                totalSize += fileStats.size;\n              } else if (entry.isDirectory()) {\n                await scanDir(fullPath);\n              }\n            }\n          };\n\n          await scanDir(sourcePath);\n\n          return {\n            path: sourcePath,\n            exists: true,\n            fileCount,\n            totalSize,\n          };\n        } catch {\n          return { path: sourcePath, exists: false };\n        }\n      }),\n    );\n\n    return {\n      configuration: config,\n      sources,\n    };\n  }\n\n  // Utility methods\n  getConfig() {\n    return this.configManager.getConfig();\n  }\n\n  async updateConfig(updates: any): Promise<void> {\n    await this.configManager.saveConfig(updates);\n  }\n\n  getProfiles(): string[] {\n    return this.configManager.listProfiles();\n  }\n\n  getProfile(name: string) {\n    return this.configManager.getProfile(name);\n  }\n\n  async discoverPromptDirectories(): Promise<string[]> {\n    return this.pathResolver.discoverPromptDirectories();\n  }\n}\n\n// Export factory function\nexport function createPromptManager(options?: PromptManagerOptions): PromptManager {\n  return new PromptManager(options);\n}\n\n// Export singleton instance\nlet defaultManager: PromptManager | null = null;\n\nexport function getDefaultPromptManager(): PromptManager {\n  if (!defaultManager) {\n    defaultManager = new PromptManager();\n  }\n  return defaultManager;\n}\n"],"names":["path","EventEmitter","copyPromptsEnhanced","PromptConfigManager","PromptPathResolver","PromptValidator","logger","PromptManager","configManager","pathResolver","options","configPath","basePath","process","cwd","autoDiscovery","defaultProfile","resolve","initialize","info","loadConfig","discovered","discoverPromptDirectories","length","config","getConfig","uniqueDirs","Array","from","Set","sourceDirectories","map","dir","relative","saveConfig","emit","copyPrompts","profile","resolved","resolvePaths","destinationDirectory","sources","Error","copyOptions","source","destination","getProfile","result","parallel","error","copyFromMultipleSources","results","push","success","totalFiles","copiedFiles","failedFiles","skippedFiles","errors","file","message","String","phase","duration","validatePrompts","sourcePath","validFiles","invalidFiles","issues","validateDirectory","filter","issue","report","dirPath","fs","require","promises","entries","readdir","withFileTypes","entry","fullPath","join","name","isFile","isPromptFile","validatePromptFile","metadata","isDirectory","fileName","patterns","defaultOptions","includePatterns","some","pattern","regex","replace","RegExp","test","syncPrompts","syncOptions","bidirectional","deleteOrphaned","compareHashes","incrementalOnly","forwardResult","performIncrementalSync","backwardResult","forward","backward","conflictResolution","verify","generateReport","Promise","all","stats","stat","exists","fileCount","totalSize","scanDir","fileStats","size","configuration","updateConfig","updates","getProfiles","listProfiles","createPromptManager","defaultManager","getDefaultPromptManager"],"mappings":"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"}