{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/neural-hooks.ts"],"sourcesContent":["/**\n * Neural training hooks for agentic-flow\n * \n * Enables learning from multi-model responses with\n * pattern detection and adaptive optimization.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  NeuralHookPayload,\n  Pattern,\n  TrainingData,\n  Prediction,\n  Adaptation,\n  SideEffect,\n} from './types.js';\n\n// ===== Pre-Neural Train Hook =====\n\nexport const preNeuralTrainHook = {\n  id: 'agentic-pre-neural-train',\n  type: 'pre-neural-train' as const,\n  priority: 100,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { operation, modelId, trainingData } = payload;\n    \n    if (operation !== 'train' || !trainingData) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate training data\n    const validation = validateTrainingData(trainingData);\n    if (!validation.valid) {\n      return {\n        continue: false,\n        sideEffects: [\n          {\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'error',\n              message: 'Invalid training data',\n              data: validation,\n            },\n          },\n        ],\n      };\n    }\n    \n    // Augment training data with historical patterns\n    const augmentedData = await augmentTrainingData(\n      trainingData,\n      modelId,\n      context\n    );\n    \n    // Balance dataset if needed\n    const balancedData = balanceTrainingData(augmentedData);\n    \n    // Apply data preprocessing\n    const preprocessedData = preprocessTrainingData(balancedData);\n    \n    // Store training session metadata\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `neural:training:${modelId}:${Date.now()}`,\n        value: {\n          originalSize: trainingData.inputs.length,\n          augmentedSize: augmentedData.inputs.length,\n          balancedSize: balancedData.inputs.length,\n          epochs: balancedData.epochs,\n          timestamp: Date.now(),\n        },\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        trainingData: preprocessedData,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Post-Neural Train Hook =====\n\nexport const postNeuralTrainHook = {\n  id: 'agentic-post-neural-train',\n  type: 'post-neural-train' as const,\n  priority: 100,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { modelId, accuracy, trainingData } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Store training results\n    const trainingResult = {\n      modelId,\n      accuracy,\n      timestamp: Date.now(),\n      sessionId: context.sessionId,\n      dataSize: trainingData?.inputs.length || 0,\n      epochs: trainingData?.epochs || 0,\n    };\n    \n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `neural:results:${modelId}:${Date.now()}`,\n        value: trainingResult,\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Update model performance history\n    await updateModelPerformance(modelId, accuracy, context);\n    \n    // Check if model should be promoted\n    const shouldPromote = await evaluateModelPromotion(modelId, accuracy, context);\n    if (shouldPromote) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'neural:model:promoted',\n          data: { modelId, accuracy },\n        },\n      });\n    }\n    \n    // Extract learned patterns\n    const patterns = await extractLearnedPatterns(modelId, context);\n    if (patterns.length > 0) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'store-patterns',\n        data: { patterns },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Neural Pattern Detected Hook =====\n\nexport const neuralPatternDetectedHook = {\n  id: 'agentic-neural-pattern-detected',\n  type: 'neural-pattern-detected' as const,\n  priority: 90,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { patterns } = payload;\n    \n    if (!patterns || patterns.length === 0) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Analyze pattern significance\n    for (const pattern of patterns) {\n      const significance = calculatePatternSignificance(pattern);\n      \n      if (significance > 0.7) {\n        // High significance pattern\n        sideEffects.push({\n          type: 'memory',\n          action: 'store',\n          data: {\n            key: `pattern:significant:${pattern.id}`,\n            value: {\n              pattern,\n              significance,\n              detectedAt: Date.now(),\n              context: context.metadata,\n            },\n            ttl: 0, // Permanent\n          },\n        });\n        \n        // Trigger adaptation if needed\n        const adaptation = await generateAdaptation(pattern, context);\n        if (adaptation) {\n          sideEffects.push({\n            type: 'neural',\n            action: 'adapt',\n            data: { adaptation },\n          });\n        }\n      }\n      \n      // Update pattern store\n      context.neural.patterns.add(pattern);\n    }\n    \n    // Check for pattern combinations\n    const combinations = findPatternCombinations(patterns, context);\n    if (combinations.length > 0) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Pattern combinations detected',\n          data: { combinations },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Neural Prediction Hook =====\n\nexport const neuralPredictionHook = {\n  id: 'agentic-neural-prediction',\n  type: 'neural-prediction' as const,\n  priority: 100,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { prediction, modelId } = payload;\n    \n    if (!prediction) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate prediction confidence\n    if (prediction.confidence < 0.5) {\n      // Low confidence - consider alternatives\n      const alternatives = await generateAlternatives(\n        prediction.input,\n        modelId,\n        context\n      );\n      \n      if (alternatives.length > 0) {\n        return {\n          continue: true,\n          modified: true,\n          payload: {\n            ...payload,\n            prediction: {\n              ...prediction,\n              alternatives: [...prediction.alternatives, ...alternatives],\n            },\n          },\n          sideEffects: [\n            {\n              type: 'metric',\n              action: 'increment',\n              data: { name: 'neural.predictions.low_confidence' },\n            },\n          ],\n        };\n      }\n    }\n    \n    // Store prediction for future training\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `prediction:${modelId}:${Date.now()}`,\n        value: {\n          input: prediction.input,\n          output: prediction.output,\n          confidence: prediction.confidence,\n          timestamp: Date.now(),\n        },\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    // Track prediction metrics\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `neural.predictions.confidence.${modelId}`,\n        value: prediction.confidence,\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Neural Adaptation Hook =====\n\nexport const neuralAdaptationHook = {\n  id: 'agentic-neural-adaptation',\n  type: 'neural-adaptation' as const,\n  priority: 90,\n  handler: async (\n    payload: NeuralHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { adaptations, modelId } = payload;\n    \n    if (!adaptations || adaptations.length === 0) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate adaptations\n    const validAdaptations = adaptations.filter(a => \n      validateAdaptation(a, modelId, context)\n    );\n    \n    if (validAdaptations.length === 0) {\n      return { continue: true };\n    }\n    \n    // Apply adaptations in order of impact\n    const sortedAdaptations = validAdaptations.sort((a, b) => \n      Math.abs(b.impact) - Math.abs(a.impact)\n    );\n    \n    for (const adaptation of sortedAdaptations) {\n      // Store adaptation history\n      sideEffects.push({\n        type: 'memory',\n        action: 'store',\n        data: {\n          key: `adaptation:${modelId}:${adaptation.target}:${Date.now()}`,\n          value: adaptation,\n          ttl: 604800, // 7 days\n        },\n      });\n      \n      // Apply adaptation based on type\n      switch (adaptation.type) {\n        case 'parameter':\n          await applyParameterAdaptation(adaptation, modelId, context);\n          break;\n          \n        case 'architecture':\n          await applyArchitectureAdaptation(adaptation, modelId, context);\n          break;\n          \n        case 'strategy':\n          await applyStrategyAdaptation(adaptation, modelId, context);\n          break;\n      }\n      \n      // Track adaptation metrics\n      sideEffects.push({\n        type: 'metric',\n        action: 'increment',\n        data: { name: `neural.adaptations.${adaptation.type}` },\n      });\n    }\n    \n    // Trigger retraining if significant adaptations\n    const totalImpact = sortedAdaptations.reduce((sum, a) => \n      sum + Math.abs(a.impact), 0\n    );\n    \n    if (totalImpact > 0.5) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'retrain',\n        data: {\n          modelId,\n          reason: 'significant_adaptations',\n          adaptations: sortedAdaptations.length,\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nfunction validateTrainingData(data: TrainingData): { valid: boolean; errors?: string[] } {\n  const errors: string[] = [];\n  \n  if (!data.inputs || data.inputs.length === 0) {\n    errors.push('No input data provided');\n  }\n  \n  if (!data.outputs || data.outputs.length === 0) {\n    errors.push('No output data provided');\n  }\n  \n  if (data.inputs.length !== data.outputs.length) {\n    errors.push('Input and output lengths do not match');\n  }\n  \n  if (data.batchSize <= 0) {\n    errors.push('Invalid batch size');\n  }\n  \n  if (data.epochs <= 0) {\n    errors.push('Invalid number of epochs');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors: errors.length > 0 ? errors : undefined,\n  };\n}\n\nasync function augmentTrainingData(\n  data: TrainingData,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<TrainingData> {\n  // Augment with historical successful patterns\n  const historicalPatterns = await loadHistoricalPatterns(modelId, context);\n  \n  const augmented: TrainingData = {\n    ...data,\n    inputs: [...data.inputs],\n    outputs: [...data.outputs],\n    labels: data.labels ? [...data.labels] : undefined,\n    weights: data.weights ? [...data.weights] : undefined,\n  };\n  \n  // Add successful patterns\n  for (const pattern of historicalPatterns) {\n    if (pattern.type === 'success' && pattern.confidence > 0.8) {\n      augmented.inputs.push(pattern.context.input);\n      augmented.outputs.push(pattern.context.output);\n      \n      if (augmented.weights) {\n        // Give higher weight to successful patterns\n        augmented.weights.push(pattern.confidence);\n      }\n    }\n  }\n  \n  return augmented;\n}\n\nfunction balanceTrainingData(data: TrainingData): TrainingData {\n  // Balance dataset to prevent bias\n  if (!data.labels) {\n    return data;\n  }\n  \n  // Count occurrences of each label\n  const labelCounts = new Map<string, number>();\n  for (const label of data.labels) {\n    labelCounts.set(label, (labelCounts.get(label) || 0) + 1);\n  }\n  \n  // Find minimum count\n  const minCount = Math.min(...labelCounts.values());\n  \n  // Balance by undersampling\n  const balanced: TrainingData = {\n    ...data,\n    inputs: [],\n    outputs: [],\n    labels: [],\n    weights: data.weights ? [] : undefined,\n  };\n  \n  const labelIndices = new Map<string, number[]>();\n  data.labels.forEach((label, i) => {\n    if (!labelIndices.has(label)) {\n      labelIndices.set(label, []);\n    }\n    labelIndices.get(label)!.push(i);\n  });\n  \n  // Sample equally from each label\n  for (const [label, indices] of labelIndices.entries()) {\n    const sampled = indices\n      .sort(() => Math.random() - 0.5)\n      .slice(0, minCount);\n    \n    for (const idx of sampled) {\n      balanced.inputs.push(data.inputs[idx]);\n      balanced.outputs.push(data.outputs[idx]);\n      balanced.labels!.push(label);\n      \n      if (data.weights && balanced.weights) {\n        balanced.weights.push(data.weights[idx]);\n      }\n    }\n  }\n  \n  return balanced;\n}\n\nfunction preprocessTrainingData(data: TrainingData): TrainingData {\n  // Apply preprocessing transformations\n  const processed: TrainingData = {\n    ...data,\n    inputs: data.inputs.map(input => normalizeInput(input)),\n    outputs: data.outputs.map(output => normalizeOutput(output)),\n  };\n  \n  return processed;\n}\n\nfunction normalizeInput(input: any): any {\n  // Normalize input data\n  // Placeholder - actual implementation would depend on data type\n  return input;\n}\n\nfunction normalizeOutput(output: any): any {\n  // Normalize output data\n  // Placeholder - actual implementation would depend on data type\n  return output;\n}\n\nasync function updateModelPerformance(\n  modelId: string,\n  accuracy: number,\n  context: AgenticHookContext\n): Promise<void> {\n  const perfKey = `model:performance:${modelId}`;\n  const history = await context.memory.cache.get(perfKey) || [];\n  \n  history.push({\n    accuracy,\n    timestamp: Date.now(),\n    sessionId: context.sessionId,\n  });\n  \n  // Keep last 100 performance records\n  if (history.length > 100) {\n    history.shift();\n  }\n  \n  await context.memory.cache.set(perfKey, history);\n}\n\nasync function evaluateModelPromotion(\n  modelId: string,\n  accuracy: number,\n  context: AgenticHookContext\n): Promise<boolean> {\n  // Check if model should be promoted to production\n  const perfKey = `model:performance:${modelId}`;\n  const history = await context.memory.cache.get(perfKey) || [];\n  \n  if (history.length < 10) {\n    return false; // Not enough history\n  }\n  \n  // Calculate average accuracy over last 10 runs\n  const recent = history.slice(-10);\n  const avgAccuracy = recent.reduce((sum: number, h: any) => \n    sum + h.accuracy, 0\n  ) / recent.length;\n  \n  // Promote if consistently above threshold\n  return avgAccuracy > 0.85 && accuracy > 0.85;\n}\n\nasync function extractLearnedPatterns(\n  modelId: string,\n  context: AgenticHookContext\n): Promise<Pattern[]> {\n  // Extract patterns learned during training\n  // Placeholder implementation\n  return [];\n}\n\nfunction calculatePatternSignificance(pattern: Pattern): number {\n  // Calculate pattern significance score\n  const baseScore = pattern.confidence;\n  const occurrenceBonus = Math.min(pattern.occurrences / 100, 0.2);\n  \n  return Math.min(baseScore + occurrenceBonus, 1.0);\n}\n\nasync function generateAdaptation(\n  pattern: Pattern,\n  context: AgenticHookContext\n): Promise<Adaptation | null> {\n  // Generate adaptation based on pattern\n  if (pattern.type === 'failure' && pattern.confidence > 0.8) {\n    return {\n      type: 'parameter',\n      target: 'learning_rate',\n      oldValue: context.neural.training.learningRate,\n      newValue: context.neural.training.learningRate * 0.9,\n      reason: `High confidence failure pattern detected: ${pattern.id}`,\n      impact: -0.1,\n    };\n  }\n  \n  if (pattern.type === 'optimization' && pattern.confidence > 0.9) {\n    return {\n      type: 'strategy',\n      target: 'batch_size',\n      oldValue: 32,\n      newValue: 64,\n      reason: `Optimization opportunity detected: ${pattern.id}`,\n      impact: 0.2,\n    };\n  }\n  \n  return null;\n}\n\nfunction findPatternCombinations(\n  patterns: Pattern[],\n  context: AgenticHookContext\n): Array<{ patterns: Pattern[]; significance: number }> {\n  const combinations: Array<{ patterns: Pattern[]; significance: number }> = [];\n  \n  // Find co-occurring patterns\n  for (let i = 0; i < patterns.length; i++) {\n    for (let j = i + 1; j < patterns.length; j++) {\n      const pattern1 = patterns[i];\n      const pattern2 = patterns[j];\n      \n      // Check if patterns are related\n      if (areRelatedPatterns(pattern1, pattern2)) {\n        const significance = \n          (pattern1.confidence + pattern2.confidence) / 2 * 1.2;\n        \n        combinations.push({\n          patterns: [pattern1, pattern2],\n          significance: Math.min(significance, 1.0),\n        });\n      }\n    }\n  }\n  \n  return combinations;\n}\n\nfunction areRelatedPatterns(p1: Pattern, p2: Pattern): boolean {\n  // Check if patterns are related\n  // Simplified implementation\n  return p1.type === p2.type || \n    Object.keys(p1.context).some(key => key in p2.context);\n}\n\nasync function generateAlternatives(\n  input: any,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<Array<{ output: any; confidence: number }>> {\n  // Generate alternative predictions\n  // Placeholder implementation\n  return [];\n}\n\nfunction validateAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): boolean {\n  // Validate adaptation is safe to apply\n  if (Math.abs(adaptation.impact) > 0.5) {\n    // Large impact adaptations need more validation\n    return context.neural.training.epoch > 10;\n  }\n  \n  return true;\n}\n\nasync function applyParameterAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply parameter adaptation\n  // Placeholder implementation\n}\n\nasync function applyArchitectureAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply architecture adaptation\n  // Placeholder implementation\n}\n\nasync function applyStrategyAdaptation(\n  adaptation: Adaptation,\n  modelId: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply strategy adaptation\n  // Placeholder implementation\n}\n\nasync function loadHistoricalPatterns(\n  modelId: string,\n  context: AgenticHookContext\n): Promise<Pattern[]> {\n  // Load historical patterns\n  const patterns: Pattern[] = [];\n  \n  // Get recent patterns from memory\n  const patternKeys = await context.memory.cache.get(`patterns:${modelId}`) || [];\n  \n  for (const key of patternKeys.slice(-100)) {\n    const pattern = await context.memory.cache.get(key);\n    if (pattern) {\n      patterns.push(pattern);\n    }\n  }\n  \n  return patterns;\n}\n\n// ===== Register Hooks =====\n\nexport function registerNeuralHooks(): void {\n  agenticHookManager.register(preNeuralTrainHook);\n  agenticHookManager.register(postNeuralTrainHook);\n  agenticHookManager.register(neuralPatternDetectedHook);\n  agenticHookManager.register(neuralPredictionHook);\n  agenticHookManager.register(neuralAdaptationHook);\n}"],"names":["agenticHookManager","preNeuralTrainHook","id","type","priority","handler","payload","context","operation","modelId","trainingData","continue","sideEffects","validation","validateTrainingData","valid","action","data","level","message","augmentedData","augmentTrainingData","balancedData","balanceTrainingData","preprocessedData","preprocessTrainingData","push","key","Date","now","value","originalSize","inputs","length","augmentedSize","balancedSize","epochs","timestamp","ttl","modified","postNeuralTrainHook","accuracy","trainingResult","sessionId","dataSize","updateModelPerformance","shouldPromote","evaluateModelPromotion","event","patterns","extractLearnedPatterns","neuralPatternDetectedHook","pattern","significance","calculatePatternSignificance","detectedAt","metadata","adaptation","generateAdaptation","neural","add","combinations","findPatternCombinations","neuralPredictionHook","prediction","confidence","alternatives","generateAlternatives","input","name","output","neuralAdaptationHook","adaptations","validAdaptations","filter","a","validateAdaptation","sortedAdaptations","sort","b","Math","abs","impact","target","applyParameterAdaptation","applyArchitectureAdaptation","applyStrategyAdaptation","totalImpact","reduce","sum","reason","errors","outputs","batchSize","undefined","historicalPatterns","loadHistoricalPatterns","augmented","labels","weights","labelCounts","Map","label","set","get","minCount","min","values","balanced","labelIndices","forEach","i","has","indices","entries","sampled","random","slice","idx","processed","map","normalizeInput","normalizeOutput","perfKey","history","memory","cache","shift","recent","avgAccuracy","h","baseScore","occurrenceBonus","occurrences","oldValue","training","learningRate","newValue","j","pattern1","pattern2","areRelatedPatterns","p1","p2","Object","keys","some","epoch","patternKeys","registerNeuralHooks","register"],"mappings":"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"}