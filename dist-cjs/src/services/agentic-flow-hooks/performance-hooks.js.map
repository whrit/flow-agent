{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/performance-hooks.ts"],"sourcesContent":["/**\n * Performance optimization hooks for agentic-flow\n * \n * Tracks metrics, identifies bottlenecks, and provides\n * optimization suggestions based on provider performance.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  PerformanceHookPayload,\n  PerformanceMetric,\n  BottleneckAnalysis,\n  OptimizationSuggestion,\n  SideEffect,\n} from './types.js';\n\n// ===== Performance Metric Hook =====\n\nexport const performanceMetricHook = {\n  id: 'agentic-performance-metric',\n  type: 'performance-metric' as const,\n  priority: 100,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { metric, value, unit, threshold } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Store metric\n    const metricData: PerformanceMetric = {\n      name: metric,\n      value,\n      unit,\n      timestamp: Date.now(),\n      tags: extractTags(payload.context),\n    };\n    \n    context.performance.metrics.set(metric, metricData);\n    \n    // Check threshold violations\n    if (threshold !== undefined) {\n      const violated = checkThreshold(value, threshold, payload.context);\n      \n      if (violated) {\n        sideEffects.push({\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'performance:threshold:violated',\n            data: {\n              metric,\n              value,\n              threshold,\n              unit,\n            },\n          },\n        });\n        \n        // Generate optimization suggestion\n        const suggestion = await generateOptimizationSuggestion(\n          metric,\n          value,\n          threshold,\n          context\n        );\n        \n        if (suggestion) {\n          context.performance.optimizations.push(suggestion);\n          sideEffects.push({\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'info',\n              message: 'Optimization suggestion generated',\n              data: suggestion,\n            },\n          });\n        }\n      }\n    }\n    \n    // Update rolling averages\n    await updateRollingAverages(metric, value, context);\n    \n    // Detect anomalies\n    const anomaly = await detectAnomaly(metric, value, context);\n    if (anomaly) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:anomaly:detected',\n          data: { metric, value, anomaly },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Performance Bottleneck Hook =====\n\nexport const performanceBottleneckHook = {\n  id: 'agentic-performance-bottleneck',\n  type: 'performance-bottleneck' as const,\n  priority: 90,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { bottleneck } = payload;\n    \n    if (!bottleneck) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Analyze bottleneck severity\n    const analysis: BottleneckAnalysis = {\n      component: bottleneck.location,\n      severity: mapSeverity(bottleneck.severity),\n      impact: bottleneck.severity / 10, // Normalize to 0-1\n      suggestions: bottleneck.suggestions,\n    };\n    \n    context.performance.bottlenecks.push(analysis);\n    \n    // Store for historical analysis\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `bottleneck:${analysis.component}:${Date.now()}`,\n        value: analysis,\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    // Check for recurring bottlenecks\n    const recurrence = await checkBottleneckRecurrence(\n      analysis.component,\n      context\n    );\n    \n    if (recurrence.count > 3) {\n      // Recurring bottleneck - escalate\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:bottleneck:recurring',\n          data: {\n            component: analysis.component,\n            occurrences: recurrence.count,\n            timespan: recurrence.timespan,\n          },\n        },\n      });\n      \n      // Generate advanced optimization\n      const optimization = await generateAdvancedOptimization(\n        analysis,\n        recurrence,\n        context\n      );\n      \n      if (optimization) {\n        context.performance.optimizations.push(optimization);\n      }\n    }\n    \n    // Correlate with other metrics\n    const correlations = await findMetricCorrelations(\n      analysis.component,\n      context\n    );\n    \n    if (correlations.length > 0) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Bottleneck correlations found',\n          data: { bottleneck: analysis, correlations },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Performance Optimization Hook =====\n\nexport const performanceOptimizationHook = {\n  id: 'agentic-performance-optimization',\n  type: 'performance-optimization' as const,\n  priority: 80,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { optimization } = payload;\n    \n    if (!optimization) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate optimization\n    const validation = await validateOptimization(optimization, context);\n    if (!validation.valid) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'warning',\n          message: 'Optimization validation failed',\n          data: { optimization, validation },\n        },\n      });\n      return { continue: true, sideEffects };\n    }\n    \n    // Simulate optimization impact\n    const simulation = await simulateOptimization(optimization, context);\n    \n    if (simulation.expectedImprovement < 0.1) {\n      // Low impact - skip\n      return { continue: true };\n    }\n    \n    // Store optimization recommendation\n    const recommendation = {\n      optimization,\n      simulation,\n      timestamp: Date.now(),\n      autoApply: optimization.applied && simulation.risk === 'low',\n    };\n    \n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `optimization:${optimization.type}:${Date.now()}`,\n        value: recommendation,\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Auto-apply low-risk optimizations\n    if (recommendation.autoApply) {\n      await applyOptimization(optimization, context);\n      \n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:optimization:applied',\n          data: { optimization, automatic: true },\n        },\n      });\n    } else {\n      // Queue for manual review\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:optimization:suggested',\n          data: { optimization, simulation },\n        },\n      });\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Performance Threshold Hook =====\n\nexport const performanceThresholdHook = {\n  id: 'agentic-performance-threshold',\n  type: 'performance-threshold' as const,\n  priority: 95,\n  handler: async (\n    payload: PerformanceHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { metric, value, threshold } = payload;\n    \n    if (threshold === undefined) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Dynamic threshold adjustment\n    const historicalData = await getMetricHistory(metric, context);\n    const adjustedThreshold = calculateDynamicThreshold(\n      threshold,\n      historicalData\n    );\n    \n    if (adjustedThreshold !== threshold) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Threshold dynamically adjusted',\n          data: {\n            metric,\n            original: threshold,\n            adjusted: adjustedThreshold,\n          },\n        },\n      });\n    }\n    \n    // Predict threshold violations\n    const prediction = await predictThresholdViolation(\n      metric,\n      value,\n      adjustedThreshold,\n      historicalData\n    );\n    \n    if (prediction.willViolate && prediction.confidence > 0.7) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'performance:threshold:predicted',\n          data: {\n            metric,\n            currentValue: value,\n            threshold: adjustedThreshold,\n            predictedTime: prediction.timeToViolation,\n            confidence: prediction.confidence,\n          },\n        },\n      });\n      \n      // Proactive optimization\n      const proactiveOpt = await generateProactiveOptimization(\n        metric,\n        prediction,\n        context\n      );\n      \n      if (proactiveOpt) {\n        context.performance.optimizations.push(proactiveOpt);\n      }\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nfunction extractTags(context: Record<string, any>): string[] {\n  const tags: string[] = [];\n  \n  if (context.provider) tags.push(`provider:${context.provider}`);\n  if (context.model) tags.push(`model:${context.model}`);\n  if (context.operation) tags.push(`op:${context.operation}`);\n  if (context.component) tags.push(`component:${context.component}`);\n  \n  return tags;\n}\n\nfunction checkThreshold(\n  value: number,\n  threshold: number,\n  context: Record<string, any>\n): boolean {\n  // Check if threshold is violated based on context\n  const operator = context.thresholdOperator || 'gt';\n  \n  switch (operator) {\n    case 'gt': return value > threshold;\n    case 'gte': return value >= threshold;\n    case 'lt': return value < threshold;\n    case 'lte': return value <= threshold;\n    case 'eq': return value === threshold;\n    case 'ne': return value !== threshold;\n    default: return value > threshold;\n  }\n}\n\nasync function generateOptimizationSuggestion(\n  metric: string,\n  value: number,\n  threshold: number,\n  context: AgenticHookContext\n): Promise<OptimizationSuggestion | null> {\n  // Generate optimization based on metric type\n  const metricType = getMetricType(metric);\n  \n  switch (metricType) {\n    case 'latency':\n      if (value > threshold * 2) {\n        return {\n          type: 'cache',\n          target: metric,\n          expectedImprovement: 50,\n          implementation: 'Enable response caching for frequently accessed data',\n          risk: 'low',\n        };\n      } else if (value > threshold * 1.5) {\n        return {\n          type: 'parallel',\n          target: metric,\n          expectedImprovement: 30,\n          implementation: 'Parallelize independent operations',\n          risk: 'medium',\n        };\n      }\n      break;\n      \n    case 'throughput':\n      if (value < threshold * 0.5) {\n        return {\n          type: 'batch',\n          target: metric,\n          expectedImprovement: 40,\n          implementation: 'Batch similar requests together',\n          risk: 'low',\n        };\n      }\n      break;\n      \n    case 'memory':\n      if (value > threshold * 0.9) {\n        return {\n          type: 'resource',\n          target: metric,\n          expectedImprovement: 20,\n          implementation: 'Implement memory pooling and recycling',\n          risk: 'medium',\n        };\n      }\n      break;\n  }\n  \n  return null;\n}\n\nasync function updateRollingAverages(\n  metric: string,\n  value: number,\n  context: AgenticHookContext\n): Promise<void> {\n  const avgKey = `avg:${metric}`;\n  const history = await context.memory.cache.get(avgKey) || [];\n  \n  history.push({ value, timestamp: Date.now() });\n  \n  // Keep last 1000 values\n  if (history.length > 1000) {\n    history.shift();\n  }\n  \n  await context.memory.cache.set(avgKey, history);\n}\n\nasync function detectAnomaly(\n  metric: string,\n  value: number,\n  context: AgenticHookContext\n): Promise<any | null> {\n  const avgKey = `avg:${metric}`;\n  const history = await context.memory.cache.get(avgKey) || [];\n  \n  if (history.length < 100) {\n    return null; // Not enough data\n  }\n  \n  // Calculate statistics\n  const values = history.map((h: any) => h.value);\n  const mean = values.reduce((a: number, b: number) => a + b, 0) / values.length;\n  const variance = values.reduce((a: number, b: number) => \n    a + Math.pow(b - mean, 2), 0\n  ) / values.length;\n  const stdDev = Math.sqrt(variance);\n  \n  // Check if value is anomalous (> 3 standard deviations)\n  const zScore = Math.abs((value - mean) / stdDev);\n  \n  if (zScore > 3) {\n    return {\n      type: 'statistical',\n      zScore,\n      mean,\n      stdDev,\n      severity: zScore > 5 ? 'high' : 'medium',\n    };\n  }\n  \n  return null;\n}\n\nfunction mapSeverity(severity: number): BottleneckAnalysis['severity'] {\n  if (severity >= 8) return 'critical';\n  if (severity >= 6) return 'high';\n  if (severity >= 4) return 'medium';\n  return 'low';\n}\n\nasync function checkBottleneckRecurrence(\n  component: string,\n  context: AgenticHookContext\n): Promise<{ count: number; timespan: number }> {\n  const historyKey = `bottleneck:history:${component}`;\n  const history = await context.memory.cache.get(historyKey) || [];\n  \n  const now = Date.now();\n  const dayAgo = now - 86400000;\n  \n  // Count occurrences in last 24 hours\n  const recentOccurrences = history.filter((h: any) => \n    h.timestamp > dayAgo\n  );\n  \n  return {\n    count: recentOccurrences.length,\n    timespan: 86400000, // 24 hours in ms\n  };\n}\n\nasync function generateAdvancedOptimization(\n  bottleneck: BottleneckAnalysis,\n  recurrence: { count: number; timespan: number },\n  context: AgenticHookContext\n): Promise<OptimizationSuggestion | null> {\n  // Generate advanced optimization for recurring bottlenecks\n  if (bottleneck.severity === 'critical' && recurrence.count > 5) {\n    return {\n      type: 'algorithm',\n      target: bottleneck.component,\n      expectedImprovement: 60,\n      implementation: `Redesign ${bottleneck.component} algorithm for better scalability`,\n      risk: 'high',\n    };\n  }\n  \n  if (bottleneck.severity === 'high' && recurrence.count > 3) {\n    return {\n      type: 'cache',\n      target: bottleneck.component,\n      expectedImprovement: 40,\n      implementation: `Implement distributed caching for ${bottleneck.component}`,\n      risk: 'medium',\n    };\n  }\n  \n  return null;\n}\n\nasync function findMetricCorrelations(\n  component: string,\n  context: AgenticHookContext\n): Promise<Array<{ metric: string; correlation: number }>> {\n  const correlations: Array<{ metric: string; correlation: number }> = [];\n  \n  // Check correlations with other metrics\n  for (const [metric, data] of context.performance.metrics) {\n    if (data.tags.includes(`component:${component}`)) {\n      // Simple correlation check\n      correlations.push({\n        metric: data.name,\n        correlation: 0.7, // Placeholder\n      });\n    }\n  }\n  \n  return correlations;\n}\n\nasync function validateOptimization(\n  optimization: any,\n  context: AgenticHookContext\n): Promise<{ valid: boolean; reason?: string }> {\n  // Validate optimization is safe to apply\n  if (!optimization.type || !optimization.details) {\n    return {\n      valid: false,\n      reason: 'Missing required optimization fields',\n    };\n  }\n  \n  // Check risk level\n  if (optimization.details === 'high' && !context.metadata.allowHighRisk) {\n    return {\n      valid: false,\n      reason: 'High-risk optimizations not allowed',\n    };\n  }\n  \n  return { valid: true };\n}\n\nasync function simulateOptimization(\n  optimization: any,\n  context: AgenticHookContext\n): Promise<any> {\n  // Simulate optimization impact\n  const baseline = await getBaselineMetrics(optimization.type, context);\n  \n  const simulation = {\n    expectedImprovement: optimization.improvement || 0.2,\n    risk: calculateRisk(optimization),\n    affectedMetrics: identifyAffectedMetrics(optimization),\n    rollbackPlan: generateRollbackPlan(optimization),\n  };\n  \n  return simulation;\n}\n\nasync function applyOptimization(\n  optimization: any,\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply optimization\n  // Placeholder implementation\n  const timestamp = Date.now();\n  \n  // Store optimization application\n  await context.memory.cache.set(\n    `applied:${optimization.type}:${timestamp}`,\n    {\n      optimization,\n      appliedAt: timestamp,\n      appliedBy: 'automatic',\n    }\n  );\n}\n\nasync function getMetricHistory(\n  metric: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  const historyKey = `history:${metric}`;\n  return await context.memory.cache.get(historyKey) || [];\n}\n\nfunction calculateDynamicThreshold(\n  baseThreshold: number,\n  historicalData: any[]\n): number {\n  if (historicalData.length < 50) {\n    return baseThreshold; // Not enough data\n  }\n  \n  // Calculate percentile-based threshold\n  const values = historicalData\n    .map(d => d.value)\n    .sort((a, b) => a - b);\n  \n  const p95 = values[Math.floor(values.length * 0.95)];\n  \n  // Adjust threshold based on historical performance\n  return Math.max(baseThreshold, p95 * 1.1);\n}\n\nasync function predictThresholdViolation(\n  metric: string,\n  currentValue: number,\n  threshold: number,\n  historicalData: any[]\n): Promise<any> {\n  if (historicalData.length < 10) {\n    return {\n      willViolate: false,\n      confidence: 0,\n    };\n  }\n  \n  // Simple linear trend prediction\n  const recentValues = historicalData.slice(-10).map(d => d.value);\n  const trend = calculateTrend(recentValues);\n  \n  if (trend > 0 && currentValue > threshold * 0.8) {\n    const timeToViolation = (threshold - currentValue) / trend;\n    \n    return {\n      willViolate: true,\n      timeToViolation,\n      confidence: Math.min(trend * 10, 0.9),\n    };\n  }\n  \n  return {\n    willViolate: false,\n    confidence: 0,\n  };\n}\n\nasync function generateProactiveOptimization(\n  metric: string,\n  prediction: any,\n  context: AgenticHookContext\n): Promise<OptimizationSuggestion | null> {\n  // Generate proactive optimization to prevent violation\n  const metricType = getMetricType(metric);\n  \n  if (metricType === 'latency' && prediction.timeToViolation < 300000) {\n    return {\n      type: 'cache',\n      target: metric,\n      expectedImprovement: 30,\n      implementation: 'Preemptively cache high-latency operations',\n      risk: 'low',\n    };\n  }\n  \n  return null;\n}\n\nfunction getMetricType(metric: string): string {\n  if (metric.includes('latency')) return 'latency';\n  if (metric.includes('throughput')) return 'throughput';\n  if (metric.includes('memory')) return 'memory';\n  if (metric.includes('cpu')) return 'cpu';\n  return 'unknown';\n}\n\nasync function getBaselineMetrics(\n  type: string,\n  context: AgenticHookContext\n): Promise<any> {\n  // Get baseline metrics for comparison\n  // Placeholder implementation\n  return {};\n}\n\nfunction calculateRisk(optimization: any): string {\n  // Calculate optimization risk level\n  if (optimization.type === 'algorithm') return 'high';\n  if (optimization.type === 'architecture') return 'high';\n  if (optimization.type === 'cache') return 'low';\n  if (optimization.type === 'batch') return 'low';\n  return 'medium';\n}\n\nfunction identifyAffectedMetrics(optimization: any): string[] {\n  // Identify metrics affected by optimization\n  const affected: string[] = [];\n  \n  switch (optimization.type) {\n    case 'cache':\n      affected.push('latency', 'memory_usage');\n      break;\n    case 'parallel':\n      affected.push('latency', 'cpu_usage', 'throughput');\n      break;\n    case 'batch':\n      affected.push('throughput', 'latency');\n      break;\n    case 'algorithm':\n      affected.push('latency', 'cpu_usage', 'memory_usage');\n      break;\n  }\n  \n  return affected;\n}\n\nfunction generateRollbackPlan(optimization: any): any {\n  // Generate rollback plan\n  return {\n    steps: [\n      'Capture current metrics',\n      'Apply optimization',\n      'Monitor for 5 minutes',\n      'Rollback if metrics degrade',\n    ],\n    triggers: {\n      errorRate: 0.05,\n      latencyIncrease: 1.5,\n    },\n  };\n}\n\nfunction calculateTrend(values: number[]): number {\n  if (values.length < 2) return 0;\n  \n  // Simple linear regression\n  const n = values.length;\n  const sumX = values.reduce((a, _, i) => a + i, 0);\n  const sumY = values.reduce((a, b) => a + b, 0);\n  const sumXY = values.reduce((a, b, i) => a + i * b, 0);\n  const sumX2 = values.reduce((a, _, i) => a + i * i, 0);\n  \n  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n  \n  return slope;\n}\n\n// ===== Register Hooks =====\n\nexport function registerPerformanceHooks(): void {\n  agenticHookManager.register(performanceMetricHook);\n  agenticHookManager.register(performanceBottleneckHook);\n  agenticHookManager.register(performanceOptimizationHook);\n  agenticHookManager.register(performanceThresholdHook);\n}"],"names":["agenticHookManager","performanceMetricHook","id","type","priority","handler","payload","context","metric","value","unit","threshold","sideEffects","metricData","name","timestamp","Date","now","tags","extractTags","performance","metrics","set","undefined","violated","checkThreshold","push","action","data","event","suggestion","generateOptimizationSuggestion","optimizations","level","message","updateRollingAverages","anomaly","detectAnomaly","continue","performanceBottleneckHook","bottleneck","analysis","component","location","severity","mapSeverity","impact","suggestions","bottlenecks","key","ttl","recurrence","checkBottleneckRecurrence","count","occurrences","timespan","optimization","generateAdvancedOptimization","correlations","findMetricCorrelations","length","performanceOptimizationHook","validation","validateOptimization","valid","simulation","simulateOptimization","expectedImprovement","recommendation","autoApply","applied","risk","applyOptimization","automatic","performanceThresholdHook","historicalData","getMetricHistory","adjustedThreshold","calculateDynamicThreshold","original","adjusted","prediction","predictThresholdViolation","willViolate","confidence","currentValue","predictedTime","timeToViolation","proactiveOpt","generateProactiveOptimization","provider","model","operation","operator","thresholdOperator","metricType","getMetricType","target","implementation","avgKey","history","memory","cache","get","shift","values","map","h","mean","reduce","a","b","variance","Math","pow","stdDev","sqrt","zScore","abs","historyKey","dayAgo","recentOccurrences","filter","includes","correlation","details","reason","metadata","allowHighRisk","baseline","getBaselineMetrics","improvement","calculateRisk","affectedMetrics","identifyAffectedMetrics","rollbackPlan","generateRollbackPlan","appliedAt","appliedBy","baseThreshold","d","sort","p95","floor","max","recentValues","slice","trend","calculateTrend","min","affected","steps","triggers","errorRate","latencyIncrease","n","sumX","_","i","sumY","sumXY","sumX2","slope","registerPerformanceHooks","register"],"mappings":"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"}