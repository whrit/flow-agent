{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/workflow-hooks.ts"],"sourcesContent":["/**\n * Self-improving workflow hooks for agentic-flow\n * \n * Enables adaptive workflows with provider selection\n * and continuous improvement based on outcomes.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  WorkflowHookPayload,\n  WorkflowDecision,\n  Learning,\n  SideEffect,\n  Pattern,\n} from './types.js';\n\n// ===== Workflow Start Hook =====\n\nexport const workflowStartHook = {\n  id: 'agentic-workflow-start',\n  type: 'workflow-start' as const,\n  priority: 100,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, state } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Load workflow history and learnings\n    const history = await loadWorkflowHistory(workflowId, context);\n    const learnings = await loadWorkflowLearnings(workflowId, context);\n    \n    // Select optimal provider based on history\n    const provider = await selectOptimalProvider(\n      workflowId,\n      state,\n      history,\n      context\n    );\n    \n    // Initialize workflow state\n    const enhancedState = {\n      ...state,\n      startTime: Date.now(),\n      provider,\n      learnings: learnings.slice(-10), // Last 10 learnings\n      predictions: await generateWorkflowPredictions(workflowId, state, context),\n    };\n    \n    // Store workflow session\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `workflow:session:${workflowId}:${context.sessionId}`,\n        value: enhancedState,\n        ttl: 86400, // 24 hours\n      },\n    });\n    \n    // Track workflow start\n    sideEffects.push({\n      type: 'metric',\n      action: 'increment',\n      data: { name: `workflow.starts.${workflowId}` },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        state: enhancedState,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Step Hook =====\n\nexport const workflowStepHook = {\n  id: 'agentic-workflow-step',\n  type: 'workflow-step' as const,\n  priority: 100,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, step, state } = payload;\n    \n    if (!step) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Measure step performance\n    const stepStart = Date.now();\n    \n    // Check for step optimizations\n    const optimizations = await getStepOptimizations(\n      workflowId,\n      step,\n      context\n    );\n    \n    if (optimizations.length > 0) {\n      // Apply step optimizations\n      const optimizedState = applyStepOptimizations(\n        state,\n        optimizations\n      );\n      \n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: `Applied ${optimizations.length} optimizations to step ${step}`,\n          data: { optimizations },\n        },\n      });\n      \n      return {\n        continue: true,\n        modified: true,\n        payload: {\n          ...payload,\n          state: optimizedState,\n        },\n        sideEffects,\n      };\n    }\n    \n    // Track step execution\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `workflow:step:${workflowId}:${step}:${Date.now()}`,\n        value: {\n          step,\n          state: summarizeState(state),\n          timestamp: Date.now(),\n        },\n        ttl: 86400,\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Decision Hook =====\n\nexport const workflowDecisionHook = {\n  id: 'agentic-workflow-decision',\n  type: 'workflow-decision' as const,\n  priority: 90,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, decision, state } = payload;\n    \n    if (!decision) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Enhance decision with historical data\n    const historicalOutcomes = await getDecisionOutcomes(\n      workflowId,\n      decision.point,\n      context\n    );\n    \n    // Calculate confidence adjustments\n    const adjustedDecision = adjustDecisionConfidence(\n      decision,\n      historicalOutcomes\n    );\n    \n    // Generate alternative paths\n    const alternatives = await generateAlternativeDecisions(\n      workflowId,\n      decision,\n      state,\n      context\n    );\n    \n    if (alternatives.length > 0) {\n      // Check if better alternative exists\n      const bestAlternative = alternatives.find(alt => \n        alt.confidence > adjustedDecision.confidence * 1.2\n      );\n      \n      if (bestAlternative) {\n        sideEffects.push({\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'workflow:decision:alternative',\n            data: {\n              original: adjustedDecision,\n              suggested: bestAlternative,\n            },\n          },\n        });\n        \n        // Override with better decision\n        adjustedDecision.selected = bestAlternative.selected;\n        adjustedDecision.confidence = bestAlternative.confidence;\n        adjustedDecision.reasoning = `${adjustedDecision.reasoning} (AI-optimized)`;\n      }\n    }\n    \n    // Store decision for learning\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `decision:${workflowId}:${decision.point}:${Date.now()}`,\n        value: {\n          ...adjustedDecision,\n          alternatives,\n          state: summarizeState(state),\n        },\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Track decision metrics\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `workflow.decisions.confidence.${workflowId}`,\n        value: adjustedDecision.confidence,\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        decision: adjustedDecision,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Complete Hook =====\n\nexport const workflowCompleteHook = {\n  id: 'agentic-workflow-complete',\n  type: 'workflow-complete' as const,\n  priority: 100,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, state, metrics } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Calculate workflow performance\n    const performance = calculateWorkflowPerformance(state, metrics);\n    \n    // Extract learnings from this execution\n    const learnings = await extractWorkflowLearnings(\n      workflowId,\n      state,\n      performance,\n      context\n    );\n    \n    // Store learnings\n    for (const learning of learnings) {\n      sideEffects.push({\n        type: 'memory',\n        action: 'store',\n        data: {\n          key: `learning:${workflowId}:${learning.type}:${Date.now()}`,\n          value: learning,\n          ttl: 0, // Permanent\n        },\n      });\n    }\n    \n    // Update workflow success patterns\n    if (performance.success) {\n      const pattern: Pattern = {\n        id: `workflow_success_${Date.now()}`,\n        type: 'success',\n        confidence: performance.score,\n        occurrences: 1,\n        context: {\n          workflowId,\n          provider: state.provider,\n          duration: metrics?.duration || 0,\n          decisions: countDecisions(state),\n        },\n      };\n      \n      context.neural.patterns.add(pattern);\n      \n      sideEffects.push({\n        type: 'neural',\n        action: 'train',\n        data: {\n          patterns: [pattern],\n          modelId: `workflow-optimizer-${workflowId}`,\n        },\n      });\n    }\n    \n    // Generate improvement suggestions\n    const improvements = await generateImprovementSuggestions(\n      workflowId,\n      state,\n      performance,\n      learnings,\n      context\n    );\n    \n    if (improvements.length > 0) {\n      sideEffects.push({\n        type: 'notification',\n        action: 'emit',\n        data: {\n          event: 'workflow:improvements:suggested',\n          data: {\n            workflowId,\n            improvements,\n            performance,\n          },\n        },\n      });\n    }\n    \n    // Update workflow metrics\n    sideEffects.push(\n      {\n        type: 'metric',\n        action: 'update',\n        data: {\n          name: `workflow.completion.rate.${workflowId}`,\n          value: performance.success ? 1 : 0,\n        },\n      },\n      {\n        type: 'metric',\n        action: 'update',\n        data: {\n          name: `workflow.performance.score.${workflowId}`,\n          value: performance.score,\n        },\n      }\n    );\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Workflow Error Hook =====\n\nexport const workflowErrorHook = {\n  id: 'agentic-workflow-error',\n  type: 'workflow-error' as const,\n  priority: 95,\n  handler: async (\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { workflowId, error, state } = payload;\n    \n    if (!error) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Analyze error pattern\n    const errorPattern = await analyzeErrorPattern(\n      workflowId,\n      error,\n      state,\n      context\n    );\n    \n    // Store error for learning\n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `error:${workflowId}:${Date.now()}`,\n        value: {\n          error: {\n            message: error.message,\n            stack: error.stack,\n            type: error.name,\n          },\n          pattern: errorPattern,\n          state: summarizeState(state),\n          timestamp: Date.now(),\n        },\n        ttl: 604800, // 7 days\n      },\n    });\n    \n    // Check for recovery strategies\n    const recovery = await findRecoveryStrategy(\n      workflowId,\n      error,\n      errorPattern,\n      context\n    );\n    \n    if (recovery) {\n      sideEffects.push({\n        type: 'log',\n        action: 'write',\n        data: {\n          level: 'info',\n          message: 'Recovery strategy found',\n          data: recovery,\n        },\n      });\n      \n      // Apply recovery\n      const recoveredState = applyRecoveryStrategy(state, recovery);\n      \n      return {\n        continue: true,\n        modified: true,\n        payload: {\n          ...payload,\n          state: recoveredState,\n          error: undefined, // Clear error after recovery\n        },\n        sideEffects,\n      };\n    }\n    \n    // Learn from failure\n    const failureLearning: Learning = {\n      type: 'failure',\n      context: `Error in workflow ${workflowId}: ${error.message}`,\n      value: {\n        errorType: error.name,\n        state: summarizeState(state),\n        pattern: errorPattern,\n      },\n      applicability: errorPattern.confidence,\n    };\n    \n    sideEffects.push({\n      type: 'memory',\n      action: 'store',\n      data: {\n        key: `learning:failure:${workflowId}:${Date.now()}`,\n        value: failureLearning,\n        ttl: 0, // Permanent\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nasync function loadWorkflowHistory(\n  workflowId: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  const historyKey = `workflow:history:${workflowId}`;\n  return await context.memory.cache.get(historyKey) || [];\n}\n\nasync function loadWorkflowLearnings(\n  workflowId: string,\n  context: AgenticHookContext\n): Promise<Learning[]> {\n  const learningsKey = `workflow:learnings:${workflowId}`;\n  return await context.memory.cache.get(learningsKey) || [];\n}\n\nasync function selectOptimalProvider(\n  workflowId: string,\n  state: any,\n  history: any[],\n  context: AgenticHookContext\n): Promise<string> {\n  // Analyze historical performance by provider\n  const providerStats = new Map<string, { success: number; total: number }>();\n  \n  for (const execution of history) {\n    const provider = execution.provider;\n    if (!provider) continue;\n    \n    const stats = providerStats.get(provider) || { success: 0, total: 0 };\n    stats.total++;\n    if (execution.success) stats.success++;\n    providerStats.set(provider, stats);\n  }\n  \n  // Calculate success rates\n  let bestProvider = 'openai'; // Default\n  let bestRate = 0;\n  \n  for (const [provider, stats] of providerStats) {\n    const rate = stats.success / stats.total;\n    if (rate > bestRate && stats.total >= 5) {\n      bestRate = rate;\n      bestProvider = provider;\n    }\n  }\n  \n  // Check current provider health\n  const healthKey = `provider:health:${bestProvider}`;\n  const health = await context.memory.cache.get(healthKey);\n  \n  if (health && health.score < 0.5) {\n    // Provider unhealthy, select alternative\n    return selectAlternativeProvider(bestProvider, providerStats);\n  }\n  \n  return bestProvider;\n}\n\nasync function generateWorkflowPredictions(\n  workflowId: string,\n  state: any,\n  context: AgenticHookContext\n): Promise<any> {\n  // Generate predictions for workflow execution\n  const predictions = {\n    estimatedDuration: 0,\n    successProbability: 0.7,\n    likelyBottlenecks: [],\n    recommendedOptimizations: [],\n  };\n  \n  // Load historical durations\n  const history = await loadWorkflowHistory(workflowId, context);\n  if (history.length > 0) {\n    const durations = history\n      .filter(h => h.duration)\n      .map(h => h.duration);\n    \n    if (durations.length > 0) {\n      predictions.estimatedDuration = \n        durations.reduce((a, b) => a + b, 0) / durations.length;\n    }\n    \n    const successes = history.filter(h => h.success).length;\n    predictions.successProbability = successes / history.length;\n  }\n  \n  return predictions;\n}\n\nasync function getStepOptimizations(\n  workflowId: string,\n  step: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Get optimizations for specific step\n  const optKey = `optimizations:${workflowId}:${step}`;\n  return await context.memory.cache.get(optKey) || [];\n}\n\nfunction applyStepOptimizations(\n  state: any,\n  optimizations: any[]\n): any {\n  let optimizedState = { ...state };\n  \n  for (const opt of optimizations) {\n    switch (opt.type) {\n      case 'skip':\n        if (opt.condition && opt.condition(state)) {\n          optimizedState.skipSteps = [\n            ...(optimizedState.skipSteps || []),\n            opt.target,\n          ];\n        }\n        break;\n        \n      case 'parallel':\n        optimizedState.parallelSteps = [\n          ...(optimizedState.parallelSteps || []),\n          ...opt.steps,\n        ];\n        break;\n        \n      case 'cache':\n        optimizedState.useCache = true;\n        optimizedState.cacheKeys = [\n          ...(optimizedState.cacheKeys || []),\n          opt.key,\n        ];\n        break;\n    }\n  }\n  \n  return optimizedState;\n}\n\nfunction summarizeState(state: any): any {\n  // Create summary of state for storage\n  return {\n    keys: Object.keys(state),\n    size: JSON.stringify(state).length,\n    hasError: !!state.error,\n    provider: state.provider,\n    timestamp: Date.now(),\n  };\n}\n\nasync function getDecisionOutcomes(\n  workflowId: string,\n  decisionPoint: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Get historical outcomes for decision point\n  const outcomeKey = `outcomes:${workflowId}:${decisionPoint}`;\n  return await context.memory.cache.get(outcomeKey) || [];\n}\n\nfunction adjustDecisionConfidence(\n  decision: WorkflowDecision,\n  historicalOutcomes: any[]\n): WorkflowDecision {\n  if (historicalOutcomes.length === 0) {\n    return decision;\n  }\n  \n  // Calculate success rate for selected option\n  const relevantOutcomes = historicalOutcomes.filter(o => \n    o.selected === decision.selected\n  );\n  \n  if (relevantOutcomes.length === 0) {\n    return decision;\n  }\n  \n  const successRate = relevantOutcomes.filter(o => o.success).length / \n    relevantOutcomes.length;\n  \n  // Adjust confidence based on historical success\n  const adjustedConfidence = decision.confidence * 0.7 + successRate * 0.3;\n  \n  return {\n    ...decision,\n    confidence: adjustedConfidence,\n    learnings: [\n      ...decision.learnings,\n      {\n        type: 'success',\n        context: `Historical success rate: ${(successRate * 100).toFixed(1)}%`,\n        value: successRate,\n        applicability: Math.min(relevantOutcomes.length / 10, 1),\n      },\n    ],\n  };\n}\n\nasync function generateAlternativeDecisions(\n  workflowId: string,\n  decision: WorkflowDecision,\n  state: any,\n  context: AgenticHookContext\n): Promise<WorkflowDecision[]> {\n  // Generate alternative decision paths\n  const alternatives: WorkflowDecision[] = [];\n  \n  // Check each option not selected\n  for (const option of decision.options) {\n    if (option === decision.selected) continue;\n    \n    // Calculate alternative confidence\n    const altConfidence = await calculateAlternativeConfidence(\n      workflowId,\n      decision.point,\n      option,\n      state,\n      context\n    );\n    \n    if (altConfidence > 0.5) {\n      alternatives.push({\n        ...decision,\n        selected: option,\n        confidence: altConfidence,\n        reasoning: `Alternative path based on historical analysis`,\n      });\n    }\n  }\n  \n  return alternatives;\n}\n\nfunction calculateWorkflowPerformance(\n  state: any,\n  metrics: any\n): any {\n  const performance = {\n    success: !state.error,\n    score: 0,\n    duration: metrics?.duration || 0,\n    efficiency: 0,\n    reliability: 0,\n  };\n  \n  // Calculate performance score\n  if (performance.success) {\n    performance.score = 0.7; // Base success score\n    \n    // Adjust for duration\n    if (metrics?.duration && state.predictions?.estimatedDuration) {\n      const durationRatio = state.predictions.estimatedDuration / metrics.duration;\n      performance.efficiency = Math.min(durationRatio, 1);\n      performance.score += performance.efficiency * 0.2;\n    }\n    \n    // Adjust for error rate\n    if (metrics?.errorRate !== undefined) {\n      performance.reliability = 1 - metrics.errorRate;\n      performance.score += performance.reliability * 0.1;\n    }\n  }\n  \n  return performance;\n}\n\nasync function extractWorkflowLearnings(\n  workflowId: string,\n  state: any,\n  performance: any,\n  context: AgenticHookContext\n): Promise<Learning[]> {\n  const learnings: Learning[] = [];\n  \n  // Learn from successful execution\n  if (performance.success) {\n    learnings.push({\n      type: 'success',\n      context: `Successful workflow execution with score ${performance.score}`,\n      value: {\n        provider: state.provider,\n        duration: performance.duration,\n        decisions: extractDecisions(state),\n      },\n      applicability: performance.score,\n    });\n  }\n  \n  // Learn from optimizations\n  if (state.appliedOptimizations) {\n    for (const opt of state.appliedOptimizations) {\n      learnings.push({\n        type: 'optimization',\n        context: `Applied ${opt.type} optimization at ${opt.step}`,\n        value: opt,\n        applicability: 0.8,\n      });\n    }\n  }\n  \n  return learnings;\n}\n\nfunction countDecisions(state: any): number {\n  // Count decisions made during workflow\n  return state.decisions?.length || 0;\n}\n\nasync function generateImprovementSuggestions(\n  workflowId: string,\n  state: any,\n  performance: any,\n  learnings: Learning[],\n  context: AgenticHookContext\n): Promise<any[]> {\n  const suggestions: any[] = [];\n  \n  // Suggest caching if repeated operations\n  if (performance.duration > 5000) {\n    suggestions.push({\n      type: 'cache',\n      target: 'frequent_operations',\n      reason: 'Long execution time detected',\n      expectedImprovement: '30-50% reduction in duration',\n    });\n  }\n  \n  // Suggest parallelization\n  if (state.sequentialSteps?.length > 3) {\n    suggestions.push({\n      type: 'parallel',\n      target: 'independent_steps',\n      reason: 'Multiple sequential steps detected',\n      expectedImprovement: '40-60% reduction in duration',\n    });\n  }\n  \n  // Suggest provider switch based on learnings\n  const providerLearnings = learnings.filter(l => \n    l.type === 'success' && l.value.provider\n  );\n  \n  if (providerLearnings.length > 0) {\n    const providerScores = new Map<string, number>();\n    for (const learning of providerLearnings) {\n      const provider = learning.value.provider;\n      const score = providerScores.get(provider) || 0;\n      providerScores.set(provider, score + learning.applicability);\n    }\n    \n    const currentScore = providerScores.get(state.provider) || 0;\n    for (const [provider, score] of providerScores) {\n      if (score > currentScore * 1.2) {\n        suggestions.push({\n          type: 'provider',\n          target: provider,\n          reason: `${provider} shows better historical performance`,\n          expectedImprovement: `${((score / currentScore - 1) * 100).toFixed(0)}% better reliability`,\n        });\n      }\n    }\n  }\n  \n  return suggestions;\n}\n\nasync function analyzeErrorPattern(\n  workflowId: string,\n  error: Error,\n  state: any,\n  context: AgenticHookContext\n): Promise<any> {\n  // Analyze error to find patterns\n  const pattern = {\n    type: classifyError(error),\n    confidence: 0.7,\n    context: {\n      step: state.currentStep,\n      provider: state.provider,\n      errorMessage: error.message,\n    },\n  };\n  \n  // Check for similar errors\n  const errorHistory = await context.memory.cache.get(\n    `errors:${workflowId}:${pattern.type}`\n  ) || [];\n  \n  if (errorHistory.length > 5) {\n    pattern.confidence = 0.9;\n    pattern.context.recurring = true;\n    pattern.context.occurrences = errorHistory.length;\n  }\n  \n  return pattern;\n}\n\nasync function findRecoveryStrategy(\n  workflowId: string,\n  error: Error,\n  errorPattern: any,\n  context: AgenticHookContext\n): Promise<any | null> {\n  // Find recovery strategy for error\n  if (errorPattern.type === 'timeout') {\n    return {\n      type: 'retry',\n      params: {\n        maxRetries: 3,\n        backoff: 'exponential',\n        timeout: 30000,\n      },\n    };\n  }\n  \n  if (errorPattern.type === 'rate_limit') {\n    return {\n      type: 'throttle',\n      params: {\n        delay: 1000,\n        maxConcurrent: 1,\n      },\n    };\n  }\n  \n  if (errorPattern.type === 'validation') {\n    return {\n      type: 'transform',\n      params: {\n        sanitize: true,\n        validate: true,\n      },\n    };\n  }\n  \n  return null;\n}\n\nfunction applyRecoveryStrategy(state: any, recovery: any): any {\n  const recoveredState = { ...state };\n  \n  switch (recovery.type) {\n    case 'retry':\n      recoveredState.retryConfig = recovery.params;\n      recoveredState.shouldRetry = true;\n      break;\n      \n    case 'throttle':\n      recoveredState.throttleConfig = recovery.params;\n      recoveredState.throttled = true;\n      break;\n      \n    case 'transform':\n      recoveredState.transformConfig = recovery.params;\n      recoveredState.needsTransform = true;\n      break;\n  }\n  \n  recoveredState.recoveryApplied = recovery;\n  delete recoveredState.error; // Clear error state\n  \n  return recoveredState;\n}\n\nfunction selectAlternativeProvider(\n  currentProvider: string,\n  providerStats: Map<string, { success: number; total: number }>\n): string {\n  // Select alternative provider based on stats\n  let bestAlternative = 'anthropic'; // Default fallback\n  let bestRate = 0;\n  \n  for (const [provider, stats] of providerStats) {\n    if (provider === currentProvider) continue;\n    \n    const rate = stats.success / stats.total;\n    if (rate > bestRate && stats.total >= 3) {\n      bestRate = rate;\n      bestAlternative = provider;\n    }\n  }\n  \n  return bestAlternative;\n}\n\nasync function calculateAlternativeConfidence(\n  workflowId: string,\n  decisionPoint: string,\n  option: string,\n  state: any,\n  context: AgenticHookContext\n): Promise<number> {\n  // Calculate confidence for alternative option\n  const outcomeKey = `outcomes:${workflowId}:${decisionPoint}:${option}`;\n  const outcomes = await context.memory.cache.get(outcomeKey) || [];\n  \n  if (outcomes.length === 0) {\n    return 0.5; // Default confidence\n  }\n  \n  const successRate = outcomes.filter((o: any) => o.success).length / \n    outcomes.length;\n  \n  // Adjust for recency\n  const recentOutcomes = outcomes.slice(-10);\n  const recentSuccessRate = recentOutcomes.filter((o: any) => o.success).length / \n    recentOutcomes.length;\n  \n  return successRate * 0.7 + recentSuccessRate * 0.3;\n}\n\nfunction extractDecisions(state: any): any[] {\n  // Extract decisions from state\n  return state.decisions || [];\n}\n\nfunction classifyError(error: Error): string {\n  const message = error.message.toLowerCase();\n  \n  if (message.includes('timeout')) return 'timeout';\n  if (message.includes('rate limit')) return 'rate_limit';\n  if (message.includes('validation')) return 'validation';\n  if (message.includes('network')) return 'network';\n  if (message.includes('auth')) return 'authentication';\n  \n  return 'unknown';\n}\n\n// ===== Register Hooks =====\n\nexport function registerWorkflowHooks(): void {\n  agenticHookManager.register(workflowStartHook);\n  agenticHookManager.register(workflowStepHook);\n  agenticHookManager.register(workflowDecisionHook);\n  agenticHookManager.register(workflowCompleteHook);\n  agenticHookManager.register(workflowErrorHook);\n}"],"names":["agenticHookManager","workflowStartHook","id","type","priority","handler","payload","context","workflowId","state","sideEffects","history","loadWorkflowHistory","learnings","loadWorkflowLearnings","provider","selectOptimalProvider","enhancedState","startTime","Date","now","slice","predictions","generateWorkflowPredictions","push","action","data","key","sessionId","value","ttl","name","continue","modified","workflowStepHook","step","stepStart","optimizations","getStepOptimizations","length","optimizedState","applyStepOptimizations","level","message","summarizeState","timestamp","workflowDecisionHook","decision","historicalOutcomes","getDecisionOutcomes","point","adjustedDecision","adjustDecisionConfidence","alternatives","generateAlternativeDecisions","bestAlternative","find","alt","confidence","event","original","suggested","selected","reasoning","workflowCompleteHook","metrics","performance","calculateWorkflowPerformance","extractWorkflowLearnings","learning","success","pattern","score","occurrences","duration","decisions","countDecisions","neural","patterns","add","modelId","improvements","generateImprovementSuggestions","workflowErrorHook","error","errorPattern","analyzeErrorPattern","stack","recovery","findRecoveryStrategy","recoveredState","applyRecoveryStrategy","undefined","failureLearning","errorType","applicability","historyKey","memory","cache","get","learningsKey","providerStats","Map","execution","stats","total","set","bestProvider","bestRate","rate","healthKey","health","selectAlternativeProvider","estimatedDuration","successProbability","likelyBottlenecks","recommendedOptimizations","durations","filter","h","map","reduce","a","b","successes","optKey","opt","condition","skipSteps","target","parallelSteps","steps","useCache","cacheKeys","keys","Object","size","JSON","stringify","hasError","decisionPoint","outcomeKey","relevantOutcomes","o","successRate","adjustedConfidence","toFixed","Math","min","option","options","altConfidence","calculateAlternativeConfidence","efficiency","reliability","durationRatio","errorRate","extractDecisions","appliedOptimizations","suggestions","reason","expectedImprovement","sequentialSteps","providerLearnings","l","providerScores","currentScore","classifyError","currentStep","errorMessage","errorHistory","recurring","params","maxRetries","backoff","timeout","delay","maxConcurrent","sanitize","validate","retryConfig","shouldRetry","throttleConfig","throttled","transformConfig","needsTransform","recoveryApplied","currentProvider","outcomes","recentOutcomes","recentSuccessRate","toLowerCase","includes","registerWorkflowHooks","register"],"mappings":"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"}