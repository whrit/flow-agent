{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/memory-hooks.ts"],"sourcesContent":["/**\n * Memory persistence hooks for agentic-flow\n * \n * Provides cross-provider memory state management with\n * synchronization and persistence capabilities.\n */\n\nimport { agenticHookManager } from './hook-manager.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  MemoryHookPayload,\n  SideEffect,\n} from './types.js';\n\n// ===== Pre-Memory Store Hook =====\n\nexport const preMemoryStoreHook = {\n  id: 'agentic-pre-memory-store',\n  type: 'pre-memory-store' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key, value, ttl, provider } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Validate memory constraints\n    const validation = await validateMemoryStore(namespace, key, value, context);\n    if (!validation.valid) {\n      return {\n        continue: false,\n        sideEffects: [\n          {\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'error',\n              message: 'Memory store validation failed',\n              data: validation,\n            },\n          },\n        ],\n      };\n    }\n    \n    // Compress large values\n    let processedValue = value;\n    if (shouldCompress(value)) {\n      processedValue = await compressValue(value);\n      sideEffects.push({\n        type: 'metric',\n        action: 'increment',\n        data: { name: 'memory.compressions' },\n      });\n    }\n    \n    // Add metadata\n    const enrichedValue = {\n      data: processedValue,\n      metadata: {\n        stored: Date.now(),\n        provider,\n        sessionId: context.sessionId,\n        compressed: processedValue !== value,\n        size: getValueSize(processedValue),\n      },\n    };\n    \n    // Track memory usage\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `memory.usage.${namespace}`,\n        value: getValueSize(enrichedValue),\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        value: enrichedValue,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Post-Memory Store Hook =====\n\nexport const postMemoryStoreHook = {\n  id: 'agentic-post-memory-store',\n  type: 'post-memory-store' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key, value, crossProvider, syncTargets } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Cross-provider sync if enabled\n    if (crossProvider && syncTargets && syncTargets.length > 0) {\n      for (const target of syncTargets) {\n        sideEffects.push({\n          type: 'memory',\n          action: 'sync',\n          data: {\n            source: payload.provider,\n            target,\n            namespace,\n            key,\n            value,\n          },\n        });\n      }\n    }\n    \n    // Update memory index for search\n    await updateMemoryIndex(namespace, key, value, context);\n    \n    // Neural pattern detection\n    const patterns = await detectMemoryPatterns(namespace, key, value, context);\n    if (patterns.length > 0) {\n      sideEffects.push({\n        type: 'neural',\n        action: 'analyze',\n        data: {\n          patterns,\n          context: { namespace, key },\n        },\n      });\n    }\n    \n    // Emit memory change event\n    sideEffects.push({\n      type: 'notification',\n      action: 'emit',\n      data: {\n        event: 'memory:stored',\n        data: { namespace, key, size: getValueSize(value) },\n      },\n    });\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Pre-Memory Retrieve Hook =====\n\nexport const preMemoryRetrieveHook = {\n  id: 'agentic-pre-memory-retrieve',\n  type: 'pre-memory-retrieve' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key } = payload;\n    \n    // Check local cache first\n    const cached = await checkLocalCache(namespace, key!, context);\n    if (cached) {\n      return {\n        continue: false,\n        modified: true,\n        payload: {\n          ...payload,\n          value: cached,\n        },\n        sideEffects: [\n          {\n            type: 'metric',\n            action: 'increment',\n            data: { name: 'memory.cache.hits' },\n          },\n        ],\n      };\n    }\n    \n    // Pre-fetch related keys\n    const relatedKeys = await findRelatedKeys(namespace, key!, context);\n    if (relatedKeys.length > 0) {\n      // Trigger background fetch\n      prefetchKeys(namespace, relatedKeys, context);\n    }\n    \n    return {\n      continue: true,\n      sideEffects: [\n        {\n          type: 'metric',\n          action: 'increment',\n          data: { name: `memory.retrievals.${namespace}` },\n        },\n      ],\n    };\n  },\n};\n\n// ===== Post-Memory Retrieve Hook =====\n\nexport const postMemoryRetrieveHook = {\n  id: 'agentic-post-memory-retrieve',\n  type: 'post-memory-retrieve' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace, key, value } = payload;\n    \n    if (!value) {\n      return { continue: true };\n    }\n    \n    const sideEffects: SideEffect[] = [];\n    \n    // Decompress if needed\n    let processedValue = value;\n    if (value.metadata?.compressed) {\n      processedValue = await decompressValue(value.data);\n      sideEffects.push({\n        type: 'metric',\n        action: 'increment',\n        data: { name: 'memory.decompressions' },\n      });\n    }\n    \n    // Update access patterns\n    await updateAccessPattern(namespace, key!, context);\n    \n    // Cache locally for fast access\n    await cacheLocally(namespace, key!, processedValue, context);\n    \n    // Track retrieval latency\n    const latency = Date.now() - context.timestamp;\n    sideEffects.push({\n      type: 'metric',\n      action: 'update',\n      data: {\n        name: `memory.latency.${namespace}`,\n        value: latency,\n      },\n    });\n    \n    return {\n      continue: true,\n      modified: true,\n      payload: {\n        ...payload,\n        value: processedValue.data || processedValue,\n      },\n      sideEffects,\n    };\n  },\n};\n\n// ===== Memory Sync Hook =====\n\nexport const memorySyncHook = {\n  id: 'agentic-memory-sync',\n  type: 'memory-sync' as const,\n  priority: 100,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { operation, namespace, provider, syncTargets } = payload;\n    \n    const sideEffects: SideEffect[] = [];\n    \n    switch (operation) {\n      case 'sync':\n        // Bidirectional sync\n        const changes = await detectMemoryChanges(namespace, provider, context);\n        \n        if (changes.length > 0) {\n          sideEffects.push({\n            type: 'log',\n            action: 'write',\n            data: {\n              level: 'info',\n              message: `Syncing ${changes.length} memory changes`,\n              data: { namespace, provider, targets: syncTargets },\n            },\n          });\n          \n          // Apply changes\n          for (const change of changes) {\n            await applyMemoryChange(change, syncTargets || [], context);\n          }\n          \n          sideEffects.push({\n            type: 'metric',\n            action: 'update',\n            data: {\n              name: 'memory.sync.changes',\n              value: changes.length,\n            },\n          });\n        }\n        break;\n        \n      case 'persist':\n        // Persist to long-term storage\n        const snapshot = await createMemorySnapshot(namespace, context);\n        \n        sideEffects.push({\n          type: 'memory',\n          action: 'store',\n          data: {\n            key: `snapshot:${namespace}:${Date.now()}`,\n            value: snapshot,\n            ttl: 0, // No expiration\n          },\n        });\n        \n        sideEffects.push({\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'memory:persisted',\n            data: { namespace, size: snapshot.size },\n          },\n        });\n        break;\n        \n      case 'expire':\n        // Clean up expired entries\n        const expired = await findExpiredEntries(namespace, context);\n        \n        if (expired.length > 0) {\n          for (const key of expired) {\n            await removeMemoryEntry(namespace, key, context);\n          }\n          \n          sideEffects.push({\n            type: 'metric',\n            action: 'update',\n            data: {\n              name: 'memory.expired',\n              value: expired.length,\n            },\n          });\n        }\n        break;\n    }\n    \n    return {\n      continue: true,\n      sideEffects,\n    };\n  },\n};\n\n// ===== Memory Persist Hook =====\n\nexport const memoryPersistHook = {\n  id: 'agentic-memory-persist',\n  type: 'memory-persist' as const,\n  priority: 90,\n  handler: async (\n    payload: MemoryHookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> => {\n    const { namespace } = payload;\n    \n    // Create full memory backup\n    const backup = await createFullBackup(namespace, context);\n    \n    // Store backup with metadata\n    const backupData = {\n      timestamp: Date.now(),\n      sessionId: context.sessionId,\n      namespace,\n      entries: backup.entries,\n      size: backup.size,\n      checksum: calculateChecksum(backup),\n    };\n    \n    return {\n      continue: true,\n      sideEffects: [\n        {\n          type: 'memory',\n          action: 'store',\n          data: {\n            key: `backup:${namespace}:${context.sessionId}`,\n            value: backupData,\n            ttl: 604800, // 7 days\n          },\n        },\n        {\n          type: 'notification',\n          action: 'emit',\n          data: {\n            event: 'memory:backup:created',\n            data: {\n              namespace,\n              size: backup.size,\n              entries: backup.entries.length,\n            },\n          },\n        },\n      ],\n    };\n  },\n};\n\n// ===== Helper Functions =====\n\nasync function validateMemoryStore(\n  namespace: string,\n  key: string | undefined,\n  value: any,\n  context: AgenticHookContext\n): Promise<{ valid: boolean; reason?: string }> {\n  // Check size limits\n  const size = getValueSize(value);\n  const maxSize = 10 * 1024 * 1024; // 10MB\n  \n  if (size > maxSize) {\n    return {\n      valid: false,\n      reason: `Value size ${size} exceeds limit ${maxSize}`,\n    };\n  }\n  \n  // Check namespace quota\n  const quota = await getNamespaceQuota(namespace, context);\n  const usage = await getNamespaceUsage(namespace, context);\n  \n  if (usage + size > quota) {\n    return {\n      valid: false,\n      reason: `Namespace quota exceeded: ${usage + size} > ${quota}`,\n    };\n  }\n  \n  // Validate key format\n  if (key && !isValidKey(key)) {\n    return {\n      valid: false,\n      reason: `Invalid key format: ${key}`,\n    };\n  }\n  \n  return { valid: true };\n}\n\nfunction shouldCompress(value: any): boolean {\n  const size = getValueSize(value);\n  return size > 1024; // Compress if larger than 1KB\n}\n\nasync function compressValue(value: any): Promise<any> {\n  // Implement compression (placeholder)\n  // In real implementation, use zlib or similar\n  return {\n    compressed: true,\n    data: JSON.stringify(value),\n  };\n}\n\nasync function decompressValue(value: any): Promise<any> {\n  // Implement decompression (placeholder)\n  if (value.compressed) {\n    return JSON.parse(value.data);\n  }\n  return value;\n}\n\nfunction getValueSize(value: any): number {\n  return Buffer.byteLength(JSON.stringify(value), 'utf8');\n}\n\nasync function updateMemoryIndex(\n  namespace: string,\n  key: string,\n  value: any,\n  context: AgenticHookContext\n): Promise<void> {\n  // Update search index (placeholder)\n  // In real implementation, update inverted index for search\n}\n\nasync function detectMemoryPatterns(\n  namespace: string,\n  key: string,\n  value: any,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Detect patterns in memory usage\n  const patterns = [];\n  \n  // Check for sequential access pattern\n  const accessHistory = await getAccessHistory(namespace, context);\n  if (isSequentialPattern(accessHistory)) {\n    patterns.push({\n      type: 'sequential',\n      confidence: 0.8,\n      suggestion: 'prefetch-next',\n    });\n  }\n  \n  // Check for temporal patterns\n  if (isTemporalPattern(accessHistory)) {\n    patterns.push({\n      type: 'temporal',\n      confidence: 0.7,\n      suggestion: 'cache-duration',\n    });\n  }\n  \n  return patterns;\n}\n\nasync function checkLocalCache(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<any | null> {\n  const cacheKey = `${namespace}:${key}`;\n  return context.memory.cache.get(cacheKey);\n}\n\nasync function findRelatedKeys(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<string[]> {\n  // Find related keys based on patterns\n  // Placeholder implementation\n  return [];\n}\n\nasync function prefetchKeys(\n  namespace: string,\n  keys: string[],\n  context: AgenticHookContext\n): Promise<void> {\n  // Trigger background prefetch\n  // Placeholder implementation\n}\n\nasync function updateAccessPattern(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Track access patterns for optimization\n  const patternKey = `pattern:${namespace}:${key}`;\n  const pattern = await context.memory.cache.get(patternKey) || {\n    accesses: [],\n    lastAccess: 0,\n  };\n  \n  pattern.accesses.push(Date.now());\n  pattern.lastAccess = Date.now();\n  \n  // Keep last 100 accesses\n  if (pattern.accesses.length > 100) {\n    pattern.accesses = pattern.accesses.slice(-100);\n  }\n  \n  await context.memory.cache.set(patternKey, pattern);\n}\n\nasync function cacheLocally(\n  namespace: string,\n  key: string,\n  value: any,\n  context: AgenticHookContext\n): Promise<void> {\n  const cacheKey = `${namespace}:${key}`;\n  context.memory.cache.set(cacheKey, value);\n}\n\nasync function detectMemoryChanges(\n  namespace: string,\n  provider: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Detect changes for sync\n  // Placeholder implementation\n  return [];\n}\n\nasync function applyMemoryChange(\n  change: any,\n  targets: string[],\n  context: AgenticHookContext\n): Promise<void> {\n  // Apply memory change to targets\n  // Placeholder implementation\n}\n\nasync function createMemorySnapshot(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<any> {\n  // Create snapshot of namespace\n  // Placeholder implementation\n  return {\n    namespace,\n    timestamp: Date.now(),\n    entries: [],\n    size: 0,\n  };\n}\n\nasync function findExpiredEntries(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<string[]> {\n  // Find expired entries\n  // Placeholder implementation\n  return [];\n}\n\nasync function removeMemoryEntry(\n  namespace: string,\n  key: string,\n  context: AgenticHookContext\n): Promise<void> {\n  // Remove memory entry\n  // Placeholder implementation\n}\n\nasync function createFullBackup(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<any> {\n  // Create full backup\n  // Placeholder implementation\n  return {\n    entries: [],\n    size: 0,\n  };\n}\n\nfunction calculateChecksum(data: any): string {\n  // Calculate checksum\n  // Placeholder implementation\n  return 'checksum';\n}\n\nasync function getNamespaceQuota(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<number> {\n  // Get namespace quota\n  return 100 * 1024 * 1024; // 100MB default\n}\n\nasync function getNamespaceUsage(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<number> {\n  // Get current usage\n  // Placeholder implementation\n  return 0;\n}\n\nfunction isValidKey(key: string): boolean {\n  // Validate key format\n  return /^[a-zA-Z0-9:_\\-./]+$/.test(key);\n}\n\nasync function getAccessHistory(\n  namespace: string,\n  context: AgenticHookContext\n): Promise<any[]> {\n  // Get access history\n  // Placeholder implementation\n  return [];\n}\n\nfunction isSequentialPattern(history: any[]): boolean {\n  // Check for sequential access\n  // Placeholder implementation\n  return false;\n}\n\nfunction isTemporalPattern(history: any[]): boolean {\n  // Check for temporal patterns\n  // Placeholder implementation\n  return false;\n}\n\n// ===== Register Hooks =====\n\nexport function registerMemoryHooks(): void {\n  agenticHookManager.register(preMemoryStoreHook);\n  agenticHookManager.register(postMemoryStoreHook);\n  agenticHookManager.register(preMemoryRetrieveHook);\n  agenticHookManager.register(postMemoryRetrieveHook);\n  agenticHookManager.register(memorySyncHook);\n  agenticHookManager.register(memoryPersistHook);\n}"],"names":["agenticHookManager","preMemoryStoreHook","id","type","priority","handler","payload","context","namespace","key","value","ttl","provider","sideEffects","validation","validateMemoryStore","valid","continue","action","data","level","message","processedValue","shouldCompress","compressValue","push","name","enrichedValue","metadata","stored","Date","now","sessionId","compressed","size","getValueSize","modified","postMemoryStoreHook","crossProvider","syncTargets","length","target","source","updateMemoryIndex","patterns","detectMemoryPatterns","event","preMemoryRetrieveHook","cached","checkLocalCache","relatedKeys","findRelatedKeys","prefetchKeys","postMemoryRetrieveHook","decompressValue","updateAccessPattern","cacheLocally","latency","timestamp","memorySyncHook","operation","changes","detectMemoryChanges","targets","change","applyMemoryChange","snapshot","createMemorySnapshot","expired","findExpiredEntries","removeMemoryEntry","memoryPersistHook","backup","createFullBackup","backupData","entries","checksum","calculateChecksum","maxSize","reason","quota","getNamespaceQuota","usage","getNamespaceUsage","isValidKey","JSON","stringify","parse","Buffer","byteLength","accessHistory","getAccessHistory","isSequentialPattern","confidence","suggestion","isTemporalPattern","cacheKey","memory","cache","get","keys","patternKey","pattern","accesses","lastAccess","slice","set","test","history","registerMemoryHooks","register"],"mappings":"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"}