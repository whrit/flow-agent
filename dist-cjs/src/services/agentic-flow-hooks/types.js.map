{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/types.ts"],"sourcesContent":["/**\n * Agentic Flow Hook System Type Definitions\n * \n * This module defines the comprehensive hook system for integrating\n * agentic-flow with Claude Flow's existing infrastructure.\n */\n\nimport type { HookType, HookResult } from '../../cli/commands/hook-types.js';\n\n// ===== Core Hook Types =====\n\nexport interface AgenticHookContext {\n  sessionId: string;\n  timestamp: number;\n  correlationId: string;\n  metadata: Record<string, any>;\n  memory: MemoryContext;\n  neural: NeuralContext;\n  performance: PerformanceContext;\n}\n\nexport interface MemoryContext {\n  namespace: string;\n  provider: string;\n  ttl?: number;\n  cache: Map<string, any>;\n}\n\nexport interface NeuralContext {\n  modelId: string;\n  patterns: PatternStore;\n  training: TrainingState;\n}\n\nexport interface PerformanceContext {\n  metrics: Map<string, PerformanceMetric>;\n  bottlenecks: BottleneckAnalysis[];\n  optimizations: OptimizationSuggestion[];\n}\n\n// ===== LLM Hook Types =====\n\nexport type LLMHookType = \n  | 'pre-llm-call'\n  | 'post-llm-call'\n  | 'llm-error'\n  | 'llm-retry'\n  | 'llm-fallback'\n  | 'llm-cache-hit'\n  | 'llm-cache-miss';\n\nexport interface LLMHookPayload {\n  provider: string;\n  model: string;\n  operation: 'completion' | 'embedding' | 'function-call' | 'vision';\n  request: LLMRequest;\n  response?: LLMResponse;\n  error?: Error;\n  metrics?: LLMMetrics;\n}\n\nexport interface LLMRequest {\n  messages?: Array<{\n    role: 'system' | 'user' | 'assistant' | 'function';\n    content: string;\n    name?: string;\n  }>;\n  prompt?: string;\n  temperature?: number;\n  maxTokens?: number;\n  topP?: number;\n  frequencyPenalty?: number;\n  presencePenalty?: number;\n  stopSequences?: string[];\n  functions?: Array<{\n    name: string;\n    description: string;\n    parameters: Record<string, any>;\n  }>;\n  tools?: Array<{\n    type: string;\n    function: Record<string, any>;\n  }>;\n}\n\nexport interface LLMResponse {\n  id: string;\n  choices: Array<{\n    message?: {\n      role: string;\n      content: string;\n      functionCall?: {\n        name: string;\n        arguments: string;\n      };\n    };\n    text?: string;\n    finishReason: string;\n    index: number;\n  }>;\n  usage: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  model: string;\n  created: number;\n}\n\nexport interface LLMMetrics {\n  latency: number;\n  tokensPerSecond: number;\n  costEstimate: number;\n  cacheHit: boolean;\n  retryCount: number;\n  providerHealth: number; // 0-1 health score\n}\n\n// ===== Memory Hook Types =====\n\nexport type MemoryHookType =\n  | 'pre-memory-store'\n  | 'post-memory-store'\n  | 'pre-memory-retrieve'\n  | 'post-memory-retrieve'\n  | 'memory-sync'\n  | 'memory-persist'\n  | 'memory-expire';\n\nexport interface MemoryHookPayload {\n  operation: 'store' | 'retrieve' | 'sync' | 'persist' | 'expire';\n  namespace: string;\n  key?: string;\n  value?: any;\n  ttl?: number;\n  provider: string;\n  crossProvider?: boolean;\n  syncTargets?: string[];\n}\n\n// ===== Neural Hook Types =====\n\nexport type NeuralHookType =\n  | 'pre-neural-train'\n  | 'post-neural-train'\n  | 'neural-pattern-detected'\n  | 'neural-prediction'\n  | 'neural-adaptation';\n\nexport interface NeuralHookPayload {\n  operation: 'train' | 'predict' | 'adapt' | 'analyze';\n  modelId: string;\n  patterns?: Pattern[];\n  trainingData?: TrainingData;\n  prediction?: Prediction;\n  accuracy?: number;\n  adaptations?: Adaptation[];\n}\n\nexport interface Pattern {\n  id: string;\n  type: 'success' | 'failure' | 'optimization' | 'behavior';\n  confidence: number;\n  occurrences: number;\n  context: Record<string, any>;\n}\n\nexport interface TrainingData {\n  inputs: any[];\n  outputs: any[];\n  labels?: string[];\n  weights?: number[];\n  batchSize: number;\n  epochs: number;\n}\n\nexport interface Prediction {\n  input: any;\n  output: any;\n  confidence: number;\n  alternatives: Array<{\n    output: any;\n    confidence: number;\n  }>;\n}\n\nexport interface Adaptation {\n  type: 'parameter' | 'architecture' | 'strategy';\n  target: string;\n  oldValue: any;\n  newValue: any;\n  reason: string;\n  impact: number; // -1 to 1\n}\n\n// ===== Performance Hook Types =====\n\nexport type PerformanceHookType =\n  | 'performance-metric'\n  | 'performance-bottleneck'\n  | 'performance-optimization'\n  | 'performance-threshold';\n\nexport interface PerformanceHookPayload {\n  metric: string;\n  value: number;\n  unit: string;\n  threshold?: number;\n  bottleneck?: BottleneckInfo;\n  optimization?: OptimizationInfo;\n  context: Record<string, any>;\n}\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: string;\n  timestamp: number;\n  tags: string[];\n}\n\nexport interface BottleneckAnalysis {\n  component: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  impact: number; // 0-1\n  suggestions: string[];\n}\n\nexport interface OptimizationSuggestion {\n  type: 'cache' | 'parallel' | 'batch' | 'algorithm' | 'resource';\n  target: string;\n  expectedImprovement: number; // percentage\n  implementation: string;\n  risk: 'low' | 'medium' | 'high';\n}\n\nexport interface BottleneckInfo {\n  location: string;\n  type: string;\n  severity: number;\n  suggestions: string[];\n}\n\nexport interface OptimizationInfo {\n  applied: boolean;\n  type: string;\n  improvement: number;\n  details: string;\n}\n\n// ===== Workflow Hook Types =====\n\nexport type WorkflowHookType =\n  | 'workflow-start'\n  | 'workflow-step'\n  | 'workflow-decision'\n  | 'workflow-complete'\n  | 'workflow-error';\n\nexport interface WorkflowHookPayload {\n  workflowId: string;\n  step?: string;\n  decision?: WorkflowDecision;\n  state: Record<string, any>;\n  metrics?: WorkflowMetrics;\n  error?: Error;\n}\n\nexport interface WorkflowDecision {\n  point: string;\n  options: string[];\n  selected: string;\n  confidence: number;\n  reasoning: string;\n  learnings: Learning[];\n}\n\nexport interface Learning {\n  type: 'success' | 'failure' | 'optimization';\n  context: string;\n  value: any;\n  applicability: number; // 0-1\n}\n\nexport interface WorkflowMetrics {\n  duration: number;\n  steps: number;\n  decisions: number;\n  errorRate: number;\n  successRate: number;\n  improvementRate: number;\n}\n\n// ===== Hook Registration & Management =====\n\nexport interface HookRegistration {\n  id: string;\n  type: AgenticHookType;\n  handler: HookHandler;\n  priority: number;\n  filter?: HookFilter;\n  options?: HookOptions;\n}\n\nexport type AgenticHookType = \n  | LLMHookType \n  | MemoryHookType \n  | NeuralHookType \n  | PerformanceHookType \n  | WorkflowHookType\n  | HookType; // Include existing Claude Flow hooks\n\nexport type HookHandler = (\n  payload: HookPayload,\n  context: AgenticHookContext\n) => Promise<HookHandlerResult>;\n\nexport type HookPayload = \n  | LLMHookPayload\n  | MemoryHookPayload\n  | NeuralHookPayload\n  | PerformanceHookPayload\n  | WorkflowHookPayload;\n\nexport interface HookHandlerResult {\n  continue: boolean;\n  modified?: boolean;\n  payload?: any;\n  metadata?: Record<string, any>;\n  sideEffects?: SideEffect[];\n}\n\nexport interface SideEffect {\n  type: 'memory' | 'neural' | 'metric' | 'notification' | 'log';\n  action: string;\n  data: any;\n}\n\nexport interface HookFilter {\n  providers?: string[];\n  models?: string[];\n  operations?: string[];\n  namespaces?: string[];\n  patterns?: RegExp[];\n  conditions?: Array<{\n    field: string;\n    operator: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte' | 'in' | 'nin' | 'regex';\n    value: any;\n  }>;\n}\n\nexport interface HookOptions {\n  async?: boolean;\n  timeout?: number;\n  retries?: number;\n  fallback?: HookHandler;\n  errorHandler?: (error: Error) => void;\n  cache?: {\n    enabled: boolean;\n    ttl: number;\n    key: (payload: HookPayload) => string;\n  };\n}\n\n// ===== Hook Pipeline =====\n\nexport interface HookPipeline {\n  id: string;\n  name: string;\n  stages: PipelineStage[];\n  errorStrategy: 'fail-fast' | 'continue' | 'rollback';\n  metrics: PipelineMetrics;\n}\n\nexport interface PipelineStage {\n  name: string;\n  hooks: HookRegistration[];\n  parallel: boolean;\n  condition?: (context: AgenticHookContext) => boolean;\n  transform?: (result: HookHandlerResult) => HookHandlerResult;\n}\n\nexport interface PipelineMetrics {\n  executions: number;\n  avgDuration: number;\n  errorRate: number;\n  throughput: number;\n}\n\n// ===== Provider Integration =====\n\nexport interface ProviderHookConfig {\n  provider: string;\n  hooks: {\n    preCall?: HookRegistration[];\n    postCall?: HookRegistration[];\n    error?: HookRegistration[];\n    cache?: HookRegistration[];\n  };\n  memory: {\n    enabled: boolean;\n    namespace: string;\n    persistence: 'session' | 'persistent';\n  };\n  neural: {\n    enabled: boolean;\n    modelId: string;\n    training: 'online' | 'batch' | 'hybrid';\n  };\n  performance: {\n    tracking: boolean;\n    optimization: boolean;\n    thresholds: Record<string, number>;\n  };\n}\n\n// ===== Self-Improvement Types =====\n\nexport interface SelfImprovementConfig {\n  enabled: boolean;\n  strategies: ImprovementStrategy[];\n  evaluation: EvaluationConfig;\n  adaptation: AdaptationConfig;\n}\n\nexport interface ImprovementStrategy {\n  name: string;\n  type: 'reinforcement' | 'evolutionary' | 'gradient' | 'heuristic';\n  target: 'latency' | 'accuracy' | 'cost' | 'reliability';\n  parameters: Record<string, any>;\n}\n\nexport interface EvaluationConfig {\n  metrics: string[];\n  window: number; // evaluation window in seconds\n  minSamples: number;\n  confidenceThreshold: number;\n}\n\nexport interface AdaptationConfig {\n  automatic: boolean;\n  requiresApproval: boolean;\n  maxChangeMagnitude: number;\n  rollbackThreshold: number;\n}\n\n// ===== Hook Context Helpers =====\n\nexport interface HookContextBuilder {\n  withSession(sessionId: string): HookContextBuilder;\n  withMemory(namespace: string, provider: string): HookContextBuilder;\n  withNeural(modelId: string): HookContextBuilder;\n  withPerformance(metrics: PerformanceMetric[]): HookContextBuilder;\n  withMetadata(metadata: Record<string, any>): HookContextBuilder;\n  build(): AgenticHookContext;\n}\n\n// ===== Hook Registry Interface =====\n\nexport interface HookRegistry {\n  register(registration: HookRegistration): void;\n  unregister(id: string): void;\n  getHooks(type: AgenticHookType, filter?: HookFilter): HookRegistration[];\n  executeHooks(\n    type: AgenticHookType,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]>;\n  createPipeline(config: Partial<HookPipeline>): HookPipeline;\n  getMetrics(): Record<string, any>;\n}\n\n// ===== Pattern Store =====\n\nexport interface PatternStore {\n  add(pattern: Pattern): void;\n  get(id: string): Pattern | undefined;\n  findSimilar(pattern: Partial<Pattern>, threshold: number): Pattern[];\n  getByType(type: Pattern['type']): Pattern[];\n  prune(maxAge: number): void;\n  export(): Pattern[];\n  import(patterns: Pattern[]): void;\n}\n\n// ===== Training State =====\n\nexport interface TrainingState {\n  epoch: number;\n  loss: number;\n  accuracy: number;\n  validationLoss?: number;\n  validationAccuracy?: number;\n  learningRate: number;\n  optimizer: string;\n  checkpoints: Checkpoint[];\n}\n\nexport interface Checkpoint {\n  epoch: number;\n  timestamp: number;\n  metrics: Record<string, number>;\n  path: string;\n}"],"names":[],"mappings":"AAifA,WAKC"}