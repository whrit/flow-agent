{"version":3,"sources":["../../../../src/services/agentic-flow-hooks/hook-manager.ts"],"sourcesContent":["/**\n * Agentic Flow Hook Manager\n * \n * Central manager for all agentic-flow hooks, providing registration,\n * execution, and lifecycle management.\n */\n\nimport { EventEmitter } from 'events';\nimport { Logger } from '../../core/logger.js';\nimport { HookMatcher } from '../../hooks/hook-matchers.js';\nimport type {\n  AgenticHookContext,\n  AgenticHookType,\n  HookFilter,\n  HookHandler,\n  HookHandlerResult,\n  HookOptions,\n  HookPayload,\n  HookPipeline,\n  HookRegistration,\n  HookRegistry,\n  PipelineMetrics,\n  PipelineStage,\n  SideEffect,\n} from './types.js';\n\nconst logger = new Logger({\n  level: 'info',\n  format: 'text',\n  destination: 'console'\n}, { prefix: 'AgenticHookManager' });\n\nexport class AgenticHookManager extends EventEmitter implements HookRegistry {\n  private hooks: Map<AgenticHookType, HookRegistration[]> = new Map();\n  private pipelines: Map<string, HookPipeline> = new Map();\n  private metrics: Map<string, any> = new Map();\n  private activeExecutions: Set<string> = new Set();\n  private hookMatcher: HookMatcher;\n\n  constructor() {\n    super();\n    this.initializeMetrics();\n    this.hookMatcher = new HookMatcher({\n      cacheEnabled: true,\n      cacheTTL: 60000,\n      matchStrategy: 'all',\n    });\n  }\n\n  /**\n   * Register a new hook\n   */\n  register(registration: HookRegistration): void {\n    const { type, id } = registration;\n    \n    // Validate registration\n    this.validateRegistration(registration);\n    \n    // Get or create hook list for type\n    if (!this.hooks.has(type)) {\n      this.hooks.set(type, []);\n    }\n    \n    const hookList = this.hooks.get(type)!;\n    \n    // Check for duplicate ID\n    if (hookList.some(h => h.id === id)) {\n      throw new Error(`Hook with ID '${id}' already registered for type '${type}'`);\n    }\n    \n    // Insert hook sorted by priority (higher priority first)\n    const insertIndex = hookList.findIndex(h => h.priority < registration.priority);\n    if (insertIndex === -1) {\n      hookList.push(registration);\n    } else {\n      hookList.splice(insertIndex, 0, registration);\n    }\n    \n    logger.info(`Registered hook '${id}' for type '${type}' with priority ${registration.priority}`);\n    this.emit('hook:registered', { type, registration });\n    \n    // Update metrics\n    this.updateMetric('hooks.registered', 1);\n  }\n\n  /**\n   * Unregister a hook\n   */\n  unregister(id: string): void {\n    let found = false;\n    \n    for (const [type, hookList] of this.hooks.entries()) {\n      const index = hookList.findIndex(h => h.id === id);\n      if (index !== -1) {\n        hookList.splice(index, 1);\n        found = true;\n        \n        logger.info(`Unregistered hook '${id}' from type '${type}'`);\n        this.emit('hook:unregistered', { type, id });\n        \n        // Clean up empty lists\n        if (hookList.length === 0) {\n          this.hooks.delete(type);\n        }\n        \n        break;\n      }\n    }\n    \n    if (!found) {\n      throw new Error(`Hook with ID '${id}' not found`);\n    }\n    \n    this.updateMetric('hooks.unregistered', 1);\n  }\n\n  /**\n   * Get hooks by type with optional filtering\n   */\n  getHooks(type: AgenticHookType, filter?: HookFilter): HookRegistration[] {\n    const hookList = this.hooks.get(type) || [];\n    \n    if (!filter) {\n      return [...hookList];\n    }\n    \n    return hookList.filter(hook => this.matchesFilter(hook, filter));\n  }\n\n  /**\n   * Execute hooks for a given type\n   */\n  async executeHooks(\n    type: AgenticHookType,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    const executionId = this.generateExecutionId();\n    this.activeExecutions.add(executionId);\n\n    const startTime = Date.now();\n    const results: HookHandlerResult[] = [];\n\n    try {\n      // Get all hooks for this type\n      const allHooks = this.hooks.get(type) || [];\n\n      // Use hook matcher to filter applicable hooks (2-3x performance improvement)\n      const matchedHooks: HookRegistration[] = [];\n      for (const hook of allHooks) {\n        const matchResult = await this.hookMatcher.match(hook, context, payload);\n        if (matchResult.matched) {\n          matchedHooks.push(hook);\n\n          // Track matcher performance\n          this.updateMetric('hooks.matcher.executionTime', matchResult.executionTime);\n          if (matchResult.cacheHit) {\n            this.updateMetric('hooks.matcher.cacheHits', 1);\n          }\n        }\n      }\n\n      logger.debug(`Executing ${matchedHooks.length}/${allHooks.length} matched hooks for type '${type}'`);\n      this.emit('hooks:executing', {\n        type,\n        total: allHooks.length,\n        matched: matchedHooks.length,\n        executionId\n      });\n\n      // Execute matched hooks in order\n      let modifiedPayload = payload;\n      for (const hook of matchedHooks) {\n        try {\n          const result = await this.executeHook(hook, modifiedPayload, context);\n          results.push(result);\n\n          // Handle side effects\n          if (result.sideEffects) {\n            await this.processSideEffects(result.sideEffects, context);\n          }\n\n          // Update payload if modified\n          if (result.modified && result.payload) {\n            modifiedPayload = result.payload;\n          }\n\n          // Check if we should continue\n          if (!result.continue) {\n            logger.debug(`Hook '${hook.id}' halted execution chain`);\n            break;\n          }\n        } catch (error) {\n          await this.handleHookError(hook, error as Error, context);\n\n          // Determine if we should continue after error\n          if (hook.options?.errorHandler) {\n            hook.options.errorHandler(error as Error);\n          } else {\n            throw error; // Re-throw if no error handler\n          }\n        }\n      }\n      \n      // Update metrics\n      const duration = Date.now() - startTime;\n      this.updateMetric('hooks.executions', 1);\n      this.updateMetric('hooks.totalDuration', duration);\n      this.updateMetric(`hooks.${type}.executions`, 1);\n      this.updateMetric(`hooks.${type}.duration`, duration);\n      \n      this.emit('hooks:executed', { \n        type, \n        results, \n        duration, \n        executionId \n      });\n      \n      return results;\n    } finally {\n      this.activeExecutions.delete(executionId);\n    }\n  }\n\n  /**\n   * Create a new hook pipeline\n   */\n  createPipeline(config: Partial<HookPipeline>): HookPipeline {\n    const pipeline: HookPipeline = {\n      id: config.id || this.generatePipelineId(),\n      name: config.name || 'Unnamed Pipeline',\n      stages: config.stages || [],\n      errorStrategy: config.errorStrategy || 'fail-fast',\n      metrics: {\n        executions: 0,\n        avgDuration: 0,\n        errorRate: 0,\n        throughput: 0,\n      },\n    };\n    \n    this.pipelines.set(pipeline.id, pipeline);\n    logger.info(`Created pipeline '${pipeline.name}' with ID '${pipeline.id}'`);\n    \n    return pipeline;\n  }\n\n  /**\n   * Execute a pipeline\n   */\n  async executePipeline(\n    pipelineId: string,\n    initialPayload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    const pipeline = this.pipelines.get(pipelineId);\n    if (!pipeline) {\n      throw new Error(`Pipeline '${pipelineId}' not found`);\n    }\n    \n    const startTime = Date.now();\n    const results: HookHandlerResult[] = [];\n    let currentPayload = initialPayload;\n    \n    try {\n      for (const stage of pipeline.stages) {\n        // Check stage condition\n        if (stage.condition && !stage.condition(context)) {\n          logger.debug(`Skipping stage '${stage.name}' due to condition`);\n          continue;\n        }\n        \n        // Execute stage hooks\n        const stageResults = await this.executeStage(\n          stage, \n          currentPayload, \n          context\n        );\n        \n        // Apply stage transform if provided\n        if (stage.transform) {\n          for (let i = 0; i < stageResults.length; i++) {\n            stageResults[i] = stage.transform(stageResults[i]);\n          }\n        }\n        \n        results.push(...stageResults);\n        \n        // Update payload for next stage\n        const lastModified = stageResults\n          .reverse()\n          .find(r => r.modified && r.payload);\n        if (lastModified) {\n          currentPayload = lastModified.payload;\n        }\n      }\n      \n      // Update pipeline metrics\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, false);\n      \n      return results;\n    } catch (error) {\n      // Update error metrics\n      this.updatePipelineMetrics(pipeline, Date.now() - startTime, true);\n      \n      // Handle error based on strategy\n      if (pipeline.errorStrategy === 'rollback') {\n        await this.rollbackPipeline(pipeline, results, context);\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): Record<string, any> {\n    const metrics: Record<string, any> = {};\n\n    for (const [key, value] of this.metrics.entries()) {\n      metrics[key] = value;\n    }\n\n    // Add computed metrics\n    metrics['hooks.count'] = this.getTotalHookCount();\n    metrics['hooks.types'] = Array.from(this.hooks.keys());\n    metrics['pipelines.count'] = this.pipelines.size;\n    metrics['executions.active'] = this.activeExecutions.size;\n\n    // Add matcher metrics\n    const matcherStats = this.hookMatcher.getCacheStats();\n    metrics['hooks.matcher.cacheSize'] = matcherStats.size;\n    metrics['hooks.matcher.cacheHitRate'] = matcherStats.hitRate;\n\n    return metrics;\n  }\n\n  /**\n   * Clear hook matcher cache\n   */\n  clearMatcherCache(): void {\n    this.hookMatcher.clearCache();\n    logger.info('Hook matcher cache cleared');\n  }\n\n  /**\n   * Prune matcher cache\n   */\n  pruneMatcherCache(): number {\n    const pruned = this.hookMatcher.pruneCache();\n    logger.info(`Pruned ${pruned} expired matcher cache entries`);\n    return pruned;\n  }\n\n  // ===== Private Methods =====\n\n  private validateRegistration(registration: HookRegistration): void {\n    if (!registration.id) {\n      throw new Error('Hook registration must have an ID');\n    }\n    \n    if (!registration.type) {\n      throw new Error('Hook registration must have a type');\n    }\n    \n    if (typeof registration.handler !== 'function') {\n      throw new Error('Hook registration must have a handler function');\n    }\n    \n    if (registration.priority < 0) {\n      throw new Error('Hook priority must be non-negative');\n    }\n  }\n\n  private matchesFilter(hook: HookRegistration, filter: HookFilter): boolean {\n    if (!hook.filter) {\n      return true; // No filter means hook applies to all\n    }\n    \n    // Check providers\n    if (filter.providers && hook.filter.providers) {\n      const hasProvider = filter.providers.some(p => \n        hook.filter!.providers!.includes(p)\n      );\n      if (!hasProvider) return false;\n    }\n    \n    // Check models\n    if (filter.models && hook.filter.models) {\n      const hasModel = filter.models.some(m => \n        hook.filter!.models!.includes(m)\n      );\n      if (!hasModel) return false;\n    }\n    \n    // Check patterns\n    if (filter.patterns && hook.filter.patterns) {\n      // Complex pattern matching logic here\n      // For now, simplified version\n      return true;\n    }\n    \n    // Check conditions\n    if (filter.conditions && hook.filter.conditions) {\n      // Evaluate conditions\n      // Simplified for now\n      return true;\n    }\n    \n    return true;\n  }\n\n  private createFilterFromPayload(payload: HookPayload): HookFilter | undefined {\n    const filter: HookFilter = {};\n    \n    // Extract filter criteria from payload\n    if ('provider' in payload) {\n      filter.providers = [payload.provider];\n    }\n    \n    if ('model' in payload) {\n      filter.models = [payload.model];\n    }\n    \n    if ('operation' in payload) {\n      filter.operations = [payload.operation];\n    }\n    \n    if ('namespace' in payload) {\n      filter.namespaces = [payload.namespace];\n    }\n    \n    return Object.keys(filter).length > 0 ? filter : undefined;\n  }\n\n  private async executeHook(\n    hook: HookRegistration,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Check cache if enabled\n      if (hook.options?.cache?.enabled) {\n        const cacheKey = hook.options.cache.key(payload);\n        const cached = this.getCachedResult(hook.id, cacheKey);\n        if (cached) {\n          this.updateMetric('hooks.cacheHits', 1);\n          return cached;\n        }\n      }\n      \n      // Execute with timeout if specified\n      let resultPromise = hook.handler(payload, context);\n      \n      if (hook.options?.timeout) {\n        resultPromise = this.withTimeout(\n          resultPromise, \n          hook.options.timeout,\n          `Hook '${hook.id}' timed out`\n        );\n      }\n      \n      const result = await resultPromise;\n      \n      // Cache result if enabled\n      if (hook.options?.cache?.enabled && result) {\n        const cacheKey = hook.options.cache.key(payload);\n        this.cacheResult(hook.id, cacheKey, result, hook.options.cache.ttl);\n      }\n      \n      // Update hook-specific metrics\n      const duration = Date.now() - startTime;\n      this.updateMetric(`hooks.${hook.id}.executions`, 1);\n      this.updateMetric(`hooks.${hook.id}.duration`, duration);\n      \n      return result;\n    } catch (error) {\n      // Handle retries if configured\n      if (hook.options?.retries && hook.options.retries > 0) {\n        logger.warn(`Hook '${hook.id}' failed, retrying...`);\n        return this.retryHook(hook, payload, context, hook.options.retries);\n      }\n      \n      // Use fallback if provided\n      if (hook.options?.fallback) {\n        logger.warn(`Hook '${hook.id}' failed, using fallback`);\n        return hook.options.fallback(payload, context);\n      }\n      \n      throw error;\n    }\n  }\n\n  private async retryHook(\n    hook: HookRegistration,\n    payload: HookPayload,\n    context: AgenticHookContext,\n    retriesLeft: number\n  ): Promise<HookHandlerResult> {\n    for (let i = 0; i < retriesLeft; i++) {\n      try {\n        await this.delay(Math.pow(2, i) * 1000); // Exponential backoff\n        return await hook.handler(payload, context);\n      } catch (error) {\n        if (i === retriesLeft - 1) {\n          throw error; // Last retry failed\n        }\n      }\n    }\n    \n    // Should not reach here\n    throw new Error('Retry logic error');\n  }\n\n  private async processSideEffects(\n    sideEffects: SideEffect[],\n    context: AgenticHookContext\n  ): Promise<void> {\n    for (const effect of sideEffects) {\n      try {\n        await this.processSideEffect(effect, context);\n      } catch (error) {\n        logger.error(`Failed to process side effect: ${effect.type}`, error);\n        // Continue processing other side effects\n      }\n    }\n  }\n\n  private async processSideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    switch (effect.type) {\n      case 'memory':\n        await this.processMemorySideEffect(effect, context);\n        break;\n      \n      case 'neural':\n        await this.processNeuralSideEffect(effect, context);\n        break;\n      \n      case 'metric':\n        this.processMetricSideEffect(effect);\n        break;\n      \n      case 'notification':\n        this.processNotificationSideEffect(effect);\n        break;\n      \n      case 'log':\n        this.processLogSideEffect(effect);\n        break;\n    }\n  }\n\n  private async processMemorySideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Implement memory side effect processing\n    // This would integrate with the memory service\n    logger.debug(`Processing memory side effect: ${effect.action}`, effect.data);\n  }\n\n  private async processNeuralSideEffect(\n    effect: SideEffect,\n    context: AgenticHookContext\n  ): Promise<void> {\n    // Implement neural side effect processing\n    // This would integrate with the neural service\n    logger.debug(`Processing neural side effect: ${effect.action}`, effect.data);\n  }\n\n  private processMetricSideEffect(effect: SideEffect): void {\n    if (effect.action === 'update') {\n      this.updateMetric(effect.data.name, effect.data.value);\n    } else if (effect.action === 'increment') {\n      this.updateMetric(effect.data.name, 1);\n    }\n  }\n\n  private processNotificationSideEffect(effect: SideEffect): void {\n    this.emit('notification', effect.data);\n  }\n\n  private processLogSideEffect(effect: SideEffect): void {\n    const { level = 'info', message, data } = effect.data;\n    logger[level as keyof Logger](message, data);\n  }\n\n  private async handleHookError(\n    hook: HookRegistration,\n    error: Error,\n    context: AgenticHookContext\n  ): Promise<void> {\n    logger.error(`Hook '${hook.id}' error:`, error);\n    \n    this.updateMetric('hooks.errors', 1);\n    this.updateMetric(`hooks.${hook.id}.errors`, 1);\n    \n    this.emit('hook:error', {\n      hookId: hook.id,\n      type: hook.type,\n      error,\n      context,\n    });\n  }\n\n  private async executeStage(\n    stage: PipelineStage,\n    payload: HookPayload,\n    context: AgenticHookContext\n  ): Promise<HookHandlerResult[]> {\n    if (stage.parallel) {\n      // Execute hooks in parallel\n      const promises = stage.hooks.map(hook => \n        this.executeHook(hook, payload, context)\n      );\n      return Promise.all(promises);\n    } else {\n      // Execute hooks sequentially\n      const results: HookHandlerResult[] = [];\n      let currentPayload = payload;\n      \n      for (const hook of stage.hooks) {\n        const result = await this.executeHook(hook, currentPayload, context);\n        results.push(result);\n        \n        if (result.modified && result.payload) {\n          currentPayload = result.payload;\n        }\n        \n        if (!result.continue) {\n          break;\n        }\n      }\n      \n      return results;\n    }\n  }\n\n  private updatePipelineMetrics(\n    pipeline: HookPipeline,\n    duration: number,\n    hasError: boolean\n  ): void {\n    const metrics = pipeline.metrics;\n    \n    metrics.executions++;\n    metrics.avgDuration = \n      (metrics.avgDuration * (metrics.executions - 1) + duration) / \n      metrics.executions;\n    \n    if (hasError) {\n      metrics.errorRate = \n        (metrics.errorRate * (metrics.executions - 1) + 1) / \n        metrics.executions;\n    } else {\n      metrics.errorRate = \n        (metrics.errorRate * (metrics.executions - 1)) / \n        metrics.executions;\n    }\n    \n    // Calculate throughput (executions per minute)\n    const timeWindow = 60000; // 1 minute\n    metrics.throughput = (metrics.executions / duration) * timeWindow;\n  }\n\n  private async rollbackPipeline(\n    pipeline: HookPipeline,\n    results: HookHandlerResult[],\n    context: AgenticHookContext\n  ): Promise<void> {\n    logger.warn(`Rolling back pipeline '${pipeline.name}'`);\n    // Implement rollback logic based on side effects in results\n    // This is a placeholder for actual rollback implementation\n  }\n\n  private getTotalHookCount(): number {\n    let count = 0;\n    for (const hookList of this.hooks.values()) {\n      count += hookList.length;\n    }\n    return count;\n  }\n\n  private initializeMetrics(): void {\n    this.metrics.set('hooks.registered', 0);\n    this.metrics.set('hooks.unregistered', 0);\n    this.metrics.set('hooks.executions', 0);\n    this.metrics.set('hooks.errors', 0);\n    this.metrics.set('hooks.cacheHits', 0);\n    this.metrics.set('hooks.totalDuration', 0);\n  }\n\n  private updateMetric(key: string, value: number): void {\n    const current = this.metrics.get(key) || 0;\n    this.metrics.set(key, current + value);\n  }\n\n  private generateExecutionId(): string {\n    return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generatePipelineId(): string {\n    return `pipe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getCachedResult(\n    hookId: string, \n    cacheKey: string\n  ): HookHandlerResult | null {\n    // Implement cache retrieval\n    // This is a placeholder\n    return null;\n  }\n\n  private cacheResult(\n    hookId: string,\n    cacheKey: string,\n    result: HookHandlerResult,\n    ttl: number\n  ): void {\n    // Implement cache storage\n    // This is a placeholder\n  }\n\n  private async withTimeout<T>(\n    promise: Promise<T>,\n    timeout: number,\n    message: string\n  ): Promise<T> {\n    return Promise.race([\n      promise,\n      new Promise<T>((_, reject) => \n        setTimeout(() => reject(new Error(message)), timeout)\n      ),\n    ]);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Export singleton instance\nexport const agenticHookManager = new AgenticHookManager();"],"names":["EventEmitter","Logger","HookMatcher","logger","level","format","destination","prefix","AgenticHookManager","hooks","Map","pipelines","metrics","activeExecutions","Set","hookMatcher","initializeMetrics","cacheEnabled","cacheTTL","matchStrategy","register","registration","type","id","validateRegistration","has","set","hookList","get","some","h","Error","insertIndex","findIndex","priority","push","splice","info","emit","updateMetric","unregister","found","entries","index","length","delete","getHooks","filter","hook","matchesFilter","executeHooks","payload","context","executionId","generateExecutionId","add","startTime","Date","now","results","allHooks","matchedHooks","matchResult","match","matched","executionTime","cacheHit","debug","total","modifiedPayload","result","executeHook","sideEffects","processSideEffects","modified","continue","error","handleHookError","options","errorHandler","duration","createPipeline","config","pipeline","generatePipelineId","name","stages","errorStrategy","executions","avgDuration","errorRate","throughput","executePipeline","pipelineId","initialPayload","currentPayload","stage","condition","stageResults","executeStage","transform","i","lastModified","reverse","find","r","updatePipelineMetrics","rollbackPipeline","getMetrics","key","value","getTotalHookCount","Array","from","keys","size","matcherStats","getCacheStats","hitRate","clearMatcherCache","clearCache","pruneMatcherCache","pruned","pruneCache","handler","providers","hasProvider","p","includes","models","hasModel","m","patterns","conditions","createFilterFromPayload","provider","model","operations","operation","namespaces","namespace","Object","undefined","cache","enabled","cacheKey","cached","getCachedResult","resultPromise","timeout","withTimeout","cacheResult","ttl","retries","warn","retryHook","fallback","retriesLeft","delay","Math","pow","effect","processSideEffect","processMemorySideEffect","processNeuralSideEffect","processMetricSideEffect","processNotificationSideEffect","processLogSideEffect","action","data","message","hookId","parallel","promises","map","Promise","all","hasError","timeWindow","count","values","current","random","toString","substr","promise","race","_","reject","setTimeout","ms","resolve","agenticHookManager"],"mappings":"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"}