{"version":3,"sources":["../../../src/maestro/maestro-types.ts"],"sourcesContent":["export interface MaestroSpec {\n  name: string;\n  description: string;\n  version: string;\n  goals: string[];\n  workflow: WorkflowPhase[];\n}\n\nexport interface WorkflowPhase {\n  step: string;\n  agent: string; // Name of the sub-agent\n  input?: string;\n  input_from?: string; // Reference to previous step's output\n  input_transform?: string;\n  output_format: string;\n  next_step_on_success?: string;\n  parallel_tasks?: Array<{ task: string; agent: string; input: string }>;\n  environment?: string;\n  on_failure?: string;\n}\n\nexport interface TaskItem {\n  id: string;\n  description: string;\n  status: 'pending' | 'in-progress' | 'completed' | 'failed';\n  assignedAgent?: string;\n  dependencies?: string[];\n  priority: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface AgentProfile {\n  id: string;\n  name: string;\n  type: string;\n  capabilities: string[];\n  maxConcurrentTasks: number;\n  priority: number;\n}\n\nexport interface SteeringContext {\n  domain: string;\n  guidelines: string;\n  constraints: string[];\n  examples?: string[];\n}\n\nexport type WorkflowPhase = \n  | 'Requirements Clarification'\n  | 'Research & Design'\n  | 'Implementation Planning'\n  | 'Task Execution'\n  | 'Completed';\n\nexport interface MaestroWorkflowState {\n  featureName: string;\n  currentPhase: WorkflowPhase;\n  currentTaskIndex: number;\n  status: 'idle' | 'running' | 'paused' | 'completed' | 'failed';\n  lastActivity: Date;\n  history: Array<{ phase: WorkflowPhase; status: 'completed' | 'failed' | 'in-progress' | 'approved'; timestamp: Date; output?: any; error?: string }>;\n  // Add more state as needed, e.g., for human-in-the-loop gates\n}\n\n// ===== KIRO ENHANCEMENT TYPES =====\n\nexport interface KiroEnhancedSpec extends MaestroSpec {\n  livingDocumentation: LivingDocumentationConfig;\n  agentHooks: AgentHookConfig[];\n  consensusRequirements: ConsensusRequirements;\n  patternLearning: PatternLearningConfig;\n  enhancedMetadata: SpecMetadata;\n}\n\nexport interface LivingDocumentationConfig {\n  enabled: boolean;\n  syncMode: 'bidirectional' | 'spec-to-code' | 'code-to-spec';\n  autoUpdateThreshold: number; // 0-1, how much change triggers auto-update\n  conflictResolution: 'manual' | 'spec-wins' | 'code-wins' | 'merge';\n  versionTracking: boolean;\n  changeDetectionGranularity: 'file' | 'function' | 'line';\n  realTimeSync: boolean;\n  watchPatterns: string[]; // File patterns to watch\n  excludePatterns: string[]; // File patterns to exclude\n}\n\nexport interface AgentHookConfig {\n  type: 'file-change' | 'code-quality' | 'documentation' | 'testing' | 'deployment';\n  trigger: HookTrigger;\n  actions: HookAction[];\n  conditions: HookCondition[];\n  priority: number;\n  enabled: boolean;\n  agentTypes: string[]; // Which agent types should handle this hook\n  metadata: Record<string, any>;\n}\n\nexport interface HookTrigger {\n  event: 'file-modified' | 'file-created' | 'file-deleted' | 'git-commit' | 'test-failed' | 'build-failed';\n  patterns: string[]; // File patterns or other patterns\n  debounceMs: number; // Debounce multiple triggers\n  batchingEnabled: boolean;\n  conditions?: string[]; // Additional trigger conditions\n}\n\nexport interface HookAction {\n  type: 'spawn-agent' | 'update-spec' | 'run-tests' | 'generate-docs' | 'quality-check';\n  agentType: string;\n  parameters: Record<string, any>;\n  timeout: number;\n  retryCount: number;\n  background: boolean;\n}\n\nexport interface HookCondition {\n  type: 'file-size' | 'file-age' | 'git-status' | 'test-status' | 'custom';\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches';\n  value: any;\n  negate?: boolean;\n}\n\nexport interface ConsensusRequirements {\n  enabled: boolean;\n  algorithm: 'simple-majority' | 'weighted-vote' | 'byzantine-fault-tolerant' | 'raft';\n  minimumAgents: number;\n  quorumPercentage: number; // 0-1, what percentage needed for consensus\n  timeoutMs: number;\n  retryCount: number;\n  validatorAgentTypes: string[];\n  consensusScope: 'design-phase' | 'implementation-phase' | 'all-phases';\n  conflictResolution: 'revote' | 'escalate' | 'fallback-to-human';\n}\n\nexport interface PatternLearningConfig {\n  enabled: boolean;\n  learningMode: 'passive' | 'active' | 'hybrid';\n  dataCollection: {\n    specHistory: boolean;\n    designDecisions: boolean;\n    implementationOutcomes: boolean;\n    userFeedback: boolean;\n  };\n  modelType: 'rule-based' | 'ml-based' | 'hybrid';\n  adaptationThreshold: number; // How much data before adapting\n  confidenceThreshold: number; // Minimum confidence for suggestions\n}\n\nexport interface SpecMetadata {\n  createdAt: Date;\n  lastModified: Date;\n  version: string;\n  contributors: string[];\n  reviewers: string[];\n  approvalStatus: 'draft' | 'under-review' | 'approved' | 'deprecated';\n  tags: string[];\n  relatedSpecs: string[];\n  implementationStatus: {\n    phase: string;\n    progress: number; // 0-1\n    quality: number; // 0-1\n    testCoverage: number; // 0-1\n  };\n  metrics: {\n    cycleTime: number; // ms from spec to implementation\n    defectRate: number;\n    changeFrequency: number;\n    stakeholderSatisfaction: number; // 0-1\n  };\n}\n\n// ===== ENHANCED WORKFLOW TYPES =====\n\nexport interface EnhancedWorkflowPhase extends WorkflowPhase {\n  hooks: AgentHookConfig[];\n  consensusRequired: boolean;\n  livingDocSync: boolean;\n  patternLearningEnabled: boolean;\n  qualityGates: QualityGate[];\n  parallelExecution: boolean;\n  backgroundMonitoring: boolean;\n}\n\nexport interface QualityGate {\n  id: string;\n  name: string;\n  type: 'automated' | 'manual' | 'hybrid';\n  criteria: QualityCriteria[];\n  threshold: number; // 0-1\n  blocking: boolean; // Does failure block progression?\n  agentTypes: string[]; // Which agents can validate this gate\n}\n\nexport interface QualityCriteria {\n  metric: string;\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';\n  value: number;\n  weight: number; // 0-1, importance of this criteria\n  source: 'automated-test' | 'code-analysis' | 'human-review' | 'consensus';\n}\n\n// ===== LIVING DOCUMENTATION TYPES =====\n\nexport interface LivingDocumentationState {\n  specVersion: string;\n  codeVersion: string;\n  lastSyncTimestamp: Date;\n  syncStatus: 'in-sync' | 'diverged' | 'syncing' | 'conflict';\n  changesSinceLastSync: DocumentationChange[];\n  conflicts: SyncConflict[];\n  automatedSyncEnabled: boolean;\n}\n\nexport interface DocumentationChange {\n  id: string;\n  type: 'spec-change' | 'code-change';\n  file: string;\n  section?: string;\n  oldValue: string;\n  newValue: string;\n  timestamp: Date;\n  author: string;\n  confidence: number; // 0-1, how confident we are about this change\n}\n\nexport interface SyncConflict {\n  id: string;\n  type: 'content-conflict' | 'structural-conflict' | 'semantic-conflict';\n  specSection: string;\n  codeSection: string;\n  description: string;\n  resolutionStrategy: 'manual' | 'spec-wins' | 'code-wins' | 'merge';\n  priority: 'low' | 'medium' | 'high';\n  createdAt: Date;\n}\n\n// ===== CONSENSUS SYSTEM TYPES =====\n\nexport interface ConsensusSession {\n  id: string;\n  topic: string;\n  participants: ConsensusParticipant[];\n  status: 'pending' | 'active' | 'completed' | 'failed' | 'timeout';\n  startedAt: Date;\n  completedAt?: Date;\n  result?: ConsensusResult;\n  rounds: ConsensusRound[];\n  metadata: Record<string, any>;\n}\n\nexport interface ConsensusParticipant {\n  agentId: string;\n  agentType: string;\n  weight: number; // Voting weight based on expertise\n  reliability: number; // 0-1, historical reliability\n  expertise: Record<string, number>; // Domain expertise scores\n  availability: boolean;\n}\n\nexport interface ConsensusRound {\n  round: number;\n  votes: ConsensusVote[];\n  result: 'consensus' | 'no-consensus' | 'timeout';\n  timestamp: Date;\n  convergenceMetric: number; // How close to consensus\n}\n\nexport interface ConsensusVote {\n  agentId: string;\n  option: string;\n  confidence: number; // 0-1\n  reasoning: string;\n  timestamp: Date;\n  metadata?: Record<string, any>;\n}\n\nexport interface ConsensusResult {\n  decision: string;\n  confidence: number; // 0-1\n  unanimity: boolean;\n  participationRate: number; // 0-1\n  qualityScore: number; // 0-1\n  dissents: ConsensusDissent[];\n  metadata: Record<string, any>;\n}\n\nexport interface ConsensusDissent {\n  agentId: string;\n  reason: string;\n  alternativeProposal?: string;\n  severity: 'low' | 'medium' | 'high';\n}\n\n// ===== AGENT HOOK SYSTEM TYPES =====\n\nexport interface AgentHookEvent {\n  id: string;\n  type: string;\n  source: string;\n  timestamp: Date;\n  data: Record<string, any>;\n  processed: boolean;\n  processingResults?: HookProcessingResult[];\n}\n\nexport interface HookProcessingResult {\n  hookId: string;\n  agentId: string;\n  status: 'success' | 'failed' | 'timeout';\n  result?: any;\n  error?: string;\n  processingTime: number; // ms\n  timestamp: Date;\n}\n\n// ===== PATTERN LEARNING TYPES =====\n\nexport interface PatternLearningData {\n  specificationPatterns: SpecPattern[];\n  designPatterns: DesignPattern[];\n  implementationPatterns: ImplementationPattern[];\n  outcomePatterns: OutcomePattern[];\n}\n\nexport interface SpecPattern {\n  id: string;\n  domain: string;\n  pattern: string;\n  frequency: number;\n  successRate: number;\n  contexts: string[];\n  examples: string[];\n}\n\nexport interface DesignPattern {\n  id: string;\n  architecture: string;\n  components: string[];\n  relationships: string[];\n  applicability: string[];\n  pros: string[];\n  cons: string[];\n  usage_frequency: number;\n}\n\nexport interface ImplementationPattern {\n  id: string;\n  language: string;\n  framework: string;\n  pattern_code: string;\n  complexity: 'low' | 'medium' | 'high';\n  maintainability: number; // 0-1\n  performance: number; // 0-1\n}\n\nexport interface OutcomePattern {\n  id: string;\n  inputs: Record<string, any>;\n  outputs: Record<string, any>;\n  quality: number; // 0-1\n  timeline: number; // actual time taken\n  stakeholder_satisfaction: number; // 0-1\n  lessons_learned: string[];\n}\n\n// ===== ENHANCED ORCHESTRATOR STATE =====\n\nexport interface KiroEnhancedWorkflowState extends MaestroWorkflowState {\n  livingDocState: LivingDocumentationState;\n  activeHooks: string[]; // Active hook IDs\n  consensusSessions: ConsensusSession[];\n  patternLearningData: PatternLearningData;\n  qualityMetrics: QualityMetrics;\n  backgroundAgents: string[]; // Background monitoring agents\n  enhancedMetadata: Record<string, any>;\n}\n\nexport interface QualityMetrics {\n  codeQuality: number; // 0-1\n  documentationQuality: number; // 0-1\n  testCoverage: number; // 0-1\n  specCompleteness: number; // 0-1\n  implementationFidelity: number; // 0-1, how well code matches spec\n  consensusReliability: number; // 0-1\n  cycletime: number; // ms\n  defectDensity: number; // defects per KLOC\n}\n"],"names":[],"mappings":"AAwXA,WASC"}