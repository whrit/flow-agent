{"version":3,"sources":["../../../../src/maestro/tests/native-hive-mind-integration.test.ts"],"sourcesContent":["/**\n * Native Hive Mind Integration Tests\n * \n * Comprehensive testing of the MaestroSwarmCoordinator and specs-driven\n * swarm topology to ensure proper integration with native hive mind.\n */\n\nimport { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect, jest } from '@jest/globals';\nimport { EventBus } from '../../core/event-bus.js';\nimport { Logger } from '../../core/logger.js';\nimport { MaestroSwarmCoordinator, MaestroSwarmConfig } from '../maestro-swarm-coordinator.js';\nimport { HiveMindConfig } from '../../hive-mind/types.js';\nimport { join } from 'path';\nimport { tmpdir } from 'os';\nimport { mkdtemp, rm, access } from 'fs/promises';\n\ndescribe('Native Hive Mind Integration Tests', () => {\n  let swarmCoordinator: MaestroSwarmCoordinator;\n  let eventBus: EventBus;\n  let logger: Logger;\n  let tempDir: string;\n  let config: MaestroSwarmConfig;\n\n  beforeAll(async () => {\n    // Setup test environment\n    tempDir = await mkdtemp(join(tmpdir(), 'maestro-test-'));\n    \n    // Initialize core components\n    eventBus = new EventBus();\n    logger = new Logger({ level: 'debug' });\n    \n    // Configure test swarm\n    config = {\n      hiveMindConfig: {\n        name: 'test-maestro-specs-swarm',\n        topology: 'specs-driven',\n        queenMode: 'strategic',\n        maxAgents: 8,\n        consensusThreshold: 0.66,\n        memoryTTL: 60000, // 1 minute for testing\n        autoSpawn: true,\n        enableConsensus: true,\n        enableMemory: true,\n        enableCommunication: true\n      },\n      enableConsensusValidation: true,\n      enableLivingDocumentation: true,\n      enableSteeringIntegration: true,\n      specsDirectory: join(tempDir, 'specs'),\n      steeringDirectory: join(tempDir, 'steering')\n    };\n  });\n\n  afterAll(async () => {\n    // Cleanup\n    if (swarmCoordinator) {\n      await swarmCoordinator.shutdown();\n    }\n    await rm(tempDir, { recursive: true, force: true });\n  });\n\n  beforeEach(async () => {\n    // Create fresh coordinator for each test\n    swarmCoordinator = new MaestroSwarmCoordinator(config, eventBus, logger);\n  });\n\n  afterEach(async () => {\n    if (swarmCoordinator) {\n      await swarmCoordinator.shutdown();\n    }\n  });\n\n  describe('Swarm Initialization', () => {\n    it('should initialize native hive mind with specs-driven topology', async () => {\n      const swarmId = await swarmCoordinator.initialize();\n      \n      expect(swarmId).toBeDefined();\n      expect(typeof swarmId).toBe('string');\n      expect(swarmId).toMatch(/^swarm_/);\n    });\n\n    it('should spawn 8 specialized agents with correct types', async () => {\n      await swarmCoordinator.initialize();\n      \n      // Verify swarm status contains all expected agent types\n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const agents = hiveMind.agents;\n      \n      expect(agents.size).toBe(8);\n      \n      // Check for specs-driven agent types\n      const agentTypes = Array.from(agents.values()).map((agent: any) => agent.type);\n      expect(agentTypes).toContain('requirements_analyst');\n      expect(agentTypes).toContain('design_architect');\n      expect(agentTypes).toContain('task_planner');\n      expect(agentTypes).toContain('implementation_coder');\n      expect(agentTypes).toContain('quality_reviewer');\n      expect(agentTypes).toContain('steering_documenter');\n      \n      // Check agent counts\n      expect(agentTypes.filter(t => t === 'requirements_analyst')).toHaveLength(1);\n      expect(agentTypes.filter(t => t === 'design_architect')).toHaveLength(2);\n      expect(agentTypes.filter(t => t === 'task_planner')).toHaveLength(1);\n      expect(agentTypes.filter(t => t === 'implementation_coder')).toHaveLength(2);\n      expect(agentTypes.filter(t => t === 'quality_reviewer')).toHaveLength(1);\n      expect(agentTypes.filter(t => t === 'steering_documenter')).toHaveLength(1);\n    });\n\n    it('should initialize steering documents in swarm memory', async () => {\n      await swarmCoordinator.initialize();\n      \n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      \n      // Check that default steering documents are initialized\n      const productSteering = await hiveMind.memory.retrieve('steering/product');\n      const techSteering = await hiveMind.memory.retrieve('steering/tech');\n      const workflowSteering = await hiveMind.memory.retrieve('steering/workflow');\n      \n      expect(productSteering).toBeDefined();\n      expect(productSteering.domain).toBe('product');\n      expect(techSteering).toBeDefined();\n      expect(techSteering.domain).toBe('tech');\n      expect(workflowSteering).toBeDefined();\n      expect(workflowSteering.domain).toBe('workflow');\n    });\n  });\n\n  describe('Specs-Driven Workflow', () => {\n    beforeEach(async () => {\n      await swarmCoordinator.initialize();\n    });\n\n    it('should create specification using requirements_analyst agent', async () => {\n      const featureName = 'test-auth-feature';\n      const initialRequest = 'Create user authentication system with JWT tokens';\n      \n      await swarmCoordinator.createSpec(featureName, initialRequest);\n      \n      // Verify workflow state\n      const workflowState = swarmCoordinator.getWorkflowState(featureName);\n      expect(workflowState).toBeDefined();\n      expect(workflowState!.featureName).toBe(featureName);\n      expect(workflowState!.currentPhase).toBe('Requirements Clarification');\n      expect(workflowState!.status).toBe('running');\n      \n      // Verify requirements file was created\n      const requirementsPath = join(config.specsDirectory, featureName, 'requirements.md');\n      await expect(access(requirementsPath)).resolves.not.toThrow();\n    }, 30000);\n\n    it('should generate design using parallel design_architect agents with consensus', async () => {\n      const featureName = 'test-design-feature';\n      \n      // First create spec\n      await swarmCoordinator.createSpec(featureName, 'Test feature for design generation');\n      \n      // Then generate design\n      await swarmCoordinator.generateDesign(featureName);\n      \n      // Verify workflow progression\n      const workflowState = swarmCoordinator.getWorkflowState(featureName);\n      expect(workflowState!.currentPhase).toBe('Research & Design');\n      expect(workflowState!.history).toHaveLength(2);\n      expect(workflowState!.history[1].phase).toBe('Research & Design');\n      expect(workflowState!.history[1].status).toBe('completed');\n      \n      // Verify design file was created\n      const designPath = join(config.specsDirectory, featureName, 'design.md');\n      await expect(access(designPath)).resolves.not.toThrow();\n    }, 60000);\n\n    it('should generate tasks using task_planner agent', async () => {\n      const featureName = 'test-tasks-feature';\n      \n      // Setup: create spec and design\n      await swarmCoordinator.createSpec(featureName, 'Test feature for task generation');\n      await swarmCoordinator.generateDesign(featureName);\n      \n      // Generate tasks\n      await swarmCoordinator.generateTasks(featureName);\n      \n      // Verify workflow progression\n      const workflowState = swarmCoordinator.getWorkflowState(featureName);\n      expect(workflowState!.currentPhase).toBe('Implementation Planning');\n      \n      // Verify tasks file was created\n      const tasksPath = join(config.specsDirectory, featureName, 'tasks.md');\n      await expect(access(tasksPath)).resolves.not.toThrow();\n    }, 90000);\n\n    it('should implement tasks using implementation_coder agents', async () => {\n      const featureName = 'test-implementation-feature';\n      \n      // Setup complete workflow\n      await swarmCoordinator.createSpec(featureName, 'Test feature for implementation');\n      await swarmCoordinator.generateDesign(featureName);\n      await swarmCoordinator.generateTasks(featureName);\n      \n      // Implement first task\n      await swarmCoordinator.implementTask(featureName, 1);\n      \n      // Verify workflow state\n      const workflowState = swarmCoordinator.getWorkflowState(featureName);\n      expect(workflowState!.currentPhase).toBe('Task Execution');\n      expect(workflowState!.currentTaskIndex).toBe(1);\n    }, 120000);\n  });\n\n  describe('Consensus Validation', () => {\n    beforeEach(async () => {\n      await swarmCoordinator.initialize();\n    });\n\n    it('should use consensus for phase approval when enabled', async () => {\n      const featureName = 'test-consensus-feature';\n      \n      await swarmCoordinator.createSpec(featureName, 'Test consensus validation');\n      \n      // Mock consensus engine for testing\n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const consensusEngine = hiveMind.consensus;\n      \n      jest.spyOn(consensusEngine, 'createProposal').mockResolvedValue('test-proposal-id');\n      jest.spyOn(consensusEngine, 'getProposalStatus').mockResolvedValue({\n        status: 'achieved',\n        currentRatio: 0.75\n      });\n      \n      await swarmCoordinator.approvePhase(featureName);\n      \n      expect(consensusEngine.createProposal).toHaveBeenCalled();\n      expect(consensusEngine.getProposalStatus).toHaveBeenCalled();\n    });\n\n    it('should handle consensus failure gracefully', async () => {\n      const featureName = 'test-consensus-failure';\n      \n      await swarmCoordinator.createSpec(featureName, 'Test consensus failure handling');\n      \n      // Mock consensus failure\n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const consensusEngine = hiveMind.consensus;\n      \n      jest.spyOn(consensusEngine, 'createProposal').mockResolvedValue('test-proposal-id');\n      jest.spyOn(consensusEngine, 'getProposalStatus').mockResolvedValue({\n        status: 'failed',\n        currentRatio: 0.4\n      });\n      \n      await expect(swarmCoordinator.approvePhase(featureName))\n        .rejects.toThrow('Phase approval consensus failed');\n    });\n  });\n\n  describe('Steering Integration', () => {\n    beforeEach(async () => {\n      await swarmCoordinator.initialize();\n    });\n\n    it('should create steering documents in swarm memory', async () => {\n      const domain = 'custom-steering';\n      const content = 'Custom steering guidelines for testing';\n      \n      await swarmCoordinator.createSteeringDocument(domain, content);\n      \n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const storedDoc = await hiveMind.memory.retrieve(`steering/${domain}`);\n      \n      expect(storedDoc).toBeDefined();\n      expect(storedDoc.content).toBe(content);\n      expect(storedDoc.domain).toBe(domain);\n      expect(storedDoc.maintainer).toBe('steering_documenter');\n    });\n\n    it('should broadcast steering updates to all agents', async () => {\n      const domain = 'broadcast-test';\n      const content = 'Test broadcast content';\n      \n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const broadcastSpy = jest.spyOn(hiveMind.communication, 'broadcast');\n      \n      await swarmCoordinator.createSteeringDocument(domain, content);\n      \n      expect(broadcastSpy).toHaveBeenCalledWith({\n        type: 'steering_update',\n        domain,\n        content: expect.stringContaining('Test broadcast content')\n      });\n    });\n\n    it('should retrieve steering context for agents', async () => {\n      await swarmCoordinator.createSteeringDocument('test-context', 'Context for testing');\n      \n      const steeringContext = await (swarmCoordinator as any).getSteeringContext();\n      \n      expect(steeringContext).toContain('test-context');\n      expect(steeringContext).toContain('Context for testing');\n    });\n  });\n\n  describe('Performance and Error Handling', () => {\n    beforeEach(async () => {\n      await swarmCoordinator.initialize();\n    });\n\n    it('should handle agent spawning limits gracefully', async () => {\n      // Test with reduced agent limit\n      const limitedConfig = {\n        ...config,\n        hiveMindConfig: {\n          ...config.hiveMindConfig,\n          maxAgents: 4\n        }\n      };\n      \n      const limitedCoordinator = new MaestroSwarmCoordinator(limitedConfig, eventBus, logger);\n      await limitedCoordinator.initialize();\n      \n      const hiveMind = (limitedCoordinator as any).hiveMind;\n      expect(hiveMind.agents.size).toBeLessThanOrEqual(4);\n      \n      await limitedCoordinator.shutdown();\n    });\n\n    it('should timeout on task completion properly', async () => {\n      const featureName = 'timeout-test';\n      \n      // Mock task that never completes\n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      jest.spyOn(hiveMind, 'getTask').mockResolvedValue({\n        id: 'test-task',\n        status: 'in_progress',\n        result: null\n      });\n      \n      await expect(\n        (swarmCoordinator as any).waitForTaskCompletion('test-task', 1000)\n      ).rejects.toThrow('Task timeout');\n    });\n\n    it('should handle swarm shutdown gracefully', async () => {\n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const shutdownSpy = jest.spyOn(hiveMind, 'shutdown');\n      \n      await swarmCoordinator.shutdown();\n      \n      expect(shutdownSpy).toHaveBeenCalled();\n    });\n  });\n\n  describe('Event Integration', () => {\n    beforeEach(async () => {\n      await swarmCoordinator.initialize();\n    });\n\n    it('should emit maestro events through event bus', async () => {\n      const specCreatedSpy = jest.fn();\n      eventBus.on('maestro:spec_created', specCreatedSpy);\n      \n      await swarmCoordinator.createSpec('event-test', 'Test event emission');\n      \n      expect(specCreatedSpy).toHaveBeenCalledWith({\n        featureName: 'event-test'\n      });\n    });\n\n    it('should handle event-driven workflow progression', async () => {\n      const phaseApprovedSpy = jest.fn();\n      eventBus.on('maestro:phase_approved', phaseApprovedSpy);\n      \n      const featureName = 'workflow-events';\n      await swarmCoordinator.createSpec(featureName, 'Test workflow events');\n      \n      // Mock consensus for approval\n      const hiveMind = (swarmCoordinator as any).hiveMind;\n      const consensusEngine = hiveMind.consensus;\n      jest.spyOn(consensusEngine, 'createProposal').mockResolvedValue('test-proposal');\n      jest.spyOn(consensusEngine, 'getProposalStatus').mockResolvedValue({\n        status: 'achieved',\n        currentRatio: 0.8\n      });\n      \n      await swarmCoordinator.approvePhase(featureName);\n      \n      expect(phaseApprovedSpy).toHaveBeenCalledWith({\n        featureName,\n        nextPhase: 'Research & Design'\n      });\n    });\n  });\n});\n\n/**\n * Performance Benchmarks\n * \n * These tests measure performance improvements from native hive mind integration\n */\ndescribe('Performance Benchmarks', () => {\n  let coordinator: MaestroSwarmCoordinator;\n  let eventBus: EventBus;\n  let logger: Logger;\n  let tempDir: string;\n\n  beforeAll(async () => {\n    tempDir = await mkdtemp(join(tmpdir(), 'maestro-perf-'));\n    eventBus = new EventBus();\n    logger = new Logger({ level: 'warn' }); // Reduce logging for performance tests\n    \n    const config: MaestroSwarmConfig = {\n      hiveMindConfig: {\n        name: 'perf-test-swarm',\n        topology: 'specs-driven',\n        queenMode: 'strategic',\n        maxAgents: 8,\n        consensusThreshold: 0.66,\n        memoryTTL: 300000,\n        autoSpawn: true,\n        enableConsensus: false, // Disable for pure performance testing\n        enableMemory: true,\n        enableCommunication: true\n      },\n      enableConsensusValidation: false,\n      enableLivingDocumentation: true,\n      enableSteeringIntegration: true,\n      specsDirectory: join(tempDir, 'specs'),\n      steeringDirectory: join(tempDir, 'steering')\n    };\n    \n    coordinator = new MaestroSwarmCoordinator(config, eventBus, logger);\n    await coordinator.initialize();\n  });\n\n  afterAll(async () => {\n    await coordinator.shutdown();\n    await rm(tempDir, { recursive: true, force: true });\n  });\n\n  it('should initialize swarm within performance target (< 5 seconds)', async () => {\n    const startTime = Date.now();\n    \n    const testCoordinator = new MaestroSwarmCoordinator(\n      (coordinator as any).config,\n      eventBus,\n      logger\n    );\n    \n    await testCoordinator.initialize();\n    const duration = Date.now() - startTime;\n    \n    expect(duration).toBeLessThan(5000);\n    \n    await testCoordinator.shutdown();\n  });\n\n  it('should create specs within performance target (< 2 minutes)', async () => {\n    const startTime = Date.now();\n    \n    await coordinator.createSpec('perf-test-spec', 'Performance test specification');\n    \n    const duration = Date.now() - startTime;\n    expect(duration).toBeLessThan(120000); // 2 minutes\n  });\n\n  it('should handle multiple concurrent spec creations efficiently', async () => {\n    const startTime = Date.now();\n    const concurrentSpecs = 3;\n    \n    const promises = Array.from({ length: concurrentSpecs }, (_, i) =>\n      coordinator.createSpec(`concurrent-spec-${i}`, `Concurrent test spec ${i}`)\n    );\n    \n    await Promise.all(promises);\n    \n    const duration = Date.now() - startTime;\n    const avgTimePerSpec = duration / concurrentSpecs;\n    \n    // Should be more efficient than sequential execution\n    expect(avgTimePerSpec).toBeLessThan(90000); // < 1.5 minutes per spec on average\n  }, 300000);\n});"],"names":["describe","beforeAll","afterAll","beforeEach","afterEach","it","expect","jest","EventBus","Logger","MaestroSwarmCoordinator","join","tmpdir","mkdtemp","rm","access","swarmCoordinator","eventBus","logger","tempDir","config","level","hiveMindConfig","name","topology","queenMode","maxAgents","consensusThreshold","memoryTTL","autoSpawn","enableConsensus","enableMemory","enableCommunication","enableConsensusValidation","enableLivingDocumentation","enableSteeringIntegration","specsDirectory","steeringDirectory","shutdown","recursive","force","swarmId","initialize","toBeDefined","toBe","toMatch","hiveMind","agents","size","agentTypes","Array","from","values","map","agent","type","toContain","filter","t","toHaveLength","productSteering","memory","retrieve","techSteering","workflowSteering","domain","featureName","initialRequest","createSpec","workflowState","getWorkflowState","currentPhase","status","requirementsPath","resolves","not","toThrow","generateDesign","history","phase","designPath","generateTasks","tasksPath","implementTask","currentTaskIndex","consensusEngine","consensus","spyOn","mockResolvedValue","currentRatio","approvePhase","createProposal","toHaveBeenCalled","getProposalStatus","rejects","content","createSteeringDocument","storedDoc","maintainer","broadcastSpy","communication","toHaveBeenCalledWith","stringContaining","steeringContext","getSteeringContext","limitedConfig","limitedCoordinator","toBeLessThanOrEqual","id","result","waitForTaskCompletion","shutdownSpy","specCreatedSpy","fn","on","phaseApprovedSpy","nextPhase","coordinator","startTime","Date","now","testCoordinator","duration","toBeLessThan","concurrentSpecs","promises","length","_","i","Promise","all","avgTimePerSpec"],"mappings":"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"}