{"version":3,"sources":["../../../src/utils/metrics-reader.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\ninterface SystemMetrics {\n  timestamp: number;\n  memoryTotal: number;\n  memoryUsed: number;\n  memoryFree: number;\n  memoryUsagePercent: number;\n  memoryEfficiency: number;\n  cpuCount: number;\n  cpuLoad: number;\n  platform: string;\n  uptime: number;\n}\n\ninterface TaskMetric {\n  id: string;\n  type: string;\n  success: boolean;\n  duration: number;\n  timestamp: number;\n  metadata: Record<string, any>;\n}\n\ninterface PerformanceMetrics {\n  startTime: number;\n  totalTasks: number;\n  successfulTasks: number;\n  failedTasks: number;\n  totalAgents: number;\n  activeAgents: number;\n  neuralEvents: number;\n}\n\ninterface Agent {\n  id: string;\n  name: string;\n  type: string;\n  status: 'active' | 'idle' | 'busy';\n  activeTasks: number;\n  lastActivity?: number;\n}\n\ninterface SessionData {\n  id: string;\n  startTime: number;\n  endTime?: number;\n  agents: Agent[];\n  tasks: any[];\n  status: 'active' | 'completed' | 'paused';\n}\n\ninterface MCPServerStatus {\n  running: boolean;\n  processCount: number;\n  orchestratorRunning: boolean;\n  port: number | null;\n  connections: number;\n}\n\nexport class MetricsReader {\n  private metricsDir = '.claude-flow/metrics';\n  private sessionsDir = '.claude-flow/sessions';\n\n  async getSystemMetrics(): Promise<SystemMetrics | null> {\n    try {\n      const filePath = path.join(this.metricsDir, 'system-metrics.json');\n      const content = await fs.readFile(filePath, 'utf8');\n      const metrics: SystemMetrics[] = JSON.parse(content);\n      \n      // Return the most recent metric\n      return metrics.length > 0 ? metrics[metrics.length - 1] : null;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async getTaskMetrics(): Promise<TaskMetric[]> {\n    try {\n      const filePath = path.join(this.metricsDir, 'task-metrics.json');\n      const content = await fs.readFile(filePath, 'utf8');\n      return JSON.parse(content);\n    } catch (error) {\n      return [];\n    }\n  }\n\n  async getPerformanceMetrics(): Promise<PerformanceMetrics | null> {\n    try {\n      const filePath = path.join(this.metricsDir, 'performance.json');\n      const content = await fs.readFile(filePath, 'utf8');\n      return JSON.parse(content);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async getActiveAgents(): Promise<Agent[]> {\n    try {\n      // First check performance metrics for agent count\n      const perfMetrics = await this.getPerformanceMetrics();\n      \n      // Also check session files for more detailed agent info\n      const sessionFiles = await this.getSessionFiles();\n      const agents: Agent[] = [];\n      \n      for (const file of sessionFiles) {\n        try {\n          const content = await fs.readFile(path.join(this.sessionsDir, 'pair', file), 'utf8');\n          const sessionData = JSON.parse(content);\n          \n          if (sessionData.agents && Array.isArray(sessionData.agents)) {\n            agents.push(...sessionData.agents);\n          }\n        } catch {\n          // Skip invalid session files\n        }\n      }\n      \n      // If no agents found in sessions, create mock agents based on performance metrics\n      if (agents.length === 0 && perfMetrics) {\n        const activeCount = perfMetrics.activeAgents || 0;\n        const totalCount = perfMetrics.totalAgents || 0;\n        \n        for (let i = 0; i < totalCount; i++) {\n          agents.push({\n            id: `agent-${i + 1}`,\n            name: `Agent ${i + 1}`,\n            type: i === 0 ? 'orchestrator' : 'worker',\n            status: i < activeCount ? 'active' : 'idle',\n            activeTasks: i < activeCount ? 1 : 0,\n            lastActivity: Date.now() - (i * 1000)\n          });\n        }\n      }\n      \n      return agents;\n    } catch (error) {\n      return [];\n    }\n  }\n\n  async getSessionStatus(): Promise<SessionData | null> {\n    try {\n      const sessionFiles = await this.getSessionFiles();\n      \n      if (sessionFiles.length === 0) {\n        return null;\n      }\n      \n      // Get the most recent session\n      const mostRecentFile = sessionFiles[sessionFiles.length - 1];\n      const content = await fs.readFile(path.join(this.sessionsDir, 'pair', mostRecentFile), 'utf8');\n      return JSON.parse(content);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async getRecentTasks(limit: number = 10): Promise<any[]> {\n    try {\n      const taskMetrics = await this.getTaskMetrics();\n      \n      // Sort by timestamp descending and take the limit\n      return taskMetrics\n        .sort((a, b) => b.timestamp - a.timestamp)\n        .slice(0, limit)\n        .map(task => ({\n          id: task.id,\n          type: task.type,\n          status: task.success ? 'completed' : 'failed',\n          startTime: task.timestamp - task.duration,\n          endTime: task.timestamp,\n          duration: task.duration\n        }));\n    } catch (error) {\n      return [];\n    }\n  }\n\n  async getOverallHealth(): Promise<'healthy' | 'warning' | 'error'> {\n    try {\n      const systemMetrics = await this.getSystemMetrics();\n      const perfMetrics = await this.getPerformanceMetrics();\n      \n      if (!systemMetrics && !perfMetrics) {\n        return 'error';\n      }\n      \n      // Check memory usage\n      if (systemMetrics && systemMetrics.memoryUsagePercent > 90) {\n        return 'error';\n      }\n      \n      if (systemMetrics && systemMetrics.memoryUsagePercent > 75) {\n        return 'warning';\n      }\n      \n      // Check CPU load\n      if (systemMetrics && systemMetrics.cpuLoad > 0.8) {\n        return 'warning';\n      }\n      \n      // Check task failure rate\n      if (perfMetrics && perfMetrics.totalTasks > 0) {\n        const failureRate = perfMetrics.failedTasks / perfMetrics.totalTasks;\n        if (failureRate > 0.5) {\n          return 'error';\n        }\n        if (failureRate > 0.2) {\n          return 'warning';\n        }\n      }\n      \n      return 'healthy';\n    } catch (error) {\n      return 'error';\n    }\n  }\n\n  private async getSessionFiles(): Promise<string[]> {\n    try {\n      const files = await fs.readdir(path.join(this.sessionsDir, 'pair'));\n      return files.filter(f => f.endsWith('.json')).sort();\n    } catch (error) {\n      return [];\n    }\n  }\n\n  async getMCPServerStatus(): Promise<MCPServerStatus> {\n    try {\n      // Check if MCP server process is running\n      const { stdout } = await execAsync('ps aux | grep -E \"mcp-server\\\\.js|claude-flow mcp start\" | grep -v grep | wc -l');\n      const processCount = parseInt(stdout.trim(), 10);\n      \n      // Check for orchestrator running\n      const { stdout: orchestratorOut } = await execAsync('ps aux | grep -E \"claude-flow start\" | grep -v grep | wc -l');\n      const orchestratorRunning = parseInt(orchestratorOut.trim(), 10) > 0;\n      \n      // Determine status\n      const isRunning = processCount > 0;\n      \n      // Try to get port from process (default is 3000)\n      let port: number | null = 3000;\n      try {\n        const { stdout: portOut } = await execAsync('lsof -i :3000 2>/dev/null | grep LISTEN | wc -l');\n        if (parseInt(portOut.trim(), 10) === 0) {\n          // If port 3000 not listening, check other common ports\n          port = null;\n        }\n      } catch {\n        // lsof might not be available or port not in use\n      }\n      \n      return {\n        running: isRunning,\n        processCount,\n        orchestratorRunning,\n        port,\n        connections: processCount > 0 ? Math.max(1, processCount - 1) : 0 // Estimate connections\n      };\n    } catch (error) {\n      // Fallback if commands fail\n      return {\n        running: false,\n        processCount: 0,\n        orchestratorRunning: false,\n        port: null,\n        connections: 0\n      };\n    }\n  }\n}"],"names":["fs","path","exec","promisify","execAsync","MetricsReader","metricsDir","sessionsDir","getSystemMetrics","filePath","join","content","readFile","metrics","JSON","parse","length","error","getTaskMetrics","getPerformanceMetrics","getActiveAgents","perfMetrics","sessionFiles","getSessionFiles","agents","file","sessionData","Array","isArray","push","activeCount","activeAgents","totalCount","totalAgents","i","id","name","type","status","activeTasks","lastActivity","Date","now","getSessionStatus","mostRecentFile","getRecentTasks","limit","taskMetrics","sort","a","b","timestamp","slice","map","task","success","startTime","duration","endTime","getOverallHealth","systemMetrics","memoryUsagePercent","cpuLoad","totalTasks","failureRate","failedTasks","files","readdir","filter","f","endsWith","getMCPServerStatus","stdout","processCount","parseInt","trim","orchestratorOut","orchestratorRunning","isRunning","port","portOut","running","connections","Math","max"],"mappings":"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"}