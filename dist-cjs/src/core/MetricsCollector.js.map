{"version":3,"sources":["../../../src/core/MetricsCollector.ts"],"sourcesContent":["/**\n * MetricsCollector - Performance and coordination tracking\n * Collects, aggregates, and analyzes system performance metrics\n */\n\nimport { IDatabaseProvider, InitializationMetrics, Metrics, PerformanceMetrics } from '../types/interfaces.js';\n\nexport interface SystemHealth {\n  status: 'healthy' | 'degraded' | 'critical';\n  score: number; // 0-100\n  issues: string[];\n  recommendations: string[];\n}\n\nexport interface PerformanceTrend {\n  metric: string;\n  trend: 'improving' | 'stable' | 'degrading';\n  change: number; // percentage change\n  period: string;\n}\n\nexport interface Benchmark {\n  name: string;\n  value: number;\n  unit: string;\n  timestamp: Date;\n  baseline?: number;\n  percentile?: number;\n}\n\nexport class MetricsCollector {\n  private metricsBuffer: Map<string, any[]> = new Map();\n  private initialized: boolean = false;\n\n  constructor(private database: IDatabaseProvider) {}\n\n  /**\n   * Initialize metrics collection\n   */\n  async initialize(): Promise<void> {\n    // Create metrics tables/collections if using database\n    await this.setupMetricsStorage();\n    this.initialized = true;\n  }\n\n  /**\n   * Setup metrics storage structure\n   */\n  private async setupMetricsStorage(): Promise<void> {\n    // Initialize metrics namespaces\n    const namespaces = [\n      'initialization',\n      'system',\n      'performance',\n      'agents',\n      'consensus',\n      'topology',\n      'benchmarks'\n    ];\n\n    for (const namespace of namespaces) {\n      try {\n        await this.database.store(`metrics-${namespace}-init`, {\n          initialized: true,\n          timestamp: new Date().toISOString()\n        }, 'metrics');\n      } catch (error) {\n        console.warn(`Failed to initialize metrics namespace ${namespace}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Record initialization metrics\n   */\n  async recordInitialization(metrics: InitializationMetrics): Promise<void> {\n    const key = `init-${Date.now()}`;\n    await this.database.store(key, metrics, 'metrics');\n\n    // Update aggregated initialization stats\n    await this.updateAggregatedMetrics('initialization', metrics);\n  }\n\n  /**\n   * Record system metrics\n   */\n  async recordSystemMetrics(metrics: {\n    cpuUsage: number;\n    memoryUsage: number;\n    diskUsage: number;\n    networkLatency: number;\n    activeConnections: number;\n    timestamp?: Date;\n  }): Promise<void> {\n    const timestampedMetrics = {\n      ...metrics,\n      timestamp: metrics.timestamp || new Date()\n    };\n\n    const key = `system-${Date.now()}`;\n    await this.database.store(key, timestampedMetrics, 'metrics');\n\n    // Buffer for real-time analysis\n    this.addToBuffer('system', timestampedMetrics);\n  }\n\n  /**\n   * Record agent performance metrics\n   */\n  async recordAgentMetrics(agentId: string, metrics: {\n    tasksCompleted: number;\n    successRate: number;\n    averageResponseTime: number;\n    resourceUtilization: any;\n    timestamp?: Date;\n  }): Promise<void> {\n    const timestampedMetrics = {\n      agentId,\n      ...metrics,\n      timestamp: metrics.timestamp || new Date()\n    };\n\n    const key = `agent-${agentId}-${Date.now()}`;\n    await this.database.store(key, timestampedMetrics, 'metrics');\n\n    this.addToBuffer('agents', timestampedMetrics);\n  }\n\n  /**\n   * Record consensus metrics\n   */\n  async recordConsensusMetrics(metrics: {\n    algorithm: string;\n    decisionId: string;\n    participantCount: number;\n    consensusTime: number;\n    outcome: boolean;\n    confidence: number;\n    timestamp?: Date;\n  }): Promise<void> {\n    const timestampedMetrics = {\n      ...metrics,\n      timestamp: metrics.timestamp || new Date()\n    };\n\n    const key = `consensus-${metrics.decisionId}`;\n    await this.database.store(key, timestampedMetrics, 'metrics');\n\n    this.addToBuffer('consensus', timestampedMetrics);\n  }\n\n  /**\n   * Record topology metrics\n   */\n  async recordTopologyMetrics(metrics: {\n    type: string;\n    agentCount: number;\n    connectionCount: number;\n    averageLatency: number;\n    throughput: number;\n    reliability: number;\n    timestamp?: Date;\n  }): Promise<void> {\n    const timestampedMetrics = {\n      ...metrics,\n      timestamp: metrics.timestamp || new Date()\n    };\n\n    const key = `topology-${Date.now()}`;\n    await this.database.store(key, timestampedMetrics, 'metrics');\n\n    this.addToBuffer('topology', timestampedMetrics);\n  }\n\n  /**\n   * Record performance benchmark\n   */\n  async recordBenchmark(benchmark: Benchmark): Promise<void> {\n    const key = `benchmark-${benchmark.name}-${Date.now()}`;\n    await this.database.store(key, benchmark, 'metrics');\n\n    this.addToBuffer('benchmarks', benchmark);\n  }\n\n  /**\n   * Get initialization metrics\n   */\n  async getInitializationMetrics(): Promise<{\n    total: number;\n    successful: number;\n    failed: number;\n    averageDuration: number;\n    modeDistribution: Record<string, number>;\n    recentMetrics: InitializationMetrics[];\n  }> {\n    const keys = await this.database.list('metrics');\n    const initKeys = keys.filter(key => key.startsWith('init-'));\n\n    const metrics: InitializationMetrics[] = [];\n    for (const key of initKeys) {\n      const metric = await this.database.retrieve(key, 'metrics');\n      if (metric) metrics.push(metric);\n    }\n\n    // Sort by timestamp (most recent first)\n    metrics.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n    const total = metrics.length;\n    const successful = metrics.filter(m => m.success).length;\n    const failed = total - successful;\n\n    const durations = metrics.map(m => m.duration).filter(d => d > 0);\n    const averageDuration = durations.length > 0\n      ? durations.reduce((sum, d) => sum + d, 0) / durations.length\n      : 0;\n\n    // Mode distribution\n    const modeDistribution: Record<string, number> = {};\n    metrics.forEach(m => {\n      modeDistribution[m.mode] = (modeDistribution[m.mode] || 0) + 1;\n    });\n\n    return {\n      total,\n      successful,\n      failed,\n      averageDuration,\n      modeDistribution,\n      recentMetrics: metrics.slice(0, 10) // Last 10 initializations\n    };\n  }\n\n  /**\n   * Get system health status\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    const systemMetrics = this.getBufferedMetrics('system', 10); // Last 10 measurements\n\n    if (systemMetrics.length === 0) {\n      return {\n        status: 'critical',\n        score: 0,\n        issues: ['No system metrics available'],\n        recommendations: ['Ensure metrics collection is working']\n      };\n    }\n\n    const latest = systemMetrics[systemMetrics.length - 1];\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    let score = 100;\n\n    // Check CPU usage\n    if (latest.cpuUsage > 90) {\n      issues.push('High CPU usage');\n      recommendations.push('Consider scaling or optimizing CPU-intensive tasks');\n      score -= 30;\n    } else if (latest.cpuUsage > 70) {\n      issues.push('Elevated CPU usage');\n      score -= 15;\n    }\n\n    // Check memory usage\n    if (latest.memoryUsage > 90) {\n      issues.push('High memory usage');\n      recommendations.push('Check for memory leaks or increase available memory');\n      score -= 25;\n    } else if (latest.memoryUsage > 70) {\n      issues.push('Elevated memory usage');\n      score -= 10;\n    }\n\n    // Check network latency\n    if (latest.networkLatency > 100) {\n      issues.push('High network latency');\n      recommendations.push('Check network connectivity and optimize communication');\n      score -= 20;\n    }\n\n    // Check trend (if we have historical data)\n    if (systemMetrics.length >= 5) {\n      const recent = systemMetrics.slice(-3);\n      const older = systemMetrics.slice(-6, -3);\n\n      const recentAvgCpu = recent.reduce((sum, m) => sum + m.cpuUsage, 0) / recent.length;\n      const olderAvgCpu = older.reduce((sum, m) => sum + m.cpuUsage, 0) / older.length;\n\n      if (recentAvgCpu > olderAvgCpu * 1.2) {\n        issues.push('CPU usage trending upward');\n        score -= 10;\n      }\n    }\n\n    let status: 'healthy' | 'degraded' | 'critical';\n    if (score >= 80) status = 'healthy';\n    else if (score >= 50) status = 'degraded';\n    else status = 'critical';\n\n    return { status, score, issues, recommendations };\n  }\n\n  /**\n   * Get performance trends\n   */\n  async getPerformanceTrends(period: string = '1h'): Promise<PerformanceTrend[]> {\n    const trends: PerformanceTrend[] = [];\n\n    // Analyze different metric types\n    const metricTypes = ['system', 'agents', 'consensus', 'topology'];\n\n    for (const type of metricTypes) {\n      const metrics = this.getBufferedMetrics(type, 20);\n      if (metrics.length < 2) continue;\n\n      const recent = metrics.slice(-5);\n      const older = metrics.slice(-10, -5);\n\n      if (recent.length === 0 || older.length === 0) continue;\n\n      // Calculate trends for different metrics\n      switch (type) {\n        case 'system':\n          trends.push(...this.analyzeSystemTrends(recent, older, period));\n          break;\n        case 'agents':\n          trends.push(...this.analyzeAgentTrends(recent, older, period));\n          break;\n        case 'consensus':\n          trends.push(...this.analyzeConsensusTrends(recent, older, period));\n          break;\n        case 'topology':\n          trends.push(...this.analyzeTopologyTrends(recent, older, period));\n          break;\n      }\n    }\n\n    return trends;\n  }\n\n  /**\n   * Run performance benchmarks\n   */\n  async runBenchmarks(): Promise<Benchmark[]> {\n    const benchmarks: Benchmark[] = [];\n\n    // CPU benchmark\n    const cpuStart = Date.now();\n    for (let i = 0; i < 1000000; i++) {\n      Math.sqrt(i);\n    }\n    const cpuTime = Date.now() - cpuStart;\n\n    benchmarks.push({\n      name: 'cpu-computation',\n      value: cpuTime,\n      unit: 'ms',\n      timestamp: new Date(),\n      baseline: 50 // Expected baseline\n    });\n\n    // Memory allocation benchmark\n    const memStart = Date.now();\n    const arrays = [];\n    for (let i = 0; i < 1000; i++) {\n      arrays.push(new Array(1000).fill(i));\n    }\n    const memTime = Date.now() - memStart;\n\n    benchmarks.push({\n      name: 'memory-allocation',\n      value: memTime,\n      unit: 'ms',\n      timestamp: new Date(),\n      baseline: 20\n    });\n\n    // Database I/O benchmark\n    const dbStart = Date.now();\n    for (let i = 0; i < 10; i++) {\n      await this.database.store(`benchmark-test-${i}`, { value: i }, 'temp');\n      await this.database.retrieve(`benchmark-test-${i}`, 'temp');\n    }\n    const dbTime = Date.now() - dbStart;\n\n    benchmarks.push({\n      name: 'database-io',\n      value: dbTime,\n      unit: 'ms',\n      timestamp: new Date(),\n      baseline: 100\n    });\n\n    // Store benchmarks\n    for (const benchmark of benchmarks) {\n      await this.recordBenchmark(benchmark);\n    }\n\n    return benchmarks;\n  }\n\n  /**\n   * Get performance summary\n   */\n  async getPerformanceSummary(): Promise<{\n    health: SystemHealth;\n    trends: PerformanceTrend[];\n    benchmarks: Benchmark[];\n    recommendations: string[];\n  }> {\n    const [health, trends, benchmarks] = await Promise.all([\n      this.getSystemHealth(),\n      this.getPerformanceTrends(),\n      this.getRecentBenchmarks()\n    ]);\n\n    const recommendations = [\n      ...health.recommendations,\n      ...this.generateTrendRecommendations(trends),\n      ...this.generateBenchmarkRecommendations(benchmarks)\n    ];\n\n    return {\n      health,\n      trends,\n      benchmarks,\n      recommendations: [...new Set(recommendations)] // Remove duplicates\n    };\n  }\n\n  // Helper methods\n\n  private addToBuffer(type: string, data: any): void {\n    if (!this.metricsBuffer.has(type)) {\n      this.metricsBuffer.set(type, []);\n    }\n\n    const buffer = this.metricsBuffer.get(type)!;\n    buffer.push(data);\n\n    // Keep buffer size manageable\n    if (buffer.length > 100) {\n      buffer.shift();\n    }\n  }\n\n  private getBufferedMetrics(type: string, limit?: number): any[] {\n    const buffer = this.metricsBuffer.get(type) || [];\n    return limit ? buffer.slice(-limit) : buffer;\n  }\n\n  private async updateAggregatedMetrics(type: string, metrics: any): Promise<void> {\n    const key = `aggregated-${type}`;\n    const existing = await this.database.retrieve(key, 'metrics') || {\n      count: 0,\n      sum: {},\n      avg: {}\n    };\n\n    // Update aggregated data (simplified example)\n    existing.count++;\n    existing.lastUpdated = new Date().toISOString();\n\n    await this.database.store(key, existing, 'metrics');\n  }\n\n  private analyzeSystemTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\n    const trends: PerformanceTrend[] = [];\n\n    const recentAvgCpu = recent.reduce((sum, m) => sum + m.cpuUsage, 0) / recent.length;\n    const olderAvgCpu = older.reduce((sum, m) => sum + m.cpuUsage, 0) / older.length;\n    const cpuChange = ((recentAvgCpu - olderAvgCpu) / olderAvgCpu) * 100;\n\n    trends.push({\n      metric: 'cpu-usage',\n      trend: cpuChange > 5 ? 'degrading' : cpuChange < -5 ? 'improving' : 'stable',\n      change: cpuChange,\n      period\n    });\n\n    return trends;\n  }\n\n  private analyzeAgentTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\n    // Analyze agent performance trends\n    return [];\n  }\n\n  private analyzeConsensusTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\n    // Analyze consensus performance trends\n    return [];\n  }\n\n  private analyzeTopologyTrends(recent: any[], older: any[], period: string): PerformanceTrend[] {\n    // Analyze topology performance trends\n    return [];\n  }\n\n  private async getRecentBenchmarks(): Promise<Benchmark[]> {\n    const keys = await this.database.list('metrics');\n    const benchmarkKeys = keys.filter(key => key.startsWith('benchmark-')).slice(-10);\n\n    const benchmarks: Benchmark[] = [];\n    for (const key of benchmarkKeys) {\n      const benchmark = await this.database.retrieve(key, 'metrics');\n      if (benchmark) benchmarks.push(benchmark);\n    }\n\n    return benchmarks;\n  }\n\n  private generateTrendRecommendations(trends: PerformanceTrend[]): string[] {\n    const recommendations: string[] = [];\n\n    trends.forEach(trend => {\n      if (trend.trend === 'degrading') {\n        recommendations.push(`${trend.metric} is degrading (${trend.change.toFixed(1)}% change) - investigate potential causes`);\n      }\n    });\n\n    return recommendations;\n  }\n\n  private generateBenchmarkRecommendations(benchmarks: Benchmark[]): string[] {\n    const recommendations: string[] = [];\n\n    benchmarks.forEach(benchmark => {\n      if (benchmark.baseline && benchmark.value > benchmark.baseline * 2) {\n        recommendations.push(`${benchmark.name} performance is significantly below baseline - consider optimization`);\n      }\n    });\n\n    return recommendations;\n  }\n}"],"names":["MetricsCollector","metricsBuffer","Map","initialized","database","initialize","setupMetricsStorage","namespaces","namespace","store","timestamp","Date","toISOString","error","console","warn","recordInitialization","metrics","key","now","updateAggregatedMetrics","recordSystemMetrics","timestampedMetrics","addToBuffer","recordAgentMetrics","agentId","recordConsensusMetrics","decisionId","recordTopologyMetrics","recordBenchmark","benchmark","name","getInitializationMetrics","keys","list","initKeys","filter","startsWith","metric","retrieve","push","sort","a","b","getTime","total","length","successful","m","success","failed","durations","map","duration","d","averageDuration","reduce","sum","modeDistribution","forEach","mode","recentMetrics","slice","getSystemHealth","systemMetrics","getBufferedMetrics","status","score","issues","recommendations","latest","cpuUsage","memoryUsage","networkLatency","recent","older","recentAvgCpu","olderAvgCpu","getPerformanceTrends","period","trends","metricTypes","type","analyzeSystemTrends","analyzeAgentTrends","analyzeConsensusTrends","analyzeTopologyTrends","runBenchmarks","benchmarks","cpuStart","i","Math","sqrt","cpuTime","value","unit","baseline","memStart","arrays","Array","fill","memTime","dbStart","dbTime","getPerformanceSummary","health","Promise","all","getRecentBenchmarks","generateTrendRecommendations","generateBenchmarkRecommendations","Set","data","has","set","buffer","get","shift","limit","existing","count","avg","lastUpdated","cpuChange","trend","change","benchmarkKeys","toFixed"],"mappings":"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"}