{"version":3,"sources":["../../../src/core/DatabaseManager.ts"],"sourcesContent":["/**\n * DatabaseManager - Manages SQLite and JSON fallback storage\n * Provides a unified interface for persistent data storage with automatic fallback\n */\n\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { IDatabaseProvider } from '../types/interfaces.js';\n\nexport class DatabaseManager implements IDatabaseProvider {\n  private provider: IDatabaseProvider;\n  private dbType: 'sqlite' | 'json';\n  private dbPath: string;\n  private initialized: boolean = false;\n\n  constructor(dbType: 'sqlite' | 'json' = 'sqlite', dbPath?: string) {\n    this.dbType = dbType;\n    this.dbPath = dbPath || this.getDefaultPath();\n\n    // Try SQLite first, fallback to JSON if needed\n    if (this.dbType === 'sqlite') {\n      try {\n        this.provider = new SQLiteProvider(this.dbPath);\n      } catch (error) {\n        console.warn('SQLite not available, falling back to JSON storage:', error);\n        this.provider = new JSONProvider(this.dbPath.replace('.sqlite', '.json'));\n        this.dbType = 'json';\n      }\n    } else {\n      this.provider = new JSONProvider(this.dbPath);\n    }\n  }\n\n  private getDefaultPath(): string {\n    const baseDir = path.join(process.cwd(), '.claude-flow');\n    return this.dbType === 'sqlite'\n      ? path.join(baseDir, 'database.sqlite')\n      : path.join(baseDir, 'database.json');\n  }\n\n  async initialize(): Promise<void> {\n    await fs.ensureDir(path.dirname(this.dbPath));\n    await this.provider.initialize();\n    this.initialized = true;\n  }\n\n  async store(key: string, value: any, namespace: string = 'default'): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    return this.provider.store(key, value, namespace);\n  }\n\n  async retrieve(key: string, namespace: string = 'default'): Promise<any> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    return this.provider.retrieve(key, namespace);\n  }\n\n  async delete(key: string, namespace: string = 'default'): Promise<boolean> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    return this.provider.delete(key, namespace);\n  }\n\n  async list(namespace: string = 'default'): Promise<string[]> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    return this.provider.list(namespace);\n  }\n\n  async close(): Promise<void> {\n    if (this.provider) {\n      await this.provider.close();\n    }\n    this.initialized = false;\n  }\n\n  getDatabaseType(): 'sqlite' | 'json' {\n    return this.dbType;\n  }\n\n  getDatabasePath(): string {\n    return this.dbPath;\n  }\n\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  // Specialized methods for common operations\n  async storeJSON(key: string, data: object, namespace?: string): Promise<void> {\n    await this.store(key, JSON.stringify(data), namespace);\n  }\n\n  async retrieveJSON(key: string, namespace?: string): Promise<object | null> {\n    const data = await this.retrieve(key, namespace);\n    if (!data) return null;\n    try {\n      return typeof data === 'string' ? JSON.parse(data) : data;\n    } catch {\n      return null;\n    }\n  }\n\n  async exists(key: string, namespace?: string): Promise<boolean> {\n    const data = await this.retrieve(key, namespace);\n    return data !== null && data !== undefined;\n  }\n\n  async clear(namespace?: string): Promise<void> {\n    const keys = await this.list(namespace);\n    await Promise.all(keys.map(key => this.delete(key, namespace)));\n  }\n}\n\n/**\n * SQLite implementation\n */\nclass SQLiteProvider implements IDatabaseProvider {\n  private db: any;\n  private dbPath: string;\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n    // Dynamic import to handle optional dependency\n    try {\n      const Database = require('better-sqlite3');\n      this.db = new Database(dbPath);\n    } catch (error) {\n      throw new Error('better-sqlite3 not available. Install with: npm install better-sqlite3');\n    }\n  }\n\n  async initialize(): Promise<void> {\n    // Create tables\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS storage (\n        namespace TEXT NOT NULL,\n        key TEXT NOT NULL,\n        value TEXT NOT NULL,\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\n        updated_at INTEGER DEFAULT (strftime('%s', 'now')),\n        PRIMARY KEY (namespace, key)\n      )\n    `);\n\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_storage_namespace ON storage(namespace);\n      CREATE INDEX IF NOT EXISTS idx_storage_created_at ON storage(created_at);\n    `);\n  }\n\n  async store(key: string, value: any, namespace: string = 'default'): Promise<void> {\n    const stmt = this.db.prepare(`\n      INSERT OR REPLACE INTO storage (namespace, key, value, updated_at)\n      VALUES (?, ?, ?, strftime('%s', 'now'))\n    `);\n\n    const serializedValue = typeof value === 'string' ? value : JSON.stringify(value);\n    stmt.run(namespace, key, serializedValue);\n  }\n\n  async retrieve(key: string, namespace: string = 'default'): Promise<any> {\n    const stmt = this.db.prepare('SELECT value FROM storage WHERE namespace = ? AND key = ?');\n    const row = stmt.get(namespace, key);\n\n    if (!row) return null;\n\n    try {\n      return JSON.parse(row.value);\n    } catch {\n      return row.value;\n    }\n  }\n\n  async delete(key: string, namespace: string = 'default'): Promise<boolean> {\n    const stmt = this.db.prepare('DELETE FROM storage WHERE namespace = ? AND key = ?');\n    const result = stmt.run(namespace, key);\n    return result.changes > 0;\n  }\n\n  async list(namespace: string = 'default'): Promise<string[]> {\n    const stmt = this.db.prepare('SELECT key FROM storage WHERE namespace = ? ORDER BY key');\n    const rows = stmt.all(namespace);\n    return rows.map((row: any) => row.key);\n  }\n\n  async close(): Promise<void> {\n    if (this.db) {\n      this.db.close();\n    }\n  }\n}\n\n/**\n * JSON file-based implementation\n */\nclass JSONProvider implements IDatabaseProvider {\n  private data: Record<string, Record<string, any>> = {};\n  private dbPath: string;\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      if (await fs.pathExists(this.dbPath)) {\n        const content = await fs.readJSON(this.dbPath);\n        this.data = content || {};\n      }\n    } catch (error) {\n      console.warn('Failed to load JSON database, starting fresh:', error);\n      this.data = {};\n    }\n  }\n\n  async store(key: string, value: any, namespace: string = 'default'): Promise<void> {\n    if (!this.data[namespace]) {\n      this.data[namespace] = {};\n    }\n\n    this.data[namespace][key] = value;\n    await this.persist();\n  }\n\n  async retrieve(key: string, namespace: string = 'default'): Promise<any> {\n    if (!this.data[namespace]) {\n      return null;\n    }\n    return this.data[namespace][key] || null;\n  }\n\n  async delete(key: string, namespace: string = 'default'): Promise<boolean> {\n    if (!this.data[namespace] || !(key in this.data[namespace])) {\n      return false;\n    }\n\n    delete this.data[namespace][key];\n    await this.persist();\n    return true;\n  }\n\n  async list(namespace: string = 'default'): Promise<string[]> {\n    if (!this.data[namespace]) {\n      return [];\n    }\n    return Object.keys(this.data[namespace]).sort();\n  }\n\n  async close(): Promise<void> {\n    await this.persist();\n  }\n\n  private async persist(): Promise<void> {\n    try {\n      await fs.ensureDir(path.dirname(this.dbPath));\n      await fs.writeJSON(this.dbPath, this.data, { spaces: 2 });\n    } catch (error) {\n      console.error('Failed to persist JSON database:', error);\n    }\n  }\n}"],"names":["fs","path","DatabaseManager","provider","dbType","dbPath","initialized","getDefaultPath","SQLiteProvider","error","console","warn","JSONProvider","replace","baseDir","join","process","cwd","initialize","ensureDir","dirname","store","key","value","namespace","retrieve","delete","list","close","getDatabaseType","getDatabasePath","isInitialized","storeJSON","data","JSON","stringify","retrieveJSON","parse","exists","undefined","clear","keys","Promise","all","map","db","Database","require","Error","exec","stmt","prepare","serializedValue","run","row","get","result","changes","rows","pathExists","content","readJSON","persist","Object","sort","writeJSON","spaces"],"mappings":"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"}