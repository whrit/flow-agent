{"version":3,"sources":["../../../src/core/TopologyManager.ts"],"sourcesContent":["/**\n * TopologyManager - Manages swarm topology (mesh, hierarchical, ring, star)\n * Implements network topology patterns for agent coordination\n */\n\nimport { IDatabaseProvider, ITopology, Agent, Network, Connection, Optimization, TopologyType, NetworkMetrics } from '../types/interfaces.js';\n\nexport class TopologyManager {\n  private currentTopology: ITopology | null = null;\n  private agents: Agent[] = [];\n  private connections: Connection[] = [];\n\n  constructor(private database: IDatabaseProvider) {}\n\n  /**\n   * Configure the swarm topology\n   */\n  async configure(topologyType: TopologyType, agents: Agent[] = []): Promise<Network> {\n    this.agents = agents;\n    this.currentTopology = this.createTopology(topologyType);\n\n    const network = await this.currentTopology.configure(agents);\n    this.connections = network.connections;\n\n    // Persist topology configuration\n    await this.database.store('topology', {\n      type: topologyType,\n      agentCount: agents.length,\n      connectionCount: network.connections.length,\n      timestamp: new Date().toISOString()\n    }, 'system');\n\n    return network;\n  }\n\n  /**\n   * Create specific topology implementation\n   */\n  private createTopology(type: TopologyType): ITopology {\n    switch (type) {\n      case 'mesh':\n        return new MeshTopology();\n      case 'hierarchical':\n        return new HierarchicalTopology();\n      case 'ring':\n        return new RingTopology();\n      case 'star':\n        return new StarTopology();\n      default:\n        throw new Error(`Unknown topology type: ${type}`);\n    }\n  }\n\n  /**\n   * Add agent to topology\n   */\n  async addAgent(agent: Agent): Promise<void> {\n    if (!this.currentTopology) {\n      throw new Error('Topology not configured');\n    }\n\n    this.agents.push(agent);\n    const network = await this.currentTopology.configure(this.agents);\n    this.connections = network.connections;\n\n    await this.database.store(`agent:${agent.id}`, agent, 'agents');\n  }\n\n  /**\n   * Remove agent from topology\n   */\n  async removeAgent(agentId: string): Promise<void> {\n    if (!this.currentTopology) {\n      throw new Error('Topology not configured');\n    }\n\n    this.agents = this.agents.filter(agent => agent.id !== agentId);\n    const network = await this.currentTopology.configure(this.agents);\n    this.connections = network.connections;\n\n    await this.database.delete(`agent:${agentId}`, 'agents');\n  }\n\n  /**\n   * Optimize current topology\n   */\n  async optimize(): Promise<Optimization> {\n    if (!this.currentTopology) {\n      throw new Error('Topology not configured');\n    }\n\n    const optimization = await this.currentTopology.optimize();\n\n    // Apply optimization changes\n    for (const change of optimization.changes) {\n      switch (change.action) {\n        case 'add-connection':\n          this.connections.push(change.connection);\n          break;\n        case 'remove-connection':\n          this.connections = this.connections.filter(conn =>\n            !(conn.from === change.connection.from && conn.to === change.connection.to)\n          );\n          break;\n        case 'modify-weight':\n          const existing = this.connections.find(conn =>\n            conn.from === change.connection.from && conn.to === change.connection.to\n          );\n          if (existing) {\n            existing.weight = change.connection.weight;\n          }\n          break;\n      }\n    }\n\n    return optimization;\n  }\n\n  /**\n   * Get current topology information\n   */\n  async getTopologyInfo(): Promise<{\n    type: TopologyType;\n    agents: Agent[];\n    connections: Connection[];\n    metrics: NetworkMetrics;\n  }> {\n    if (!this.currentTopology) {\n      throw new Error('Topology not configured');\n    }\n\n    const metrics = this.calculateMetrics();\n\n    return {\n      type: this.currentTopology.getType(),\n      agents: this.agents,\n      connections: this.connections,\n      metrics\n    };\n  }\n\n  /**\n   * Calculate network metrics\n   */\n  private calculateMetrics(): NetworkMetrics {\n    const totalAgents = this.agents.length;\n    const totalConnections = this.connections.length;\n\n    // Calculate average latency\n    const latencies = this.connections\n      .map(conn => conn.latency || 0)\n      .filter(latency => latency > 0);\n    const averageLatency = latencies.length > 0\n      ? latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length\n      : 0;\n\n    // Estimate throughput based on connections\n    const throughput = totalConnections > 0 ? totalAgents / totalConnections : 0;\n\n    // Calculate reliability (percentage of active agents)\n    const activeAgents = this.agents.filter(agent => agent.status === 'active').length;\n    const reliability = totalAgents > 0 ? activeAgents / totalAgents : 0;\n\n    return {\n      totalAgents,\n      totalConnections,\n      averageLatency,\n      throughput,\n      reliability\n    };\n  }\n\n  /**\n   * Get agents connected to a specific agent\n   */\n  getConnectedAgents(agentId: string): Agent[] {\n    const connectedIds = new Set<string>();\n\n    this.connections.forEach(conn => {\n      if (conn.from === agentId) {\n        connectedIds.add(conn.to);\n      } else if (conn.to === agentId) {\n        connectedIds.add(conn.from);\n      }\n    });\n\n    return this.agents.filter(agent => connectedIds.has(agent.id));\n  }\n\n  /**\n   * Check if two agents are connected\n   */\n  areConnected(agentId1: string, agentId2: string): boolean {\n    return this.connections.some(conn =>\n      (conn.from === agentId1 && conn.to === agentId2) ||\n      (conn.from === agentId2 && conn.to === agentId1)\n    );\n  }\n}\n\n/**\n * Mesh Topology - All agents connected to all others\n */\nclass MeshTopology implements ITopology {\n  getType(): TopologyType {\n    return 'mesh';\n  }\n\n  async configure(agents: Agent[]): Promise<Network> {\n    const connections: Connection[] = [];\n\n    // Create connections between all pairs\n    for (let i = 0; i < agents.length; i++) {\n      for (let j = i + 1; j < agents.length; j++) {\n        connections.push({\n          from: agents[i].id,\n          to: agents[j].id,\n          type: 'direct',\n          weight: 1.0,\n          latency: Math.random() * 10 + 5 // 5-15ms simulated latency\n        });\n      }\n    }\n\n    return {\n      topology: 'mesh',\n      agents,\n      connections,\n      metrics: this.calculateMetrics(agents, connections)\n    };\n  }\n\n  async optimize(): Promise<Optimization> {\n    // For mesh topology, optimization might involve removing redundant connections\n    return {\n      type: 'latency',\n      changes: [],\n      expectedImprovement: 0\n    };\n  }\n\n  getConnections(): Connection[] {\n    return [];\n  }\n\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\n    return {\n      totalAgents: agents.length,\n      totalConnections: connections.length,\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\n      throughput: agents.length,\n      reliability: 0.95 // High reliability for mesh\n    };\n  }\n}\n\n/**\n * Hierarchical Topology - Tree-like structure with coordinators\n */\nclass HierarchicalTopology implements ITopology {\n  getType(): TopologyType {\n    return 'hierarchical';\n  }\n\n  async configure(agents: Agent[]): Promise<Network> {\n    const connections: Connection[] = [];\n\n    if (agents.length === 0) {\n      return { topology: 'hierarchical', agents, connections, metrics: this.calculateMetrics(agents, connections) };\n    }\n\n    // Select coordinators (every 3-4 agents)\n    const coordinators = agents.filter((_, index) => index % 4 === 0);\n    const workers = agents.filter((_, index) => index % 4 !== 0);\n\n    // Connect workers to nearest coordinator\n    workers.forEach((worker, index) => {\n      const coordinatorIndex = Math.floor(index / 3);\n      const coordinator = coordinators[coordinatorIndex] || coordinators[0];\n\n      connections.push({\n        from: worker.id,\n        to: coordinator.id,\n        type: 'direct',\n        weight: 1.0,\n        latency: Math.random() * 5 + 2\n      });\n    });\n\n    // Connect coordinators in a chain\n    for (let i = 0; i < coordinators.length - 1; i++) {\n      connections.push({\n        from: coordinators[i].id,\n        to: coordinators[i + 1].id,\n        type: 'relay',\n        weight: 2.0,\n        latency: Math.random() * 8 + 3\n      });\n    }\n\n    return {\n      topology: 'hierarchical',\n      agents,\n      connections,\n      metrics: this.calculateMetrics(agents, connections)\n    };\n  }\n\n  async optimize(): Promise<Optimization> {\n    return {\n      type: 'throughput',\n      changes: [],\n      expectedImprovement: 0\n    };\n  }\n\n  getConnections(): Connection[] {\n    return [];\n  }\n\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\n    return {\n      totalAgents: agents.length,\n      totalConnections: connections.length,\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\n      throughput: Math.sqrt(agents.length), // Logarithmic scaling\n      reliability: 0.85 // Good reliability\n    };\n  }\n}\n\n/**\n * Ring Topology - Agents connected in a circular pattern\n */\nclass RingTopology implements ITopology {\n  getType(): TopologyType {\n    return 'ring';\n  }\n\n  async configure(agents: Agent[]): Promise<Network> {\n    const connections: Connection[] = [];\n\n    if (agents.length < 2) {\n      return { topology: 'ring', agents, connections, metrics: this.calculateMetrics(agents, connections) };\n    }\n\n    // Connect each agent to the next (and last to first)\n    for (let i = 0; i < agents.length; i++) {\n      const nextIndex = (i + 1) % agents.length;\n      connections.push({\n        from: agents[i].id,\n        to: agents[nextIndex].id,\n        type: 'direct',\n        weight: 1.0,\n        latency: Math.random() * 6 + 3\n      });\n    }\n\n    return {\n      topology: 'ring',\n      agents,\n      connections,\n      metrics: this.calculateMetrics(agents, connections)\n    };\n  }\n\n  async optimize(): Promise<Optimization> {\n    return {\n      type: 'reliability',\n      changes: [],\n      expectedImprovement: 0\n    };\n  }\n\n  getConnections(): Connection[] {\n    return [];\n  }\n\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\n    return {\n      totalAgents: agents.length,\n      totalConnections: connections.length,\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\n      throughput: agents.length * 0.7, // Reduced due to ring bottlenecks\n      reliability: 0.75 // Lower reliability due to single points of failure\n    };\n  }\n}\n\n/**\n * Star Topology - All agents connected to a central hub\n */\nclass StarTopology implements ITopology {\n  getType(): TopologyType {\n    return 'star';\n  }\n\n  async configure(agents: Agent[]): Promise<Network> {\n    const connections: Connection[] = [];\n\n    if (agents.length === 0) {\n      return { topology: 'star', agents, connections, metrics: this.calculateMetrics(agents, connections) };\n    }\n\n    // First agent becomes the hub\n    const hub = agents[0];\n    const spokes = agents.slice(1);\n\n    // Connect all spokes to hub\n    spokes.forEach(spoke => {\n      connections.push({\n        from: spoke.id,\n        to: hub.id,\n        type: 'direct',\n        weight: 1.0,\n        latency: Math.random() * 4 + 2\n      });\n    });\n\n    return {\n      topology: 'star',\n      agents,\n      connections,\n      metrics: this.calculateMetrics(agents, connections)\n    };\n  }\n\n  async optimize(): Promise<Optimization> {\n    return {\n      type: 'latency',\n      changes: [],\n      expectedImprovement: 0\n    };\n  }\n\n  getConnections(): Connection[] {\n    return [];\n  }\n\n  private calculateMetrics(agents: Agent[], connections: Connection[]): NetworkMetrics {\n    return {\n      totalAgents: agents.length,\n      totalConnections: connections.length,\n      averageLatency: connections.reduce((sum, conn) => sum + (conn.latency || 0), 0) / connections.length || 0,\n      throughput: Math.min(agents.length, 10), // Limited by hub capacity\n      reliability: 0.70 // Lower due to single point of failure\n    };\n  }\n}"],"names":["TopologyManager","currentTopology","agents","connections","database","configure","topologyType","createTopology","network","store","type","agentCount","length","connectionCount","timestamp","Date","toISOString","MeshTopology","HierarchicalTopology","RingTopology","StarTopology","Error","addAgent","agent","push","id","removeAgent","agentId","filter","delete","optimize","optimization","change","changes","action","connection","conn","from","to","existing","find","weight","getTopologyInfo","metrics","calculateMetrics","getType","totalAgents","totalConnections","latencies","map","latency","averageLatency","reduce","sum","lat","throughput","activeAgents","status","reliability","getConnectedAgents","connectedIds","Set","forEach","add","has","areConnected","agentId1","agentId2","some","i","j","Math","random","topology","expectedImprovement","getConnections","coordinators","_","index","workers","worker","coordinatorIndex","floor","coordinator","sqrt","nextIndex","hub","spokes","slice","spoke","min"],"mappings":"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"}