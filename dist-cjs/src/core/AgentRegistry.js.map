{"version":3,"sources":["../../../src/core/AgentRegistry.ts"],"sourcesContent":["/**\n * AgentRegistry - Tracks and manages agent lifecycle\n * Provides centralized management for agent spawning, coordination, and monitoring\n */\n\nimport { IDatabaseProvider, IAgentCoordinator, Agent, AgentType, AgentConfig, Task, Result, Metrics, AgentMetrics, AgentPerformance } from '../types/interfaces.js';\nimport { nanoid } from 'nanoid';\n\nexport class AgentRegistry implements IAgentCoordinator {\n  private agents: Map<string, Agent> = new Map();\n  private tasks: Map<string, Task> = new Map();\n  private activeAssignments: Map<string, string[]> = new Map(); // agentId -> taskIds\n\n  constructor(private database: IDatabaseProvider) {}\n\n  /**\n   * Initialize the agent registry\n   */\n  async initialize(): Promise<void> {\n    // Load existing agents from database\n    try {\n      const agentIds = await this.database.list('agents');\n      for (const agentId of agentIds) {\n        const agentData = await this.database.retrieve(agentId, 'agents');\n        if (agentData) {\n          const agent = typeof agentData === 'string' ? JSON.parse(agentData) : agentData;\n          this.agents.set(agent.id, agent);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load existing agents:', error);\n    }\n  }\n\n  /**\n   * Spawn a new agent\n   */\n  async spawn(type: AgentType, config: AgentConfig = {}): Promise<Agent> {\n    const agent: Agent = {\n      id: nanoid(),\n      type,\n      capabilities: config.capabilities || this.getDefaultCapabilities(type),\n      status: 'idle',\n      metadata: {\n        ...config.metadata,\n        spawnedAt: new Date().toISOString(),\n        maxConcurrency: config.maxConcurrency || 1,\n        timeout: config.timeout || 30000,\n        resources: config.resources || {\n          memory: 512,\n          cpu: 1,\n          storage: 100,\n          network: 10\n        }\n      },\n      connections: [],\n      performance: {\n        tasksCompleted: 0,\n        averageResponseTime: 0,\n        successRate: 1.0,\n        resourceUtilization: {\n          memory: 0,\n          cpu: 0,\n          storage: 0,\n          network: 0\n        },\n        lastActivity: new Date()\n      }\n    };\n\n    // Store agent\n    this.agents.set(agent.id, agent);\n    await this.database.store(agent.id, agent, 'agents');\n\n    // Initialize task tracking\n    this.activeAssignments.set(agent.id, []);\n\n    return agent;\n  }\n\n  /**\n   * Get default capabilities for agent type\n   */\n  private getDefaultCapabilities(type: AgentType): string[] {\n    const capabilityMap: Record<AgentType, string[]> = {\n      researcher: ['research', 'analysis', 'documentation', 'web-search'],\n      coder: ['programming', 'debugging', 'refactoring', 'testing'],\n      analyst: ['data-analysis', 'visualization', 'reporting', 'metrics'],\n      optimizer: ['performance-tuning', 'resource-optimization', 'bottleneck-analysis'],\n      coordinator: ['task-delegation', 'workflow-management', 'communication'],\n      tester: ['unit-testing', 'integration-testing', 'quality-assurance'],\n      reviewer: ['code-review', 'security-audit', 'compliance-check']\n    };\n\n    return capabilityMap[type] || ['general'];\n  }\n\n  /**\n   * Coordinate task execution\n   */\n  async coordinate(task: Task): Promise<Result> {\n    const startTime = Date.now();\n\n    try {\n      // Find suitable agents\n      const suitableAgents = this.findSuitableAgents(task);\n\n      if (suitableAgents.length === 0) {\n        return {\n          success: false,\n          error: `No suitable agents found for task ${task.id}. Required capabilities: ${task.requiredCapabilities.join(', ')}`\n        };\n      }\n\n      // Select best agent based on availability and performance\n      const selectedAgent = this.selectBestAgent(suitableAgents, task);\n\n      // Assign task to agent\n      await this.assignTask(selectedAgent.id, task);\n\n      // Simulate task execution (in real implementation, this would communicate with actual agent)\n      const executionResult = await this.executeTask(selectedAgent, task);\n\n      // Update agent performance\n      await this.updateAgentPerformance(selectedAgent.id, task, executionResult, Date.now() - startTime);\n\n      return executionResult;\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Find agents with required capabilities\n   */\n  private findSuitableAgents(task: Task): Agent[] {\n    return Array.from(this.agents.values()).filter(agent => {\n      // Check if agent has required capabilities\n      const hasCapabilities = task.requiredCapabilities.every(cap =>\n        agent.capabilities.some(agentCap =>\n          agentCap.toLowerCase().includes(cap.toLowerCase()) ||\n          cap.toLowerCase().includes(agentCap.toLowerCase())\n        )\n      );\n\n      // Check availability\n      const isAvailable = agent.status === 'idle' || agent.status === 'active';\n\n      // Check concurrency limits\n      const currentTasks = this.activeAssignments.get(agent.id)?.length || 0;\n      const maxConcurrency = agent.metadata.maxConcurrency || 1;\n      const canTakeTask = currentTasks < maxConcurrency;\n\n      return hasCapabilities && isAvailable && canTakeTask;\n    });\n  }\n\n  /**\n   * Select the best agent for a task\n   */\n  private selectBestAgent(candidates: Agent[], task: Task): Agent {\n    // Score agents based on performance, availability, and specialization\n    const scored = candidates.map(agent => {\n      let score = 0;\n\n      // Performance score (higher success rate and lower response time is better)\n      score += agent.performance!.successRate * 40;\n      score += Math.max(0, 20 - (agent.performance!.averageResponseTime / 1000)) * 2;\n\n      // Availability score (fewer active tasks is better)\n      const activeTasks = this.activeAssignments.get(agent.id)?.length || 0;\n      score += Math.max(0, 10 - activeTasks) * 3;\n\n      // Specialization score (exact capability matches are better)\n      const exactMatches = task.requiredCapabilities.filter(cap =>\n        agent.capabilities.includes(cap)\n      ).length;\n      score += exactMatches * 5;\n\n      // Priority matching\n      if (task.priority === 'critical' && agent.type === 'coordinator') score += 10;\n      if (task.priority === 'high' && ['coordinator', 'optimizer'].includes(agent.type)) score += 5;\n\n      return { agent, score };\n    });\n\n    // Return agent with highest score\n    scored.sort((a, b) => b.score - a.score);\n    return scored[0].agent;\n  }\n\n  /**\n   * Assign task to agent\n   */\n  private async assignTask(agentId: string, task: Task): Promise<void> {\n    // Update agent status\n    const agent = this.agents.get(agentId);\n    if (agent) {\n      agent.status = 'busy';\n      await this.database.store(agentId, agent, 'agents');\n    }\n\n    // Add to active assignments\n    const currentTasks = this.activeAssignments.get(agentId) || [];\n    currentTasks.push(task.id);\n    this.activeAssignments.set(agentId, currentTasks);\n\n    // Store task\n    this.tasks.set(task.id, task);\n    await this.database.store(task.id, task, 'tasks');\n  }\n\n  /**\n   * Execute task (simulation)\n   */\n  private async executeTask(agent: Agent, task: Task): Promise<Result> {\n    // Simulate processing time based on task complexity and agent performance\n    const baseTime = 1000 + Math.random() * 2000; // 1-3 seconds\n    const complexityFactor = task.requiredCapabilities.length * 0.5;\n    const performanceFactor = 2 - agent.performance!.successRate;\n\n    const processingTime = baseTime * complexityFactor * performanceFactor;\n\n    await new Promise(resolve => setTimeout(resolve, Math.min(processingTime, 5000)));\n\n    // Simulate success/failure based on agent performance\n    const successProbability = agent.performance!.successRate * 0.9 + 0.1;\n    const success = Math.random() < successProbability;\n\n    if (success) {\n      return {\n        success: true,\n        data: {\n          taskId: task.id,\n          agentId: agent.id,\n          result: `Task ${task.description} completed successfully by ${agent.type} agent`,\n          processingTime: Math.round(processingTime)\n        },\n        metadata: {\n          capabilities: agent.capabilities,\n          performance: agent.performance\n        }\n      };\n    } else {\n      return {\n        success: false,\n        error: `Task ${task.id} failed during execution by agent ${agent.id}`,\n        metadata: {\n          processingTime: Math.round(processingTime)\n        }\n      };\n    }\n  }\n\n  /**\n   * Update agent performance metrics\n   */\n  private async updateAgentPerformance(agentId: string, task: Task, result: Result, duration: number): Promise<void> {\n    const agent = this.agents.get(agentId);\n    if (!agent || !agent.performance) return;\n\n    const perf = agent.performance;\n\n    // Update task count\n    perf.tasksCompleted++;\n\n    // Update success rate (exponential moving average)\n    const alpha = 0.1; // Learning rate\n    perf.successRate = perf.successRate * (1 - alpha) + (result.success ? 1 : 0) * alpha;\n\n    // Update average response time\n    perf.averageResponseTime = perf.averageResponseTime * (1 - alpha) + duration * alpha;\n\n    // Update last activity\n    perf.lastActivity = new Date();\n\n    // Update resource utilization (simulated)\n    perf.resourceUtilization = {\n      memory: Math.min(100, perf.resourceUtilization.memory + Math.random() * 10),\n      cpu: Math.min(100, perf.resourceUtilization.cpu + Math.random() * 15),\n      storage: Math.min(100, perf.resourceUtilization.storage + Math.random() * 5),\n      network: Math.min(100, perf.resourceUtilization.network + Math.random() * 8)\n    };\n\n    // Update agent status\n    const currentTasks = this.activeAssignments.get(agentId) || [];\n    const updatedTasks = currentTasks.filter(id => id !== task.id);\n    this.activeAssignments.set(agentId, updatedTasks);\n\n    agent.status = updatedTasks.length > 0 ? 'busy' : 'idle';\n\n    // Persist changes\n    await this.database.store(agentId, agent, 'agents');\n  }\n\n  /**\n   * Monitor all agents\n   */\n  async monitor(): Promise<Metrics> {\n    const agentMetrics: AgentMetrics[] = Array.from(this.agents.values()).map(agent => ({\n      agentId: agent.id,\n      type: agent.type,\n      performance: agent.performance!,\n      status: agent.status\n    }));\n\n    // Calculate system metrics\n    const totalMemory = agentMetrics.reduce((sum, m) => sum + m.performance.resourceUtilization.memory, 0);\n    const totalCpu = agentMetrics.reduce((sum, m) => sum + m.performance.resourceUtilization.cpu, 0);\n    const activeConnections = Array.from(this.agents.values()).reduce((sum, agent) => sum + (agent.connections?.length || 0), 0);\n\n    const systemMetrics = {\n      uptime: Date.now() - (this.getOldestAgent()?.metadata.spawnedAt ? new Date(this.getOldestAgent()!.metadata.spawnedAt).getTime() : Date.now()),\n      memoryUsage: totalMemory / agentMetrics.length || 0,\n      cpuUsage: totalCpu / agentMetrics.length || 0,\n      networkLatency: Math.random() * 10 + 5, // Simulated\n      activeConnections\n    };\n\n    // Calculate performance metrics\n    const totalTasks = agentMetrics.reduce((sum, m) => sum + m.performance.tasksCompleted, 0);\n    const avgSuccessRate = agentMetrics.reduce((sum, m) => sum + m.performance.successRate, 0) / agentMetrics.length || 0;\n    const avgResponseTime = agentMetrics.reduce((sum, m) => sum + m.performance.averageResponseTime, 0) / agentMetrics.length || 0;\n\n    const performanceMetrics = {\n      throughput: totalTasks / (systemMetrics.uptime / 1000 / 60) || 0, // tasks per minute\n      latency: avgResponseTime,\n      errorRate: 1 - avgSuccessRate,\n      bottlenecks: this.identifyBottlenecks(agentMetrics)\n    };\n\n    return {\n      agents: agentMetrics,\n      system: systemMetrics,\n      performance: performanceMetrics\n    };\n  }\n\n  /**\n   * Identify performance bottlenecks\n   */\n  private identifyBottlenecks(agentMetrics: AgentMetrics[]): string[] {\n    const bottlenecks: string[] = [];\n\n    // High CPU usage\n    const highCpuAgents = agentMetrics.filter(m => m.performance.resourceUtilization.cpu > 80);\n    if (highCpuAgents.length > 0) {\n      bottlenecks.push(`High CPU usage: ${highCpuAgents.map(a => a.agentId).join(', ')}`);\n    }\n\n    // High memory usage\n    const highMemoryAgents = agentMetrics.filter(m => m.performance.resourceUtilization.memory > 80);\n    if (highMemoryAgents.length > 0) {\n      bottlenecks.push(`High memory usage: ${highMemoryAgents.map(a => a.agentId).join(', ')}`);\n    }\n\n    // Low success rate\n    const lowSuccessAgents = agentMetrics.filter(m => m.performance.successRate < 0.8);\n    if (lowSuccessAgents.length > 0) {\n      bottlenecks.push(`Low success rate: ${lowSuccessAgents.map(a => a.agentId).join(', ')}`);\n    }\n\n    // High response time\n    const slowAgents = agentMetrics.filter(m => m.performance.averageResponseTime > 5000);\n    if (slowAgents.length > 0) {\n      bottlenecks.push(`Slow response time: ${slowAgents.map(a => a.agentId).join(', ')}`);\n    }\n\n    return bottlenecks;\n  }\n\n  /**\n   * Shutdown agent\n   */\n  async shutdown(agentId: string): Promise<void> {\n    const agent = this.agents.get(agentId);\n    if (!agent) return;\n\n    // Cancel active tasks\n    const activeTasks = this.activeAssignments.get(agentId) || [];\n    for (const taskId of activeTasks) {\n      await this.database.delete(taskId, 'tasks');\n    }\n\n    // Remove agent\n    this.agents.delete(agentId);\n    this.activeAssignments.delete(agentId);\n    await this.database.delete(agentId, 'agents');\n  }\n\n  /**\n   * Get active agents\n   */\n  async getActiveAgents(): Promise<Agent[]> {\n    return Array.from(this.agents.values()).filter(agent => agent.status !== 'offline');\n  }\n\n  /**\n   * Get agent by ID\n   */\n  getAgent(agentId: string): Agent | undefined {\n    return this.agents.get(agentId);\n  }\n\n  /**\n   * Get agents by type\n   */\n  getAgentsByType(type: AgentType): Agent[] {\n    return Array.from(this.agents.values()).filter(agent => agent.type === type);\n  }\n\n  /**\n   * Get agent count\n   */\n  getAgentCount(): number {\n    return this.agents.size;\n  }\n\n  /**\n   * Get oldest agent (for uptime calculation)\n   */\n  private getOldestAgent(): Agent | undefined {\n    let oldest: Agent | undefined;\n    let oldestTime = Date.now();\n\n    for (const agent of this.agents.values()) {\n      const spawnTime = new Date(agent.metadata.spawnedAt).getTime();\n      if (spawnTime < oldestTime) {\n        oldestTime = spawnTime;\n        oldest = agent;\n      }\n    }\n\n    return oldest;\n  }\n}"],"names":["nanoid","AgentRegistry","agents","Map","tasks","activeAssignments","database","initialize","agentIds","list","agentId","agentData","retrieve","agent","JSON","parse","set","id","error","console","warn","spawn","type","config","capabilities","getDefaultCapabilities","status","metadata","spawnedAt","Date","toISOString","maxConcurrency","timeout","resources","memory","cpu","storage","network","connections","performance","tasksCompleted","averageResponseTime","successRate","resourceUtilization","lastActivity","store","capabilityMap","researcher","coder","analyst","optimizer","coordinator","tester","reviewer","coordinate","task","startTime","now","suitableAgents","findSuitableAgents","length","success","requiredCapabilities","join","selectedAgent","selectBestAgent","assignTask","executionResult","executeTask","updateAgentPerformance","Error","message","String","Array","from","values","filter","hasCapabilities","every","cap","some","agentCap","toLowerCase","includes","isAvailable","currentTasks","get","canTakeTask","candidates","scored","map","score","Math","max","activeTasks","exactMatches","priority","sort","a","b","push","baseTime","random","complexityFactor","performanceFactor","processingTime","Promise","resolve","setTimeout","min","successProbability","data","taskId","result","description","round","duration","perf","alpha","updatedTasks","monitor","agentMetrics","totalMemory","reduce","sum","m","totalCpu","activeConnections","systemMetrics","uptime","getOldestAgent","getTime","memoryUsage","cpuUsage","networkLatency","totalTasks","avgSuccessRate","avgResponseTime","performanceMetrics","throughput","latency","errorRate","bottlenecks","identifyBottlenecks","system","highCpuAgents","highMemoryAgents","lowSuccessAgents","slowAgents","shutdown","delete","getActiveAgents","getAgent","getAgentsByType","getAgentCount","size","oldest","oldestTime","spawnTime"],"mappings":"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"}