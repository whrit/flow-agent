{"version":3,"sources":["../../../src/core/HiveMindCore.ts"],"sourcesContent":["/**\n * HiveMindCore - Collective intelligence coordination\n * Implements the Queen-Worker pattern for distributed AI coordination\n */\n\nimport { IDatabaseProvider, IHiveMindQueen, Objective, Strategy, Task, Assignment, QueenMetrics, Feedback, Agent } from '../types/interfaces.js';\nimport { AgentRegistry } from './AgentRegistry.js';\nimport { ConsensusEngine } from './ConsensusEngine.js';\nimport { MetricsCollector } from './MetricsCollector.js';\nimport { nanoid } from 'nanoid';\n\nexport interface WorkerPool {\n  id: string;\n  specialization: string;\n  agents: Agent[];\n  capacity: number;\n  utilization: number;\n  performance: {\n    tasksCompleted: number;\n    averageQuality: number;\n    successRate: number;\n  };\n}\n\nexport interface HiveMindConfig {\n  maxWorkerPools: number;\n  queenEnabled: boolean;\n  adaptationRate: number;\n  consensusThreshold: number;\n  specializations: string[];\n}\n\nexport class HiveMindCore {\n  private queen: QueenManager;\n  private workerPools: Map<string, WorkerPool> = new Map();\n  private objectives: Map<string, Objective> = new Map();\n  private strategies: Map<string, Strategy> = new Map();\n  private assignments: Map<string, Assignment> = new Map();\n  private config: HiveMindConfig;\n\n  constructor(\n    private database: IDatabaseProvider,\n    private agentRegistry: AgentRegistry,\n    private consensusEngine: ConsensusEngine,\n    private metricsCollector: MetricsCollector,\n    config: Partial<HiveMindConfig> = {}\n  ) {\n    this.config = {\n      maxWorkerPools: 5,\n      queenEnabled: true,\n      adaptationRate: 0.1,\n      consensusThreshold: 0.7,\n      specializations: ['research', 'development', 'testing', 'optimization', 'coordination'],\n      ...config\n    };\n\n    this.queen = new QueenManager(\n      this.database,\n      this.agentRegistry,\n      this.consensusEngine,\n      this.metricsCollector\n    );\n  }\n\n  /**\n   * Initialize the Hive Mind system\n   */\n  async initialize(): Promise<void> {\n    // Initialize Queen\n    if (this.config.queenEnabled) {\n      await this.queen.initialize();\n    }\n\n    // Create initial worker pools\n    await this.createInitialWorkerPools();\n\n    // Load existing objectives and strategies\n    await this.loadPersistedState();\n\n    console.log('ðŸ§  Hive Mind Core initialized with collective intelligence capabilities');\n  }\n\n  /**\n   * Create initial worker pools based on specializations\n   */\n  private async createInitialWorkerPools(): Promise<void> {\n    for (const specialization of this.config.specializations) {\n      const pool: WorkerPool = {\n        id: nanoid(),\n        specialization,\n        agents: [],\n        capacity: 5, // Default capacity\n        utilization: 0,\n        performance: {\n          tasksCompleted: 0,\n          averageQuality: 0.8,\n          successRate: 1.0\n        }\n      };\n\n      this.workerPools.set(pool.id, pool);\n      await this.database.store(`worker-pool:${pool.id}`, pool, 'hive-mind');\n    }\n  }\n\n  /**\n   * Load persisted objectives and strategies\n   */\n  private async loadPersistedState(): Promise<void> {\n    try {\n      const objectiveKeys = await this.database.list('hive-mind');\n      const objectiveItems = objectiveKeys.filter(key => key.startsWith('objective:'));\n\n      for (const key of objectiveItems) {\n        const objective = await this.database.retrieve(key, 'hive-mind');\n        if (objective) {\n          this.objectives.set(objective.id, objective);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load persisted hive mind state:', error);\n    }\n  }\n\n  /**\n   * Set a new objective for the hive mind\n   */\n  async setObjective(objective: Omit<Objective, 'id'>): Promise<string> {\n    const fullObjective: Objective = {\n      ...objective,\n      id: nanoid()\n    };\n\n    this.objectives.set(fullObjective.id, fullObjective);\n    await this.database.store(`objective:${fullObjective.id}`, fullObjective, 'hive-mind');\n\n    // Have the Queen strategize if enabled\n    if (this.config.queenEnabled) {\n      const strategy = await this.queen.strategize(fullObjective);\n      this.strategies.set(fullObjective.id, strategy);\n      await this.database.store(`strategy:${fullObjective.id}`, strategy, 'hive-mind');\n    }\n\n    return fullObjective.id;\n  }\n\n  /**\n   * Execute an objective using collective intelligence\n   */\n  async executeObjective(objectiveId: string): Promise<{\n    success: boolean;\n    assignments: Assignment[];\n    results: any[];\n    metrics: any;\n  }> {\n    const objective = this.objectives.get(objectiveId);\n    if (!objective) {\n      throw new Error(`Objective ${objectiveId} not found`);\n    }\n\n    const strategy = this.strategies.get(objectiveId);\n    if (!strategy) {\n      throw new Error(`No strategy found for objective ${objectiveId}`);\n    }\n\n    // Extract tasks from strategy phases\n    const allTasks: Task[] = [];\n    strategy.phases.forEach(phase => {\n      allTasks.push(...phase.tasks);\n    });\n\n    // Delegate tasks to worker pools\n    const assignments = await this.delegateTasks(allTasks);\n\n    // Execute assignments in parallel (with dependency management)\n    const results = await this.executeAssignments(assignments);\n\n    // Collect metrics\n    const metrics = await this.collectExecutionMetrics(objectiveId, assignments, results);\n\n    return {\n      success: results.every(r => r.success),\n      assignments,\n      results,\n      metrics\n    };\n  }\n\n  /**\n   * Delegate tasks to appropriate worker pools\n   */\n  private async delegateTasks(tasks: Task[]): Promise<Assignment[]> {\n    const assignments: Assignment[] = [];\n\n    for (const task of tasks) {\n      // Find best worker pool for this task\n      const bestPool = this.findBestWorkerPool(task);\n      if (!bestPool) {\n        console.warn(`No suitable worker pool found for task ${task.id}`);\n        continue;\n      }\n\n      // Find best agent in the pool\n      const bestAgent = await this.findBestAgentInPool(bestPool, task);\n      if (!bestAgent) {\n        console.warn(`No suitable agent found in pool ${bestPool.id} for task ${task.id}`);\n        continue;\n      }\n\n      const assignment: Assignment = {\n        agentId: bestAgent.id,\n        task,\n        deadline: task.deadline || new Date(Date.now() + 3600000), // 1 hour default\n        resources: {\n          memory: 256,\n          cpu: 1,\n          storage: 100,\n          network: 10\n        }\n      };\n\n      assignments.push(assignment);\n      this.assignments.set(task.id, assignment);\n\n      // Update pool utilization\n      bestPool.utilization += 1;\n    }\n\n    return assignments;\n  }\n\n  /**\n   * Find the best worker pool for a task\n   */\n  private findBestWorkerPool(task: Task): WorkerPool | null {\n    let bestPool: WorkerPool | null = null;\n    let bestScore = -1;\n\n    for (const pool of this.workerPools.values()) {\n      // Check if pool can handle the task's capabilities\n      const canHandle = task.requiredCapabilities.some(capability =>\n        capability.toLowerCase().includes(pool.specialization.toLowerCase()) ||\n        pool.specialization.toLowerCase().includes(capability.toLowerCase())\n      );\n\n      if (!canHandle) continue;\n\n      // Score based on performance, capacity, and utilization\n      let score = pool.performance.successRate * 40;\n      score += pool.performance.averageQuality * 30;\n      score += Math.max(0, (pool.capacity - pool.utilization) / pool.capacity) * 30;\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestPool = pool;\n      }\n    }\n\n    return bestPool;\n  }\n\n  /**\n   * Find the best agent in a worker pool for a task\n   */\n  private async findBestAgentInPool(pool: WorkerPool, task: Task): Promise<Agent | null> {\n    if (pool.agents.length === 0) {\n      // Spawn a new agent for this pool\n      const agent = await this.agentRegistry.spawn(\n        this.getAgentTypeForSpecialization(pool.specialization),\n        {\n          capabilities: task.requiredCapabilities,\n          metadata: { workerPoolId: pool.id, specialization: pool.specialization }\n        }\n      );\n\n      pool.agents.push(agent);\n      await this.database.store(`worker-pool:${pool.id}`, pool, 'hive-mind');\n      return agent;\n    }\n\n    // Find best existing agent\n    let bestAgent: Agent | null = null;\n    let bestScore = -1;\n\n    for (const agent of pool.agents) {\n      if (agent.status !== 'idle' && agent.status !== 'active') continue;\n\n      // Score based on capability match and performance\n      const capabilityMatch = task.requiredCapabilities.filter(cap =>\n        agent.capabilities.includes(cap)\n      ).length / task.requiredCapabilities.length;\n\n      const performanceScore = agent.performance?.successRate || 0.5;\n\n      const score = capabilityMatch * 60 + performanceScore * 40;\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestAgent = agent;\n      }\n    }\n\n    return bestAgent;\n  }\n\n  /**\n   * Get appropriate agent type for specialization\n   */\n  private getAgentTypeForSpecialization(specialization: string): any {\n    const typeMap: Record<string, string> = {\n      research: 'researcher',\n      development: 'coder',\n      testing: 'tester',\n      optimization: 'optimizer',\n      coordination: 'coordinator'\n    };\n\n    return typeMap[specialization] || 'researcher';\n  }\n\n  /**\n   * Execute assignments\n   */\n  private async executeAssignments(assignments: Assignment[]): Promise<any[]> {\n    const results: any[] = [];\n\n    // Group assignments by dependencies\n    const dependencyGroups = this.groupByDependencies(assignments);\n\n    // Execute groups in order\n    for (const group of dependencyGroups) {\n      const groupResults = await Promise.all(\n        group.map(async assignment => {\n          try {\n            return await this.agentRegistry.coordinate(assignment.task);\n          } catch (error) {\n            return {\n              success: false,\n              error: error instanceof Error ? error.message : String(error),\n              assignment\n            };\n          }\n        })\n      );\n\n      results.push(...groupResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Group assignments by dependencies\n   */\n  private groupByDependencies(assignments: Assignment[]): Assignment[][] {\n    // Simplified dependency grouping - in production, this would be more sophisticated\n    const groups: Assignment[][] = [];\n    const remaining = [...assignments];\n\n    while (remaining.length > 0) {\n      const currentGroup = remaining.filter(assignment =>\n        !assignment.task.dependencies?.some(dep =>\n          remaining.some(other => other.task.id === dep)\n        )\n      );\n\n      if (currentGroup.length === 0) {\n        // Break circular dependencies by taking first item\n        currentGroup.push(remaining[0]);\n      }\n\n      groups.push(currentGroup);\n      remaining.splice(0, currentGroup.length);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Collect execution metrics\n   */\n  private async collectExecutionMetrics(\n    objectiveId: string,\n    assignments: Assignment[],\n    results: any[]\n  ): Promise<any> {\n    const successCount = results.filter(r => r.success).length;\n    const successRate = successCount / results.length;\n\n    const totalTime = results.reduce((sum, r) => sum + (r.metadata?.executionTime || 0), 0);\n    const averageTime = totalTime / results.length;\n\n    const metrics = {\n      objectiveId,\n      totalTasks: assignments.length,\n      successfulTasks: successCount,\n      successRate,\n      averageExecutionTime: averageTime,\n      workerPoolUtilization: this.calculatePoolUtilization(),\n      timestamp: new Date().toISOString()\n    };\n\n    await this.metricsCollector.recordSystemMetrics({\n      cpuUsage: 50 + Math.random() * 30, // Simulated\n      memoryUsage: 60 + Math.random() * 20,\n      diskUsage: 30 + Math.random() * 10,\n      networkLatency: 10 + Math.random() * 20,\n      activeConnections: assignments.length\n    });\n\n    return metrics;\n  }\n\n  /**\n   * Calculate worker pool utilization\n   */\n  private calculatePoolUtilization(): Record<string, number> {\n    const utilization: Record<string, number> = {};\n\n    for (const [poolId, pool] of this.workerPools) {\n      utilization[pool.specialization] = pool.utilization / pool.capacity;\n    }\n\n    return utilization;\n  }\n\n  /**\n   * Adapt hive mind based on feedback\n   */\n  async adapt(feedback: Feedback[]): Promise<void> {\n    if (this.config.queenEnabled) {\n      await this.queen.adapt(feedback);\n    }\n\n    // Adapt worker pools based on performance\n    for (const pool of this.workerPools.values()) {\n      const poolFeedback = feedback.filter(f =>\n        pool.agents.some(agent => agent.id === f.source)\n      );\n\n      if (poolFeedback.length > 0) {\n        const avgRating = poolFeedback.reduce((sum, f) => sum + f.rating, 0) / poolFeedback.length;\n\n        // Adjust pool performance metrics\n        const alpha = this.config.adaptationRate;\n        pool.performance.averageQuality = pool.performance.averageQuality * (1 - alpha) + (avgRating / 5) * alpha;\n\n        await this.database.store(`worker-pool:${pool.id}`, pool, 'hive-mind');\n      }\n    }\n  }\n\n  /**\n   * Get hive mind status\n   */\n  async getStatus(): Promise<{\n    queen: any;\n    workerPools: WorkerPool[];\n    activeObjectives: number;\n    totalAssignments: number;\n    overallPerformance: number;\n  }> {\n    const queenMetrics = this.config.queenEnabled ? await this.queen.monitor() : null;\n\n    const overallPerformance = Array.from(this.workerPools.values())\n      .reduce((sum, pool) => sum + pool.performance.averageQuality, 0) / this.workerPools.size;\n\n    return {\n      queen: queenMetrics,\n      workerPools: Array.from(this.workerPools.values()),\n      activeObjectives: this.objectives.size,\n      totalAssignments: this.assignments.size,\n      overallPerformance\n    };\n  }\n\n  /**\n   * Get worker pool by specialization\n   */\n  getWorkerPoolBySpecialization(specialization: string): WorkerPool | undefined {\n    return Array.from(this.workerPools.values())\n      .find(pool => pool.specialization === specialization);\n  }\n\n  /**\n   * Scale worker pool\n   */\n  async scaleWorkerPool(poolId: string, newCapacity: number): Promise<void> {\n    const pool = this.workerPools.get(poolId);\n    if (!pool) return;\n\n    pool.capacity = newCapacity;\n    await this.database.store(`worker-pool:${poolId}`, pool, 'hive-mind');\n  }\n}\n\n/**\n * Queen Manager - Implements the strategic intelligence layer\n */\nclass QueenManager implements IHiveMindQueen {\n  private strategies: Map<string, Strategy> = new Map();\n  private metrics: QueenMetrics = {\n    strategiesCreated: 0,\n    tasksAssigned: 0,\n    successRate: 1.0,\n    adaptationCount: 0,\n    performanceScore: 100\n  };\n\n  constructor(\n    private database: IDatabaseProvider,\n    private agentRegistry: AgentRegistry,\n    private consensusEngine: ConsensusEngine,\n    private metricsCollector: MetricsCollector\n  ) {}\n\n  async initialize(): Promise<void> {\n    console.log('ðŸ‘‘ Queen Manager initialized - Strategic intelligence online');\n  }\n\n  async strategize(objective: Objective): Promise<Strategy> {\n    // Analyze objective complexity and requirements\n    const complexity = this.analyzeComplexity(objective);\n    const riskLevel = this.assessRisk(objective);\n\n    // Create strategy phases\n    const phases = this.createStrategyPhases(objective, complexity);\n\n    // Estimate resource requirements\n    const resourceAllocation = this.estimateResources(objective, phases);\n\n    // Assess risks\n    const riskAssessment = this.identifyRisks(objective, riskLevel);\n\n    const strategy: Strategy = {\n      approach: this.selectApproach(complexity, riskLevel),\n      phases,\n      resourceAllocation,\n      expectedOutcome: `Complete objective: ${objective.description}`,\n      riskAssessment\n    };\n\n    this.strategies.set(objective.id, strategy);\n    this.metrics.strategiesCreated++;\n\n    return strategy;\n  }\n\n  async delegate(tasks: Task[]): Promise<Assignment[]> {\n    // This would be handled by the main HiveMindCore\n    // Queen focuses on high-level strategy\n    this.metrics.tasksAssigned += tasks.length;\n    return [];\n  }\n\n  async monitor(): Promise<QueenMetrics> {\n    // Update performance score based on recent strategies\n    const recentStrategies = Array.from(this.strategies.values()).slice(-10);\n    if (recentStrategies.length > 0) {\n      // Simulate performance based on strategy complexity and success\n      this.metrics.performanceScore = Math.min(100, 70 + Math.random() * 30);\n    }\n\n    return { ...this.metrics };\n  }\n\n  async adapt(feedback: Feedback[]): Promise<void> {\n    // Adapt strategy creation based on feedback\n    const avgRating = feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length;\n\n    // Update success rate\n    const alpha = 0.1;\n    this.metrics.successRate = this.metrics.successRate * (1 - alpha) + (avgRating / 5) * alpha;\n    this.metrics.adaptationCount++;\n  }\n\n  private analyzeComplexity(objective: Objective): 'low' | 'medium' | 'high' {\n    const factors = [\n      objective.goals.length,\n      objective.constraints.length,\n      objective.priority === 'critical' ? 2 : 1\n    ];\n\n    const complexity = factors.reduce((sum, factor) => sum + factor, 0);\n\n    if (complexity <= 3) return 'low';\n    if (complexity <= 6) return 'medium';\n    return 'high';\n  }\n\n  private assessRisk(objective: Objective): 'low' | 'medium' | 'high' {\n    // Assess risk based on constraints and deadline\n    const hasDeadline = !!objective.deadline;\n    const constraintCount = objective.constraints.length;\n    const isCritical = objective.priority === 'critical';\n\n    if (isCritical || constraintCount > 3 || (hasDeadline && new Date(objective.deadline!) < new Date(Date.now() + 86400000))) {\n      return 'high';\n    }\n\n    if (constraintCount > 1 || hasDeadline) {\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  private createStrategyPhases(objective: Objective, complexity: string): any[] {\n    const basePhases = [\n      { name: 'Analysis', description: 'Analyze requirements and constraints' },\n      { name: 'Planning', description: 'Create detailed execution plan' },\n      { name: 'Execution', description: 'Implement the solution' },\n      { name: 'Validation', description: 'Validate outcomes against goals' }\n    ];\n\n    if (complexity === 'high') {\n      basePhases.splice(2, 0, { name: 'Prototyping', description: 'Create and test prototypes' });\n    }\n\n    return basePhases.map((phase, index) => ({\n      ...phase,\n      tasks: this.createTasksForPhase(phase, objective),\n      dependencies: index > 0 ? [basePhases[index - 1].name] : [],\n      duration: complexity === 'high' ? 3600 : complexity === 'medium' ? 1800 : 900 // seconds\n    }));\n  }\n\n  private createTasksForPhase(phase: any, objective: Objective): Task[] {\n    // Generate tasks based on phase and objective\n    return [{\n      id: nanoid(),\n      type: phase.name.toLowerCase(),\n      description: `${phase.description} for objective: ${objective.description}`,\n      priority: objective.priority,\n      requiredCapabilities: this.inferCapabilities(phase.name),\n      deadline: objective.deadline\n    }];\n  }\n\n  private inferCapabilities(phaseName: string): string[] {\n    const capabilityMap: Record<string, string[]> = {\n      'Analysis': ['research', 'analysis'],\n      'Planning': ['planning', 'coordination'],\n      'Prototyping': ['programming', 'testing'],\n      'Execution': ['programming', 'implementation'],\n      'Validation': ['testing', 'quality-assurance']\n    };\n\n    return capabilityMap[phaseName] || ['general'];\n  }\n\n  private selectApproach(complexity: string, riskLevel: string): string {\n    if (complexity === 'high' && riskLevel === 'high') {\n      return 'Incremental development with continuous validation';\n    }\n\n    if (complexity === 'high') {\n      return 'Phased implementation with parallel workstreams';\n    }\n\n    if (riskLevel === 'high') {\n      return 'Risk-first approach with contingency planning';\n    }\n\n    return 'Standard agile approach with regular checkpoints';\n  }\n\n  private estimateResources(objective: Objective, phases: any[]): any {\n    return {\n      memory: phases.length * 512, // MB\n      cpu: phases.length * 2, // cores\n      storage: phases.length * 100, // MB\n      network: 10 // Mbps\n    };\n  }\n\n  private identifyRisks(objective: Objective, riskLevel: string): any[] {\n    const baseRisks = [\n      {\n        description: 'Requirement changes during execution',\n        probability: 0.3,\n        impact: 0.6,\n        mitigation: 'Regular stakeholder communication and flexible planning'\n      }\n    ];\n\n    if (riskLevel === 'high') {\n      baseRisks.push({\n        description: 'Resource constraints affecting timeline',\n        probability: 0.5,\n        impact: 0.8,\n        mitigation: 'Resource monitoring and contingency planning'\n      });\n    }\n\n    return baseRisks;\n  }\n}"],"names":["nanoid","HiveMindCore","queen","workerPools","Map","objectives","strategies","assignments","config","database","agentRegistry","consensusEngine","metricsCollector","maxWorkerPools","queenEnabled","adaptationRate","consensusThreshold","specializations","QueenManager","initialize","createInitialWorkerPools","loadPersistedState","console","log","specialization","pool","id","agents","capacity","utilization","performance","tasksCompleted","averageQuality","successRate","set","store","objectiveKeys","list","objectiveItems","filter","key","startsWith","objective","retrieve","error","warn","setObjective","fullObjective","strategy","strategize","executeObjective","objectiveId","get","Error","allTasks","phases","forEach","phase","push","tasks","delegateTasks","results","executeAssignments","metrics","collectExecutionMetrics","success","every","r","task","bestPool","findBestWorkerPool","bestAgent","findBestAgentInPool","assignment","agentId","deadline","Date","now","resources","memory","cpu","storage","network","bestScore","values","canHandle","requiredCapabilities","some","capability","toLowerCase","includes","score","Math","max","length","agent","spawn","getAgentTypeForSpecialization","capabilities","metadata","workerPoolId","status","capabilityMatch","cap","performanceScore","typeMap","research","development","testing","optimization","coordination","dependencyGroups","groupByDependencies","group","groupResults","Promise","all","map","coordinate","message","String","groups","remaining","currentGroup","dependencies","dep","other","splice","successCount","totalTime","reduce","sum","executionTime","averageTime","totalTasks","successfulTasks","averageExecutionTime","workerPoolUtilization","calculatePoolUtilization","timestamp","toISOString","recordSystemMetrics","cpuUsage","random","memoryUsage","diskUsage","networkLatency","activeConnections","poolId","adapt","feedback","poolFeedback","f","source","avgRating","rating","alpha","getStatus","queenMetrics","monitor","overallPerformance","Array","from","size","activeObjectives","totalAssignments","getWorkerPoolBySpecialization","find","scaleWorkerPool","newCapacity","strategiesCreated","tasksAssigned","adaptationCount","complexity","analyzeComplexity","riskLevel","assessRisk","createStrategyPhases","resourceAllocation","estimateResources","riskAssessment","identifyRisks","approach","selectApproach","expectedOutcome","description","delegate","recentStrategies","slice","min","factors","goals","constraints","priority","factor","hasDeadline","constraintCount","isCritical","basePhases","name","index","createTasksForPhase","duration","type","inferCapabilities","phaseName","capabilityMap","baseRisks","probability","impact","mitigation"],"mappings":"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"}