{"version":3,"sources":["../../../src/core/event-bus.ts"],"sourcesContent":["/**\n * Event bus implementation for Claude-Flow\n */\n\nimport { SystemEvents } from '../utils/types.js';\nimport type { EventMap } from '../utils/types.js';\nimport { TypedEventEmitter } from '../utils/helpers.js';\n\nexport interface IEventBus {\n  emit(event: string, data?: unknown): void;\n  on(event: string, handler: (data: unknown) => void): void;\n  off(event: string, handler: (data: unknown) => void): void;\n  once(event: string, handler: (data: unknown) => void): void;\n}\n\n/**\n * Internal typed event bus\n */\nclass TypedEventBus extends TypedEventEmitter<EventMap> {\n  private eventCounts = new Map<keyof EventMap, number>();\n  private lastEventTimes = new Map<keyof EventMap, number>();\n  private debug: boolean;\n\n  constructor(debug = false) {\n    super();\n    this.debug = debug;\n  }\n\n  /**\n   * Emits an event with logging\n   */\n  override emit<K extends keyof EventMap>(event: K, data: EventMap[K]): void {\n    if (this.debug) {\n      console.debug(`[EventBus] Emitting event: ${String(event)}`, data);\n    }\n\n    // Track event metrics\n    const count = this.eventCounts.get(event) || 0;\n    this.eventCounts.set(event, count + 1);\n    this.lastEventTimes.set(event, Date.now());\n\n    super.emit(event, data);\n  }\n\n  /**\n   * Get event statistics\n   */\n  getEventStats(): { event: string; count: number; lastEmitted: Date | null }[] {\n    const stats: { event: string; count: number; lastEmitted: Date | null }[] = [];\n\n    for (const [event, count] of this.eventCounts.entries()) {\n      const lastTime = this.lastEventTimes.get(event);\n      stats.push({\n        event: String(event),\n        count,\n        lastEmitted: lastTime ? new Date(lastTime) : null,\n      });\n    }\n\n    return stats.sort((a, b) => b.count - a.count);\n  }\n\n  /**\n   * Reset event statistics\n   */\n  resetStats(): void {\n    this.eventCounts.clear();\n    this.lastEventTimes.clear();\n  }\n}\n\n/**\n * Global event bus for system-wide communication\n */\nexport class EventBus implements IEventBus {\n  private static instance: EventBus;\n  private typedBus: TypedEventBus;\n\n  private constructor(debug = false) {\n    this.typedBus = new TypedEventBus(debug);\n  }\n\n  /**\n   * Gets the singleton instance of the event bus\n   */\n  static getInstance(debug = false): EventBus {\n    if (!EventBus.instance) {\n      EventBus.instance = new EventBus(debug);\n    }\n    return EventBus.instance;\n  }\n\n  /**\n   * Emits an event\n   */\n  emit(event: string, data?: unknown): void {\n    // Type-safe emission for known events\n    if (event in SystemEvents) {\n      this.typedBus.emit(event as keyof EventMap, data as any);\n    } else {\n      // For custom events, emit as-is\n      this.typedBus.emit(event as any, data as any);\n    }\n  }\n\n  /**\n   * Registers an event handler\n   */\n  on(event: string, handler: (data: unknown) => void): void {\n    this.typedBus.on(event as any, handler);\n  }\n\n  /**\n   * Removes an event handler\n   */\n  off(event: string, handler: (data: unknown) => void): void {\n    this.typedBus.off(event as any, handler);\n  }\n\n  /**\n   * Registers a one-time event handler\n   */\n  once(event: string, handler: (data: unknown) => void): void {\n    this.typedBus.once(event as any, handler);\n  }\n\n  /**\n   * Waits for an event to occur\n   */\n  async waitFor(event: string, timeoutMs?: number): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      const handler = (data: unknown) => {\n        if (timer) clearTimeout(timer);\n        resolve(data);\n      };\n\n      let timer: number | undefined;\n      if (timeoutMs) {\n        timer = setTimeout(() => {\n          this.off(event, handler);\n          reject(new Error(`Timeout waiting for event: ${event}`));\n        }, timeoutMs);\n      }\n\n      this.once(event, handler);\n    });\n  }\n\n  /**\n   * Creates a filtered event listener\n   */\n  onFiltered(\n    event: string,\n    filter: (data: unknown) => boolean,\n    handler: (data: unknown) => void,\n  ): void {\n    this.on(event, (data) => {\n      if (filter(data)) {\n        handler(data);\n      }\n    });\n  }\n\n  /**\n   * Get event statistics\n   */\n  getEventStats(): { event: string; count: number; lastEmitted: Date | null }[] {\n    return this.typedBus.getEventStats();\n  }\n\n  /**\n   * Reset event statistics\n   */\n  resetStats(): void {\n    this.typedBus.resetStats();\n  }\n\n  /**\n   * Remove all listeners for an event\n   */\n  removeAllListeners(event?: string): void {\n    this.typedBus.removeAllListeners(event as any);\n  }\n}\n\n// Export singleton instance\nexport const eventBus = EventBus.getInstance();\n"],"names":["SystemEvents","TypedEventEmitter","TypedEventBus","eventCounts","Map","lastEventTimes","debug","emit","event","data","console","String","count","get","set","Date","now","getEventStats","stats","entries","lastTime","push","lastEmitted","sort","a","b","resetStats","clear","EventBus","instance","typedBus","getInstance","on","handler","off","once","waitFor","timeoutMs","Promise","resolve","reject","timer","clearTimeout","setTimeout","Error","onFiltered","filter","removeAllListeners","eventBus"],"mappings":"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"}