{"version":3,"sources":["../../../src/api/database-service.ts"],"sourcesContent":["/**\n * Database service for swarm coordination system\n * Provides data access layer with support for multiple database engines\n */\n\nimport { ILogger } from '../core/logger.js';\nimport { ConfigManager } from '../config/config-manager.js';\nimport { SwarmError, DatabaseError } from '../utils/errors.js';\nimport { nanoid } from 'nanoid';\n\nexport interface DatabaseConfig {\n  type: 'sqlite' | 'mysql' | 'postgresql';\n  host?: string;\n  port?: number;\n  database: string;\n  username?: string;\n  password?: string;\n  ssl?: boolean;\n  poolSize?: number;\n  timeout?: number;\n  retryAttempts?: number;\n}\n\nexport interface SwarmRecord {\n  id: string;\n  name: string;\n  topology: 'hierarchical' | 'mesh' | 'ring' | 'star';\n  maxAgents: number;\n  strategy: 'balanced' | 'specialized' | 'adaptive';\n  status: 'initializing' | 'active' | 'paused' | 'destroyed';\n  config?: Record<string, unknown>;\n  createdAt: Date;\n  updatedAt: Date;\n  destroyedAt?: Date;\n}\n\nexport interface AgentRecord {\n  id: string;\n  swarmId: string;\n  type: string;\n  name?: string;\n  status: 'spawning' | 'idle' | 'busy' | 'error' | 'terminated';\n  capabilities?: string[];\n  config?: Record<string, unknown>;\n  metadata?: Record<string, unknown>;\n  createdAt: Date;\n  updatedAt: Date;\n  terminatedAt?: Date;\n}\n\nexport interface TaskRecord {\n  id: string;\n  swarmId: string;\n  description: string;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  strategy: 'parallel' | 'sequential' | 'adaptive';\n  status: 'pending' | 'assigned' | 'running' | 'completed' | 'failed' | 'cancelled';\n  maxAgents?: number;\n  requirements?: string[];\n  metadata?: Record<string, unknown>;\n  result?: unknown;\n  errorMessage?: string;\n  assignedTo?: string;\n  createdAt: Date;\n  updatedAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n}\n\nexport interface MetricRecord {\n  id: string;\n  swarmId?: string;\n  agentId?: string;\n  metricType: string;\n  metricName: string;\n  metricValue: number;\n  unit?: string;\n  timestamp: Date;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface EventRecord {\n  id: string;\n  swarmId?: string;\n  agentId?: string;\n  eventType: string;\n  eventName: string;\n  eventData?: Record<string, unknown>;\n  severity: 'debug' | 'info' | 'warning' | 'error' | 'critical';\n  createdAt: Date;\n}\n\n/**\n * Database service implementation\n */\nexport class DatabaseService {\n  private db: any; // Database connection instance\n  private initialized = false;\n\n  constructor(\n    private config: DatabaseConfig,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    try {\n      this.logger.info('Initializing database service', {\n        type: this.config.type,\n        database: this.config.database,\n      });\n\n      // Initialize database connection based on type\n      switch (this.config.type) {\n        case 'sqlite':\n          await this.initializeSQLite();\n          break;\n        case 'mysql':\n          await this.initializeMySQL();\n          break;\n        case 'postgresql':\n          await this.initializePostgreSQL();\n          break;\n        default:\n          throw new DatabaseError(`Unsupported database type: ${this.config.type}`);\n      }\n\n      // Run migrations if needed\n      await this.runMigrations();\n\n      this.initialized = true;\n      this.logger.info('Database service initialized successfully');\n    } catch (error) {\n      this.logger.error('Failed to initialize database service', error);\n      throw new DatabaseError('Database initialization failed', { error });\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.initialized || !this.db) {\n      return;\n    }\n\n    try {\n      if (this.config.type === 'sqlite') {\n        await this.db.close();\n      } else {\n        await this.db.end();\n      }\n      this.initialized = false;\n      this.logger.info('Database service shutdown complete');\n    } catch (error) {\n      this.logger.error('Error shutting down database service', error);\n    }\n  }\n\n  // Swarm operations\n  async createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<SwarmRecord> {\n    const id = `swarm_${Date.now()}_${nanoid(10)}`;\n    const now = new Date();\n\n    const record: SwarmRecord = {\n      id,\n      ...swarm,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    try {\n      const query = `\n        INSERT INTO swarms (id, name, topology, max_agents, strategy, status, config, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      const values = [\n        record.id,\n        record.name,\n        record.topology,\n        record.maxAgents,\n        record.strategy,\n        record.status,\n        JSON.stringify(record.config),\n        record.createdAt,\n        record.updatedAt,\n      ];\n\n      await this.execute(query, values);\n      return record;\n    } catch (error) {\n      throw new DatabaseError('Failed to create swarm', { error, swarmId: id });\n    }\n  }\n\n  async getSwarm(id: string): Promise<SwarmRecord | null> {\n    try {\n      const query = 'SELECT * FROM swarms WHERE id = ?';\n      const rows = await this.query(query, [id]);\n      \n      if (rows.length === 0) {\n        return null;\n      }\n\n      return this.mapSwarmRow(rows[0]);\n    } catch (error) {\n      throw new DatabaseError('Failed to get swarm', { error, swarmId: id });\n    }\n  }\n\n  async updateSwarm(id: string, updates: Partial<SwarmRecord>): Promise<void> {\n    try {\n      const setClause = Object.keys(updates)\n        .filter(key => key !== 'id' && key !== 'createdAt')\n        .map(key => `${this.camelToSnake(key)} = ?`)\n        .join(', ');\n      \n      const values = Object.entries(updates)\n        .filter(([key]) => key !== 'id' && key !== 'createdAt')\n        .map(([key, value]) => {\n          if (key === 'config' && typeof value === 'object') {\n            return JSON.stringify(value);\n          }\n          return value;\n        });\n      \n      values.push(new Date()); // updated_at\n      values.push(id);\n\n      const query = `UPDATE swarms SET ${setClause}, updated_at = ? WHERE id = ?`;\n      await this.execute(query, values);\n    } catch (error) {\n      throw new DatabaseError('Failed to update swarm', { error, swarmId: id });\n    }\n  }\n\n  async deleteSwarm(id: string): Promise<void> {\n    try {\n      const query = 'UPDATE swarms SET status = ?, destroyed_at = ? WHERE id = ?';\n      await this.execute(query, ['destroyed', new Date(), id]);\n    } catch (error) {\n      throw new DatabaseError('Failed to delete swarm', { error, swarmId: id });\n    }\n  }\n\n  async listSwarms(filter?: { status?: string }): Promise<SwarmRecord[]> {\n    try {\n      let query = 'SELECT * FROM swarms';\n      const values: any[] = [];\n\n      if (filter?.status) {\n        query += ' WHERE status = ?';\n        values.push(filter.status);\n      }\n\n      query += ' ORDER BY created_at DESC';\n      const rows = await this.query(query, values);\n      \n      return rows.map(row => this.mapSwarmRow(row));\n    } catch (error) {\n      throw new DatabaseError('Failed to list swarms', { error });\n    }\n  }\n\n  // Agent operations\n  async createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<AgentRecord> {\n    const id = `agent_${Date.now()}_${nanoid(10)}`;\n    const now = new Date();\n\n    const record: AgentRecord = {\n      id,\n      ...agent,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    try {\n      const query = `\n        INSERT INTO agents (id, swarm_id, type, name, status, capabilities, config, metadata, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      const values = [\n        record.id,\n        record.swarmId,\n        record.type,\n        record.name,\n        record.status,\n        JSON.stringify(record.capabilities),\n        JSON.stringify(record.config),\n        JSON.stringify(record.metadata),\n        record.createdAt,\n        record.updatedAt,\n      ];\n\n      await this.execute(query, values);\n      return record;\n    } catch (error) {\n      throw new DatabaseError('Failed to create agent', { error, agentId: id });\n    }\n  }\n\n  async getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]> {\n    try {\n      const query = 'SELECT * FROM agents WHERE swarm_id = ? AND status != ? ORDER BY created_at';\n      const rows = await this.query(query, [swarmId, 'terminated']);\n      \n      return rows.map(row => this.mapAgentRow(row));\n    } catch (error) {\n      throw new DatabaseError('Failed to get agents by swarm', { error, swarmId });\n    }\n  }\n\n  async updateAgent(id: string, updates: Partial<AgentRecord>): Promise<void> {\n    try {\n      const setClause = Object.keys(updates)\n        .filter(key => key !== 'id' && key !== 'createdAt')\n        .map(key => `${this.camelToSnake(key)} = ?`)\n        .join(', ');\n      \n      const values = Object.entries(updates)\n        .filter(([key]) => key !== 'id' && key !== 'createdAt')\n        .map(([key, value]) => {\n          if (['capabilities', 'config', 'metadata'].includes(key) && typeof value === 'object') {\n            return JSON.stringify(value);\n          }\n          return value;\n        });\n      \n      values.push(new Date()); // updated_at\n      values.push(id);\n\n      const query = `UPDATE agents SET ${setClause}, updated_at = ? WHERE id = ?`;\n      await this.execute(query, values);\n    } catch (error) {\n      throw new DatabaseError('Failed to update agent', { error, agentId: id });\n    }\n  }\n\n  // Task operations\n  async createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<TaskRecord> {\n    const id = `task_${Date.now()}_${nanoid(10)}`;\n    const now = new Date();\n\n    const record: TaskRecord = {\n      id,\n      ...task,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    try {\n      const query = `\n        INSERT INTO tasks (id, swarm_id, description, priority, strategy, status, max_agents, requirements, metadata, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      const values = [\n        record.id,\n        record.swarmId,\n        record.description,\n        record.priority,\n        record.strategy,\n        record.status,\n        record.maxAgents,\n        JSON.stringify(record.requirements),\n        JSON.stringify(record.metadata),\n        record.createdAt,\n        record.updatedAt,\n      ];\n\n      await this.execute(query, values);\n      return record;\n    } catch (error) {\n      throw new DatabaseError('Failed to create task', { error, taskId: id });\n    }\n  }\n\n  async getTasksBySwarm(swarmId: string): Promise<TaskRecord[]> {\n    try {\n      const query = 'SELECT * FROM tasks WHERE swarm_id = ? ORDER BY created_at DESC';\n      const rows = await this.query(query, [swarmId]);\n      \n      return rows.map(row => this.mapTaskRow(row));\n    } catch (error) {\n      throw new DatabaseError('Failed to get tasks by swarm', { error, swarmId });\n    }\n  }\n\n  async updateTask(id: string, updates: Partial<TaskRecord>): Promise<void> {\n    try {\n      const setClause = Object.keys(updates)\n        .filter(key => key !== 'id' && key !== 'createdAt')\n        .map(key => `${this.camelToSnake(key)} = ?`)\n        .join(', ');\n      \n      const values = Object.entries(updates)\n        .filter(([key]) => key !== 'id' && key !== 'createdAt')\n        .map(([key, value]) => {\n          if (['requirements', 'metadata', 'result'].includes(key) && typeof value === 'object') {\n            return JSON.stringify(value);\n          }\n          return value;\n        });\n      \n      values.push(new Date()); // updated_at\n      values.push(id);\n\n      const query = `UPDATE tasks SET ${setClause}, updated_at = ? WHERE id = ?`;\n      await this.execute(query, values);\n    } catch (error) {\n      throw new DatabaseError('Failed to update task', { error, taskId: id });\n    }\n  }\n\n  // Metrics operations\n  async recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<void> {\n    const id = `metric_${Date.now()}_${nanoid(8)}`;\n    const record = {\n      id,\n      ...metric,\n      timestamp: new Date(),\n    };\n\n    try {\n      const query = `\n        INSERT INTO performance_metrics (id, swarm_id, agent_id, metric_type, metric_name, metric_value, unit, timestamp, metadata)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      const values = [\n        record.id,\n        record.swarmId,\n        record.agentId,\n        record.metricType,\n        record.metricName,\n        record.metricValue,\n        record.unit,\n        record.timestamp,\n        JSON.stringify(record.metadata),\n      ];\n\n      await this.execute(query, values);\n    } catch (error) {\n      throw new DatabaseError('Failed to record metric', { error, metricId: id });\n    }\n  }\n\n  async getMetrics(filter: {\n    swarmId?: string;\n    agentId?: string;\n    metricType?: string;\n    startTime?: Date;\n    endTime?: Date;\n    limit?: number;\n  }): Promise<MetricRecord[]> {\n    try {\n      let query = 'SELECT * FROM performance_metrics WHERE 1=1';\n      const values: any[] = [];\n\n      if (filter.swarmId) {\n        query += ' AND swarm_id = ?';\n        values.push(filter.swarmId);\n      }\n      if (filter.agentId) {\n        query += ' AND agent_id = ?';\n        values.push(filter.agentId);\n      }\n      if (filter.metricType) {\n        query += ' AND metric_type = ?';\n        values.push(filter.metricType);\n      }\n      if (filter.startTime) {\n        query += ' AND timestamp >= ?';\n        values.push(filter.startTime);\n      }\n      if (filter.endTime) {\n        query += ' AND timestamp <= ?';\n        values.push(filter.endTime);\n      }\n\n      query += ' ORDER BY timestamp DESC';\n      \n      if (filter.limit) {\n        query += ' LIMIT ?';\n        values.push(filter.limit);\n      }\n\n      const rows = await this.query(query, values);\n      return rows.map(row => this.mapMetricRow(row));\n    } catch (error) {\n      throw new DatabaseError('Failed to get metrics', { error });\n    }\n  }\n\n  // Event logging\n  async recordEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<void> {\n    const id = `event_${Date.now()}_${nanoid(8)}`;\n    const record = {\n      id,\n      ...event,\n      createdAt: new Date(),\n    };\n\n    try {\n      const query = `\n        INSERT INTO events (id, swarm_id, agent_id, event_type, event_name, event_data, severity, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      const values = [\n        record.id,\n        record.swarmId,\n        record.agentId,\n        record.eventType,\n        record.eventName,\n        JSON.stringify(record.eventData),\n        record.severity,\n        record.createdAt,\n      ];\n\n      await this.execute(query, values);\n    } catch (error) {\n      // Don't throw for event logging failures, just log the error\n      this.logger.error('Failed to record event', { error, event: record });\n    }\n  }\n\n  // Health check\n  async getHealthStatus(): Promise<{\n    healthy: boolean;\n    error?: string;\n    metrics?: Record<string, number>;\n  }> {\n    try {\n      const query = 'SELECT 1 as test';\n      await this.query(query);\n      \n      // Get basic metrics\n      const swarmCount = await this.query('SELECT COUNT(*) as count FROM swarms WHERE status != ?', ['destroyed']);\n      const agentCount = await this.query('SELECT COUNT(*) as count FROM agents WHERE status != ?', ['terminated']);\n      const activeTaskCount = await this.query('SELECT COUNT(*) as count FROM tasks WHERE status IN (?, ?, ?)', ['pending', 'assigned', 'running']);\n\n      return {\n        healthy: true,\n        metrics: {\n          totalSwarms: swarmCount[0]?.count || 0,\n          totalAgents: agentCount[0]?.count || 0,\n          activeTasks: activeTaskCount[0]?.count || 0,\n        },\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        error: error instanceof Error ? error.message : 'Unknown database error',\n      };\n    }\n  }\n\n  // Private helper methods\n  private async initializeSQLite(): Promise<void> {\n    try {\n      // Import better-sqlite3 dynamically\n      const Database = (await import('better-sqlite3')).default;\n      this.db = new Database(this.config.database);\n      \n      // Enable WAL mode for better concurrency\n      this.db.pragma('journal_mode = WAL');\n      this.db.pragma('synchronous = NORMAL');\n      this.db.pragma('cache_size = 1000');\n      this.db.pragma('temp_store = memory');\n    } catch (error) {\n      throw new DatabaseError('Failed to initialize SQLite', { error });\n    }\n  }\n\n  private async initializeMySQL(): Promise<void> {\n    // MySQL initialization would go here\n    throw new DatabaseError('MySQL support not implemented yet');\n  }\n\n  private async initializePostgreSQL(): Promise<void> {\n    // PostgreSQL initialization would go here\n    throw new DatabaseError('PostgreSQL support not implemented yet');\n  }\n\n  private async runMigrations(): Promise<void> {\n    try {\n      // Check if migrations table exists\n      const migrationQuery = this.config.type === 'sqlite'\n        ? \"SELECT name FROM sqlite_master WHERE type='table' AND name='migrations'\"\n        : \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'migrations'\";\n      \n      const migrationTable = await this.query(migrationQuery);\n      \n      if (migrationTable.length === 0) {\n        // Create migrations table and run initial schema\n        await this.execute(`\n          CREATE TABLE migrations (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            filename VARCHAR(255) NOT NULL,\n            executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n          )\n        `);\n        \n        // Run schema creation (simplified for demo)\n        await this.createTables();\n        \n        await this.execute(\n          \"INSERT INTO migrations (filename) VALUES (?)\",\n          ['001_initial_schema.sql']\n        );\n      }\n    } catch (error) {\n      throw new DatabaseError('Failed to run migrations', { error });\n    }\n  }\n\n  private async createTables(): Promise<void> {\n    const tables = [\n      // Swarms table\n      `CREATE TABLE IF NOT EXISTS swarms (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        topology TEXT NOT NULL,\n        max_agents INTEGER DEFAULT 8,\n        strategy TEXT DEFAULT 'balanced',\n        status TEXT DEFAULT 'initializing',\n        config TEXT,\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        destroyed_at TEXT\n      )`,\n      \n      // Agents table\n      `CREATE TABLE IF NOT EXISTS agents (\n        id TEXT PRIMARY KEY,\n        swarm_id TEXT NOT NULL,\n        type TEXT NOT NULL,\n        name TEXT,\n        status TEXT DEFAULT 'spawning',\n        capabilities TEXT,\n        config TEXT,\n        metadata TEXT,\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        terminated_at TEXT,\n        FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n      )`,\n      \n      // Tasks table\n      `CREATE TABLE IF NOT EXISTS tasks (\n        id TEXT PRIMARY KEY,\n        swarm_id TEXT NOT NULL,\n        description TEXT NOT NULL,\n        priority TEXT DEFAULT 'medium',\n        strategy TEXT DEFAULT 'adaptive',\n        status TEXT DEFAULT 'pending',\n        max_agents INTEGER,\n        requirements TEXT,\n        metadata TEXT,\n        result TEXT,\n        error_message TEXT,\n        assigned_to TEXT,\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,\n        started_at TEXT,\n        completed_at TEXT,\n        FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n      )`,\n      \n      // Performance metrics table\n      `CREATE TABLE IF NOT EXISTS performance_metrics (\n        id TEXT PRIMARY KEY,\n        swarm_id TEXT,\n        agent_id TEXT,\n        metric_type TEXT NOT NULL,\n        metric_name TEXT NOT NULL,\n        metric_value REAL NOT NULL,\n        unit TEXT,\n        timestamp TEXT DEFAULT CURRENT_TIMESTAMP,\n        metadata TEXT\n      )`,\n      \n      // Events table\n      `CREATE TABLE IF NOT EXISTS events (\n        id TEXT PRIMARY KEY,\n        swarm_id TEXT,\n        agent_id TEXT,\n        event_type TEXT NOT NULL,\n        event_name TEXT NOT NULL,\n        event_data TEXT,\n        severity TEXT DEFAULT 'info',\n        created_at TEXT DEFAULT CURRENT_TIMESTAMP\n      )`,\n    ];\n\n    for (const table of tables) {\n      await this.execute(table);\n    }\n  }\n\n  private async query(sql: string, params: any[] = []): Promise<any[]> {\n    if (this.config.type === 'sqlite') {\n      const stmt = this.db.prepare(sql);\n      return stmt.all(...params);\n    }\n    \n    // Other database types would be handled here\n    throw new DatabaseError('Unsupported database operation');\n  }\n\n  private async execute(sql: string, params: any[] = []): Promise<any> {\n    if (this.config.type === 'sqlite') {\n      const stmt = this.db.prepare(sql);\n      return stmt.run(...params);\n    }\n    \n    // Other database types would be handled here\n    throw new DatabaseError('Unsupported database operation');\n  }\n\n  private camelToSnake(str: string): string {\n    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\n  }\n\n  private mapSwarmRow(row: any): SwarmRecord {\n    return {\n      id: row.id,\n      name: row.name,\n      topology: row.topology,\n      maxAgents: row.max_agents,\n      strategy: row.strategy,\n      status: row.status,\n      config: row.config ? JSON.parse(row.config) : undefined,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n      destroyedAt: row.destroyed_at ? new Date(row.destroyed_at) : undefined,\n    };\n  }\n\n  private mapAgentRow(row: any): AgentRecord {\n    return {\n      id: row.id,\n      swarmId: row.swarm_id,\n      type: row.type,\n      name: row.name,\n      status: row.status,\n      capabilities: row.capabilities ? JSON.parse(row.capabilities) : undefined,\n      config: row.config ? JSON.parse(row.config) : undefined,\n      metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n      terminatedAt: row.terminated_at ? new Date(row.terminated_at) : undefined,\n    };\n  }\n\n  private mapTaskRow(row: any): TaskRecord {\n    return {\n      id: row.id,\n      swarmId: row.swarm_id,\n      description: row.description,\n      priority: row.priority,\n      strategy: row.strategy,\n      status: row.status,\n      maxAgents: row.max_agents,\n      requirements: row.requirements ? JSON.parse(row.requirements) : undefined,\n      metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\n      result: row.result ? JSON.parse(row.result) : undefined,\n      errorMessage: row.error_message,\n      assignedTo: row.assigned_to,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n      startedAt: row.started_at ? new Date(row.started_at) : undefined,\n      completedAt: row.completed_at ? new Date(row.completed_at) : undefined,\n    };\n  }\n\n  private mapMetricRow(row: any): MetricRecord {\n    return {\n      id: row.id,\n      swarmId: row.swarm_id,\n      agentId: row.agent_id,\n      metricType: row.metric_type,\n      metricName: row.metric_name,\n      metricValue: row.metric_value,\n      unit: row.unit,\n      timestamp: new Date(row.timestamp),\n      metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\n    };\n  }\n}"],"names":["DatabaseError","nanoid","DatabaseService","db","initialized","config","logger","initialize","info","type","database","initializeSQLite","initializeMySQL","initializePostgreSQL","runMigrations","error","shutdown","close","end","createSwarm","swarm","id","Date","now","record","createdAt","updatedAt","query","values","name","topology","maxAgents","strategy","status","JSON","stringify","execute","swarmId","getSwarm","rows","length","mapSwarmRow","updateSwarm","updates","setClause","Object","keys","filter","key","map","camelToSnake","join","entries","value","push","deleteSwarm","listSwarms","row","createAgent","agent","capabilities","metadata","agentId","getAgentsBySwarm","mapAgentRow","updateAgent","includes","createTask","task","description","priority","requirements","taskId","getTasksBySwarm","mapTaskRow","updateTask","recordMetric","metric","timestamp","metricType","metricName","metricValue","unit","metricId","getMetrics","startTime","endTime","limit","mapMetricRow","recordEvent","event","eventType","eventName","eventData","severity","getHealthStatus","swarmCount","agentCount","activeTaskCount","healthy","metrics","totalSwarms","count","totalAgents","activeTasks","Error","message","Database","default","pragma","migrationQuery","migrationTable","createTables","tables","table","sql","params","stmt","prepare","all","run","str","replace","letter","toLowerCase","max_agents","parse","undefined","created_at","updated_at","destroyedAt","destroyed_at","swarm_id","terminatedAt","terminated_at","result","errorMessage","error_message","assignedTo","assigned_to","startedAt","started_at","completedAt","completed_at","agent_id","metric_type","metric_name","metric_value"],"mappings":"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"}