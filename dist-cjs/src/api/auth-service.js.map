{"version":3,"sources":["../../../src/api/auth-service.ts"],"sourcesContent":["/**\n * Authentication and authorization service for swarm coordination system\n * Provides secure access control with JWT tokens, API keys, and role-based permissions\n */\n\nimport { ILogger } from '../core/logger.js';\nimport { AuthenticationError, AuthorizationError } from '../utils/errors.js';\nimport { nanoid } from 'nanoid';\nimport { createHash, createHmac, timingSafeEqual } from 'crypto';\n\nexport interface AuthConfig {\n  jwtSecret: string;\n  jwtExpiresIn?: string; // Default: '24h'\n  apiKeyLength?: number; // Default: 32\n  bcryptRounds?: number; // Default: 12\n  sessionTimeout?: number; // Default: 3600000 (1 hour)\n  maxLoginAttempts?: number; // Default: 5\n  lockoutDuration?: number; // Default: 900000 (15 minutes)\n  requireMFA?: boolean; // Default: false\n}\n\nexport interface User {\n  id: string;\n  email: string;\n  passwordHash: string;\n  role: UserRole;\n  permissions: Permission[];\n  apiKeys: ApiKey[];\n  isActive: boolean;\n  lastLogin?: Date;\n  loginAttempts: number;\n  lockedUntil?: Date;\n  mfaSecret?: string;\n  mfaEnabled: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface ApiKey {\n  id: string;\n  key: string;\n  keyHash: string;\n  name: string;\n  permissions: Permission[];\n  expiresAt?: Date;\n  lastUsed?: Date;\n  isActive: boolean;\n  createdAt: Date;\n}\n\nexport interface AuthToken {\n  token: string;\n  type: 'jwt' | 'api_key';\n  userId?: string;\n  apiKeyId?: string;\n  permissions: Permission[];\n  expiresAt: Date;\n  createdAt: Date;\n}\n\nexport interface AuthSession {\n  id: string;\n  userId: string;\n  token: string;\n  clientInfo?: {\n    userAgent?: string;\n    ip?: string;\n    device?: string;\n  };\n  isActive: boolean;\n  expiresAt: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport type UserRole = \n  | 'admin'       // Full system access\n  | 'operator'    // Can manage swarms and agents\n  | 'developer'   // Can create and monitor tasks\n  | 'viewer'      // Read-only access\n  | 'service';    // Service-to-service authentication\n\nexport type Permission = \n  | 'swarm.create'\n  | 'swarm.read'\n  | 'swarm.update'\n  | 'swarm.delete'\n  | 'swarm.scale'\n  | 'agent.spawn'\n  | 'agent.read'\n  | 'agent.terminate'\n  | 'task.create'\n  | 'task.read'\n  | 'task.cancel'\n  | 'metrics.read'\n  | 'system.admin'\n  | 'api.access';\n\nconst ROLE_PERMISSIONS: Record<UserRole, Permission[]> = {\n  admin: [\n    'swarm.create', 'swarm.read', 'swarm.update', 'swarm.delete', 'swarm.scale',\n    'agent.spawn', 'agent.read', 'agent.terminate',\n    'task.create', 'task.read', 'task.cancel',\n    'metrics.read', 'system.admin', 'api.access'\n  ],\n  operator: [\n    'swarm.create', 'swarm.read', 'swarm.update', 'swarm.scale',\n    'agent.spawn', 'agent.read', 'agent.terminate',\n    'task.create', 'task.read', 'task.cancel',\n    'metrics.read', 'api.access'\n  ],\n  developer: [\n    'swarm.read', 'agent.read',\n    'task.create', 'task.read', 'task.cancel',\n    'metrics.read', 'api.access'\n  ],\n  viewer: [\n    'swarm.read', 'agent.read', 'task.read', 'metrics.read', 'api.access'\n  ],\n  service: [\n    'api.access'\n  ]\n};\n\n/**\n * Authentication service implementation\n */\nexport class AuthService {\n  private users = new Map<string, User>();\n  private sessions = new Map<string, AuthSession>();\n  private apiKeys = new Map<string, ApiKey>();\n  private loginAttempts = new Map<string, { count: number; lastAttempt: Date }>();\n\n  constructor(\n    private config: AuthConfig,\n    private logger: ILogger,\n  ) {\n    this.initializeDefaultUsers();\n  }\n\n  /**\n   * Authenticate user with email and password\n   */\n  async authenticateUser(email: string, password: string, clientInfo?: {\n    userAgent?: string;\n    ip?: string;\n    device?: string;\n  }): Promise<{ user: User; token: string; session: AuthSession }> {\n    try {\n      // Check for rate limiting\n      await this.checkRateLimit(email);\n\n      // Find user\n      const user = Array.from(this.users.values()).find(u => u.email === email);\n      if (!user) {\n        await this.recordFailedLogin(email);\n        throw new AuthenticationError('Invalid credentials');\n      }\n\n      // Check if account is locked\n      if (user.lockedUntil && user.lockedUntil > new Date()) {\n        throw new AuthenticationError('Account locked due to too many failed attempts');\n      }\n\n      // Check if account is active\n      if (!user.isActive) {\n        throw new AuthenticationError('Account is disabled');\n      }\n\n      // Verify password\n      const isValid = await this.verifyPassword(password, user.passwordHash);\n      if (!isValid) {\n        await this.recordFailedLogin(email);\n        throw new AuthenticationError('Invalid credentials');\n      }\n\n      // Reset login attempts on successful authentication\n      this.loginAttempts.delete(email);\n      user.loginAttempts = 0;\n      user.lockedUntil = undefined;\n      user.lastLogin = new Date();\n\n      // Create session\n      const session = await this.createSession(user.id, clientInfo);\n\n      // Generate JWT token\n      const token = await this.generateJWT(user, session.id);\n\n      this.logger.info('User authenticated successfully', {\n        userId: user.id,\n        email: user.email,\n        sessionId: session.id,\n      });\n\n      return { user, token, session };\n    } catch (error) {\n      this.logger.error('Authentication failed', {\n        email,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate API key\n   */\n  async authenticateApiKey(apiKey: string): Promise<{ key: ApiKey; user?: User }> {\n    try {\n      // Hash the provided key to compare with stored hash\n      const keyHash = this.hashApiKey(apiKey);\n      \n      // Find matching API key\n      const storedKey = Array.from(this.apiKeys.values()).find(k => \n        this.constantTimeCompare(k.keyHash, keyHash)\n      );\n\n      if (!storedKey) {\n        throw new AuthenticationError('Invalid API key');\n      }\n\n      // Check if key is active\n      if (!storedKey.isActive) {\n        throw new AuthenticationError('API key is disabled');\n      }\n\n      // Check if key is expired\n      if (storedKey.expiresAt && storedKey.expiresAt < new Date()) {\n        throw new AuthenticationError('API key has expired');\n      }\n\n      // Update last used timestamp\n      storedKey.lastUsed = new Date();\n\n      // Find associated user (if any)\n      const user = Array.from(this.users.values()).find(u => \n        u.apiKeys.some(k => k.id === storedKey.id)\n      );\n\n      this.logger.info('API key authenticated successfully', {\n        keyId: storedKey.id,\n        keyName: storedKey.name,\n        userId: user?.id,\n      });\n\n      return { key: storedKey, user };\n    } catch (error) {\n      this.logger.error('API key authentication failed', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Verify JWT token\n   */\n  async verifyJWT(token: string): Promise<{ user: User; session: AuthSession }> {\n    try {\n      const payload = this.decodeJWT(token);\n      \n      if (!payload.userId || !payload.sessionId) {\n        throw new AuthenticationError('Invalid token payload');\n      }\n\n      // Check if session exists and is active\n      const session = this.sessions.get(payload.sessionId);\n      if (!session || !session.isActive) {\n        throw new AuthenticationError('Invalid or expired session');\n      }\n\n      // Check if session is expired\n      if (session.expiresAt < new Date()) {\n        session.isActive = false;\n        throw new AuthenticationError('Session expired');\n      }\n\n      // Get user\n      const user = this.users.get(payload.userId);\n      if (!user || !user.isActive) {\n        throw new AuthenticationError('User not found or inactive');\n      }\n\n      // Update session activity\n      session.updatedAt = new Date();\n\n      return { user, session };\n    } catch (error) {\n      this.logger.error('JWT verification failed', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if user has required permission\n   */\n  hasPermission(userOrPermissions: User | Permission[], requiredPermission: Permission): boolean {\n    const permissions = Array.isArray(userOrPermissions) \n      ? userOrPermissions \n      : userOrPermissions.permissions;\n    \n    return permissions.includes(requiredPermission) || permissions.includes('system.admin');\n  }\n\n  /**\n   * Create new user\n   */\n  async createUser(userData: {\n    email: string;\n    password: string;\n    role: UserRole;\n    isActive?: boolean;\n  }): Promise<User> {\n    // Check if email already exists\n    const existingUser = Array.from(this.users.values()).find(u => u.email === userData.email);\n    if (existingUser) {\n      throw new AuthenticationError('Email already exists');\n    }\n\n    const userId = `user_${Date.now()}_${nanoid(8)}`;\n    const passwordHash = await this.hashPassword(userData.password);\n    const permissions = ROLE_PERMISSIONS[userData.role] || [];\n\n    const user: User = {\n      id: userId,\n      email: userData.email,\n      passwordHash,\n      role: userData.role,\n      permissions,\n      apiKeys: [],\n      isActive: userData.isActive ?? true,\n      loginAttempts: 0,\n      mfaEnabled: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.users.set(userId, user);\n\n    this.logger.info('User created', {\n      userId,\n      email: userData.email,\n      role: userData.role,\n    });\n\n    return user;\n  }\n\n  /**\n   * Create API key for user\n   */\n  async createApiKey(userId: string, keyData: {\n    name: string;\n    permissions?: Permission[];\n    expiresAt?: Date;\n  }): Promise<{ apiKey: ApiKey; key: string }> {\n    const user = this.users.get(userId);\n    if (!user) {\n      throw new AuthenticationError('User not found');\n    }\n\n    const key = this.generateApiKey();\n    const keyHash = this.hashApiKey(key);\n    const keyId = `key_${Date.now()}_${nanoid(8)}`;\n\n    const permissions = keyData.permissions || user.permissions;\n\n    const apiKey: ApiKey = {\n      id: keyId,\n      key: key.substring(0, 8) + '...',  // Store only prefix for display\n      keyHash,\n      name: keyData.name,\n      permissions,\n      expiresAt: keyData.expiresAt,\n      isActive: true,\n      createdAt: new Date(),\n    };\n\n    // Add to user's API keys\n    user.apiKeys.push(apiKey);\n    \n    // Store in global API keys map\n    this.apiKeys.set(keyId, apiKey);\n\n    this.logger.info('API key created', {\n      userId,\n      keyId,\n      keyName: keyData.name,\n    });\n\n    return { apiKey, key };\n  }\n\n  /**\n   * Revoke API key\n   */\n  async revokeApiKey(keyId: string): Promise<void> {\n    const apiKey = this.apiKeys.get(keyId);\n    if (!apiKey) {\n      throw new AuthenticationError('API key not found');\n    }\n\n    apiKey.isActive = false;\n    \n    // Remove from user's keys\n    const user = Array.from(this.users.values()).find(u => \n      u.apiKeys.some(k => k.id === keyId)\n    );\n    if (user) {\n      user.apiKeys = user.apiKeys.filter(k => k.id !== keyId);\n    }\n\n    this.logger.info('API key revoked', {\n      keyId,\n      keyName: apiKey.name,\n      userId: user?.id,\n    });\n  }\n\n  /**\n   * Invalidate session\n   */\n  async invalidateSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.isActive = false;\n      this.logger.info('Session invalidated', {\n        sessionId,\n        userId: session.userId,\n      });\n    }\n  }\n\n  /**\n   * Clean up expired sessions\n   */\n  async cleanupSessions(): Promise<void> {\n    const now = new Date();\n    let cleaned = 0;\n\n    for (const [sessionId, session] of this.sessions) {\n      if (!session.isActive || session.expiresAt < now) {\n        this.sessions.delete(sessionId);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.info('Cleaned up expired sessions', { count: cleaned });\n    }\n  }\n\n  /**\n   * Get user by ID\n   */\n  getUser(userId: string): User | undefined {\n    return this.users.get(userId);\n  }\n\n  /**\n   * List all users (admin only)\n   */\n  listUsers(): User[] {\n    return Array.from(this.users.values());\n  }\n\n  // Private helper methods\n  private async checkRateLimit(email: string): Promise<void> {\n    const attempts = this.loginAttempts.get(email);\n    const maxAttempts = this.config.maxLoginAttempts || 5;\n    const lockoutDuration = this.config.lockoutDuration || 900000; // 15 minutes\n\n    if (attempts && attempts.count >= maxAttempts) {\n      const timeSinceLastAttempt = Date.now() - attempts.lastAttempt.getTime();\n      if (timeSinceLastAttempt < lockoutDuration) {\n        throw new AuthenticationError('Too many failed login attempts. Please try again later.');\n      } else {\n        // Reset attempts after lockout period\n        this.loginAttempts.delete(email);\n      }\n    }\n  }\n\n  private async recordFailedLogin(email: string): Promise<void> {\n    const attempts = this.loginAttempts.get(email) || { count: 0, lastAttempt: new Date() };\n    attempts.count++;\n    attempts.lastAttempt = new Date();\n    this.loginAttempts.set(email, attempts);\n  }\n\n  private async createSession(userId: string, clientInfo?: {\n    userAgent?: string;\n    ip?: string;\n    device?: string;\n  }): Promise<AuthSession> {\n    const sessionId = `session_${Date.now()}_${nanoid(16)}`;\n    const sessionTimeout = this.config.sessionTimeout || 3600000; // 1 hour\n    const expiresAt = new Date(Date.now() + sessionTimeout);\n\n    const session: AuthSession = {\n      id: sessionId,\n      userId,\n      token: nanoid(32),\n      clientInfo,\n      isActive: true,\n      expiresAt,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.sessions.set(sessionId, session);\n    return session;\n  }\n\n  private async generateJWT(user: User, sessionId: string): Promise<string> {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n      permissions: user.permissions,\n      sessionId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours\n    };\n\n    const header = {\n      alg: 'HS256',\n      typ: 'JWT',\n    };\n\n    const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');\n    const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64url');\n    \n    const signature = createHmac('sha256', this.config.jwtSecret)\n      .update(`${encodedHeader}.${encodedPayload}`)\n      .digest('base64url');\n\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\n  }\n\n  private decodeJWT(token: string): any {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new AuthenticationError('Invalid token format');\n    }\n\n    const [encodedHeader, encodedPayload, signature] = parts;\n    \n    // Verify signature\n    const expectedSignature = createHmac('sha256', this.config.jwtSecret)\n      .update(`${encodedHeader}.${encodedPayload}`)\n      .digest('base64url');\n    \n    if (!this.constantTimeCompare(signature, expectedSignature)) {\n      throw new AuthenticationError('Invalid token signature');\n    }\n\n    // Decode payload\n    const payload = JSON.parse(Buffer.from(encodedPayload, 'base64url').toString());\n    \n    // Check expiration\n    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\n      throw new AuthenticationError('Token expired');\n    }\n\n    return payload;\n  }\n\n  private generateApiKey(): string {\n    const length = this.config.apiKeyLength || 32;\n    return nanoid(length);\n  }\n\n  private hashApiKey(key: string): string {\n    return createHash('sha256').update(key).digest('hex');\n  }\n\n  private async hashPassword(password: string): Promise<string> {\n    // In a real implementation, use bcrypt\n    return createHash('sha256').update(password + 'salt').digest('hex');\n  }\n\n  private async verifyPassword(password: string, hash: string): Promise<boolean> {\n    // In a real implementation, use bcrypt.compare\n    const passwordHash = createHash('sha256').update(password + 'salt').digest('hex');\n    return this.constantTimeCompare(passwordHash, hash);\n  }\n\n  private constantTimeCompare(a: string, b: string): boolean {\n    if (a.length !== b.length) {\n      return false;\n    }\n    \n    const bufferA = Buffer.from(a, 'hex');\n    const bufferB = Buffer.from(b, 'hex');\n    \n    return timingSafeEqual(bufferA, bufferB);\n  }\n\n  private initializeDefaultUsers(): void {\n    // Create default admin user\n    const adminId = 'admin_default';\n    const adminUser: User = {\n      id: adminId,\n      email: 'admin@claude-flow.local',\n      passwordHash: createHash('sha256').update('admin123' + 'salt').digest('hex'),\n      role: 'admin',\n      permissions: ROLE_PERMISSIONS.admin,\n      apiKeys: [],\n      isActive: true,\n      loginAttempts: 0,\n      mfaEnabled: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.users.set(adminId, adminUser);\n\n    // Create default service user\n    const serviceId = 'service_default';\n    const serviceUser: User = {\n      id: serviceId,\n      email: 'service@claude-flow.local',\n      passwordHash: createHash('sha256').update('service123' + 'salt').digest('hex'),\n      role: 'service',\n      permissions: ROLE_PERMISSIONS.service,\n      apiKeys: [],\n      isActive: true,\n      loginAttempts: 0,\n      mfaEnabled: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.users.set(serviceId, serviceUser);\n\n    this.logger.info('Default users initialized', {\n      admin: adminUser.email,\n      service: serviceUser.email,\n    });\n  }\n}"],"names":["AuthenticationError","nanoid","createHash","createHmac","timingSafeEqual","ROLE_PERMISSIONS","admin","operator","developer","viewer","service","AuthService","users","Map","sessions","apiKeys","loginAttempts","config","logger","initializeDefaultUsers","authenticateUser","email","password","clientInfo","checkRateLimit","user","Array","from","values","find","u","recordFailedLogin","lockedUntil","Date","isActive","isValid","verifyPassword","passwordHash","delete","undefined","lastLogin","session","createSession","id","token","generateJWT","info","userId","sessionId","error","Error","message","authenticateApiKey","apiKey","keyHash","hashApiKey","storedKey","k","constantTimeCompare","expiresAt","lastUsed","some","keyId","keyName","name","key","verifyJWT","payload","decodeJWT","get","updatedAt","hasPermission","userOrPermissions","requiredPermission","permissions","isArray","includes","createUser","userData","existingUser","now","hashPassword","role","mfaEnabled","createdAt","set","createApiKey","keyData","generateApiKey","substring","push","revokeApiKey","filter","invalidateSession","cleanupSessions","cleaned","count","getUser","listUsers","attempts","maxAttempts","maxLoginAttempts","lockoutDuration","timeSinceLastAttempt","lastAttempt","getTime","sessionTimeout","iat","Math","floor","exp","header","alg","typ","encodedHeader","Buffer","JSON","stringify","toString","encodedPayload","signature","jwtSecret","update","digest","parts","split","length","expectedSignature","parse","apiKeyLength","hash","a","b","bufferA","bufferB","adminId","adminUser","serviceId","serviceUser"],"mappings":"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"}