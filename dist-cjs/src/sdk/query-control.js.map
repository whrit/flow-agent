{"version":3,"sources":["../../../src/sdk/query-control.ts"],"sourcesContent":["/**\n * Real-Time Query Control\n * Claude-Flow v2.5-alpha.130\n *\n * Implements real-time control of running agent queries:\n * - Pause/resume execution\n * - Terminate agents dynamically\n * - Change model or permissions mid-execution\n * - Monitor agent status in real-time\n */\n\nimport { type Query, type PermissionMode, type ModelInfo } from '@anthropic-ai/claude-code/sdk';\nimport { EventEmitter } from 'events';\nimport { Logger } from '../core/logger.js';\n\nexport interface QueryControlOptions {\n  allowPause?: boolean;\n  allowModelChange?: boolean;\n  allowPermissionChange?: boolean;\n  monitoringInterval?: number;\n}\n\nexport interface ControlledQuery {\n  queryId: string;\n  agentId: string;\n  query: Query;\n  status: 'running' | 'paused' | 'terminated' | 'completed' | 'failed';\n  isPaused: boolean;\n  canControl: boolean;\n  startTime: number;\n  pausedAt?: number;\n  resumedAt?: number;\n  terminatedAt?: number;\n  currentModel?: string;\n  permissionMode?: PermissionMode;\n}\n\nexport interface QueryControlCommand {\n  type: 'pause' | 'resume' | 'terminate' | 'changeModel' | 'changePermissions';\n  queryId: string;\n  params?: {\n    model?: string;\n    permissionMode?: PermissionMode;\n    reason?: string;\n  };\n}\n\nexport interface QueryStatusUpdate {\n  queryId: string;\n  status: ControlledQuery['status'];\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\n/**\n * RealTimeQueryController - Control running queries dynamically\n * Enables pause, resume, terminate, and configuration changes during execution\n */\nexport class RealTimeQueryController extends EventEmitter {\n  private logger: Logger;\n  private controlledQueries: Map<string, ControlledQuery> = new Map();\n  private monitoringIntervals: Map<string, NodeJS.Timeout> = new Map();\n  private commandQueue: Map<string, QueryControlCommand[]> = new Map();\n  private options: QueryControlOptions;\n\n  constructor(options: QueryControlOptions = {}) {\n    super();\n    this.options = {\n      allowPause: options.allowPause !== false,\n      allowModelChange: options.allowModelChange !== false,\n      allowPermissionChange: options.allowPermissionChange !== false,\n      monitoringInterval: options.monitoringInterval || 1000\n    };\n\n    this.logger = new Logger(\n      { level: 'info', format: 'text', destination: 'console' },\n      { component: 'RealTimeQueryController' }\n    );\n  }\n\n  /**\n   * Register a query for control\n   */\n  registerQuery(queryId: string, agentId: string, query: Query): ControlledQuery {\n    const controlled: ControlledQuery = {\n      queryId,\n      agentId,\n      query,\n      status: 'running',\n      isPaused: false,\n      canControl: true,\n      startTime: Date.now()\n    };\n\n    this.controlledQueries.set(queryId, controlled);\n    this.startMonitoring(queryId);\n\n    this.logger.info('Query registered for control', { queryId, agentId });\n    this.emit('query:registered', { queryId, agentId });\n\n    return controlled;\n  }\n\n  /**\n   * Pause a running query\n   * Note: SDK interrupt() will stop the query, not pause it\n   * True pause/resume requires custom implementation\n   */\n  async pauseQuery(queryId: string, reason?: string): Promise<boolean> {\n    if (!this.options.allowPause) {\n      throw new Error('Pause is not enabled in controller options');\n    }\n\n    const controlled = this.controlledQueries.get(queryId);\n    if (!controlled) {\n      throw new Error(`Query not found: ${queryId}`);\n    }\n\n    if (controlled.isPaused || controlled.status !== 'running') {\n      this.logger.warn('Query is not in a state to be paused', {\n        queryId,\n        status: controlled.status,\n        isPaused: controlled.isPaused\n      });\n      return false;\n    }\n\n    try {\n      // SDK doesn't support true pause, so we interrupt\n      // In a real implementation, we'd need to track state and resume\n      await controlled.query.interrupt();\n\n      controlled.isPaused = true;\n      controlled.status = 'paused';\n      controlled.pausedAt = Date.now();\n\n      this.logger.info('Query paused', { queryId, reason });\n      this.emit('query:paused', { queryId, reason });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to pause query', {\n        queryId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Resume a paused query\n   * Note: Actual resume requires storing state and restarting\n   */\n  async resumeQuery(queryId: string): Promise<boolean> {\n    const controlled = this.controlledQueries.get(queryId);\n    if (!controlled) {\n      throw new Error(`Query not found: ${queryId}`);\n    }\n\n    if (!controlled.isPaused || controlled.status !== 'paused') {\n      this.logger.warn('Query is not paused', { queryId, status: controlled.status });\n      return false;\n    }\n\n    // In a real implementation, we'd resume from saved state\n    // For now, mark as resumed\n    controlled.isPaused = false;\n    controlled.status = 'running';\n    controlled.resumedAt = Date.now();\n\n    this.logger.info('Query resumed', { queryId });\n    this.emit('query:resumed', { queryId });\n\n    return true;\n  }\n\n  /**\n   * Terminate a query immediately\n   */\n  async terminateQuery(queryId: string, reason?: string): Promise<boolean> {\n    const controlled = this.controlledQueries.get(queryId);\n    if (!controlled) {\n      throw new Error(`Query not found: ${queryId}`);\n    }\n\n    if (controlled.status === 'terminated') {\n      return true;\n    }\n\n    try {\n      await controlled.query.interrupt();\n\n      controlled.status = 'terminated';\n      controlled.terminatedAt = Date.now();\n      this.stopMonitoring(queryId);\n\n      this.logger.info('Query terminated', { queryId, reason });\n      this.emit('query:terminated', { queryId, reason });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to terminate query', {\n        queryId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Change model for a running query\n   */\n  async changeModel(queryId: string, model: string): Promise<boolean> {\n    if (!this.options.allowModelChange) {\n      throw new Error('Model change is not enabled in controller options');\n    }\n\n    const controlled = this.controlledQueries.get(queryId);\n    if (!controlled) {\n      throw new Error(`Query not found: ${queryId}`);\n    }\n\n    if (controlled.status !== 'running') {\n      throw new Error('Can only change model for running queries');\n    }\n\n    try {\n      await controlled.query.setModel(model);\n      controlled.currentModel = model;\n\n      this.logger.info('Model changed for query', { queryId, model });\n      this.emit('query:modelChanged', { queryId, model });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to change model', {\n        queryId,\n        model,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Change permission mode for a running query\n   */\n  async changePermissionMode(queryId: string, mode: PermissionMode): Promise<boolean> {\n    if (!this.options.allowPermissionChange) {\n      throw new Error('Permission change is not enabled in controller options');\n    }\n\n    const controlled = this.controlledQueries.get(queryId);\n    if (!controlled) {\n      throw new Error(`Query not found: ${queryId}`);\n    }\n\n    if (controlled.status !== 'running') {\n      throw new Error('Can only change permissions for running queries');\n    }\n\n    try {\n      await controlled.query.setPermissionMode(mode);\n      controlled.permissionMode = mode;\n\n      this.logger.info('Permission mode changed for query', { queryId, mode });\n      this.emit('query:permissionChanged', { queryId, mode });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to change permission mode', {\n        queryId,\n        mode,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get supported models for a query\n   */\n  async getSupportedModels(queryId: string): Promise<ModelInfo[]> {\n    const controlled = this.controlledQueries.get(queryId);\n    if (!controlled) {\n      throw new Error(`Query not found: ${queryId}`);\n    }\n\n    try {\n      return await controlled.query.supportedModels();\n    } catch (error) {\n      this.logger.error('Failed to get supported models', { queryId });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a control command\n   */\n  async executeCommand(command: QueryControlCommand): Promise<boolean> {\n    this.logger.debug('Executing control command', { command });\n\n    switch (command.type) {\n      case 'pause':\n        return this.pauseQuery(command.queryId, command.params?.reason);\n\n      case 'resume':\n        return this.resumeQuery(command.queryId);\n\n      case 'terminate':\n        return this.terminateQuery(command.queryId, command.params?.reason);\n\n      case 'changeModel':\n        if (!command.params?.model) {\n          throw new Error('Model parameter required for changeModel command');\n        }\n        return this.changeModel(command.queryId, command.params.model);\n\n      case 'changePermissions':\n        if (!command.params?.permissionMode) {\n          throw new Error('Permission mode required for changePermissions command');\n        }\n        return this.changePermissionMode(command.queryId, command.params.permissionMode);\n\n      default:\n        throw new Error(`Unknown command type: ${(command as any).type}`);\n    }\n  }\n\n  /**\n   * Queue a command for execution\n   */\n  queueCommand(command: QueryControlCommand): void {\n    const queue = this.commandQueue.get(command.queryId) || [];\n    queue.push(command);\n    this.commandQueue.set(command.queryId, queue);\n\n    this.emit('command:queued', command);\n  }\n\n  /**\n   * Process queued commands for a query\n   */\n  async processQueuedCommands(queryId: string): Promise<void> {\n    const queue = this.commandQueue.get(queryId);\n    if (!queue || queue.length === 0) {\n      return;\n    }\n\n    this.logger.debug('Processing queued commands', {\n      queryId,\n      commandCount: queue.length\n    });\n\n    while (queue.length > 0) {\n      const command = queue.shift()!;\n      try {\n        await this.executeCommand(command);\n      } catch (error) {\n        this.logger.error('Failed to execute queued command', {\n          queryId,\n          command,\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }\n\n    this.commandQueue.delete(queryId);\n  }\n\n  /**\n   * Get query status\n   */\n  getQueryStatus(queryId: string): ControlledQuery | undefined {\n    return this.controlledQueries.get(queryId);\n  }\n\n  /**\n   * Get all controlled queries\n   */\n  getAllQueries(): Map<string, ControlledQuery> {\n    return new Map(this.controlledQueries);\n  }\n\n  /**\n   * Start monitoring a query\n   */\n  private startMonitoring(queryId: string): void {\n    const interval = setInterval(() => {\n      const controlled = this.controlledQueries.get(queryId);\n      if (!controlled) {\n        this.stopMonitoring(queryId);\n        return;\n      }\n\n      const update: QueryStatusUpdate = {\n        queryId,\n        status: controlled.status,\n        timestamp: Date.now(),\n        metadata: {\n          isPaused: controlled.isPaused,\n          duration: Date.now() - controlled.startTime\n        }\n      };\n\n      this.emit('query:status', update);\n\n    }, this.options.monitoringInterval);\n\n    this.monitoringIntervals.set(queryId, interval);\n  }\n\n  /**\n   * Stop monitoring a query\n   */\n  private stopMonitoring(queryId: string): void {\n    const interval = this.monitoringIntervals.get(queryId);\n    if (interval) {\n      clearInterval(interval);\n      this.monitoringIntervals.delete(queryId);\n    }\n  }\n\n  /**\n   * Unregister a query\n   */\n  unregisterQuery(queryId: string): void {\n    this.stopMonitoring(queryId);\n    this.controlledQueries.delete(queryId);\n    this.commandQueue.delete(queryId);\n\n    this.logger.info('Query unregistered', { queryId });\n    this.emit('query:unregistered', { queryId });\n  }\n\n  /**\n   * Cleanup completed queries\n   */\n  cleanup(olderThan: number = 3600000): void {\n    const cutoff = Date.now() - olderThan;\n\n    for (const [queryId, controlled] of this.controlledQueries.entries()) {\n      const endTime = controlled.terminatedAt || controlled.startTime;\n\n      if (controlled.status === 'completed' || controlled.status === 'terminated') {\n        if (endTime < cutoff) {\n          this.unregisterQuery(queryId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Shutdown controller\n   */\n  shutdown(): void {\n    // Stop all monitoring\n    for (const queryId of this.monitoringIntervals.keys()) {\n      this.stopMonitoring(queryId);\n    }\n\n    // Clear all data\n    this.controlledQueries.clear();\n    this.commandQueue.clear();\n\n    this.logger.info('Query controller shutdown complete');\n  }\n}"],"names":["EventEmitter","Logger","RealTimeQueryController","logger","controlledQueries","Map","monitoringIntervals","commandQueue","options","allowPause","allowModelChange","allowPermissionChange","monitoringInterval","level","format","destination","component","registerQuery","queryId","agentId","query","controlled","status","isPaused","canControl","startTime","Date","now","set","startMonitoring","info","emit","pauseQuery","reason","Error","get","warn","interrupt","pausedAt","error","message","String","resumeQuery","resumedAt","terminateQuery","terminatedAt","stopMonitoring","changeModel","model","setModel","currentModel","changePermissionMode","mode","setPermissionMode","permissionMode","getSupportedModels","supportedModels","executeCommand","command","debug","type","params","queueCommand","queue","push","processQueuedCommands","length","commandCount","shift","delete","getQueryStatus","getAllQueries","interval","setInterval","update","timestamp","metadata","duration","clearInterval","unregisterQuery","cleanup","olderThan","cutoff","entries","endTime","shutdown","keys","clear"],"mappings":"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"}