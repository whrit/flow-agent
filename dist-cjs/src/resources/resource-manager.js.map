{"version":3,"sources":["../../../src/resources/resource-manager.ts"],"sourcesContent":["/**\n * Comprehensive resource management system for swarm operations\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { AgentId, TaskId } from '../swarm/types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface ResourceManagerConfig {\n  enableResourcePooling: boolean;\n  enableResourceMonitoring: boolean;\n  enableAutoScaling: boolean;\n  enableQoS: boolean;\n  monitoringInterval: number;\n  cleanupInterval: number;\n  defaultLimits: ResourceLimits;\n  reservationTimeout: number;\n  allocationStrategy: 'first-fit' | 'best-fit' | 'worst-fit' | 'balanced';\n  priorityWeights: PriorityWeights;\n  enablePredictiveAllocation: boolean;\n  enableResourceSharing: boolean;\n  debugMode: boolean;\n}\n\nexport interface ResourceLimits {\n  cpu: number; // CPU cores\n  memory: number; // Bytes\n  disk: number; // Bytes\n  network: number; // Bytes per second\n  gpu?: number; // GPU units\n  custom: Record<string, number>;\n}\n\nexport interface PriorityWeights {\n  critical: number;\n  high: number;\n  normal: number;\n  low: number;\n  background: number;\n}\n\nexport interface Resource {\n  id: string;\n  type: ResourceType;\n  name: string;\n  description: string;\n  capacity: ResourceLimits;\n  allocated: ResourceLimits;\n  available: ResourceLimits;\n  status: ResourceStatus;\n  metadata: ResourceMetadata;\n  reservations: ResourceReservation[];\n  allocations: ResourceAllocation[];\n  sharable: boolean;\n  persistent: boolean;\n  cost: number;\n  location?: string;\n  tags: string[];\n}\n\nexport interface ResourcePool {\n  id: string;\n  name: string;\n  type: ResourceType;\n  resources: string[]; // Resource IDs\n  strategy: PoolStrategy;\n  loadBalancing: LoadBalancingStrategy;\n  scaling: ScalingConfig;\n  qos: QoSConfig;\n  statistics: PoolStatistics;\n  filters: ResourceFilter[];\n}\n\nexport interface ResourceReservation {\n  id: string;\n  resourceId: string;\n  agentId: AgentId;\n  taskId?: TaskId;\n  requirements: ResourceRequirements;\n  status: ReservationStatus;\n  priority: ResourcePriority;\n  createdAt: Date;\n  expiresAt?: Date;\n  activatedAt?: Date;\n  releasedAt?: Date;\n  metadata: Record<string, any>;\n}\n\nexport interface ResourceAllocation {\n  id: string;\n  reservationId: string;\n  resourceId: string;\n  agentId: AgentId;\n  taskId?: TaskId;\n  allocated: ResourceLimits;\n  actualUsage: ResourceUsage;\n  efficiency: number;\n  startTime: Date;\n  endTime?: Date;\n  status: AllocationStatus;\n  qosViolations: QoSViolation[];\n}\n\nexport interface ResourceRequirements {\n  cpu?: ResourceSpec;\n  memory?: ResourceSpec;\n  disk?: ResourceSpec;\n  network?: ResourceSpec;\n  gpu?: ResourceSpec;\n  custom?: Record<string, ResourceSpec>;\n  constraints?: ResourceConstraints;\n  preferences?: ResourcePreferences;\n}\n\nexport interface ResourceSpec {\n  min: number;\n  max?: number;\n  preferred?: number;\n  unit: string;\n  shared?: boolean;\n  exclusive?: boolean;\n}\n\nexport interface ResourceConstraints {\n  location?: string[];\n  excludeLocation?: string[];\n  nodeAffinity?: NodeAffinity[];\n  antiAffinity?: AntiAffinity[];\n  timeWindow?: TimeWindow;\n  dependencies?: string[];\n  maxCost?: number;\n}\n\nexport interface ResourcePreferences {\n  location?: string;\n  performanceClass?: 'high' | 'medium' | 'low';\n  costOptimized?: boolean;\n  energyEfficient?: boolean;\n  highAvailability?: boolean;\n}\n\nexport interface ResourceUsage {\n  cpu: number;\n  memory: number;\n  disk: number;\n  network: number;\n  gpu?: number;\n  custom: Record<string, number>;\n  timestamp: Date;\n  duration: number;\n}\n\nexport interface ResourceMetadata {\n  provider: string;\n  region?: string;\n  zone?: string;\n  instance?: string;\n  capabilities: string[];\n  performance: PerformanceMetrics;\n  reliability: ReliabilityMetrics;\n  cost: CostMetrics;\n  lastUpdated: Date;\n}\n\nexport interface PerformanceMetrics {\n  cpuScore: number;\n  memoryBandwidth: number;\n  diskIOPS: number;\n  networkBandwidth: number;\n  gpuScore?: number;\n  benchmarkResults: Record<string, number>;\n}\n\nexport interface ReliabilityMetrics {\n  uptime: number;\n  meanTimeBetweenFailures: number;\n  errorRate: number;\n  lastFailure?: Date;\n  failureHistory: FailureRecord[];\n}\n\nexport interface CostMetrics {\n  hourlyRate: number;\n  dataTransferCost: number;\n  storageCost: number;\n  spotPricing?: boolean;\n  billing: BillingModel;\n}\n\nexport interface FailureRecord {\n  timestamp: Date;\n  type: string;\n  duration: number;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  resolved: boolean;\n}\n\nexport interface QoSConfig {\n  guarantees: QoSGuarantee[];\n  objectives: QoSObjective[];\n  violations: QoSViolationPolicy;\n}\n\nexport interface QoSGuarantee {\n  metric: string;\n  threshold: number;\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n  priority: ResourcePriority;\n  penalty?: number;\n}\n\nexport interface QoSObjective {\n  metric: string;\n  target: number;\n  weight: number;\n  tolerance: number;\n}\n\nexport interface QoSViolation {\n  timestamp: Date;\n  metric: string;\n  expected: number;\n  actual: number;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  duration: number;\n  resolved: boolean;\n}\n\nexport interface QoSViolationPolicy {\n  autoRemediation: boolean;\n  escalationThreshold: number;\n  penaltyFunction: string;\n  notificationEnabled: boolean;\n}\n\nexport interface ScalingConfig {\n  enabled: boolean;\n  minResources: number;\n  maxResources: number;\n  scaleUpThreshold: number;\n  scaleDownThreshold: number;\n  cooldownPeriod: number;\n  metrics: ScalingMetric[];\n}\n\nexport interface ScalingMetric {\n  name: string;\n  weight: number;\n  threshold: number;\n  aggregation: 'avg' | 'max' | 'min' | 'sum';\n}\n\nexport interface PoolStatistics {\n  totalResources: number;\n  availableResources: number;\n  utilizationRate: number;\n  allocationSuccessRate: number;\n  averageWaitTime: number;\n  throughput: number;\n  efficiency: number;\n  costPerHour: number;\n  qosScore: number;\n}\n\nexport interface NodeAffinity {\n  key: string;\n  operator: 'in' | 'notin' | 'exists' | 'notexists';\n  values?: string[];\n}\n\nexport interface AntiAffinity {\n  type: 'agent' | 'task' | 'resource';\n  scope: 'node' | 'zone' | 'region';\n  weight: number;\n}\n\nexport interface TimeWindow {\n  start: Date;\n  end: Date;\n  timezone?: string;\n}\n\nexport interface ResourceFilter {\n  id: string;\n  name: string;\n  enabled: boolean;\n  conditions: FilterCondition[];\n  action: 'include' | 'exclude' | 'prioritize' | 'deprioritize';\n}\n\nexport interface FilterCondition {\n  field: string;\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches';\n  value: any;\n}\n\nexport type ResourceType = 'compute' | 'storage' | 'network' | 'memory' | 'gpu' | 'custom';\nexport type ResourceStatus =\n  | 'available'\n  | 'allocated'\n  | 'reserved'\n  | 'maintenance'\n  | 'failed'\n  | 'offline';\nexport type ResourcePriority = 'critical' | 'high' | 'normal' | 'low' | 'background';\nexport type ReservationStatus =\n  | 'pending'\n  | 'confirmed'\n  | 'active'\n  | 'expired'\n  | 'cancelled'\n  | 'failed';\nexport type AllocationStatus = 'active' | 'completed' | 'failed' | 'terminated' | 'suspended';\nexport type PoolStrategy = 'round-robin' | 'least-loaded' | 'performance-based' | 'cost-optimized';\nexport type LoadBalancingStrategy =\n  | 'round-robin'\n  | 'weighted'\n  | 'least-connections'\n  | 'resource-based';\nexport type BillingModel = 'hourly' | 'per-usage' | 'reserved' | 'spot' | 'hybrid';\n\n/**\n * Comprehensive resource management with allocation, monitoring, and optimization\n */\nexport class ResourceManager extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: ResourceManagerConfig;\n\n  // Resource tracking\n  private resources = new Map<string, Resource>();\n  private pools = new Map<string, ResourcePool>();\n  private reservations = new Map<string, ResourceReservation>();\n  private allocations = new Map<string, ResourceAllocation>();\n\n  // Monitoring and optimization\n  private usageHistory = new Map<string, ResourceUsage[]>();\n  private predictions = new Map<string, ResourcePrediction>();\n  private optimizer: ResourceOptimizer;\n\n  // Scheduling and cleanup\n  private monitoringInterval?: NodeJS.Timeout;\n  private cleanupInterval?: NodeJS.Timeout;\n  private scalingInterval?: NodeJS.Timeout;\n\n  // Performance tracking\n  private metrics: ResourceManagerMetrics;\n\n  constructor(config: Partial<ResourceManagerConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      enableResourcePooling: true,\n      enableResourceMonitoring: true,\n      enableAutoScaling: true,\n      enableQoS: true,\n      monitoringInterval: 30000,\n      cleanupInterval: 300000,\n      defaultLimits: {\n        cpu: 4.0,\n        memory: 8 * 1024 * 1024 * 1024, // 8GB\n        disk: 100 * 1024 * 1024 * 1024, // 100GB\n        network: 1024 * 1024 * 1024, // 1Gbps\n        custom: {},\n      },\n      reservationTimeout: 300000, // 5 minutes\n      allocationStrategy: 'best-fit',\n      priorityWeights: {\n        critical: 1.0,\n        high: 0.8,\n        normal: 0.6,\n        low: 0.4,\n        background: 0.2,\n      },\n      enablePredictiveAllocation: true,\n      enableResourceSharing: true,\n      debugMode: false,\n      ...config,\n    };\n\n    this.optimizer = new ResourceOptimizer(this.config, this.logger);\n    this.metrics = new ResourceManagerMetrics();\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('agent:resource-request', (data) => {\n      this.handleResourceRequest(data);\n    });\n\n    this.eventBus.on('agent:resource-release', (data) => {\n      this.handleResourceRelease(data);\n    });\n\n    this.eventBus.on('resource:usage-update', (data) => {\n      this.updateResourceUsage(data.resourceId, data.usage);\n    });\n\n    this.eventBus.on('resource:failure', (data) => {\n      this.handleResourceFailure(data);\n    });\n\n    this.eventBus.on('scaling:trigger', (data) => {\n      this.handleScalingTrigger(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing resource manager', {\n      pooling: this.config.enableResourcePooling,\n      monitoring: this.config.enableResourceMonitoring,\n      autoScaling: this.config.enableAutoScaling,\n    });\n\n    // Initialize optimizer\n    await this.optimizer.initialize();\n\n    // Create default resource pools\n    await this.createDefaultPools();\n\n    // Start monitoring\n    if (this.config.enableResourceMonitoring) {\n      this.startMonitoring();\n    }\n\n    // Start cleanup\n    this.startCleanup();\n\n    // Start auto-scaling\n    if (this.config.enableAutoScaling) {\n      this.startAutoScaling();\n    }\n\n    this.emit('resource-manager:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down resource manager');\n\n    // Stop intervals\n    if (this.monitoringInterval) clearInterval(this.monitoringInterval);\n    if (this.cleanupInterval) clearInterval(this.cleanupInterval);\n    if (this.scalingInterval) clearInterval(this.scalingInterval);\n\n    // Release all active allocations\n    await this.releaseAllAllocations();\n\n    // Shutdown optimizer\n    await this.optimizer.shutdown();\n\n    this.emit('resource-manager:shutdown');\n  }\n\n  // === RESOURCE MANAGEMENT ===\n\n  async registerResource(\n    type: ResourceType,\n    name: string,\n    capacity: ResourceLimits,\n    metadata: Partial<ResourceMetadata> = {},\n  ): Promise<string> {\n    const resourceId = generateId('resource');\n\n    const resource: Resource = {\n      id: resourceId,\n      type,\n      name,\n      description: `${type} resource: ${name}`,\n      capacity,\n      allocated: this.createEmptyLimits(),\n      available: { ...capacity },\n      status: 'available',\n      metadata: {\n        provider: 'local',\n        capabilities: [],\n        performance: this.createDefaultPerformanceMetrics(),\n        reliability: this.createDefaultReliabilityMetrics(),\n        cost: this.createDefaultCostMetrics(),\n        lastUpdated: new Date(),\n        ...metadata,\n      },\n      reservations: [],\n      allocations: [],\n      sharable: this.config.enableResourceSharing,\n      persistent: true,\n      cost: 1.0,\n      tags: [],\n    };\n\n    this.resources.set(resourceId, resource);\n\n    this.logger.info('Resource registered', {\n      resourceId,\n      type,\n      name,\n      capacity,\n    });\n\n    this.emit('resource:registered', { resource });\n\n    return resourceId;\n  }\n\n  async unregisterResource(resourceId: string): Promise<void> {\n    const resource = this.resources.get(resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${resourceId} not found`);\n    }\n\n    // Check for active allocations\n    if (resource.allocations.length > 0) {\n      throw new Error(`Cannot unregister resource ${resourceId}: has active allocations`);\n    }\n\n    // Cancel pending reservations\n    for (const reservation of resource.reservations) {\n      await this.cancelReservation(reservation.id, 'resource_unregistered');\n    }\n\n    this.resources.delete(resourceId);\n\n    this.logger.info('Resource unregistered', { resourceId });\n    this.emit('resource:unregistered', { resourceId });\n  }\n\n  // === RESOURCE ALLOCATION ===\n\n  async requestResources(\n    agentId: AgentId,\n    requirements: ResourceRequirements,\n    options: {\n      taskId?: TaskId;\n      priority?: ResourcePriority;\n      timeout?: number;\n      preemptible?: boolean;\n    } = {},\n  ): Promise<string> {\n    const reservationId = generateId('reservation');\n    const now = new Date();\n\n    const reservation: ResourceReservation = {\n      id: reservationId,\n      resourceId: '', // Will be set when resource is found\n      agentId,\n      taskId: options.taskId,\n      requirements,\n      status: 'pending',\n      priority: options.priority || 'normal',\n      createdAt: now,\n      expiresAt: options.timeout\n        ? new Date(now.getTime() + options.timeout)\n        : new Date(now.getTime() + this.config.reservationTimeout),\n      metadata: {\n        preemptible: options.preemptible || false,\n      },\n    };\n\n    this.reservations.set(reservationId, reservation);\n\n    try {\n      // Find suitable resource\n      const resource = await this.findSuitableResource(requirements, reservation.priority);\n\n      if (!resource) {\n        reservation.status = 'failed';\n        throw new Error('No suitable resource available');\n      }\n\n      // Reserve resource\n      reservation.resourceId = resource.id;\n      resource.reservations.push(reservation);\n\n      // Update availability\n      this.updateResourceAvailability(resource);\n\n      reservation.status = 'confirmed';\n\n      this.logger.info('Resource reservation created', {\n        reservationId,\n        resourceId: resource.id,\n        agentId: agentId.id,\n        requirements,\n      });\n\n      this.emit('reservation:created', { reservation });\n\n      // Auto-activate if possible\n      if (this.canActivateReservation(reservation)) {\n        await this.activateReservation(reservationId);\n      }\n\n      return reservationId;\n    } catch (error) {\n      reservation.status = 'failed';\n      this.logger.error('Resource reservation failed', {\n        reservationId,\n        agentId: agentId.id,\n        error,\n      });\n      throw error;\n    }\n  }\n\n  async activateReservation(reservationId: string): Promise<string> {\n    const reservation = this.reservations.get(reservationId);\n    if (!reservation) {\n      throw new Error(`Reservation ${reservationId} not found`);\n    }\n\n    if (reservation.status !== 'confirmed') {\n      throw new Error(`Reservation ${reservationId} is not confirmed`);\n    }\n\n    const resource = this.resources.get(reservation.resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${reservation.resourceId} not found`);\n    }\n\n    // Create allocation\n    const allocationId = generateId('allocation');\n\n    const allocation: ResourceAllocation = {\n      id: allocationId,\n      reservationId,\n      resourceId: resource.id,\n      agentId: reservation.agentId,\n      taskId: reservation.taskId,\n      allocated: this.calculateAllocation(reservation.requirements, resource),\n      actualUsage: this.createEmptyUsage(),\n      efficiency: 1.0,\n      startTime: new Date(),\n      status: 'active',\n      qosViolations: [],\n    };\n\n    this.allocations.set(allocationId, allocation);\n    resource.allocations.push(allocation);\n\n    // Update resource allocated amounts\n    this.addToResourceLimits(resource.allocated, allocation.allocated);\n    this.updateResourceAvailability(resource);\n\n    // Update reservation status\n    reservation.status = 'active';\n    reservation.activatedAt = new Date();\n\n    this.logger.info('Resource allocation activated', {\n      allocationId,\n      reservationId,\n      resourceId: resource.id,\n      agentId: reservation.agentId.id,\n      allocated: allocation.allocated,\n    });\n\n    this.emit('allocation:activated', { allocation });\n\n    return allocationId;\n  }\n\n  async releaseResources(allocationId: string, reason: string = 'completed'): Promise<void> {\n    const allocation = this.allocations.get(allocationId);\n    if (!allocation) {\n      throw new Error(`Allocation ${allocationId} not found`);\n    }\n\n    const resource = this.resources.get(allocation.resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${allocation.resourceId} not found`);\n    }\n\n    // Update allocation status\n    allocation.status = 'completed';\n    allocation.endTime = new Date();\n\n    // Calculate final efficiency\n    allocation.efficiency = this.calculateEfficiency(allocation);\n\n    // Remove from resource allocated amounts\n    this.subtractFromResourceLimits(resource.allocated, allocation.allocated);\n\n    // Remove allocation from resource\n    resource.allocations = resource.allocations.filter((a) => a.id !== allocationId);\n\n    // Update resource availability\n    this.updateResourceAvailability(resource);\n\n    // Update reservation if exists\n    const reservation = this.reservations.get(allocation.reservationId);\n    if (reservation) {\n      reservation.releasedAt = new Date();\n    }\n\n    this.logger.info('Resource allocation released', {\n      allocationId,\n      resourceId: resource.id,\n      agentId: allocation.agentId.id,\n      reason,\n      efficiency: allocation.efficiency,\n    });\n\n    this.emit('allocation:released', { allocation, reason });\n\n    // Update metrics\n    this.metrics.recordAllocationReleased(allocation);\n  }\n\n  async cancelReservation(reservationId: string, reason: string = 'cancelled'): Promise<void> {\n    const reservation = this.reservations.get(reservationId);\n    if (!reservation) {\n      throw new Error(`Reservation ${reservationId} not found`);\n    }\n\n    // If reservation is active, release the allocation first\n    if (reservation.status === 'active') {\n      const allocation = Array.from(this.allocations.values()).find(\n        (a) => a.reservationId === reservationId,\n      );\n\n      if (allocation) {\n        await this.releaseResources(allocation.id, reason);\n      }\n    }\n\n    // Update reservation status\n    reservation.status = 'cancelled';\n\n    // Remove from resource if it was reserved\n    if (reservation.resourceId) {\n      const resource = this.resources.get(reservation.resourceId);\n      if (resource) {\n        resource.reservations = resource.reservations.filter((r) => r.id !== reservationId);\n        this.updateResourceAvailability(resource);\n      }\n    }\n\n    this.logger.info('Resource reservation cancelled', {\n      reservationId,\n      reason,\n    });\n\n    this.emit('reservation:cancelled', { reservation, reason });\n  }\n\n  // === RESOURCE POOLS ===\n\n  async createResourcePool(\n    name: string,\n    type: ResourceType,\n    resourceIds: string[],\n    strategy: PoolStrategy = 'least-loaded',\n  ): Promise<string> {\n    const poolId = generateId('pool');\n\n    // Validate resources exist and are of correct type\n    for (const resourceId of resourceIds) {\n      const resource = this.resources.get(resourceId);\n      if (!resource) {\n        throw new Error(`Resource ${resourceId} not found`);\n      }\n      if (resource.type !== type) {\n        throw new Error(\n          `Resource ${resourceId} type mismatch: expected ${type}, got ${resource.type}`,\n        );\n      }\n    }\n\n    const pool: ResourcePool = {\n      id: poolId,\n      name,\n      type,\n      resources: [...resourceIds],\n      strategy,\n      loadBalancing: 'least-connections',\n      scaling: {\n        enabled: this.config.enableAutoScaling,\n        minResources: Math.max(1, resourceIds.length),\n        maxResources: resourceIds.length * 3,\n        scaleUpThreshold: 0.8,\n        scaleDownThreshold: 0.3,\n        cooldownPeriod: 300000,\n        metrics: [\n          { name: 'utilization', weight: 1.0, threshold: 0.8, aggregation: 'avg' },\n          { name: 'queue_depth', weight: 0.5, threshold: 10, aggregation: 'max' },\n        ],\n      },\n      qos: {\n        guarantees: [],\n        objectives: [],\n        violations: {\n          autoRemediation: true,\n          escalationThreshold: 3,\n          penaltyFunction: 'linear',\n          notificationEnabled: true,\n        },\n      },\n      statistics: this.createPoolStatistics(),\n      filters: [],\n    };\n\n    this.pools.set(poolId, pool);\n\n    this.logger.info('Resource pool created', {\n      poolId,\n      name,\n      type,\n      resourceCount: resourceIds.length,\n    });\n\n    this.emit('pool:created', { pool });\n\n    return poolId;\n  }\n\n  async addResourceToPool(poolId: string, resourceId: string): Promise<void> {\n    const pool = this.pools.get(poolId);\n    if (!pool) {\n      throw new Error(`Pool ${poolId} not found`);\n    }\n\n    const resource = this.resources.get(resourceId);\n    if (!resource) {\n      throw new Error(`Resource ${resourceId} not found`);\n    }\n\n    if (resource.type !== pool.type) {\n      throw new Error(\n        `Resource type mismatch: pool expects ${pool.type}, resource is ${resource.type}`,\n      );\n    }\n\n    if (!pool.resources.includes(resourceId)) {\n      pool.resources.push(resourceId);\n      this.updatePoolStatistics(pool);\n    }\n\n    this.logger.info('Resource added to pool', { poolId, resourceId });\n    this.emit('pool:resource-added', { poolId, resourceId });\n  }\n\n  async removeResourceFromPool(poolId: string, resourceId: string): Promise<void> {\n    const pool = this.pools.get(poolId);\n    if (!pool) {\n      throw new Error(`Pool ${poolId} not found`);\n    }\n\n    if (pool.resources.length <= pool.scaling.minResources) {\n      throw new Error(`Cannot remove resource: pool would go below minimum size`);\n    }\n\n    pool.resources = pool.resources.filter((id) => id !== resourceId);\n    this.updatePoolStatistics(pool);\n\n    this.logger.info('Resource removed from pool', { poolId, resourceId });\n    this.emit('pool:resource-removed', { poolId, resourceId });\n  }\n\n  // === RESOURCE DISCOVERY AND ALLOCATION ===\n\n  private async findSuitableResource(\n    requirements: ResourceRequirements,\n    priority: ResourcePriority,\n  ): Promise<Resource | null> {\n    const candidates: Array<{ resource: Resource; score: number }> = [];\n\n    for (const resource of this.resources.values()) {\n      if (resource.status !== 'available') continue;\n\n      const score = this.calculateResourceScore(resource, requirements, priority);\n      if (score > 0) {\n        candidates.push({ resource, score });\n      }\n    }\n\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    // Sort by score (highest first)\n    candidates.sort((a, b) => b.score - a.score);\n\n    // Apply allocation strategy\n    return this.selectResourceByStrategy(candidates, requirements);\n  }\n\n  private calculateResourceScore(\n    resource: Resource,\n    requirements: ResourceRequirements,\n    priority: ResourcePriority,\n  ): number {\n    let score = 0;\n\n    // Check if resource can satisfy requirements\n    if (!this.canSatisfyRequirements(resource, requirements)) {\n      return 0;\n    }\n\n    // Base score from resource utilization (prefer less utilized)\n    const utilization = this.calculateResourceUtilization(resource);\n    score += (1 - utilization) * 100;\n\n    // Performance score\n    score += resource.metadata.performance.cpuScore * 10;\n\n    // Reliability score\n    score += resource.metadata.reliability.uptime * 50;\n\n    // Cost efficiency (lower cost is better)\n    score += (1 / resource.cost) * 20;\n\n    // Priority adjustment\n    const priorityWeight = this.config.priorityWeights[priority] || 1.0;\n    score *= priorityWeight;\n\n    return score;\n  }\n\n  private canSatisfyRequirements(resource: Resource, requirements: ResourceRequirements): boolean {\n    // Check CPU\n    if (requirements.cpu && requirements.cpu.min > resource.available.cpu) {\n      return false;\n    }\n\n    // Check memory\n    if (requirements.memory && requirements.memory.min > resource.available.memory) {\n      return false;\n    }\n\n    // Check disk\n    if (requirements.disk && requirements.disk.min > resource.available.disk) {\n      return false;\n    }\n\n    // Check network\n    if (requirements.network && requirements.network.min > resource.available.network) {\n      return false;\n    }\n\n    // Check custom resources\n    if (requirements.custom) {\n      for (const [name, spec] of Object.entries(requirements.custom)) {\n        const available = resource.available.custom[name] || 0;\n        if (spec.min > available) {\n          return false;\n        }\n      }\n    }\n\n    // Check constraints\n    if (requirements.constraints) {\n      if (!this.checkConstraints(resource, requirements.constraints)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private checkConstraints(resource: Resource, constraints: ResourceConstraints): boolean {\n    // Location constraints\n    if (constraints.location && constraints.location.length > 0) {\n      if (!constraints.location.includes(resource.location || '')) {\n        return false;\n      }\n    }\n\n    if (constraints.excludeLocation && constraints.excludeLocation.length > 0) {\n      if (constraints.excludeLocation.includes(resource.location || '')) {\n        return false;\n      }\n    }\n\n    // Cost constraints\n    if (constraints.maxCost && resource.cost > constraints.maxCost) {\n      return false;\n    }\n\n    // Time window constraints\n    if (constraints.timeWindow) {\n      const now = new Date();\n      if (now < constraints.timeWindow.start || now > constraints.timeWindow.end) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private selectResourceByStrategy(\n    candidates: Array<{ resource: Resource; score: number }>,\n    requirements: ResourceRequirements,\n  ): Resource {\n    switch (this.config.allocationStrategy) {\n      case 'first-fit':\n        return candidates[0].resource;\n\n      case 'best-fit':\n        // Find resource with smallest waste\n        return candidates.reduce((best, current) => {\n          const bestWaste = this.calculateWaste(best.resource, requirements);\n          const currentWaste = this.calculateWaste(current.resource, requirements);\n          return currentWaste < bestWaste ? current : best;\n        }).resource;\n\n      case 'worst-fit':\n        // Find resource with largest waste (for fragmentation avoidance)\n        return candidates.reduce((worst, current) => {\n          const worstWaste = this.calculateWaste(worst.resource, requirements);\n          const currentWaste = this.calculateWaste(current.resource, requirements);\n          return currentWaste > worstWaste ? current : worst;\n        }).resource;\n\n      case 'balanced':\n      default:\n        // Use highest score (balanced approach)\n        return candidates[0].resource;\n    }\n  }\n\n  private calculateWaste(resource: Resource, requirements: ResourceRequirements): number {\n    let waste = 0;\n\n    if (requirements.cpu) {\n      waste += Math.max(0, resource.available.cpu - requirements.cpu.min);\n    }\n\n    if (requirements.memory) {\n      waste += Math.max(0, resource.available.memory - requirements.memory.min);\n    }\n\n    return waste;\n  }\n\n  private calculateAllocation(\n    requirements: ResourceRequirements,\n    resource: Resource,\n  ): ResourceLimits {\n    const allocation: ResourceLimits = {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      custom: {},\n    };\n\n    if (requirements.cpu) {\n      allocation.cpu = Math.min(\n        requirements.cpu.preferred || requirements.cpu.min,\n        resource.available.cpu,\n      );\n    }\n\n    if (requirements.memory) {\n      allocation.memory = Math.min(\n        requirements.memory.preferred || requirements.memory.min,\n        resource.available.memory,\n      );\n    }\n\n    if (requirements.disk) {\n      allocation.disk = Math.min(\n        requirements.disk.preferred || requirements.disk.min,\n        resource.available.disk,\n      );\n    }\n\n    if (requirements.network) {\n      allocation.network = Math.min(\n        requirements.network.preferred || requirements.network.min,\n        resource.available.network,\n      );\n    }\n\n    if (requirements.custom) {\n      for (const [name, spec] of Object.entries(requirements.custom)) {\n        const available = resource.available.custom[name] || 0;\n        allocation.custom[name] = Math.min(spec.preferred || spec.min, available);\n      }\n    }\n\n    return allocation;\n  }\n\n  // === MONITORING AND OPTIMIZATION ===\n\n  private startMonitoring(): void {\n    this.monitoringInterval = setInterval(() => {\n      this.performMonitoring();\n    }, this.config.monitoringInterval);\n\n    this.logger.info('Started resource monitoring', {\n      interval: this.config.monitoringInterval,\n    });\n  }\n\n  private startCleanup(): void {\n    this.cleanupInterval = setInterval(() => {\n      this.performCleanup();\n    }, this.config.cleanupInterval);\n\n    this.logger.info('Started resource cleanup', {\n      interval: this.config.cleanupInterval,\n    });\n  }\n\n  private startAutoScaling(): void {\n    this.scalingInterval = setInterval(() => {\n      this.evaluateScaling();\n    }, 60000); // Every minute\n\n    this.logger.info('Started auto-scaling');\n  }\n\n  private async performMonitoring(): Promise<void> {\n    try {\n      // Update resource statistics\n      for (const resource of this.resources.values()) {\n        await this.updateResourceStatistics(resource);\n      }\n\n      // Update pool statistics\n      for (const pool of this.pools.values()) {\n        this.updatePoolStatistics(pool);\n      }\n\n      // Check QoS violations\n      if (this.config.enableQoS) {\n        await this.checkQoSViolations();\n      }\n\n      // Predictive analysis\n      if (this.config.enablePredictiveAllocation) {\n        await this.updatePredictions();\n      }\n\n      // Emit monitoring update\n      this.emit('monitoring:updated', {\n        resources: this.resources.size,\n        pools: this.pools.size,\n        allocations: this.allocations.size,\n      });\n    } catch (error) {\n      this.logger.error('Monitoring failed', error);\n    }\n  }\n\n  private async performCleanup(): Promise<void> {\n    const now = new Date();\n\n    // Clean up expired reservations\n    const expiredReservations = Array.from(this.reservations.values()).filter(\n      (r) => r.expiresAt && r.expiresAt < now && r.status === 'pending',\n    );\n\n    for (const reservation of expiredReservations) {\n      await this.cancelReservation(reservation.id, 'expired');\n    }\n\n    // Clean up old usage history\n    const cutoff = new Date(now.getTime() - 86400000); // 24 hours\n    for (const [resourceId, history] of this.usageHistory) {\n      this.usageHistory.set(\n        resourceId,\n        history.filter((usage) => usage.timestamp > cutoff),\n      );\n    }\n\n    this.logger.debug('Cleanup completed', {\n      expiredReservations: expiredReservations.length,\n    });\n  }\n\n  private async evaluateScaling(): Promise<void> {\n    for (const pool of this.pools.values()) {\n      if (!pool.scaling.enabled) continue;\n\n      const metrics = this.calculatePoolMetrics(pool);\n      const shouldScale = this.shouldScale(pool, metrics);\n\n      if (shouldScale.action === 'scale-up') {\n        await this.scalePoolUp(pool);\n      } else if (shouldScale.action === 'scale-down') {\n        await this.scalePoolDown(pool);\n      }\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private canActivateReservation(reservation: ResourceReservation): boolean {\n    const resource = this.resources.get(reservation.resourceId);\n    if (!resource) return false;\n\n    return this.canSatisfyRequirements(resource, reservation.requirements);\n  }\n\n  private calculateResourceUtilization(resource: Resource): number {\n    let totalCapacity = 0;\n    let totalAllocated = 0;\n\n    // CPU utilization\n    totalCapacity += resource.capacity.cpu;\n    totalAllocated += resource.allocated.cpu;\n\n    // Memory utilization\n    totalCapacity += resource.capacity.memory / (1024 * 1024); // Convert to MB for comparison\n    totalAllocated += resource.allocated.memory / (1024 * 1024);\n\n    return totalCapacity > 0 ? totalAllocated / totalCapacity : 0;\n  }\n\n  private calculateEfficiency(allocation: ResourceAllocation): number {\n    if (!allocation.endTime) return 0;\n\n    const duration = allocation.endTime.getTime() - allocation.startTime.getTime();\n    if (duration <= 0) return 0;\n\n    // Calculate efficiency based on actual usage vs allocated\n    let efficiencySum = 0;\n    let factors = 0;\n\n    if (allocation.allocated.cpu > 0) {\n      efficiencySum += allocation.actualUsage.cpu / allocation.allocated.cpu;\n      factors++;\n    }\n\n    if (allocation.allocated.memory > 0) {\n      efficiencySum += allocation.actualUsage.memory / allocation.allocated.memory;\n      factors++;\n    }\n\n    return factors > 0 ? efficiencySum / factors : 1.0;\n  }\n\n  private updateResourceAvailability(resource: Resource): void {\n    resource.available = {\n      cpu: Math.max(0, resource.capacity.cpu - resource.allocated.cpu),\n      memory: Math.max(0, resource.capacity.memory - resource.allocated.memory),\n      disk: Math.max(0, resource.capacity.disk - resource.allocated.disk),\n      network: Math.max(0, resource.capacity.network - resource.allocated.network),\n      custom: {},\n    };\n\n    // Update custom resources\n    for (const [name, capacity] of Object.entries(resource.capacity.custom)) {\n      const allocated = resource.allocated.custom[name] || 0;\n      resource.available.custom[name] = Math.max(0, capacity - allocated);\n    }\n  }\n\n  private addToResourceLimits(target: ResourceLimits, source: ResourceLimits): void {\n    target.cpu += source.cpu;\n    target.memory += source.memory;\n    target.disk += source.disk;\n    target.network += source.network;\n\n    for (const [name, value] of Object.entries(source.custom)) {\n      target.custom[name] = (target.custom[name] || 0) + value;\n    }\n  }\n\n  private subtractFromResourceLimits(target: ResourceLimits, source: ResourceLimits): void {\n    target.cpu = Math.max(0, target.cpu - source.cpu);\n    target.memory = Math.max(0, target.memory - source.memory);\n    target.disk = Math.max(0, target.disk - source.disk);\n    target.network = Math.max(0, target.network - source.network);\n\n    for (const [name, value] of Object.entries(source.custom)) {\n      target.custom[name] = Math.max(0, (target.custom[name] || 0) - value);\n    }\n  }\n\n  private createEmptyLimits(): ResourceLimits {\n    return {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      custom: {},\n    };\n  }\n\n  private createEmptyUsage(): ResourceUsage {\n    return {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      custom: {},\n      timestamp: new Date(),\n      duration: 0,\n    };\n  }\n\n  private createDefaultPerformanceMetrics(): PerformanceMetrics {\n    return {\n      cpuScore: 1.0,\n      memoryBandwidth: 1000000000, // 1GB/s\n      diskIOPS: 1000,\n      networkBandwidth: 1000000000, // 1Gbps\n      benchmarkResults: {},\n    };\n  }\n\n  private createDefaultReliabilityMetrics(): ReliabilityMetrics {\n    return {\n      uptime: 0.99,\n      meanTimeBetweenFailures: 8760, // 1 year in hours\n      errorRate: 0.01,\n      failureHistory: [],\n    };\n  }\n\n  private createDefaultCostMetrics(): CostMetrics {\n    return {\n      hourlyRate: 1.0,\n      dataTransferCost: 0.1,\n      storageCost: 0.1,\n      billing: 'hourly',\n    };\n  }\n\n  private createPoolStatistics(): PoolStatistics {\n    return {\n      totalResources: 0,\n      availableResources: 0,\n      utilizationRate: 0,\n      allocationSuccessRate: 100,\n      averageWaitTime: 0,\n      throughput: 0,\n      efficiency: 1.0,\n      costPerHour: 0,\n      qosScore: 100,\n    };\n  }\n\n  private async createDefaultPools(): Promise<void> {\n    // Create default compute pool if we have compute resources\n    const computeResources = Array.from(this.resources.values())\n      .filter((r) => r.type === 'compute')\n      .map((r) => r.id);\n\n    if (computeResources.length > 0) {\n      await this.createResourcePool('default-compute', 'compute', computeResources);\n    }\n  }\n\n  private updateResourceUsage(resourceId: string, usage: ResourceUsage): void {\n    const resource = this.resources.get(resourceId);\n    if (!resource) return;\n\n    // Store usage history\n    const history = this.usageHistory.get(resourceId) || [];\n    history.push(usage);\n\n    // Keep only last 1000 entries\n    if (history.length > 1000) {\n      history.shift();\n    }\n\n    this.usageHistory.set(resourceId, history);\n\n    // Update active allocations with actual usage\n    for (const allocation of resource.allocations) {\n      if (allocation.status === 'active') {\n        allocation.actualUsage = usage;\n        allocation.efficiency = this.calculateEfficiency(allocation);\n      }\n    }\n  }\n\n  private async updateResourceStatistics(resource: Resource): Promise<void> {\n    // Update utilization\n    const utilization = this.calculateResourceUtilization(resource);\n\n    // Update performance metrics based on usage history\n    const history = this.usageHistory.get(resource.id) || [];\n    if (history.length > 0) {\n      const recent = history.slice(-10); // Last 10 measurements\n      const avgCpu = recent.reduce((sum, h) => sum + h.cpu, 0) / recent.length;\n\n      // Update performance score based on load\n      resource.metadata.performance.cpuScore = Math.max(0.1, 1.0 - avgCpu / 100);\n    }\n\n    resource.metadata.lastUpdated = new Date();\n  }\n\n  private updatePoolStatistics(pool: ResourcePool): void {\n    const resources = pool.resources\n      .map((id) => this.resources.get(id))\n      .filter(Boolean) as Resource[];\n\n    pool.statistics.totalResources = resources.length;\n    pool.statistics.availableResources = resources.filter((r) => r.status === 'available').length;\n\n    if (resources.length > 0) {\n      const totalUtilization = resources.reduce(\n        (sum, r) => sum + this.calculateResourceUtilization(r),\n        0,\n      );\n      pool.statistics.utilizationRate = totalUtilization / resources.length;\n\n      const totalCost = resources.reduce((sum, r) => sum + r.cost, 0);\n      pool.statistics.costPerHour = totalCost;\n    }\n  }\n\n  private async checkQoSViolations(): Promise<void> {\n    // Check QoS for all active allocations\n    for (const allocation of this.allocations.values()) {\n      if (allocation.status !== 'active') continue;\n\n      const resource = this.resources.get(allocation.resourceId);\n      if (!resource) continue;\n\n      // Find applicable pools\n      const pools = Array.from(this.pools.values()).filter((p) =>\n        p.resources.includes(resource.id),\n      );\n\n      for (const pool of pools) {\n        await this.checkPoolQoS(pool, allocation);\n      }\n    }\n  }\n\n  private async checkPoolQoS(pool: ResourcePool, allocation: ResourceAllocation): Promise<void> {\n    for (const guarantee of pool.qos.guarantees) {\n      const value = this.getMetricValue(allocation, guarantee.metric);\n      const violated = this.evaluateQoSCondition(value, guarantee.operator, guarantee.threshold);\n\n      if (violated) {\n        const violation: QoSViolation = {\n          timestamp: new Date(),\n          metric: guarantee.metric,\n          expected: guarantee.threshold,\n          actual: value,\n          severity: this.calculateViolationSeverity(guarantee, value),\n          duration: 0, // Will be calculated over time\n          resolved: false,\n        };\n\n        allocation.qosViolations.push(violation);\n\n        this.logger.warn('QoS violation detected', {\n          allocationId: allocation.id,\n          metric: guarantee.metric,\n          expected: guarantee.threshold,\n          actual: value,\n        });\n\n        this.emit('qos:violation', { allocation, violation });\n\n        // Auto-remediation if enabled\n        if (pool.qos.violations.autoRemediation) {\n          await this.remediateQoSViolation(allocation, violation);\n        }\n      }\n    }\n  }\n\n  private async updatePredictions(): Promise<void> {\n    for (const resource of this.resources.values()) {\n      const history = this.usageHistory.get(resource.id) || [];\n      if (history.length < 10) continue; // Need minimum history\n\n      const prediction = await this.optimizer.predictUsage(resource, history);\n      this.predictions.set(resource.id, prediction);\n    }\n  }\n\n  private calculatePoolMetrics(pool: ResourcePool): Record<string, number> {\n    const resources = pool.resources\n      .map((id) => this.resources.get(id))\n      .filter(Boolean) as Resource[];\n    const metrics: Record<string, number> = {};\n\n    if (resources.length === 0) return metrics;\n\n    // Calculate utilization\n    const totalUtilization = resources.reduce(\n      (sum, r) => sum + this.calculateResourceUtilization(r),\n      0,\n    );\n    metrics.utilization = totalUtilization / resources.length;\n\n    // Calculate queue depth (simplified)\n    const totalReservations = resources.reduce((sum, r) => sum + r.reservations.length, 0);\n    metrics.queue_depth = totalReservations;\n\n    return metrics;\n  }\n\n  private shouldScale(\n    pool: ResourcePool,\n    metrics: Record<string, number>,\n  ): { action: 'scale-up' | 'scale-down' | 'none'; reason: string } {\n    const scaling = pool.scaling;\n\n    // Check scale-up conditions\n    for (const metric of scaling.metrics) {\n      const value = metrics[metric.name] || 0;\n\n      if (metric.aggregation === 'avg' && value > metric.threshold) {\n        if (pool.resources.length < scaling.maxResources) {\n          return { action: 'scale-up', reason: `${metric.name} threshold exceeded` };\n        }\n      }\n    }\n\n    // Check scale-down conditions\n    for (const metric of scaling.metrics) {\n      const value = metrics[metric.name] || 0;\n\n      if (metric.aggregation === 'avg' && value < scaling.scaleDownThreshold) {\n        if (pool.resources.length > scaling.minResources) {\n          return { action: 'scale-down', reason: `${metric.name} below threshold` };\n        }\n      }\n    }\n\n    return { action: 'none', reason: 'No scaling needed' };\n  }\n\n  private async scalePoolUp(pool: ResourcePool): Promise<void> {\n    this.logger.info('Scaling pool up', { poolId: pool.id });\n    // Implementation would add new resources to the pool\n    this.emit('pool:scaled-up', { pool });\n  }\n\n  private async scalePoolDown(pool: ResourcePool): Promise<void> {\n    this.logger.info('Scaling pool down', { poolId: pool.id });\n    // Implementation would remove underutilized resources from the pool\n    this.emit('pool:scaled-down', { pool });\n  }\n\n  private getMetricValue(allocation: ResourceAllocation, metric: string): number {\n    switch (metric) {\n      case 'cpu':\n        return allocation.actualUsage.cpu;\n      case 'memory':\n        return allocation.actualUsage.memory;\n      case 'efficiency':\n        return allocation.efficiency;\n      default:\n        return 0;\n    }\n  }\n\n  private evaluateQoSCondition(value: number, operator: string, threshold: number): boolean {\n    switch (operator) {\n      case 'gt':\n        return value > threshold;\n      case 'lt':\n        return value < threshold;\n      case 'eq':\n        return value === threshold;\n      case 'gte':\n        return value >= threshold;\n      case 'lte':\n        return value <= threshold;\n      default:\n        return false;\n    }\n  }\n\n  private calculateViolationSeverity(\n    guarantee: QoSGuarantee,\n    actualValue: number,\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    const deviation = Math.abs(actualValue - guarantee.threshold) / guarantee.threshold;\n\n    if (deviation > 0.5) return 'critical';\n    if (deviation > 0.3) return 'high';\n    if (deviation > 0.1) return 'medium';\n    return 'low';\n  }\n\n  private async remediateQoSViolation(\n    allocation: ResourceAllocation,\n    violation: QoSViolation,\n  ): Promise<void> {\n    this.logger.info('Attempting QoS violation remediation', {\n      allocationId: allocation.id,\n      metric: violation.metric,\n      severity: violation.severity,\n    });\n\n    // Simple remediation strategies\n    switch (violation.metric) {\n      case 'cpu':\n        // Could migrate to a less loaded resource\n        break;\n      case 'memory':\n        // Could increase memory allocation if available\n        break;\n      case 'efficiency':\n        // Could provide optimization recommendations\n        break;\n    }\n\n    this.emit('qos:remediation-attempted', { allocation, violation });\n  }\n\n  private async releaseAllAllocations(): Promise<void> {\n    const activeAllocations = Array.from(this.allocations.values()).filter(\n      (a) => a.status === 'active',\n    );\n\n    for (const allocation of activeAllocations) {\n      await this.releaseResources(allocation.id, 'system_shutdown');\n    }\n  }\n\n  private handleResourceRequest(data: any): void {\n    // Handle resource requests from agents\n    this.emit('resource:request-received', data);\n  }\n\n  private handleResourceRelease(data: any): void {\n    // Handle resource releases from agents\n    this.emit('resource:release-received', data);\n  }\n\n  private handleResourceFailure(data: any): void {\n    const resource = this.resources.get(data.resourceId);\n    if (resource) {\n      resource.status = 'failed';\n\n      // Record failure\n      resource.metadata.reliability.failureHistory.push({\n        timestamp: new Date(),\n        type: data.type || 'unknown',\n        duration: data.duration || 0,\n        impact: data.impact || 'medium',\n        resolved: false,\n      });\n\n      this.logger.error('Resource failure detected', {\n        resourceId: data.resourceId,\n        type: data.type,\n      });\n\n      this.emit('resource:failed', { resource, failure: data });\n    }\n  }\n\n  private handleScalingTrigger(data: any): void {\n    // Handle scaling triggers from monitoring system\n    this.emit('scaling:triggered', data);\n  }\n\n  // === PUBLIC API ===\n\n  getResource(resourceId: string): Resource | undefined {\n    return this.resources.get(resourceId);\n  }\n\n  getAllResources(): Resource[] {\n    return Array.from(this.resources.values());\n  }\n\n  getResourcesByType(type: ResourceType): Resource[] {\n    return Array.from(this.resources.values()).filter((r) => r.type === type);\n  }\n\n  getPool(poolId: string): ResourcePool | undefined {\n    return this.pools.get(poolId);\n  }\n\n  getAllPools(): ResourcePool[] {\n    return Array.from(this.pools.values());\n  }\n\n  getReservation(reservationId: string): ResourceReservation | undefined {\n    return this.reservations.get(reservationId);\n  }\n\n  getAllReservations(): ResourceReservation[] {\n    return Array.from(this.reservations.values());\n  }\n\n  getAllocation(allocationId: string): ResourceAllocation | undefined {\n    return this.allocations.get(allocationId);\n  }\n\n  getAllAllocations(): ResourceAllocation[] {\n    return Array.from(this.allocations.values());\n  }\n\n  getResourceUsageHistory(resourceId: string): ResourceUsage[] {\n    return this.usageHistory.get(resourceId) || [];\n  }\n\n  getResourcePrediction(resourceId: string): ResourcePrediction | undefined {\n    return this.predictions.get(resourceId);\n  }\n\n  getManagerStatistics(): {\n    resources: number;\n    pools: number;\n    reservations: number;\n    allocations: number;\n    utilization: number;\n    efficiency: number;\n  } {\n    const resources = Array.from(this.resources.values());\n    const allocations = Array.from(this.allocations.values());\n\n    const totalCapacity = resources.reduce((sum, r) => sum + r.capacity.cpu, 0);\n    const totalAllocated = resources.reduce((sum, r) => sum + r.allocated.cpu, 0);\n\n    const activeAllocations = allocations.filter((a) => a.status === 'active');\n    const avgEfficiency =\n      activeAllocations.length > 0\n        ? activeAllocations.reduce((sum, a) => sum + a.efficiency, 0) / activeAllocations.length\n        : 1.0;\n\n    return {\n      resources: this.resources.size,\n      pools: this.pools.size,\n      reservations: this.reservations.size,\n      allocations: this.allocations.size,\n      utilization: totalCapacity > 0 ? totalAllocated / totalCapacity : 0,\n      efficiency: avgEfficiency,\n    };\n  }\n}\n\n// === HELPER CLASSES ===\n\ninterface ResourcePrediction {\n  resourceId: string;\n  predictions: Array<{\n    timestamp: Date;\n    predictedUsage: ResourceUsage;\n    confidence: number;\n  }>;\n  trends: {\n    cpu: 'increasing' | 'decreasing' | 'stable';\n    memory: 'increasing' | 'decreasing' | 'stable';\n    disk: 'increasing' | 'decreasing' | 'stable';\n  };\n  recommendations: string[];\n}\n\nclass ResourceOptimizer {\n  constructor(\n    private config: ResourceManagerConfig,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.debug('Resource optimizer initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.debug('Resource optimizer shutdown');\n  }\n\n  async predictUsage(resource: Resource, history: ResourceUsage[]): Promise<ResourcePrediction> {\n    // Simple linear trend analysis\n    const predictions: Array<{\n      timestamp: Date;\n      predictedUsage: ResourceUsage;\n      confidence: number;\n    }> = [];\n\n    // Calculate trends\n    const cpuTrend = this.calculateTrend(history.map((h) => h.cpu));\n    const memoryTrend = this.calculateTrend(history.map((h) => h.memory));\n    const diskTrend = this.calculateTrend(history.map((h) => h.disk));\n\n    // Generate predictions for next 24 hours\n    for (let i = 1; i <= 24; i++) {\n      const futureTime = new Date(Date.now() + i * 3600000); // i hours from now\n\n      predictions.push({\n        timestamp: futureTime,\n        predictedUsage: {\n          cpu: Math.max(0, Math.min(100, this.extrapolateTrend(cpuTrend, i))),\n          memory: Math.max(0, this.extrapolateTrend(memoryTrend, i)),\n          disk: Math.max(0, this.extrapolateTrend(diskTrend, i)),\n          network: 0, // Simplified\n          custom: {},\n          timestamp: futureTime,\n          duration: 3600000, // 1 hour\n        },\n        confidence: Math.max(0.1, 1.0 - i * 0.05), // Decreasing confidence over time\n      });\n    }\n\n    return {\n      resourceId: resource.id,\n      predictions,\n      trends: {\n        cpu: this.categorizeTrend(cpuTrend),\n        memory: this.categorizeTrend(memoryTrend),\n        disk: this.categorizeTrend(diskTrend),\n      },\n      recommendations: this.generateRecommendations(resource, history),\n    };\n  }\n\n  private calculateTrend(values: number[]): { slope: number; intercept: number; r2: number } {\n    if (values.length < 2) {\n      return { slope: 0, intercept: values[0] || 0, r2: 0 };\n    }\n\n    const n = values.length;\n    const sumX = values.reduce((sum, _, i) => sum + i, 0);\n    const sumY = values.reduce((sum, val) => sum + val, 0);\n    const sumXY = values.reduce((sum, val, i) => sum + i * val, 0);\n    const sumXX = values.reduce((sum, _, i) => sum + i * i, 0);\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n\n    // Calculate R\n    const meanY = sumY / n;\n    const ssTotal = values.reduce((sum, val) => sum + Math.pow(val - meanY, 2), 0);\n    const ssRes = values.reduce((sum, val, i) => {\n      const predicted = slope * i + intercept;\n      return sum + Math.pow(val - predicted, 2);\n    }, 0);\n\n    const r2 = 1 - ssRes / ssTotal;\n\n    return { slope, intercept, r2 };\n  }\n\n  private extrapolateTrend(trend: { slope: number; intercept: number }, steps: number): number {\n    return trend.slope * steps + trend.intercept;\n  }\n\n  private categorizeTrend(trend: { slope: number }): 'increasing' | 'decreasing' | 'stable' {\n    const threshold = 0.1;\n    if (trend.slope > threshold) return 'increasing';\n    if (trend.slope < -threshold) return 'decreasing';\n    return 'stable';\n  }\n\n  private generateRecommendations(resource: Resource, history: ResourceUsage[]): string[] {\n    const recommendations: string[] = [];\n\n    if (history.length === 0) {\n      return recommendations;\n    }\n\n    const recent = history.slice(-10);\n    const avgCpu = recent.reduce((sum, h) => sum + h.cpu, 0) / recent.length;\n    const avgMemory = recent.reduce((sum, h) => sum + h.memory, 0) / recent.length;\n\n    // CPU recommendations\n    if (avgCpu > 80) {\n      recommendations.push('High CPU usage detected. Consider scaling up or optimizing workloads.');\n    } else if (avgCpu < 20) {\n      recommendations.push('Low CPU usage. Consider scaling down to reduce costs.');\n    }\n\n    // Memory recommendations\n    const memoryUtilization = avgMemory / resource.capacity.memory;\n    if (memoryUtilization > 0.9) {\n      recommendations.push('High memory usage. Consider increasing memory allocation.');\n    } else if (memoryUtilization < 0.3) {\n      recommendations.push('Low memory usage. Consider reducing memory allocation.');\n    }\n\n    return recommendations;\n  }\n}\n\nclass ResourceManagerMetrics {\n  private allocationsCreated = 0;\n  private allocationsReleased = 0;\n  private reservationsFailed = 0;\n  private qosViolations = 0;\n\n  recordAllocationCreated(): void {\n    this.allocationsCreated++;\n  }\n\n  recordAllocationReleased(allocation: ResourceAllocation): void {\n    this.allocationsReleased++;\n  }\n\n  recordReservationFailed(): void {\n    this.reservationsFailed++;\n  }\n\n  recordQoSViolation(): void {\n    this.qosViolations++;\n  }\n\n  getMetrics(): any {\n    return {\n      allocationsCreated: this.allocationsCreated,\n      allocationsReleased: this.allocationsReleased,\n      reservationsFailed: this.reservationsFailed,\n      qosViolations: this.qosViolations,\n      successRate:\n        this.allocationsCreated > 0\n          ? ((this.allocationsCreated - this.reservationsFailed) / this.allocationsCreated) * 100\n          : 100,\n    };\n  }\n}\n"],"names":["EventEmitter","generateId","ResourceManager","logger","eventBus","config","resources","Map","pools","reservations","allocations","usageHistory","predictions","optimizer","monitoringInterval","cleanupInterval","scalingInterval","metrics","enableResourcePooling","enableResourceMonitoring","enableAutoScaling","enableQoS","defaultLimits","cpu","memory","disk","network","custom","reservationTimeout","allocationStrategy","priorityWeights","critical","high","normal","low","background","enablePredictiveAllocation","enableResourceSharing","debugMode","ResourceOptimizer","ResourceManagerMetrics","setupEventHandlers","on","data","handleResourceRequest","handleResourceRelease","updateResourceUsage","resourceId","usage","handleResourceFailure","handleScalingTrigger","initialize","info","pooling","monitoring","autoScaling","createDefaultPools","startMonitoring","startCleanup","startAutoScaling","emit","shutdown","clearInterval","releaseAllAllocations","registerResource","type","name","capacity","metadata","resource","id","description","allocated","createEmptyLimits","available","status","provider","capabilities","performance","createDefaultPerformanceMetrics","reliability","createDefaultReliabilityMetrics","cost","createDefaultCostMetrics","lastUpdated","Date","sharable","persistent","tags","set","unregisterResource","get","Error","length","reservation","cancelReservation","delete","requestResources","agentId","requirements","options","reservationId","now","taskId","priority","createdAt","expiresAt","timeout","getTime","preemptible","findSuitableResource","push","updateResourceAvailability","canActivateReservation","activateReservation","error","allocationId","allocation","calculateAllocation","actualUsage","createEmptyUsage","efficiency","startTime","qosViolations","addToResourceLimits","activatedAt","releaseResources","reason","endTime","calculateEfficiency","subtractFromResourceLimits","filter","a","releasedAt","recordAllocationReleased","Array","from","values","find","r","createResourcePool","resourceIds","strategy","poolId","pool","loadBalancing","scaling","enabled","minResources","Math","max","maxResources","scaleUpThreshold","scaleDownThreshold","cooldownPeriod","weight","threshold","aggregation","qos","guarantees","objectives","violations","autoRemediation","escalationThreshold","penaltyFunction","notificationEnabled","statistics","createPoolStatistics","filters","resourceCount","addResourceToPool","includes","updatePoolStatistics","removeResourceFromPool","candidates","score","calculateResourceScore","sort","b","selectResourceByStrategy","canSatisfyRequirements","utilization","calculateResourceUtilization","cpuScore","uptime","priorityWeight","min","spec","Object","entries","constraints","checkConstraints","location","excludeLocation","maxCost","timeWindow","start","end","reduce","best","current","bestWaste","calculateWaste","currentWaste","worst","worstWaste","waste","preferred","setInterval","performMonitoring","interval","performCleanup","evaluateScaling","updateResourceStatistics","checkQoSViolations","updatePredictions","size","expiredReservations","cutoff","history","timestamp","debug","calculatePoolMetrics","shouldScale","action","scalePoolUp","scalePoolDown","totalCapacity","totalAllocated","duration","efficiencySum","factors","target","source","value","memoryBandwidth","diskIOPS","networkBandwidth","benchmarkResults","meanTimeBetweenFailures","errorRate","failureHistory","hourlyRate","dataTransferCost","storageCost","billing","totalResources","availableResources","utilizationRate","allocationSuccessRate","averageWaitTime","throughput","costPerHour","qosScore","computeResources","map","shift","recent","slice","avgCpu","sum","h","Boolean","totalUtilization","totalCost","p","checkPoolQoS","guarantee","getMetricValue","metric","violated","evaluateQoSCondition","operator","violation","expected","actual","severity","calculateViolationSeverity","resolved","warn","remediateQoSViolation","prediction","predictUsage","totalReservations","queue_depth","actualValue","deviation","abs","activeAllocations","impact","failure","getResource","getAllResources","getResourcesByType","getPool","getAllPools","getReservation","getAllReservations","getAllocation","getAllAllocations","getResourceUsageHistory","getResourcePrediction","getManagerStatistics","avgEfficiency","cpuTrend","calculateTrend","memoryTrend","diskTrend","i","futureTime","predictedUsage","extrapolateTrend","confidence","trends","categorizeTrend","recommendations","generateRecommendations","slope","intercept","r2","n","sumX","_","sumY","val","sumXY","sumXX","meanY","ssTotal","pow","ssRes","predicted","trend","steps","avgMemory","memoryUtilization","allocationsCreated","allocationsReleased","reservationsFailed","recordAllocationCreated","recordReservationFailed","recordQoSViolation","getMetrics","successRate"],"mappings":"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"}