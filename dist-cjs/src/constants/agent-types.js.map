{"version":3,"sources":["../../../src/constants/agent-types.ts"],"sourcesContent":["/**\n * Agent Types - Dynamic loading from .claude/agents/ directory\n * This file provides type-safe access to dynamically loaded agent definitions\n */\n\nimport { \n  getAvailableAgentTypes, \n  isValidAgentType as validateAgentType,\n  resolveLegacyAgentType as resolveLegacy,\n  LEGACY_AGENT_MAPPING as LEGACY_MAPPING\n} from '../agents/agent-loader.js';\n\n// Dynamic agent type - will be a string that matches available agents\nexport type AgentType = string;\n\n// Re-export legacy mapping from agent-loader\nexport const LEGACY_AGENT_MAPPING = LEGACY_MAPPING;\n\n// Re-export getAvailableAgentTypes for MCP tools\nexport { getAvailableAgentTypes };\n\n/**\n * Get all valid agent types dynamically\n */\nexport async function getValidAgentTypes(): Promise<string[]> {\n  return await getAvailableAgentTypes();\n}\n\n/**\n * Helper function to validate agent type\n */\nexport async function isValidAgentType(type: string): Promise<boolean> {\n  return await validateAgentType(type);\n}\n\n/**\n * Resolve legacy agent types to current equivalents\n */\nexport const resolveLegacyAgentType = resolveLegacy;\n\n/**\n * Create JSON Schema for agent type validation (async)\n */\nexport async function getAgentTypeSchema() {\n  const validTypes = await getValidAgentTypes();\n  return {\n    type: 'string',\n    enum: validTypes,\n    description: 'Type of specialized AI agent',\n  };\n}\n\n// Strategy types\nexport const SWARM_STRATEGIES = {\n  AUTO: 'auto',\n  RESEARCH: 'research',\n  DEVELOPMENT: 'development',\n  ANALYSIS: 'analysis',\n  TESTING: 'testing',\n  OPTIMIZATION: 'optimization',\n  MAINTENANCE: 'maintenance',\n  CUSTOM: 'custom',\n} as const;\n\nexport type SwarmStrategy = (typeof SWARM_STRATEGIES)[keyof typeof SWARM_STRATEGIES];\nexport const VALID_SWARM_STRATEGIES = Object.values(SWARM_STRATEGIES);\n\n// Task orchestration strategies (different from swarm strategies)\nexport const ORCHESTRATION_STRATEGIES = {\n  PARALLEL: 'parallel',\n  SEQUENTIAL: 'sequential',\n  ADAPTIVE: 'adaptive',\n  BALANCED: 'balanced',\n} as const;\n\nexport type OrchestrationStrategy =\n  (typeof ORCHESTRATION_STRATEGIES)[keyof typeof ORCHESTRATION_STRATEGIES];\nexport const VALID_ORCHESTRATION_STRATEGIES = Object.values(ORCHESTRATION_STRATEGIES);\n"],"names":["getAvailableAgentTypes","isValidAgentType","validateAgentType","resolveLegacyAgentType","resolveLegacy","LEGACY_AGENT_MAPPING","LEGACY_MAPPING","getValidAgentTypes","type","getAgentTypeSchema","validTypes","enum","description","SWARM_STRATEGIES","AUTO","RESEARCH","DEVELOPMENT","ANALYSIS","TESTING","OPTIMIZATION","MAINTENANCE","CUSTOM","VALID_SWARM_STRATEGIES","Object","values","ORCHESTRATION_STRATEGIES","PARALLEL","SEQUENTIAL","ADAPTIVE","BALANCED","VALID_ORCHESTRATION_STRATEGIES"],"mappings":"AAKA,SACEA,sBAAsB,EACtBC,oBAAoBC,iBAAiB,EACrCC,0BAA0BC,aAAa,EACvCC,wBAAwBC,cAAc,QACjC,4BAA4B;AAMnC,OAAO,MAAMD,uBAAuBC,eAAe;AAGnD,SAASN,sBAAsB,GAAG;AAKlC,OAAO,eAAeO;IACpB,OAAO,MAAMP;AACf;AAKA,OAAO,eAAeC,iBAAiBO,IAAY;IACjD,OAAO,MAAMN,kBAAkBM;AACjC;AAKA,OAAO,MAAML,yBAAyBC,cAAc;AAKpD,OAAO,eAAeK;IACpB,MAAMC,aAAa,MAAMH;IACzB,OAAO;QACLC,MAAM;QACNG,MAAMD;QACNE,aAAa;IACf;AACF;AAGA,OAAO,MAAMC,mBAAmB;IAC9BC,MAAM;IACNC,UAAU;IACVC,aAAa;IACbC,UAAU;IACVC,SAAS;IACTC,cAAc;IACdC,aAAa;IACbC,QAAQ;AACV,EAAW;AAGX,OAAO,MAAMC,yBAAyBC,OAAOC,MAAM,CAACX,kBAAkB;AAGtE,OAAO,MAAMY,2BAA2B;IACtCC,UAAU;IACVC,YAAY;IACZC,UAAU;IACVC,UAAU;AACZ,EAAW;AAIX,OAAO,MAAMC,iCAAiCP,OAAOC,MAAM,CAACC,0BAA0B"}