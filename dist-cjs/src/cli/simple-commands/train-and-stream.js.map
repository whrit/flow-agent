{"version":3,"sources":["../../../../src/cli/simple-commands/train-and-stream.js"],"sourcesContent":["#!/usr/bin/env node\n/**\n * Integrated Training and Stream Chaining System\n * Combines real code training with stream-based agent chaining\n */\n\nimport fs from 'fs/promises';\nimport { spawn } from 'child_process';\nimport { TrainingPipeline } from './training-pipeline.js';\n\nexport class TrainAndStreamSystem {\n  constructor() {\n    this.trainingPipeline = new TrainingPipeline();\n    this.streamConfig = '.claude-flow/stream-config.json';\n  }\n\n  /**\n   * Train agents and then use them in a stream chain\n   */\n  async trainAndExecute(task, options = {}) {\n    console.log('🎯 Integrated Training & Stream Execution');\n    console.log('━'.repeat(50));\n\n    // Step 1: Run training to improve agent profiles\n    console.log('\\n📚 Phase 1: Training Agents with Real Code');\n    console.log('─'.repeat(40));\n    \n    await this.trainingPipeline.initialize();\n    const trainingResult = await this.trainingPipeline.runFullPipeline({\n      complexity: options.complexity || 'medium',\n      iterations: options.iterations || 2,\n      validate: true\n    });\n\n    // Step 2: Load trained profiles\n    const profiles = JSON.parse(\n      await fs.readFile('.claude-flow/agents/profiles.json', 'utf8')\n    );\n\n    // Step 3: Select best strategy based on task requirements\n    const strategy = this.selectOptimalStrategy(profiles, options);\n    console.log(`\\n🎯 Selected Strategy: ${strategy.name}`);\n    console.log(`   Success Rate: ${(strategy.profile.successRate * 100).toFixed(1)}%`);\n    console.log(`   Avg Score: ${strategy.profile.avgScore.toFixed(2)}`);\n    console.log(`   Execution Time: ${strategy.profile.avgExecutionTime.toFixed(0)}ms`);\n\n    // Step 4: Execute stream chain with trained agents\n    console.log('\\n🔗 Phase 2: Stream Chain Execution');\n    console.log('─'.repeat(40));\n    \n    const result = await this.executeStreamChain(task, strategy, options);\n    \n    // Step 5: Learn from execution results\n    await this.updateProfilesFromExecution(strategy.name, result);\n\n    return {\n      training: trainingResult,\n      execution: result,\n      strategy: strategy.name,\n      performance: {\n        trainingImprovement: trainingResult.improvements,\n        executionTime: result.duration,\n        success: result.success\n      }\n    };\n  }\n\n  /**\n   * Select optimal strategy based on task requirements\n   */\n  selectOptimalStrategy(profiles, options) {\n    const priorities = options.priorities || {\n      reliability: 0.4,\n      speed: 0.3,\n      score: 0.3\n    };\n\n    let bestScore = -1;\n    let bestStrategy = null;\n\n    for (const [name, profile] of Object.entries(profiles)) {\n      const score = \n        (profile.successRate * priorities.reliability) +\n        ((1 - profile.avgExecutionTime / 5000) * priorities.speed) +\n        (profile.avgScore / 100 * priorities.score);\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestStrategy = { name, profile, score };\n      }\n    }\n\n    return bestStrategy;\n  }\n\n  /**\n   * Execute a stream chain with multiple agents\n   */\n  async executeStreamChain(task, strategy, options) {\n    const startTime = Date.now();\n    const steps = this.decomposeTask(task, strategy.name);\n    \n    console.log(`\\n📝 Task decomposed into ${steps.length} steps:`);\n    steps.forEach((step, i) => {\n      console.log(`   ${i + 1}. ${step.description}`);\n    });\n\n    let inputStream = null;\n    let lastOutput = null;\n    const results = [];\n\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i];\n      console.log(`\\n🔄 Executing Step ${i + 1}: ${step.description}`);\n      \n      const output = await this.executeStreamStep(\n        step,\n        inputStream,\n        i === steps.length - 1 // isLast\n      );\n      \n      results.push({\n        step: i + 1,\n        description: step.description,\n        output: output.summary,\n        duration: output.duration\n      });\n\n      inputStream = output.stream;\n      lastOutput = output;\n    }\n\n    const totalDuration = Date.now() - startTime;\n    \n    console.log('\\n✅ Stream Chain Complete');\n    console.log(`   Total Duration: ${totalDuration}ms`);\n    console.log(`   Steps Completed: ${results.length}`);\n\n    return {\n      success: true,\n      duration: totalDuration,\n      steps: results,\n      finalOutput: lastOutput.summary\n    };\n  }\n\n  /**\n   * Execute a single step in the stream chain\n   */\n  async executeStreamStep(step, inputStream, isLast) {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      \n      // Build command arguments\n      const args = ['-p'];\n      if (inputStream) {\n        args.push('--input-format', 'stream-json');\n      }\n      if (!isLast) {\n        args.push('--output-format', 'stream-json');\n      }\n      args.push(step.prompt);\n\n      // Spawn Claude process\n      const claudeProcess = spawn('claude', args, {\n        stdio: inputStream ? ['pipe', 'pipe', 'pipe'] : ['inherit', 'pipe', 'pipe']\n      });\n\n      let output = '';\n      let streamOutput = '';\n\n      // Pipe input if available\n      if (inputStream && claudeProcess.stdin) {\n        inputStream.pipe(claudeProcess.stdin);\n      }\n\n      // Capture output\n      claudeProcess.stdout.on('data', (data) => {\n        const chunk = data.toString();\n        output += chunk;\n        if (!isLast) {\n          streamOutput += chunk;\n        }\n      });\n\n      claudeProcess.on('close', (code) => {\n        const duration = Date.now() - startTime;\n        \n        // Parse output for summary\n        let summary = 'Step completed';\n        try {\n          if (output.includes('\"type\":\"message\"')) {\n            const lines = output.split('\\n');\n            for (const line of lines) {\n              if (line.includes('\"type\":\"message\"')) {\n                const parsed = JSON.parse(line);\n                if (parsed.content && parsed.content[0]) {\n                  summary = parsed.content[0].text?.slice(0, 100) || summary;\n                  break;\n                }\n              }\n            }\n          } else {\n            summary = output.slice(0, 100);\n          }\n        } catch (e) {\n          // Fallback to raw output\n          summary = output.slice(0, 100);\n        }\n\n        resolve({\n          success: code === 0,\n          duration,\n          summary,\n          stream: !isLast ? streamOutput : null\n        });\n      });\n    });\n  }\n\n  /**\n   * Decompose task into stream chain steps\n   */\n  decomposeTask(task, strategy) {\n    // Different decomposition based on strategy\n    if (strategy === 'conservative') {\n      return [\n        {\n          description: 'Thorough analysis and validation',\n          prompt: `Analyze this task thoroughly and identify all requirements: ${task}`\n        },\n        {\n          description: 'Detailed planning with error handling',\n          prompt: 'Create a detailed implementation plan with comprehensive error handling'\n        },\n        {\n          description: 'Safe implementation with validation',\n          prompt: 'Implement the solution with extensive validation and safety checks'\n        }\n      ];\n    } else if (strategy === 'aggressive') {\n      return [\n        {\n          description: 'Quick analysis',\n          prompt: `Quickly analyze and implement: ${task}`\n        },\n        {\n          description: 'Optimization pass',\n          prompt: 'Optimize the implementation for maximum performance'\n        }\n      ];\n    } else {\n      // Balanced\n      return [\n        {\n          description: 'Analysis and design',\n          prompt: `Analyze and design a solution for: ${task}`\n        },\n        {\n          description: 'Implementation',\n          prompt: 'Implement the designed solution'\n        },\n        {\n          description: 'Review and refinement',\n          prompt: 'Review the implementation and make necessary refinements'\n        }\n      ];\n    }\n  }\n\n  /**\n   * Update profiles based on execution results\n   */\n  async updateProfilesFromExecution(strategy, result) {\n    const profiles = JSON.parse(\n      await fs.readFile('.claude-flow/agents/profiles.json', 'utf8')\n    );\n\n    if (profiles[strategy]) {\n      const profile = profiles[strategy];\n      const executionScore = result.success ? 80 : 20;\n      const timeScore = Math.max(0, 100 - result.duration / 100);\n      const overallScore = (executionScore + timeScore) / 2;\n\n      // Update with learning\n      const learningRate = 0.2;\n      profile.avgScore = profile.avgScore * (1 - learningRate) + overallScore * learningRate;\n      profile.avgExecutionTime = profile.avgExecutionTime * (1 - learningRate) + result.duration * learningRate;\n      profile.uses++;\n\n      // Add to trend\n      if (!profile.trend) profile.trend = [];\n      profile.trend.push({\n        score: overallScore,\n        timestamp: new Date().toISOString(),\n        streamExecution: true\n      });\n\n      await fs.writeFile(\n        '.claude-flow/agents/profiles.json',\n        JSON.stringify(profiles, null, 2)\n      );\n    }\n  }\n}\n\n/**\n * CLI Command Handler\n */\nexport async function trainAndStreamCommand(args, flags) {\n  const system = new TrainAndStreamSystem();\n  const task = args.join(' ') || 'Create a function to validate email addresses';\n\n  console.log('🚀 Train & Stream System');\n  console.log(`📋 Task: ${task}`);\n  console.log('');\n\n  const options = {\n    complexity: flags.complexity || 'medium',\n    iterations: parseInt(flags.iterations) || 2,\n    priorities: {\n      reliability: parseFloat(flags.reliability) || 0.4,\n      speed: parseFloat(flags.speed) || 0.3,\n      score: parseFloat(flags.score) || 0.3\n    }\n  };\n\n  try {\n    const result = await system.trainAndExecute(task, options);\n    \n    console.log('\\n' + '═'.repeat(50));\n    console.log('📊 Final Report');\n    console.log('═'.repeat(50));\n    \n    console.log('\\n🎯 Strategy Used:', result.strategy);\n    console.log('⏱️  Total Execution Time:', result.performance.executionTime + 'ms');\n    console.log('✅ Success:', result.performance.success ? 'Yes' : 'No');\n    \n    if (result.performance.trainingImprovement) {\n      console.log('\\n📈 Training Improvements:');\n      console.log(`   Success Rate: ${result.performance.trainingImprovement.successRate > 0 ? '+' : ''}${result.performance.trainingImprovement.successRate.toFixed(1)}%`);\n      console.log(`   Score: ${result.performance.trainingImprovement.score > 0 ? '+' : ''}${result.performance.trainingImprovement.score.toFixed(1)}%`);\n    }\n\n    console.log('\\n🔗 Stream Chain Steps:');\n    for (const step of result.execution.steps) {\n      console.log(`   ${step.step}. ${step.description} (${step.duration}ms)`);\n      console.log(`      Output: ${step.output.slice(0, 60)}...`);\n    }\n\n  } catch (error) {\n    console.error('❌ Error:', error.message);\n    process.exit(1);\n  }\n}\n\nexport default TrainAndStreamSystem;"],"names":["fs","spawn","TrainingPipeline","TrainAndStreamSystem","trainingPipeline","streamConfig","trainAndExecute","task","options","console","log","repeat","initialize","trainingResult","runFullPipeline","complexity","iterations","validate","profiles","JSON","parse","readFile","strategy","selectOptimalStrategy","name","profile","successRate","toFixed","avgScore","avgExecutionTime","result","executeStreamChain","updateProfilesFromExecution","training","execution","performance","trainingImprovement","improvements","executionTime","duration","success","priorities","reliability","speed","score","bestScore","bestStrategy","Object","entries","startTime","Date","now","steps","decomposeTask","length","forEach","step","i","description","inputStream","lastOutput","results","output","executeStreamStep","push","summary","stream","totalDuration","finalOutput","isLast","Promise","resolve","args","prompt","claudeProcess","stdio","streamOutput","stdin","pipe","stdout","on","data","chunk","toString","code","includes","lines","split","line","parsed","content","text","slice","e","executionScore","timeScore","Math","max","overallScore","learningRate","uses","trend","timestamp","toISOString","streamExecution","writeFile","stringify","trainAndStreamCommand","flags","system","join","parseInt","parseFloat","error","message","process","exit"],"mappings":";AAMA,OAAOA,QAAQ,cAAc;AAC7B,SAASC,KAAK,QAAQ,gBAAgB;AACtC,SAASC,gBAAgB,QAAQ,yBAAyB;AAE1D,OAAO,MAAMC;IACX,aAAc;QACZ,IAAI,CAACC,gBAAgB,GAAG,IAAIF;QAC5B,IAAI,CAACG,YAAY,GAAG;IACtB;IAKA,MAAMC,gBAAgBC,IAAI,EAAEC,UAAU,CAAC,CAAC,EAAE;QACxCC,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAGvBF,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAEvB,MAAM,IAAI,CAACP,gBAAgB,CAACQ,UAAU;QACtC,MAAMC,iBAAiB,MAAM,IAAI,CAACT,gBAAgB,CAACU,eAAe,CAAC;YACjEC,YAAYP,QAAQO,UAAU,IAAI;YAClCC,YAAYR,QAAQQ,UAAU,IAAI;YAClCC,UAAU;QACZ;QAGA,MAAMC,WAAWC,KAAKC,KAAK,CACzB,MAAMpB,GAAGqB,QAAQ,CAAC,qCAAqC;QAIzD,MAAMC,WAAW,IAAI,CAACC,qBAAqB,CAACL,UAAUV;QACtDC,QAAQC,GAAG,CAAC,CAAC,wBAAwB,EAAEY,SAASE,IAAI,EAAE;QACtDf,QAAQC,GAAG,CAAC,CAAC,iBAAiB,EAAE,AAACY,CAAAA,SAASG,OAAO,CAACC,WAAW,GAAG,GAAE,EAAGC,OAAO,CAAC,GAAG,CAAC,CAAC;QAClFlB,QAAQC,GAAG,CAAC,CAAC,cAAc,EAAEY,SAASG,OAAO,CAACG,QAAQ,CAACD,OAAO,CAAC,IAAI;QACnElB,QAAQC,GAAG,CAAC,CAAC,mBAAmB,EAAEY,SAASG,OAAO,CAACI,gBAAgB,CAACF,OAAO,CAAC,GAAG,EAAE,CAAC;QAGlFlB,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAEvB,MAAMmB,SAAS,MAAM,IAAI,CAACC,kBAAkB,CAACxB,MAAMe,UAAUd;QAG7D,MAAM,IAAI,CAACwB,2BAA2B,CAACV,SAASE,IAAI,EAAEM;QAEtD,OAAO;YACLG,UAAUpB;YACVqB,WAAWJ;YACXR,UAAUA,SAASE,IAAI;YACvBW,aAAa;gBACXC,qBAAqBvB,eAAewB,YAAY;gBAChDC,eAAeR,OAAOS,QAAQ;gBAC9BC,SAASV,OAAOU,OAAO;YACzB;QACF;IACF;IAKAjB,sBAAsBL,QAAQ,EAAEV,OAAO,EAAE;QACvC,MAAMiC,aAAajC,QAAQiC,UAAU,IAAI;YACvCC,aAAa;YACbC,OAAO;YACPC,OAAO;QACT;QAEA,IAAIC,YAAY,CAAC;QACjB,IAAIC,eAAe;QAEnB,KAAK,MAAM,CAACtB,MAAMC,QAAQ,IAAIsB,OAAOC,OAAO,CAAC9B,UAAW;YACtD,MAAM0B,QACJ,AAACnB,QAAQC,WAAW,GAAGe,WAAWC,WAAW,GAC5C,AAAC,CAAA,IAAIjB,QAAQI,gBAAgB,GAAG,IAAG,IAAKY,WAAWE,KAAK,GACxDlB,QAAQG,QAAQ,GAAG,MAAMa,WAAWG,KAAK;YAE5C,IAAIA,QAAQC,WAAW;gBACrBA,YAAYD;gBACZE,eAAe;oBAAEtB;oBAAMC;oBAASmB;gBAAM;YACxC;QACF;QAEA,OAAOE;IACT;IAKA,MAAMf,mBAAmBxB,IAAI,EAAEe,QAAQ,EAAEd,OAAO,EAAE;QAChD,MAAMyC,YAAYC,KAAKC,GAAG;QAC1B,MAAMC,QAAQ,IAAI,CAACC,aAAa,CAAC9C,MAAMe,SAASE,IAAI;QAEpDf,QAAQC,GAAG,CAAC,CAAC,0BAA0B,EAAE0C,MAAME,MAAM,CAAC,OAAO,CAAC;QAC9DF,MAAMG,OAAO,CAAC,CAACC,MAAMC;YACnBhD,QAAQC,GAAG,CAAC,CAAC,GAAG,EAAE+C,IAAI,EAAE,EAAE,EAAED,KAAKE,WAAW,EAAE;QAChD;QAEA,IAAIC,cAAc;QAClB,IAAIC,aAAa;QACjB,MAAMC,UAAU,EAAE;QAElB,IAAK,IAAIJ,IAAI,GAAGA,IAAIL,MAAME,MAAM,EAAEG,IAAK;YACrC,MAAMD,OAAOJ,KAAK,CAACK,EAAE;YACrBhD,QAAQC,GAAG,CAAC,CAAC,oBAAoB,EAAE+C,IAAI,EAAE,EAAE,EAAED,KAAKE,WAAW,EAAE;YAE/D,MAAMI,SAAS,MAAM,IAAI,CAACC,iBAAiB,CACzCP,MACAG,aACAF,MAAML,MAAME,MAAM,GAAG;YAGvBO,QAAQG,IAAI,CAAC;gBACXR,MAAMC,IAAI;gBACVC,aAAaF,KAAKE,WAAW;gBAC7BI,QAAQA,OAAOG,OAAO;gBACtB1B,UAAUuB,OAAOvB,QAAQ;YAC3B;YAEAoB,cAAcG,OAAOI,MAAM;YAC3BN,aAAaE;QACf;QAEA,MAAMK,gBAAgBjB,KAAKC,GAAG,KAAKF;QAEnCxC,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,CAAC,mBAAmB,EAAEyD,cAAc,EAAE,CAAC;QACnD1D,QAAQC,GAAG,CAAC,CAAC,oBAAoB,EAAEmD,QAAQP,MAAM,EAAE;QAEnD,OAAO;YACLd,SAAS;YACTD,UAAU4B;YACVf,OAAOS;YACPO,aAAaR,WAAWK,OAAO;QACjC;IACF;IAKA,MAAMF,kBAAkBP,IAAI,EAAEG,WAAW,EAAEU,MAAM,EAAE;QACjD,OAAO,IAAIC,QAAQ,CAACC;YAClB,MAAMtB,YAAYC,KAAKC,GAAG;YAG1B,MAAMqB,OAAO;gBAAC;aAAK;YACnB,IAAIb,aAAa;gBACfa,KAAKR,IAAI,CAAC,kBAAkB;YAC9B;YACA,IAAI,CAACK,QAAQ;gBACXG,KAAKR,IAAI,CAAC,mBAAmB;YAC/B;YACAQ,KAAKR,IAAI,CAACR,KAAKiB,MAAM;YAGrB,MAAMC,gBAAgBzE,MAAM,UAAUuE,MAAM;gBAC1CG,OAAOhB,cAAc;oBAAC;oBAAQ;oBAAQ;iBAAO,GAAG;oBAAC;oBAAW;oBAAQ;iBAAO;YAC7E;YAEA,IAAIG,SAAS;YACb,IAAIc,eAAe;YAGnB,IAAIjB,eAAee,cAAcG,KAAK,EAAE;gBACtClB,YAAYmB,IAAI,CAACJ,cAAcG,KAAK;YACtC;YAGAH,cAAcK,MAAM,CAACC,EAAE,CAAC,QAAQ,CAACC;gBAC/B,MAAMC,QAAQD,KAAKE,QAAQ;gBAC3BrB,UAAUoB;gBACV,IAAI,CAACb,QAAQ;oBACXO,gBAAgBM;gBAClB;YACF;YAEAR,cAAcM,EAAE,CAAC,SAAS,CAACI;gBACzB,MAAM7C,WAAWW,KAAKC,GAAG,KAAKF;gBAG9B,IAAIgB,UAAU;gBACd,IAAI;oBACF,IAAIH,OAAOuB,QAAQ,CAAC,qBAAqB;wBACvC,MAAMC,QAAQxB,OAAOyB,KAAK,CAAC;wBAC3B,KAAK,MAAMC,QAAQF,MAAO;4BACxB,IAAIE,KAAKH,QAAQ,CAAC,qBAAqB;gCACrC,MAAMI,SAAStE,KAAKC,KAAK,CAACoE;gCAC1B,IAAIC,OAAOC,OAAO,IAAID,OAAOC,OAAO,CAAC,EAAE,EAAE;oCACvCzB,UAAUwB,OAAOC,OAAO,CAAC,EAAE,CAACC,IAAI,EAAEC,MAAM,GAAG,QAAQ3B;oCACnD;gCACF;4BACF;wBACF;oBACF,OAAO;wBACLA,UAAUH,OAAO8B,KAAK,CAAC,GAAG;oBAC5B;gBACF,EAAE,OAAOC,GAAG;oBAEV5B,UAAUH,OAAO8B,KAAK,CAAC,GAAG;gBAC5B;gBAEArB,QAAQ;oBACN/B,SAAS4C,SAAS;oBAClB7C;oBACA0B;oBACAC,QAAQ,CAACG,SAASO,eAAe;gBACnC;YACF;QACF;IACF;IAKAvB,cAAc9C,IAAI,EAAEe,QAAQ,EAAE;QAE5B,IAAIA,aAAa,gBAAgB;YAC/B,OAAO;gBACL;oBACEoC,aAAa;oBACbe,QAAQ,CAAC,4DAA4D,EAAElE,MAAM;gBAC/E;gBACA;oBACEmD,aAAa;oBACbe,QAAQ;gBACV;gBACA;oBACEf,aAAa;oBACbe,QAAQ;gBACV;aACD;QACH,OAAO,IAAInD,aAAa,cAAc;YACpC,OAAO;gBACL;oBACEoC,aAAa;oBACbe,QAAQ,CAAC,+BAA+B,EAAElE,MAAM;gBAClD;gBACA;oBACEmD,aAAa;oBACbe,QAAQ;gBACV;aACD;QACH,OAAO;YAEL,OAAO;gBACL;oBACEf,aAAa;oBACbe,QAAQ,CAAC,mCAAmC,EAAElE,MAAM;gBACtD;gBACA;oBACEmD,aAAa;oBACbe,QAAQ;gBACV;gBACA;oBACEf,aAAa;oBACbe,QAAQ;gBACV;aACD;QACH;IACF;IAKA,MAAMzC,4BAA4BV,QAAQ,EAAEQ,MAAM,EAAE;QAClD,MAAMZ,WAAWC,KAAKC,KAAK,CACzB,MAAMpB,GAAGqB,QAAQ,CAAC,qCAAqC;QAGzD,IAAIH,QAAQ,CAACI,SAAS,EAAE;YACtB,MAAMG,UAAUP,QAAQ,CAACI,SAAS;YAClC,MAAMwE,iBAAiBhE,OAAOU,OAAO,GAAG,KAAK;YAC7C,MAAMuD,YAAYC,KAAKC,GAAG,CAAC,GAAG,MAAMnE,OAAOS,QAAQ,GAAG;YACtD,MAAM2D,eAAe,AAACJ,CAAAA,iBAAiBC,SAAQ,IAAK;YAGpD,MAAMI,eAAe;YACrB1E,QAAQG,QAAQ,GAAGH,QAAQG,QAAQ,GAAI,CAAA,IAAIuE,YAAW,IAAKD,eAAeC;YAC1E1E,QAAQI,gBAAgB,GAAGJ,QAAQI,gBAAgB,GAAI,CAAA,IAAIsE,YAAW,IAAKrE,OAAOS,QAAQ,GAAG4D;YAC7F1E,QAAQ2E,IAAI;YAGZ,IAAI,CAAC3E,QAAQ4E,KAAK,EAAE5E,QAAQ4E,KAAK,GAAG,EAAE;YACtC5E,QAAQ4E,KAAK,CAACrC,IAAI,CAAC;gBACjBpB,OAAOsD;gBACPI,WAAW,IAAIpD,OAAOqD,WAAW;gBACjCC,iBAAiB;YACnB;YAEA,MAAMxG,GAAGyG,SAAS,CAChB,qCACAtF,KAAKuF,SAAS,CAACxF,UAAU,MAAM;QAEnC;IACF;AACF;AAKA,OAAO,eAAeyF,sBAAsBnC,IAAI,EAAEoC,KAAK;IACrD,MAAMC,SAAS,IAAI1G;IACnB,MAAMI,OAAOiE,KAAKsC,IAAI,CAAC,QAAQ;IAE/BrG,QAAQC,GAAG,CAAC;IACZD,QAAQC,GAAG,CAAC,CAAC,SAAS,EAAEH,MAAM;IAC9BE,QAAQC,GAAG,CAAC;IAEZ,MAAMF,UAAU;QACdO,YAAY6F,MAAM7F,UAAU,IAAI;QAChCC,YAAY+F,SAASH,MAAM5F,UAAU,KAAK;QAC1CyB,YAAY;YACVC,aAAasE,WAAWJ,MAAMlE,WAAW,KAAK;YAC9CC,OAAOqE,WAAWJ,MAAMjE,KAAK,KAAK;YAClCC,OAAOoE,WAAWJ,MAAMhE,KAAK,KAAK;QACpC;IACF;IAEA,IAAI;QACF,MAAMd,SAAS,MAAM+E,OAAOvG,eAAe,CAACC,MAAMC;QAElDC,QAAQC,GAAG,CAAC,OAAO,IAAIC,MAAM,CAAC;QAC9BF,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC,IAAIC,MAAM,CAAC;QAEvBF,QAAQC,GAAG,CAAC,uBAAuBoB,OAAOR,QAAQ;QAClDb,QAAQC,GAAG,CAAC,6BAA6BoB,OAAOK,WAAW,CAACG,aAAa,GAAG;QAC5E7B,QAAQC,GAAG,CAAC,cAAcoB,OAAOK,WAAW,CAACK,OAAO,GAAG,QAAQ;QAE/D,IAAIV,OAAOK,WAAW,CAACC,mBAAmB,EAAE;YAC1C3B,QAAQC,GAAG,CAAC;YACZD,QAAQC,GAAG,CAAC,CAAC,iBAAiB,EAAEoB,OAAOK,WAAW,CAACC,mBAAmB,CAACV,WAAW,GAAG,IAAI,MAAM,KAAKI,OAAOK,WAAW,CAACC,mBAAmB,CAACV,WAAW,CAACC,OAAO,CAAC,GAAG,CAAC,CAAC;YACpKlB,QAAQC,GAAG,CAAC,CAAC,UAAU,EAAEoB,OAAOK,WAAW,CAACC,mBAAmB,CAACQ,KAAK,GAAG,IAAI,MAAM,KAAKd,OAAOK,WAAW,CAACC,mBAAmB,CAACQ,KAAK,CAACjB,OAAO,CAAC,GAAG,CAAC,CAAC;QACnJ;QAEAlB,QAAQC,GAAG,CAAC;QACZ,KAAK,MAAM8C,QAAQ1B,OAAOI,SAAS,CAACkB,KAAK,CAAE;YACzC3C,QAAQC,GAAG,CAAC,CAAC,GAAG,EAAE8C,KAAKA,IAAI,CAAC,EAAE,EAAEA,KAAKE,WAAW,CAAC,EAAE,EAAEF,KAAKjB,QAAQ,CAAC,GAAG,CAAC;YACvE9B,QAAQC,GAAG,CAAC,CAAC,cAAc,EAAE8C,KAAKM,MAAM,CAAC8B,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC;QAC5D;IAEF,EAAE,OAAOqB,OAAO;QACdxG,QAAQwG,KAAK,CAAC,YAAYA,MAAMC,OAAO;QACvCC,QAAQC,IAAI,CAAC;IACf;AACF;AAEA,eAAejH,qBAAqB"}