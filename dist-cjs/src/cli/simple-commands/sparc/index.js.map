{"version":3,"sources":["../../../../../src/cli/simple-commands/sparc/index.js"],"sourcesContent":["// SPARC Methodology Implementation\n// Specification, Pseudocode, Architecture, Refinement, Completion\n\nimport { SparcSpecification } from './specification.js';\nimport { SparcPseudocode } from './pseudocode.js';\nimport { SparcArchitecture } from './architecture.js';\nimport { SparcRefinement } from './refinement.js';\nimport { SparcCompletion } from './completion.js';\nimport { SparcCoordinator } from './coordinator.js';\n\nexport class SparcMethodology {\n  constructor(taskDescription, options = {}) {\n    this.taskDescription = taskDescription;\n    this.options = {\n      namespace: options.namespace || 'sparc',\n      swarmEnabled: options.swarmEnabled || false,\n      neuralLearning: options.neuralLearning || false,\n      verbose: options.verbose || false,\n      ...options,\n    };\n\n    this.phases = {\n      specification: new SparcSpecification(this.taskDescription, this.options),\n      pseudocode: new SparcPseudocode(this.taskDescription, this.options),\n      architecture: new SparcArchitecture(this.taskDescription, this.options),\n      refinement: new SparcRefinement(this.taskDescription, this.options),\n      completion: new SparcCompletion(this.taskDescription, this.options),\n    };\n\n    this.coordinator = new SparcCoordinator(this.phases, this.options);\n    this.currentPhase = 'specification';\n    this.phaseOrder = ['specification', 'pseudocode', 'architecture', 'refinement', 'completion'];\n    this.artifacts = {};\n    this.qualityGates = {};\n  }\n\n  /**\n   * Execute the complete SPARC methodology\n   */\n  async execute() {\n    console.log('üöÄ Starting SPARC Methodology Execution');\n    console.log(`üìã Task: ${this.taskDescription}`);\n    console.log(`üîß Namespace: ${this.options.namespace}`);\n    console.log(`üêù Swarm: ${this.options.swarmEnabled ? 'Enabled' : 'Disabled'}`);\n    console.log();\n\n    // Initialize swarm if enabled\n    if (this.options.swarmEnabled) {\n      await this.coordinator.initializeSwarm();\n    }\n\n    // Execute each phase in order\n    for (const phaseName of this.phaseOrder) {\n      console.log(`\\nüìç Phase: ${phaseName.toUpperCase()}`);\n\n      try {\n        // Pre-phase coordination\n        await this.coordinator.prePhase(phaseName);\n\n        // Execute phase\n        const phase = this.phases[phaseName];\n        const result = await phase.execute();\n\n        // Store artifacts\n        this.artifacts[phaseName] = result;\n\n        // Quality gate validation\n        const qualityGate = await this.validateQualityGate(phaseName, result);\n        this.qualityGates[phaseName] = qualityGate;\n\n        if (!qualityGate.passed) {\n          console.log(`‚ùå Quality Gate Failed for ${phaseName}`);\n          console.log(`Reasons: ${qualityGate.reasons.join(', ')}`);\n\n          // Attempt auto-remediation\n          if (this.options.autoRemediation) {\n            await this.autoRemediate(phaseName, qualityGate);\n          } else {\n            throw new Error(`Quality gate failed for phase: ${phaseName}`);\n          }\n        }\n\n        // Post-phase coordination\n        await this.coordinator.postPhase(phaseName, result);\n\n        console.log(`‚úÖ ${phaseName} completed successfully`);\n      } catch (error) {\n        console.error(`‚ùå Error in ${phaseName}: ${error.message}`);\n\n        // Neural learning from failures\n        if (this.options.neuralLearning) {\n          await this.learnFromFailure(phaseName, error);\n        }\n\n        throw error;\n      }\n    }\n\n    // Final coordination and cleanup\n    await this.coordinator.finalize();\n\n    console.log('\\nüéâ SPARC Methodology Execution Complete');\n    return this.generateSummary();\n  }\n\n  /**\n   * Execute a specific phase\n   */\n  async executePhase(phaseName) {\n    if (!this.phases[phaseName]) {\n      throw new Error(`Unknown phase: ${phaseName}`);\n    }\n\n    console.log(`üìç Executing Phase: ${phaseName.toUpperCase()}`);\n\n    const phase = this.phases[phaseName];\n    const result = await phase.execute();\n\n    this.artifacts[phaseName] = result;\n    return result;\n  }\n\n  /**\n   * Validate quality gate for a phase\n   */\n  async validateQualityGate(phaseName, result) {\n    const qualityGate = {\n      passed: true,\n      reasons: [],\n    };\n\n    switch (phaseName) {\n      case 'specification':\n        if (!result.requirements || result.requirements.length === 0) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('No requirements defined');\n        }\n        if (!result.acceptanceCriteria || result.acceptanceCriteria.length === 0) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('No acceptance criteria defined');\n        }\n        break;\n\n      case 'pseudocode':\n        if (!result.flowDiagram) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('No flow diagram created');\n        }\n        if (!result.pseudocode || result.pseudocode.length < 10) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('Insufficient pseudocode detail');\n        }\n        break;\n\n      case 'architecture':\n        if (!result.components || result.components.length === 0) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('No components defined');\n        }\n        if (!result.designPatterns || result.designPatterns.length === 0) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('No design patterns specified');\n        }\n        break;\n\n      case 'refinement':\n        if (!result.testResults || result.testResults.passed === 0) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('No passing tests');\n        }\n        if (result.codeQuality && result.codeQuality.score < 0.8) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('Code quality below threshold');\n        }\n        break;\n\n      case 'completion':\n        if (!result.validated) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('Final validation failed');\n        }\n        if (!result.documented) {\n          qualityGate.passed = false;\n          qualityGate.reasons.push('Documentation incomplete');\n        }\n        break;\n    }\n\n    return qualityGate;\n  }\n\n  /**\n   * Auto-remediate quality gate failures\n   */\n  async autoRemediate(phaseName, qualityGate) {\n    console.log(`üîÑ Attempting auto-remediation for ${phaseName}`);\n\n    // Neural learning can inform remediation strategies\n    if (this.options.neuralLearning) {\n      await this.learnFromFailure(\n        phaseName,\n        new Error(`Quality gate failed: ${qualityGate.reasons.join(', ')}`),\n      );\n    }\n\n    // Re-execute the phase with enhanced context\n    const phase = this.phases[phaseName];\n    phase.setRemediationContext(qualityGate);\n\n    const result = await phase.execute();\n    this.artifacts[phaseName] = result;\n\n    // Re-validate\n    const newQualityGate = await this.validateQualityGate(phaseName, result);\n    this.qualityGates[phaseName] = newQualityGate;\n\n    if (!newQualityGate.passed) {\n      throw new Error(\n        `Auto-remediation failed for ${phaseName}: ${newQualityGate.reasons.join(', ')}`,\n      );\n    }\n\n    console.log(`‚úÖ Auto-remediation successful for ${phaseName}`);\n  }\n\n  /**\n   * Neural learning from failures\n   */\n  async learnFromFailure(phaseName, error) {\n    const learningData = {\n      phase: phaseName,\n      task: this.taskDescription,\n      error: error.message,\n      timestamp: new Date().toISOString(),\n      context: this.artifacts,\n    };\n\n    // Store learning data for neural network training\n    if (this.options.neuralLearning) {\n      await this.coordinator.recordLearning(learningData);\n    }\n  }\n\n  /**\n   * Generate execution summary\n   */\n  generateSummary() {\n    const summary = {\n      taskDescription: this.taskDescription,\n      executionTime: Date.now() - this.startTime,\n      phases: this.phaseOrder.map((phase) => ({\n        name: phase,\n        status: this.qualityGates[phase]?.passed ? 'passed' : 'failed',\n        artifacts: this.artifacts[phase],\n      })),\n      qualityGates: this.qualityGates,\n      artifacts: this.artifacts,\n      recommendations: this.generateRecommendations(),\n    };\n\n    return summary;\n  }\n\n  /**\n   * Generate recommendations based on execution\n   */\n  generateRecommendations() {\n    const recommendations = [];\n\n    // Analyze quality gate failures\n    for (const [phase, gate] of Object.entries(this.qualityGates)) {\n      if (!gate.passed) {\n        recommendations.push({\n          type: 'quality_improvement',\n          phase: phase,\n          message: `Improve ${phase} quality: ${gate.reasons.join(', ')}`,\n        });\n      }\n    }\n\n    // Analyze artifacts for optimization opportunities\n    if (this.artifacts.architecture && this.artifacts.architecture.components.length > 10) {\n      recommendations.push({\n        type: 'architecture_optimization',\n        message: 'Consider breaking down architecture into smaller, more manageable components',\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get current phase status\n   */\n  getPhaseStatus(phaseName) {\n    return {\n      name: phaseName,\n      completed: !!this.artifacts[phaseName],\n      qualityGate: this.qualityGates[phaseName],\n      artifacts: this.artifacts[phaseName],\n    };\n  }\n\n  /**\n   * Get overall progress\n   */\n  getProgress() {\n    const completedPhases = Object.keys(this.artifacts).length;\n    const totalPhases = this.phaseOrder.length;\n\n    return {\n      completed: completedPhases,\n      total: totalPhases,\n      percentage: (completedPhases / totalPhases) * 100,\n      currentPhase: this.currentPhase,\n      phases: this.phaseOrder.map((phase) => this.getPhaseStatus(phase)),\n    };\n  }\n}\n\nexport default SparcMethodology;\n"],"names":["SparcSpecification","SparcPseudocode","SparcArchitecture","SparcRefinement","SparcCompletion","SparcCoordinator","SparcMethodology","taskDescription","options","namespace","swarmEnabled","neuralLearning","verbose","phases","specification","pseudocode","architecture","refinement","completion","coordinator","currentPhase","phaseOrder","artifacts","qualityGates","execute","console","log","initializeSwarm","phaseName","toUpperCase","prePhase","phase","result","qualityGate","validateQualityGate","passed","reasons","join","autoRemediation","autoRemediate","Error","postPhase","error","message","learnFromFailure","finalize","generateSummary","executePhase","requirements","length","push","acceptanceCriteria","flowDiagram","components","designPatterns","testResults","codeQuality","score","validated","documented","setRemediationContext","newQualityGate","learningData","task","timestamp","Date","toISOString","context","recordLearning","summary","executionTime","now","startTime","map","name","status","recommendations","generateRecommendations","gate","Object","entries","type","getPhaseStatus","completed","getProgress","completedPhases","keys","totalPhases","total","percentage"],"mappings":"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"}