{"version":3,"sources":["../../../../../src/cli/simple-commands/sparc/coordinator.js"],"sourcesContent":["// SPARC Coordinator\n// Integrates SPARC methodology with swarm system for enhanced coordination\n\nimport { SparcPhase } from './phase-base.js';\n\nexport class SparcCoordinator {\n  constructor(phases, options = {}) {\n    this.phases = phases;\n    this.options = options;\n    this.swarmId = null;\n    this.agents = [];\n    this.phaseAgents = new Map();\n    this.coordination = {\n      strategy: 'adaptive',\n      topology: 'hierarchical',\n      communication: 'event-driven',\n      loadBalancing: 'capability-based',\n    };\n    this.metrics = {\n      phaseExecutions: 0,\n      agentUtilization: {},\n      coordinationEfficiency: 0,\n      qualityGates: [],\n      learningData: [],\n    };\n    this.neuralContext = null;\n    this.swarmEnabled = options.swarmEnabled || false;\n  }\n\n  /**\n   * Initialize swarm for SPARC execution\n   */\n  async initializeSwarm() {\n    if (!this.swarmEnabled) {\n      console.log('üîÑ SPARC running in standalone mode');\n      return;\n    }\n\n    console.log('üêù Initializing SPARC Swarm Coordination');\n\n    try {\n      // Initialize swarm using ruv-swarm hooks\n      const swarmConfig = {\n        topology: this.coordination.topology,\n        maxAgents: this.calculateOptimalAgentCount(),\n        strategy: 'sparc_methodology',\n        communication: this.coordination.communication,\n        loadBalancing: this.coordination.loadBalancing,\n      };\n\n      this.swarmId = await this.executeSwarmHook('swarm_init', swarmConfig);\n      console.log(`üÜî Swarm initialized: ${this.swarmId}`);\n\n      // Spawn specialized SPARC agents\n      await this.spawnSparcAgents();\n\n      // Setup inter-phase coordination\n      await this.setupPhaseCoordination();\n\n      console.log('‚úÖ SPARC Swarm coordination initialized');\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Swarm initialization failed: ${error.message}`);\n      console.log('üîÑ Falling back to standalone mode');\n      this.swarmEnabled = false;\n    }\n  }\n\n  /**\n   * Calculate optimal agent count based on SPARC phases\n   */\n  calculateOptimalAgentCount() {\n    const baseAgents = Object.keys(this.phases).length; // One per phase\n    const complexityMultiplier = this.assessTaskComplexity();\n    const parallelismFactor = this.options.parallelExecution ? 2 : 1;\n\n    return Math.min(20, Math.max(5, baseAgents * complexityMultiplier * parallelismFactor));\n  }\n\n  /**\n   * Assess task complexity for agent allocation\n   */\n  assessTaskComplexity() {\n    const taskDescription = this.options.taskDescription || '';\n    const complexityKeywords = [\n      'complex',\n      'enterprise',\n      'scalable',\n      'distributed',\n      'microservice',\n      'integration',\n    ];\n    const matchedKeywords = complexityKeywords.filter((keyword) =>\n      taskDescription.toLowerCase().includes(keyword),\n    );\n\n    if (matchedKeywords.length >= 3) return 3; // High complexity\n    if (matchedKeywords.length >= 1) return 2; // Medium complexity\n    return 1; // Low complexity\n  }\n\n  /**\n   * Spawn specialized SPARC agents\n   */\n  async spawnSparcAgents() {\n    const agentTypes = [\n      {\n        type: 'sparc_specification',\n        role: 'Requirements Analyst',\n        capabilities: ['analysis', 'documentation', 'validation'],\n      },\n      {\n        type: 'sparc_pseudocode',\n        role: 'Logic Designer',\n        capabilities: ['design', 'flowcharts', 'algorithms'],\n      },\n      {\n        type: 'sparc_architecture',\n        role: 'System Architect',\n        capabilities: ['architecture', 'design_patterns', 'scalability'],\n      },\n      {\n        type: 'sparc_refinement',\n        role: 'TDD Engineer',\n        capabilities: ['testing', 'refactoring', 'code_quality'],\n      },\n      {\n        type: 'sparc_completion',\n        role: 'Integration Specialist',\n        capabilities: ['integration', 'deployment', 'validation'],\n      },\n      {\n        type: 'sparc_coordinator',\n        role: 'SPARC Orchestrator',\n        capabilities: ['coordination', 'monitoring', 'optimization'],\n      },\n    ];\n\n    for (const agentSpec of agentTypes) {\n      try {\n        const agentId = await this.executeSwarmHook('agent_spawn', {\n          type: agentSpec.type,\n          role: agentSpec.role,\n          capabilities: agentSpec.capabilities,\n          maxConcurrentTasks: this.getAgentConcurrency(agentSpec.type),\n          specialization: 'sparc_methodology',\n        });\n\n        const agent = {\n          id: agentId,\n          type: agentSpec.type,\n          role: agentSpec.role,\n          capabilities: agentSpec.capabilities,\n          status: 'ready',\n          currentPhase: null,\n          assignedTasks: [],\n          performance: {\n            tasksCompleted: 0,\n            averageTime: 0,\n            qualityScore: 1.0,\n            efficiency: 1.0,\n          },\n        };\n\n        this.agents.push(agent);\n        console.log(`  ü§ñ Spawned ${agentSpec.role} (${agentSpec.type})`);\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Failed to spawn ${agentSpec.role}: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Get agent concurrency based on type\n   */\n  getAgentConcurrency(agentType) {\n    const concurrencyMap = {\n      sparc_specification: 2,\n      sparc_pseudocode: 1,\n      sparc_architecture: 3,\n      sparc_refinement: 4,\n      sparc_completion: 2,\n      sparc_coordinator: 1,\n    };\n\n    return concurrencyMap[agentType] || 2;\n  }\n\n  /**\n   * Setup phase coordination\n   */\n  async setupPhaseCoordination() {\n    // Map agents to phases\n    for (const agent of this.agents) {\n      const phaseName = agent.type.replace('sparc_', '');\n      if (this.phases[phaseName]) {\n        if (!this.phaseAgents.has(phaseName)) {\n          this.phaseAgents.set(phaseName, []);\n        }\n        this.phaseAgents.get(phaseName).push(agent);\n      }\n    }\n\n    // Setup phase dependencies\n    await this.executeSwarmHook('setup_dependencies', {\n      phases: Object.keys(this.phases),\n      dependencies: {\n        pseudocode: ['specification'],\n        architecture: ['specification', 'pseudocode'],\n        refinement: ['specification', 'pseudocode', 'architecture'],\n        completion: ['specification', 'pseudocode', 'architecture', 'refinement'],\n      },\n    });\n\n    // Setup quality gates between phases\n    await this.setupQualityGates();\n  }\n\n  /**\n   * Setup quality gates between phases\n   */\n  async setupQualityGates() {\n    const qualityGates = [\n      {\n        phase: 'specification',\n        criteria: ['requirements_complete', 'acceptance_criteria_defined'],\n        threshold: 0.9,\n      },\n      {\n        phase: 'pseudocode',\n        criteria: ['flow_diagram_complete', 'algorithms_defined'],\n        threshold: 0.85,\n      },\n      {\n        phase: 'architecture',\n        criteria: ['components_defined', 'patterns_selected'],\n        threshold: 0.85,\n      },\n      {\n        phase: 'refinement',\n        criteria: ['tests_passing', 'code_quality_acceptable'],\n        threshold: 0.8,\n      },\n      {\n        phase: 'completion',\n        criteria: ['validation_passed', 'deployment_successful'],\n        threshold: 0.9,\n      },\n    ];\n\n    for (const gate of qualityGates) {\n      await this.executeSwarmHook('register_quality_gate', gate);\n    }\n  }\n\n  /**\n   * Pre-phase coordination\n   */\n  async prePhase(phaseName) {\n    if (!this.swarmEnabled) return;\n\n    console.log(`üîÑ Pre-phase coordination: ${phaseName}`);\n\n    try {\n      // Load neural context for the phase\n      await this.loadNeuralContext(phaseName);\n\n      // Assign agents to phase\n      await this.assignAgentsToPhase(phaseName);\n\n      // Prepare phase environment\n      await this.preparePhaseEnvironment(phaseName);\n\n      // Store phase initiation in memory\n      await this.executeSwarmHook('memory_store', {\n        key: `sparc_phase_${phaseName}_start`,\n        value: {\n          timestamp: Date.now(),\n          agents: this.phaseAgents.get(phaseName)?.map((a) => a.id) || [],\n          neuralContext: this.neuralContext,\n        },\n      });\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Pre-phase coordination failed for ${phaseName}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Load neural context for phase\n   */\n  async loadNeuralContext(phaseName) {\n    try {\n      const neuralData = await this.executeSwarmHook('neural_load_context', {\n        phase: phaseName,\n        methodology: 'sparc',\n        taskType: this.classifyTaskType(),\n      });\n\n      this.neuralContext = {\n        phase: phaseName,\n        patterns: neuralData.patterns || [],\n        insights: neuralData.insights || [],\n        recommendations: neuralData.recommendations || [],\n        confidence: neuralData.confidence || 0.5,\n      };\n\n      console.log(\n        `üß† Neural context loaded for ${phaseName} (confidence: ${this.neuralContext.confidence.toFixed(2)})`,\n      );\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Neural context loading failed: ${error.message}`);\n      this.neuralContext = {\n        phase: phaseName,\n        patterns: [],\n        insights: [],\n        recommendations: [],\n        confidence: 0.5,\n      };\n    }\n  }\n\n  /**\n   * Classify task type for neural learning\n   */\n  classifyTaskType() {\n    const taskDescription = this.options.taskDescription || '';\n    const taskLower = taskDescription.toLowerCase();\n\n    if (taskLower.includes('api') || taskLower.includes('service')) return 'api_development';\n    if (taskLower.includes('ui') || taskLower.includes('frontend')) return 'frontend_development';\n    if (taskLower.includes('data') || taskLower.includes('database')) return 'data_management';\n    if (taskLower.includes('test') || taskLower.includes('testing')) return 'testing';\n    if (taskLower.includes('deploy') || taskLower.includes('infrastructure')) return 'deployment';\n\n    return 'general_development';\n  }\n\n  /**\n   * Assign agents to phase\n   */\n  async assignAgentsToPhase(phaseName) {\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\n\n    for (const agent of phaseAgents) {\n      agent.currentPhase = phaseName;\n      agent.status = 'assigned';\n\n      await this.executeSwarmHook('agent_assign', {\n        agentId: agent.id,\n        phase: phaseName,\n        priority: this.getPhasePriority(phaseName),\n        context: this.neuralContext,\n      });\n    }\n\n    // If no dedicated agents, assign general coordinator\n    if (phaseAgents.length === 0) {\n      const coordinator = this.agents.find((a) => a.type === 'sparc_coordinator');\n      if (coordinator) {\n        coordinator.currentPhase = phaseName;\n        coordinator.status = 'assigned';\n\n        await this.executeSwarmHook('agent_assign', {\n          agentId: coordinator.id,\n          phase: phaseName,\n          priority: this.getPhasePriority(phaseName),\n          context: this.neuralContext,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get phase priority for scheduling\n   */\n  getPhasePriority(phaseName) {\n    const priorities = {\n      specification: 5, // Highest priority\n      pseudocode: 4,\n      architecture: 4,\n      refinement: 3,\n      completion: 2,\n    };\n\n    return priorities[phaseName] || 1;\n  }\n\n  /**\n   * Prepare phase environment\n   */\n  async preparePhaseEnvironment(phaseName) {\n    // Create phase-specific workspace\n    await this.executeSwarmHook('create_workspace', {\n      phase: phaseName,\n      namespace: this.options.namespace || 'sparc',\n      isolation: true,\n    });\n\n    // Load previous phase artifacts\n    const dependencies = this.getPhaseDependencies(phaseName);\n    for (const dependency of dependencies) {\n      await this.executeSwarmHook('load_artifacts', {\n        fromPhase: dependency,\n        toPhase: phaseName,\n        artifactTypes: ['outputs', 'decisions', 'validations'],\n      });\n    }\n  }\n\n  /**\n   * Get phase dependencies\n   */\n  getPhaseDependencies(phaseName) {\n    const dependencies = {\n      specification: [],\n      pseudocode: ['specification'],\n      architecture: ['specification', 'pseudocode'],\n      refinement: ['specification', 'pseudocode', 'architecture'],\n      completion: ['specification', 'pseudocode', 'architecture', 'refinement'],\n    };\n\n    return dependencies[phaseName] || [];\n  }\n\n  /**\n   * Post-phase coordination\n   */\n  async postPhase(phaseName, result) {\n    if (!this.swarmEnabled) return;\n\n    console.log(`‚úÖ Post-phase coordination: ${phaseName}`);\n\n    try {\n      // Validate phase results\n      const validation = await this.validatePhaseResults(phaseName, result);\n\n      // Update agent performance\n      await this.updateAgentPerformance(phaseName, result, validation);\n\n      // Store phase completion in memory\n      await this.executeSwarmHook('memory_store', {\n        key: `sparc_phase_${phaseName}_complete`,\n        value: {\n          timestamp: Date.now(),\n          result: result,\n          validation: validation,\n          agents:\n            this.phaseAgents.get(phaseName)?.map((a) => ({\n              id: a.id,\n              performance: a.performance,\n            })) || [],\n        },\n      });\n\n      // Neural learning from phase execution\n      if (this.options.neuralLearning) {\n        await this.recordNeuralLearning(phaseName, result, validation);\n      }\n\n      // Prepare handoff to next phase\n      await this.preparePhaseHandoff(phaseName, result);\n\n      // Update metrics\n      this.updateCoordinationMetrics(phaseName, result, validation);\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Post-phase coordination failed for ${phaseName}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Validate phase results\n   */\n  async validatePhaseResults(phaseName, result) {\n    const validation = {\n      phase: phaseName,\n      passed: true,\n      score: 0,\n      issues: [],\n      recommendations: [],\n    };\n\n    try {\n      // Execute swarm-based validation\n      const swarmValidation = await this.executeSwarmHook('validate_phase', {\n        phase: phaseName,\n        result: result,\n        criteria: this.getValidationCriteria(phaseName),\n      });\n\n      validation.passed = swarmValidation.passed;\n      validation.score = swarmValidation.score;\n      validation.issues = swarmValidation.issues || [];\n      validation.recommendations = swarmValidation.recommendations || [];\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Swarm validation failed: ${error.message}`);\n      // Fallback to basic validation\n      validation.passed = !!result;\n      validation.score = result ? 85 : 0;\n    }\n\n    return validation;\n  }\n\n  /**\n   * Get validation criteria for phase\n   */\n  getValidationCriteria(phaseName) {\n    const criteria = {\n      specification: {\n        requiredFields: ['requirements', 'acceptanceCriteria', 'userStories'],\n        qualityThresholds: { completeness: 0.9, clarity: 0.8 },\n      },\n      pseudocode: {\n        requiredFields: ['flowDiagram', 'pseudocode', 'algorithms'],\n        qualityThresholds: { completeness: 0.85, complexity: 0.7 },\n      },\n      architecture: {\n        requiredFields: ['systemDesign', 'components', 'designPatterns'],\n        qualityThresholds: { modularity: 0.8, scalability: 0.75 },\n      },\n      refinement: {\n        requiredFields: ['testResults', 'codeQuality', 'implementations'],\n        qualityThresholds: { testCoverage: 0.8, codeQuality: 0.75 },\n      },\n      completion: {\n        requiredFields: ['validation', 'deployment', 'documentation'],\n        qualityThresholds: { completeness: 0.9, readiness: 0.85 },\n      },\n    };\n\n    return criteria[phaseName] || { requiredFields: [], qualityThresholds: {} };\n  }\n\n  /**\n   * Update agent performance metrics\n   */\n  async updateAgentPerformance(phaseName, result, validation) {\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\n\n    for (const agent of phaseAgents) {\n      agent.performance.tasksCompleted += 1;\n\n      // Update quality score based on validation\n      const qualityScore = validation.score / 100;\n      agent.performance.qualityScore = (agent.performance.qualityScore + qualityScore) / 2;\n\n      // Update efficiency based on execution time\n      const executionTime = Date.now() - this.getPhaseStartTime(phaseName);\n      const expectedTime = this.getExpectedPhaseTime(phaseName);\n      const efficiency = Math.min(1, expectedTime / executionTime);\n      agent.performance.efficiency = (agent.performance.efficiency + efficiency) / 2;\n\n      // Update average time\n      agent.performance.averageTime = (agent.performance.averageTime + executionTime) / 2;\n\n      // Store performance update\n      await this.executeSwarmHook('update_agent_performance', {\n        agentId: agent.id,\n        performance: agent.performance,\n        phase: phaseName,\n      });\n    }\n  }\n\n  /**\n   * Get phase start time\n   */\n  getPhaseStartTime(phaseName) {\n    // This would typically be stored in memory or agent state\n    return Date.now() - 5 * 60 * 1000; // Default to 5 minutes ago\n  }\n\n  /**\n   * Get expected phase execution time\n   */\n  getExpectedPhaseTime(phaseName) {\n    const expectedTimes = {\n      specification: 10 * 60 * 1000, // 10 minutes\n      pseudocode: 5 * 60 * 1000, // 5 minutes\n      architecture: 15 * 60 * 1000, // 15 minutes\n      refinement: 20 * 60 * 1000, // 20 minutes\n      completion: 10 * 60 * 1000, // 10 minutes\n    };\n\n    return expectedTimes[phaseName] || 10 * 60 * 1000;\n  }\n\n  /**\n   * Record neural learning from phase execution\n   */\n  async recordNeuralLearning(phaseName, result, validation) {\n    try {\n      const learningData = {\n        phase: phaseName,\n        taskType: this.classifyTaskType(),\n        methodology: 'sparc',\n        execution: {\n          result: result,\n          validation: validation,\n          timestamp: Date.now(),\n        },\n        context: {\n          taskDescription: this.options.taskDescription,\n          neuralContext: this.neuralContext,\n          agentPerformance: this.getAgentPerformanceData(phaseName),\n        },\n        outcomes: {\n          success: validation.passed,\n          quality: validation.score,\n          efficiency: this.calculatePhaseEfficiency(phaseName),\n          learnings: this.extractLearnings(phaseName, result, validation),\n        },\n      };\n\n      await this.executeSwarmHook('neural_record_learning', learningData);\n\n      // Train neural patterns based on this execution\n      await this.executeSwarmHook('neural_train', {\n        data: learningData,\n        updateWeights: true,\n        savePattern: true,\n      });\n\n      console.log(`üß† Neural learning recorded for ${phaseName}`);\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Neural learning failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get agent performance data for phase\n   */\n  getAgentPerformanceData(phaseName) {\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\n    return phaseAgents.map((agent) => ({\n      id: agent.id,\n      type: agent.type,\n      performance: agent.performance,\n    }));\n  }\n\n  /**\n   * Calculate phase efficiency\n   */\n  calculatePhaseEfficiency(phaseName) {\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\n    if (phaseAgents.length === 0) return 0.5;\n\n    const avgEfficiency =\n      phaseAgents.reduce((sum, agent) => sum + agent.performance.efficiency, 0) /\n      phaseAgents.length;\n    return avgEfficiency;\n  }\n\n  /**\n   * Extract learnings from phase execution\n   */\n  extractLearnings(phaseName, result, validation) {\n    const learnings = [];\n\n    if (validation.passed) {\n      learnings.push(`${phaseName} phase executed successfully`);\n      if (validation.score > 90) {\n        learnings.push(`High quality output achieved in ${phaseName}`);\n      }\n    } else {\n      learnings.push(`${phaseName} phase encountered issues: ${validation.issues.join(', ')}`);\n    }\n\n    if (validation.recommendations.length > 0) {\n      learnings.push(`Recommendations for ${phaseName}: ${validation.recommendations.join(', ')}`);\n    }\n\n    return learnings;\n  }\n\n  /**\n   * Prepare handoff to next phase\n   */\n  async preparePhaseHandoff(phaseName, result) {\n    const nextPhase = this.getNextPhase(phaseName);\n    if (!nextPhase) return;\n\n    // Prepare artifacts for next phase\n    await this.executeSwarmHook('prepare_handoff', {\n      fromPhase: phaseName,\n      toPhase: nextPhase,\n      artifacts: {\n        outputs: result,\n        decisions: this.extractDecisions(result),\n        context: this.neuralContext,\n      },\n    });\n\n    // Pre-warm next phase agents\n    const nextPhaseAgents = this.phaseAgents.get(nextPhase) || [];\n    for (const agent of nextPhaseAgents) {\n      await this.executeSwarmHook('agent_prewarm', {\n        agentId: agent.id,\n        phase: nextPhase,\n        context: result,\n      });\n    }\n  }\n\n  /**\n   * Get next phase in SPARC sequence\n   */\n  getNextPhase(currentPhase) {\n    const sequence = ['specification', 'pseudocode', 'architecture', 'refinement', 'completion'];\n    const currentIndex = sequence.indexOf(currentPhase);\n    return currentIndex >= 0 && currentIndex < sequence.length - 1\n      ? sequence[currentIndex + 1]\n      : null;\n  }\n\n  /**\n   * Extract decisions from phase result\n   */\n  extractDecisions(result) {\n    const decisions = [];\n\n    if (result.architecturalDecisions) {\n      decisions.push(...result.architecturalDecisions);\n    }\n\n    if (result.designDecisions) {\n      decisions.push(...result.designDecisions);\n    }\n\n    if (result.qualityGates) {\n      decisions.push(\n        ...result.qualityGates.map((gate) => ({\n          decision: `Quality gate: ${gate.name}`,\n          rationale: gate.rationale || 'Quality assurance',\n          impact: gate.impact || 'process',\n        })),\n      );\n    }\n\n    return decisions;\n  }\n\n  /**\n   * Update coordination metrics\n   */\n  updateCoordinationMetrics(phaseName, result, validation) {\n    this.metrics.phaseExecutions += 1;\n\n    // Update agent utilization\n    const phaseAgents = this.phaseAgents.get(phaseName) || [];\n    for (const agent of phaseAgents) {\n      if (!this.metrics.agentUtilization[agent.id]) {\n        this.metrics.agentUtilization[agent.id] = { phases: 0, totalTime: 0, quality: 0 };\n      }\n      this.metrics.agentUtilization[agent.id].phases += 1;\n      this.metrics.agentUtilization[agent.id].quality += validation.score;\n    }\n\n    // Update coordination efficiency\n    const efficiency = this.calculatePhaseEfficiency(phaseName);\n    this.metrics.coordinationEfficiency = (this.metrics.coordinationEfficiency + efficiency) / 2;\n\n    // Record quality gate\n    this.metrics.qualityGates.push({\n      phase: phaseName,\n      passed: validation.passed,\n      score: validation.score,\n      timestamp: Date.now(),\n    });\n\n    // Record learning data\n    if (validation.passed) {\n      this.metrics.learningData.push({\n        phase: phaseName,\n        success: true,\n        quality: validation.score,\n        patterns: this.neuralContext?.patterns || [],\n      });\n    }\n  }\n\n  /**\n   * Finalize coordination\n   */\n  async finalize() {\n    if (!this.swarmEnabled) return;\n\n    console.log('üèÅ Finalizing SPARC coordination');\n\n    try {\n      // Generate coordination report\n      const report = await this.generateCoordinationReport();\n\n      // Store final metrics\n      await this.executeSwarmHook('memory_store', {\n        key: 'sparc_coordination_final',\n        value: {\n          metrics: this.metrics,\n          report: report,\n          timestamp: Date.now(),\n        },\n      });\n\n      // Shutdown agents\n      for (const agent of this.agents) {\n        await this.executeSwarmHook('agent_shutdown', {\n          agentId: agent.id,\n          graceful: true,\n        });\n      }\n\n      // Shutdown swarm\n      await this.executeSwarmHook('swarm_shutdown', {\n        swarmId: this.swarmId,\n        preserveData: true,\n      });\n\n      console.log('‚úÖ SPARC coordination finalized');\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Coordination finalization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate coordination report\n   */\n  async generateCoordinationReport() {\n    const report = {\n      summary: {\n        phasesExecuted: this.metrics.phaseExecutions,\n        agentsUtilized: Object.keys(this.metrics.agentUtilization).length,\n        coordinationEfficiency: this.metrics.coordinationEfficiency,\n        qualityGatesPassed: this.metrics.qualityGates.filter((g) => g.passed).length,\n        totalQualityGates: this.metrics.qualityGates.length,\n      },\n      agentPerformance: this.calculateAgentPerformanceSummary(),\n      phaseAnalysis: this.analyzePhasePerformance(),\n      recommendations: this.generateRecommendations(),\n      neuralInsights: this.extractNeuralInsights(),\n    };\n\n    return report;\n  }\n\n  /**\n   * Calculate agent performance summary\n   */\n  calculateAgentPerformanceSummary() {\n    const summary = {};\n\n    for (const agent of this.agents) {\n      summary[agent.id] = {\n        type: agent.type,\n        role: agent.role,\n        tasksCompleted: agent.performance.tasksCompleted,\n        averageQuality: agent.performance.qualityScore,\n        efficiency: agent.performance.efficiency,\n        averageTime: agent.performance.averageTime,\n      };\n    }\n\n    return summary;\n  }\n\n  /**\n   * Analyze phase performance\n   */\n  analyzePhasePerformance() {\n    const analysis = {};\n\n    for (const gate of this.metrics.qualityGates) {\n      if (!analysis[gate.phase]) {\n        analysis[gate.phase] = {\n          executions: 0,\n          passed: 0,\n          averageScore: 0,\n          totalScore: 0,\n        };\n      }\n\n      analysis[gate.phase].executions += 1;\n      if (gate.passed) analysis[gate.phase].passed += 1;\n      analysis[gate.phase].totalScore += gate.score;\n    }\n\n    // Calculate averages\n    for (const phase of Object.keys(analysis)) {\n      analysis[phase].averageScore = analysis[phase].totalScore / analysis[phase].executions;\n      analysis[phase].successRate = analysis[phase].passed / analysis[phase].executions;\n    }\n\n    return analysis;\n  }\n\n  /**\n   * Generate recommendations for improvement\n   */\n  generateRecommendations() {\n    const recommendations = [];\n\n    // Analyze agent utilization\n    const avgUtilization =\n      Object.values(this.metrics.agentUtilization).reduce((sum, agent) => sum + agent.phases, 0) /\n      Object.keys(this.metrics.agentUtilization).length;\n\n    if (avgUtilization < 2) {\n      recommendations.push('Consider reducing agent count for better utilization');\n    } else if (avgUtilization > 4) {\n      recommendations.push('Consider increasing agent count to distribute load');\n    }\n\n    // Analyze coordination efficiency\n    if (this.metrics.coordinationEfficiency < 0.7) {\n      recommendations.push('Improve coordination efficiency through better task decomposition');\n    }\n\n    // Analyze quality gates\n    const qualityGateSuccess =\n      this.metrics.qualityGates.filter((g) => g.passed).length / this.metrics.qualityGates.length;\n    if (qualityGateSuccess < 0.8) {\n      recommendations.push('Review quality gate criteria and provide additional agent training');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Extract neural insights\n   */\n  extractNeuralInsights() {\n    const insights = [];\n\n    // Pattern analysis\n    const successfulPatterns = this.metrics.learningData.filter((d) => d.success);\n    if (successfulPatterns.length > 0) {\n      insights.push(`${successfulPatterns.length} successful execution patterns identified`);\n    }\n\n    // Quality analysis\n    const avgQuality =\n      this.metrics.learningData.reduce((sum, d) => sum + d.quality, 0) /\n      this.metrics.learningData.length;\n    if (avgQuality > 85) {\n      insights.push('High quality outcomes consistently achieved');\n    } else if (avgQuality < 70) {\n      insights.push('Quality improvements needed in execution');\n    }\n\n    return insights;\n  }\n\n  /**\n   * Execute swarm hook with error handling\n   */\n  async executeSwarmHook(hookName, data = {}) {\n    if (!this.swarmEnabled) {\n      throw new Error('Swarm not enabled');\n    }\n\n    try {\n      const { spawn } = await import('child_process');\n\n      return new Promise((resolve, reject) => {\n        const args = ['ruv-swarm', 'hook', hookName];\n\n        // Add data as JSON argument\n        if (Object.keys(data).length > 0) {\n          args.push('--data', JSON.stringify(data));\n        }\n\n        const process = spawn('npx', args, {\n          stdio: 'pipe',\n        });\n\n        let output = '';\n        let error = '';\n\n        process.stdout.on('data', (data) => {\n          output += data.toString();\n        });\n\n        process.stderr.on('data', (data) => {\n          error += data.toString();\n        });\n\n        process.on('close', (code) => {\n          if (code === 0) {\n            try {\n              const result = JSON.parse(output);\n              resolve(result);\n            } catch (parseError) {\n              resolve(output.trim());\n            }\n          } else {\n            reject(new Error(`Hook ${hookName} failed: ${error}`));\n          }\n        });\n\n        process.on('error', (err) => {\n          reject(err);\n        });\n      });\n    } catch (error) {\n      throw new Error(`Failed to execute swarm hook ${hookName}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Record learning from SPARC execution\n   */\n  async recordLearning(learningData) {\n    if (!this.options.neuralLearning) return;\n\n    try {\n      await this.executeSwarmHook('neural_record_learning', {\n        methodology: 'sparc',\n        data: learningData,\n        timestamp: Date.now(),\n      });\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Failed to record learning: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get coordination status\n   */\n  getStatus() {\n    return {\n      swarmEnabled: this.swarmEnabled,\n      swarmId: this.swarmId,\n      agentCount: this.agents.length,\n      phaseAgents: Object.fromEntries(\n        Array.from(this.phaseAgents.entries()).map(([phase, agents]) => [\n          phase,\n          agents.map((a) => ({ id: a.id, type: a.type, status: a.status })),\n        ]),\n      ),\n      metrics: this.metrics,\n      coordination: this.coordination,\n    };\n  }\n}\n\nexport default SparcCoordinator;\n"],"names":["SparcCoordinator","phases","options","swarmId","agents","phaseAgents","Map","coordination","strategy","topology","communication","loadBalancing","metrics","phaseExecutions","agentUtilization","coordinationEfficiency","qualityGates","learningData","neuralContext","swarmEnabled","initializeSwarm","console","log","swarmConfig","maxAgents","calculateOptimalAgentCount","executeSwarmHook","spawnSparcAgents","setupPhaseCoordination","error","warn","message","baseAgents","Object","keys","length","complexityMultiplier","assessTaskComplexity","parallelismFactor","parallelExecution","Math","min","max","taskDescription","complexityKeywords","matchedKeywords","filter","keyword","toLowerCase","includes","agentTypes","type","role","capabilities","agentSpec","agentId","maxConcurrentTasks","getAgentConcurrency","specialization","agent","id","status","currentPhase","assignedTasks","performance","tasksCompleted","averageTime","qualityScore","efficiency","push","agentType","concurrencyMap","sparc_specification","sparc_pseudocode","sparc_architecture","sparc_refinement","sparc_completion","sparc_coordinator","phaseName","replace","has","set","get","dependencies","pseudocode","architecture","refinement","completion","setupQualityGates","phase","criteria","threshold","gate","prePhase","loadNeuralContext","assignAgentsToPhase","preparePhaseEnvironment","key","value","timestamp","Date","now","map","a","neuralData","methodology","taskType","classifyTaskType","patterns","insights","recommendations","confidence","toFixed","taskLower","priority","getPhasePriority","context","coordinator","find","priorities","specification","namespace","isolation","getPhaseDependencies","dependency","fromPhase","toPhase","artifactTypes","postPhase","result","validation","validatePhaseResults","updateAgentPerformance","neuralLearning","recordNeuralLearning","preparePhaseHandoff","updateCoordinationMetrics","passed","score","issues","swarmValidation","getValidationCriteria","requiredFields","qualityThresholds","completeness","clarity","complexity","modularity","scalability","testCoverage","codeQuality","readiness","executionTime","getPhaseStartTime","expectedTime","getExpectedPhaseTime","expectedTimes","execution","agentPerformance","getAgentPerformanceData","outcomes","success","quality","calculatePhaseEfficiency","learnings","extractLearnings","data","updateWeights","savePattern","avgEfficiency","reduce","sum","join","nextPhase","getNextPhase","artifacts","outputs","decisions","extractDecisions","nextPhaseAgents","sequence","currentIndex","indexOf","architecturalDecisions","designDecisions","decision","name","rationale","impact","totalTime","finalize","report","generateCoordinationReport","graceful","preserveData","summary","phasesExecuted","agentsUtilized","qualityGatesPassed","g","totalQualityGates","calculateAgentPerformanceSummary","phaseAnalysis","analyzePhasePerformance","generateRecommendations","neuralInsights","extractNeuralInsights","averageQuality","analysis","executions","averageScore","totalScore","successRate","avgUtilization","values","qualityGateSuccess","successfulPatterns","d","avgQuality","hookName","Error","spawn","Promise","resolve","reject","args","JSON","stringify","process","stdio","output","stdout","on","toString","stderr","code","parse","parseError","trim","err","recordLearning","getStatus","agentCount","fromEntries","Array","from","entries"],"mappings":"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"}