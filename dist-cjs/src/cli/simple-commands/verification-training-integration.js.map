{"version":3,"sources":["../../../../src/cli/simple-commands/verification-training-integration.js"],"sourcesContent":["/**\n * Verification-Training Integration Module\n * Connects verification results to the neural training system for continuous improvement\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { execSync } from 'child_process';\n\n/**\n * Integration between Verification and Training Systems\n * Feeds verification results into training to improve agent performance\n */\nexport class VerificationTrainingIntegration {\n  constructor() {\n    this.trainingDataPath = '.claude-flow/training/verification-data.jsonl';\n    this.modelPath = '.claude-flow/models/verification-model.json';\n    this.metricsPath = '.claude-flow/metrics/agent-performance.json';\n    this.learningRate = 0.1;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the integration\n   */\n  async initialize() {\n    // Ensure directories exist\n    const dirs = [\n      '.claude-flow/training',\n      '.claude-flow/models',\n      '.claude-flow/metrics'\n    ];\n    \n    for (const dir of dirs) {\n      await fs.mkdir(dir, { recursive: true });\n    }\n\n    // Load or create model\n    await this.loadModel();\n    this.initialized = true;\n    \n    console.log('✅ Verification-Training integration initialized');\n  }\n\n  /**\n   * Feed verification results to training system\n   */\n  async feedVerificationToTraining(verification) {\n    if (!this.initialized) await this.initialize();\n\n    // Extract training features from verification\n    const trainingData = {\n      input: {\n        taskId: verification.taskId,\n        agentType: verification.agentType,\n        timestamp: verification.timestamp,\n        mode: verification.mode || 'moderate',\n        checksPerformed: verification.results?.map(r => r.name) || []\n      },\n      output: {\n        score: verification.score,\n        passed: verification.passed,\n        threshold: verification.threshold\n      },\n      metadata: {\n        sessionId: process.env.SESSION_ID || 'default',\n        timestamp: new Date().toISOString()\n      }\n    };\n\n    // Append to training data\n    await this.appendTrainingData(trainingData);\n\n    // Update agent-specific model\n    await this.updateAgentModel(verification.agentType, verification);\n\n    // Trigger incremental learning\n    await this.incrementalLearn(trainingData);\n\n    // Update performance metrics\n    await this.updatePerformanceMetrics(verification);\n\n    return trainingData;\n  }\n\n  /**\n   * Incremental learning from new verification data\n   */\n  async incrementalLearn(trainingData) {\n    const model = await this.loadModel();\n    \n    // Update agent reliability scores\n    const agentType = trainingData.input.agentType;\n    if (!model.agentReliability) model.agentReliability = {};\n    \n    const currentReliability = model.agentReliability[agentType] || 0.5;\n    const newScore = trainingData.output.score;\n    \n    // Exponential moving average for reliability\n    model.agentReliability[agentType] = \n      currentReliability * (1 - this.learningRate) + newScore * this.learningRate;\n\n    // Update verification patterns\n    if (!model.patterns) model.patterns = {};\n    const patternKey = `${agentType}_${trainingData.output.passed ? 'success' : 'failure'}`;\n    \n    if (!model.patterns[patternKey]) {\n      model.patterns[patternKey] = {\n        count: 0,\n        avgScore: 0,\n        checks: {}\n      };\n    }\n\n    const pattern = model.patterns[patternKey];\n    pattern.count++;\n    pattern.avgScore = (pattern.avgScore * (pattern.count - 1) + newScore) / pattern.count;\n\n    // Track which checks lead to success/failure\n    for (const check of trainingData.input.checksPerformed) {\n      if (!pattern.checks[check]) {\n        pattern.checks[check] = { success: 0, failure: 0 };\n      }\n      pattern.checks[check][trainingData.output.passed ? 'success' : 'failure']++;\n    }\n\n    // Save updated model\n    await this.saveModel(model);\n\n    // Log learning progress\n    console.log(`📊 Learning update for ${agentType}: reliability ${model.agentReliability[agentType].toFixed(3)}`);\n  }\n\n  /**\n   * Predict verification outcome based on historical data\n   */\n  async predictVerificationOutcome(taskType, agentType) {\n    const model = await this.loadModel();\n    \n    // Get agent reliability\n    const reliability = model.agentReliability?.[agentType] || 0.5;\n    \n    // Get pattern statistics\n    const successPattern = model.patterns?.[`${agentType}_success`];\n    const failurePattern = model.patterns?.[`${agentType}_failure`];\n    \n    if (!successPattern && !failurePattern) {\n      return {\n        predictedScore: reliability,\n        confidence: 0.1,\n        recommendation: 'insufficient_data'\n      };\n    }\n\n    // Calculate prediction\n    const totalCount = (successPattern?.count || 0) + (failurePattern?.count || 0);\n    const successRate = (successPattern?.count || 0) / totalCount;\n    \n    const predictedScore = reliability * 0.7 + successRate * 0.3;\n    const confidence = Math.min(totalCount / 100, 1.0); // Confidence increases with data\n\n    // Generate recommendation\n    let recommendation = 'proceed';\n    if (predictedScore < 0.5) {\n      recommendation = 'use_different_agent';\n    } else if (predictedScore < 0.75) {\n      recommendation = 'add_additional_checks';\n    } else if (confidence < 0.3) {\n      recommendation = 'low_confidence_proceed_with_caution';\n    }\n\n    return {\n      predictedScore,\n      confidence,\n      recommendation,\n      agentReliability: reliability,\n      historicalSuccessRate: successRate,\n      dataPoints: totalCount\n    };\n  }\n\n  /**\n   * Get agent recommendations based on task type\n   */\n  async recommendAgent(taskType) {\n    const model = await this.loadModel();\n    \n    if (!model.agentReliability) {\n      return {\n        recommended: 'coder', // Default\n        reason: 'no_historical_data'\n      };\n    }\n\n    // Sort agents by reliability\n    const agents = Object.entries(model.agentReliability)\n      .sort(([, a], [, b]) => b - a);\n\n    if (agents.length === 0) {\n      return {\n        recommended: 'coder',\n        reason: 'no_agent_data'\n      };\n    }\n\n    const [bestAgent, bestScore] = agents[0];\n    \n    return {\n      recommended: bestAgent,\n      reliability: bestScore,\n      alternatives: agents.slice(1, 3).map(([agent, score]) => ({\n        agent,\n        reliability: score\n      })),\n      reason: `highest_reliability_score`\n    };\n  }\n\n  /**\n   * Update agent-specific model\n   */\n  async updateAgentModel(agentType, verification) {\n    const modelFile = `.claude-flow/models/agent-${agentType}.json`;\n    \n    let agentModel = {};\n    try {\n      const data = await fs.readFile(modelFile, 'utf8');\n      agentModel = JSON.parse(data);\n    } catch {\n      agentModel = {\n        agentType,\n        totalTasks: 0,\n        successfulTasks: 0,\n        averageScore: 0,\n        scoreHistory: [],\n        checkPerformance: {}\n      };\n    }\n\n    // Update statistics\n    agentModel.totalTasks++;\n    if (verification.passed) agentModel.successfulTasks++;\n    \n    // Update average score\n    agentModel.averageScore = \n      (agentModel.averageScore * (agentModel.totalTasks - 1) + verification.score) / \n      agentModel.totalTasks;\n\n    // Keep last 100 scores for trend analysis\n    agentModel.scoreHistory.push({\n      score: verification.score,\n      timestamp: verification.timestamp,\n      passed: verification.passed\n    });\n    if (agentModel.scoreHistory.length > 100) {\n      agentModel.scoreHistory = agentModel.scoreHistory.slice(-100);\n    }\n\n    // Track performance by check type\n    if (verification.results) {\n      for (const result of verification.results) {\n        if (!agentModel.checkPerformance[result.name]) {\n          agentModel.checkPerformance[result.name] = {\n            total: 0,\n            passed: 0,\n            avgScore: 0\n          };\n        }\n        \n        const checkPerf = agentModel.checkPerformance[result.name];\n        checkPerf.total++;\n        if (result.passed) checkPerf.passed++;\n        checkPerf.avgScore = \n          (checkPerf.avgScore * (checkPerf.total - 1) + result.score) / checkPerf.total;\n      }\n    }\n\n    // Calculate performance trend (last 10 vs previous 10)\n    if (agentModel.scoreHistory.length >= 20) {\n      const recent10 = agentModel.scoreHistory.slice(-10);\n      const previous10 = agentModel.scoreHistory.slice(-20, -10);\n      \n      const recentAvg = recent10.reduce((sum, h) => sum + h.score, 0) / 10;\n      const previousAvg = previous10.reduce((sum, h) => sum + h.score, 0) / 10;\n      \n      agentModel.trend = {\n        direction: recentAvg > previousAvg ? 'improving' : 'declining',\n        change: recentAvg - previousAvg,\n        recentAverage: recentAvg,\n        previousAverage: previousAvg\n      };\n    }\n\n    // Save agent model\n    await fs.writeFile(modelFile, JSON.stringify(agentModel, null, 2));\n\n    // Log if agent is improving or declining\n    if (agentModel.trend) {\n      const emoji = agentModel.trend.direction === 'improving' ? '📈' : '📉';\n      console.log(`${emoji} Agent ${agentType} is ${agentModel.trend.direction} (${agentModel.trend.change > 0 ? '+' : ''}${agentModel.trend.change.toFixed(3)})`);\n    }\n\n    return agentModel;\n  }\n\n  /**\n   * Generate training recommendations\n   */\n  async generateTrainingRecommendations() {\n    const model = await this.loadModel();\n    const recommendations = [];\n\n    // Check agent reliability\n    if (model.agentReliability) {\n      for (const [agent, reliability] of Object.entries(model.agentReliability)) {\n        if (reliability < 0.7) {\n          recommendations.push({\n            type: 'retrain_agent',\n            agent,\n            currentReliability: reliability,\n            action: `Retrain ${agent} agent - reliability below 70%`\n          });\n        }\n      }\n    }\n\n    // Check patterns\n    if (model.patterns) {\n      for (const [pattern, data] of Object.entries(model.patterns)) {\n        if (pattern.includes('failure') && data.count > 10) {\n          const [agentType] = pattern.split('_');\n          \n          // Find most common failing checks\n          const failingChecks = Object.entries(data.checks || {})\n            .filter(([, stats]) => stats.failure > stats.success)\n            .map(([check]) => check);\n\n          if (failingChecks.length > 0) {\n            recommendations.push({\n              type: 'improve_checks',\n              agent: agentType,\n              checks: failingChecks,\n              action: `Focus training on ${failingChecks.join(', ')} for ${agentType}`\n            });\n          }\n        }\n      }\n    }\n\n    // Check if we need more data\n    const totalDataPoints = Object.values(model.patterns || {})\n      .reduce((sum, p) => sum + p.count, 0);\n    \n    if (totalDataPoints < 50) {\n      recommendations.push({\n        type: 'collect_more_data',\n        currentDataPoints: totalDataPoints,\n        action: 'Run more verification cycles to improve training accuracy'\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Update performance metrics\n   */\n  async updatePerformanceMetrics(verification) {\n    let metrics = {};\n    \n    try {\n      const data = await fs.readFile(this.metricsPath, 'utf8');\n      metrics = JSON.parse(data);\n    } catch {\n      metrics = {\n        totalVerifications: 0,\n        passedVerifications: 0,\n        averageScore: 0,\n        byAgent: {},\n        byHour: {},\n        created: new Date().toISOString()\n      };\n    }\n\n    // Update totals\n    metrics.totalVerifications++;\n    if (verification.passed) metrics.passedVerifications++;\n    metrics.averageScore = \n      (metrics.averageScore * (metrics.totalVerifications - 1) + verification.score) / \n      metrics.totalVerifications;\n\n    // Update by agent\n    if (!metrics.byAgent[verification.agentType]) {\n      metrics.byAgent[verification.agentType] = {\n        total: 0,\n        passed: 0,\n        avgScore: 0\n      };\n    }\n    \n    const agentMetrics = metrics.byAgent[verification.agentType];\n    agentMetrics.total++;\n    if (verification.passed) agentMetrics.passed++;\n    agentMetrics.avgScore = \n      (agentMetrics.avgScore * (agentMetrics.total - 1) + verification.score) / \n      agentMetrics.total;\n\n    // Update by hour (for pattern detection)\n    const hour = new Date().getHours();\n    if (!metrics.byHour[hour]) {\n      metrics.byHour[hour] = {\n        total: 0,\n        avgScore: 0\n      };\n    }\n    \n    metrics.byHour[hour].total++;\n    metrics.byHour[hour].avgScore = \n      (metrics.byHour[hour].avgScore * (metrics.byHour[hour].total - 1) + verification.score) / \n      metrics.byHour[hour].total;\n\n    metrics.lastUpdated = new Date().toISOString();\n\n    await fs.writeFile(this.metricsPath, JSON.stringify(metrics, null, 2));\n    return metrics;\n  }\n\n  /**\n   * Train neural network for pattern recognition\n   */\n  async trainNeuralPatterns() {\n    console.log('🧠 Training neural patterns from verification data...');\n    \n    try {\n      // Call the training command\n      const result = execSync(\n        'npx claude-flow training neural-train --data .claude-flow/training/verification-data.jsonl --model verification-predictor --epochs 100',\n        { encoding: 'utf8', stdio: 'pipe' }\n      );\n      \n      console.log('✅ Neural training completed');\n      return { success: true, output: result };\n    } catch (error) {\n      console.error('❌ Neural training failed:', error.message);\n      return { success: false, error: error.message };\n    }\n  }\n\n  // Helper methods\n\n  async appendTrainingData(data) {\n    const line = JSON.stringify(data) + '\\n';\n    await fs.appendFile(this.trainingDataPath, line);\n  }\n\n  async loadModel() {\n    try {\n      const data = await fs.readFile(this.modelPath, 'utf8');\n      return JSON.parse(data);\n    } catch {\n      return {\n        version: '1.0.0',\n        created: new Date().toISOString(),\n        agentReliability: {},\n        patterns: {},\n        checkWeights: {}\n      };\n    }\n  }\n\n  async saveModel(model) {\n    model.lastUpdated = new Date().toISOString();\n    await fs.writeFile(this.modelPath, JSON.stringify(model, null, 2));\n  }\n\n  /**\n   * Get training status and statistics\n   */\n  async getTrainingStatus() {\n    const model = await this.loadModel();\n    const metrics = await this.loadMetrics();\n    \n    // Count training data\n    let trainingDataCount = 0;\n    try {\n      const data = await fs.readFile(this.trainingDataPath, 'utf8');\n      trainingDataCount = data.split('\\n').filter(line => line.trim()).length;\n    } catch {\n      // File doesn't exist\n    }\n\n    return {\n      modelVersion: model.version,\n      lastUpdated: model.lastUpdated,\n      trainingDataPoints: trainingDataCount,\n      agentReliability: model.agentReliability,\n      totalVerifications: metrics.totalVerifications || 0,\n      averageScore: metrics.averageScore || 0,\n      passRate: metrics.totalVerifications > 0 \n        ? metrics.passedVerifications / metrics.totalVerifications \n        : 0,\n      agentPerformance: metrics.byAgent || {},\n      recommendations: await this.generateTrainingRecommendations()\n    };\n  }\n\n  async loadMetrics() {\n    try {\n      const data = await fs.readFile(this.metricsPath, 'utf8');\n      return JSON.parse(data);\n    } catch {\n      return {};\n    }\n  }\n}\n\n/**\n * CLI integration for verification-training\n */\nexport async function verificationTrainingCommand(args, flags) {\n  const integration = new VerificationTrainingIntegration();\n  await integration.initialize();\n\n  const subcommand = args[0] || 'status';\n\n  switch (subcommand) {\n    case 'feed':\n      // Feed current verification data to training\n      const verificationFile = '.swarm/verification-memory.json';\n      try {\n        const data = await fs.readFile(verificationFile, 'utf8');\n        const memory = JSON.parse(data);\n        \n        if (memory.history && memory.history.length > 0) {\n          console.log(`📊 Feeding ${memory.history.length} verification records to training...`);\n          \n          for (const verification of memory.history) {\n            await integration.feedVerificationToTraining(verification);\n          }\n          \n          console.log('✅ Training data updated');\n        } else {\n          console.log('No verification history to feed');\n        }\n      } catch (error) {\n        console.error('Error reading verification data:', error.message);\n      }\n      break;\n\n    case 'predict':\n      // Predict verification outcome\n      const taskType = args[1] || 'default';\n      const agentType = args[2] || 'coder';\n      \n      const prediction = await integration.predictVerificationOutcome(taskType, agentType);\n      console.log('\\n🔮 Verification Prediction:');\n      console.log(`   Predicted Score: ${prediction.predictedScore.toFixed(3)}`);\n      console.log(`   Confidence: ${(prediction.confidence * 100).toFixed(1)}%`);\n      console.log(`   Recommendation: ${prediction.recommendation}`);\n      console.log(`   Historical Success Rate: ${(prediction.historicalSuccessRate * 100).toFixed(1)}%`);\n      console.log(`   Data Points: ${prediction.dataPoints}`);\n      break;\n\n    case 'recommend':\n      // Get agent recommendation\n      const task = args[1] || 'default';\n      const recommendation = await integration.recommendAgent(task);\n      \n      console.log('\\n🤖 Agent Recommendation:');\n      console.log(`   Recommended: ${recommendation.recommended}`);\n      console.log(`   Reliability: ${(recommendation.reliability * 100).toFixed(1)}%`);\n      console.log(`   Reason: ${recommendation.reason}`);\n      \n      if (recommendation.alternatives && recommendation.alternatives.length > 0) {\n        console.log('   Alternatives:');\n        for (const alt of recommendation.alternatives) {\n          console.log(`     • ${alt.agent}: ${(alt.reliability * 100).toFixed(1)}%`);\n        }\n      }\n      break;\n\n    case 'train':\n      // Trigger neural training\n      await integration.trainNeuralPatterns();\n      break;\n\n    case 'recommendations':\n      // Get training recommendations\n      const recs = await integration.generateTrainingRecommendations();\n      \n      console.log('\\n💡 Training Recommendations:');\n      if (recs.length === 0) {\n        console.log('   No recommendations at this time');\n      } else {\n        for (const rec of recs) {\n          console.log(`   • ${rec.action}`);\n        }\n      }\n      break;\n\n    case 'status':\n    default:\n      // Show training status\n      const status = await integration.getTrainingStatus();\n      \n      console.log('\\n📊 Verification-Training Status');\n      console.log('━'.repeat(50));\n      console.log(`Model Version: ${status.modelVersion}`);\n      console.log(`Last Updated: ${status.lastUpdated || 'Never'}`);\n      console.log(`Training Data Points: ${status.trainingDataPoints}`);\n      console.log(`Total Verifications: ${status.totalVerifications}`);\n      console.log(`Average Score: ${status.averageScore.toFixed(3)}`);\n      console.log(`Pass Rate: ${(status.passRate * 100).toFixed(1)}%`);\n      \n      if (Object.keys(status.agentReliability).length > 0) {\n        console.log('\\n🤖 Agent Reliability:');\n        for (const [agent, reliability] of Object.entries(status.agentReliability)) {\n          console.log(`   ${agent}: ${(reliability * 100).toFixed(1)}%`);\n        }\n      }\n      \n      if (status.recommendations.length > 0) {\n        console.log('\\n💡 Recommendations:');\n        for (const rec of status.recommendations) {\n          console.log(`   • ${rec.action}`);\n        }\n      }\n      \n      console.log('\\n📚 Commands:');\n      console.log('   feed        - Feed verification data to training');\n      console.log('   predict     - Predict verification outcome');\n      console.log('   recommend   - Get agent recommendation');\n      console.log('   train       - Trigger neural training');\n      console.log('   status      - Show training status');\n      break;\n  }\n}\n\n// Export for use in other modules\nexport default {\n  VerificationTrainingIntegration,\n  verificationTrainingCommand\n};"],"names":["fs","execSync","VerificationTrainingIntegration","trainingDataPath","modelPath","metricsPath","learningRate","initialized","initialize","dirs","dir","mkdir","recursive","loadModel","console","log","feedVerificationToTraining","verification","trainingData","input","taskId","agentType","timestamp","mode","checksPerformed","results","map","r","name","output","score","passed","threshold","metadata","sessionId","process","env","SESSION_ID","Date","toISOString","appendTrainingData","updateAgentModel","incrementalLearn","updatePerformanceMetrics","model","agentReliability","currentReliability","newScore","patterns","patternKey","count","avgScore","checks","pattern","check","success","failure","saveModel","toFixed","predictVerificationOutcome","taskType","reliability","successPattern","failurePattern","predictedScore","confidence","recommendation","totalCount","successRate","Math","min","historicalSuccessRate","dataPoints","recommendAgent","recommended","reason","agents","Object","entries","sort","a","b","length","bestAgent","bestScore","alternatives","slice","agent","modelFile","agentModel","data","readFile","JSON","parse","totalTasks","successfulTasks","averageScore","scoreHistory","checkPerformance","push","result","total","checkPerf","recent10","previous10","recentAvg","reduce","sum","h","previousAvg","trend","direction","change","recentAverage","previousAverage","writeFile","stringify","emoji","generateTrainingRecommendations","recommendations","type","action","includes","split","failingChecks","filter","stats","join","totalDataPoints","values","p","currentDataPoints","metrics","totalVerifications","passedVerifications","byAgent","byHour","created","agentMetrics","hour","getHours","lastUpdated","trainNeuralPatterns","encoding","stdio","error","message","line","appendFile","version","checkWeights","getTrainingStatus","loadMetrics","trainingDataCount","trim","modelVersion","trainingDataPoints","passRate","agentPerformance","verificationTrainingCommand","args","flags","integration","subcommand","verificationFile","memory","history","prediction","task","alt","recs","rec","status","repeat","keys"],"mappings":"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"}