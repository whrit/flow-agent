{"version":3,"sources":["../../../../../src/cli/simple-commands/init/gitignore-updater.js"],"sourcesContent":["/**\n * GitIgnore updater for Claude Flow initialization\n * Ensures Claude Flow generated files are properly ignored\n */\n\nimport { existsSync, readTextFile, writeTextFile } from '../../node-compat.js';\n\n/**\n * Default gitignore entries for Claude Flow\n */\nconst CLAUDE_FLOW_GITIGNORE_ENTRIES = `\n# Claude Flow generated files\n.claude/settings.local.json\n.mcp.json\nclaude-flow.config.json\n.swarm/\n.hive-mind/\n.claude-flow/\nmemory/\ncoordination/\nmemory/claude-flow-data.json\nmemory/sessions/*\n!memory/sessions/README.md\nmemory/agents/*\n!memory/agents/README.md\ncoordination/memory_bank/*\ncoordination/subtasks/*\ncoordination/orchestration/*\n*.db\n*.db-journal\n*.db-wal\n*.sqlite\n*.sqlite-journal\n*.sqlite-wal\nclaude-flow\n# Removed Windows wrapper files per user request\nhive-mind-prompt-*.txt\n`;\n\n/**\n * Update or create .gitignore with Claude Flow entries\n * @param {string} workingDir - The working directory\n * @param {boolean} force - Whether to force update even if entries exist\n * @param {boolean} dryRun - Whether to run in dry-run mode\n * @returns {Promise<{success: boolean, message: string}>}\n */\nexport async function updateGitignore(workingDir, force = false, dryRun = false) {\n  const gitignorePath = `${workingDir}/.gitignore`;\n\n  try {\n    let gitignoreContent = '';\n    let fileExists = false;\n\n    // Check if .gitignore exists\n    if (existsSync(gitignorePath)) {\n      fileExists = true;\n      gitignoreContent = await readTextFile(gitignorePath);\n    }\n\n    // Check if Claude Flow section already exists\n    const claudeFlowMarker = '# Claude Flow generated files';\n    if (gitignoreContent.includes(claudeFlowMarker) && !force) {\n      return {\n        success: true,\n        message: '.gitignore already contains Claude Flow entries',\n      };\n    }\n\n    // Prepare the new content\n    let newContent = gitignoreContent;\n\n    // Remove existing Claude Flow section if force updating\n    if (force && gitignoreContent.includes(claudeFlowMarker)) {\n      const startIndex = gitignoreContent.indexOf(claudeFlowMarker);\n      const endIndex = gitignoreContent.indexOf('\\n# ', startIndex + 1);\n      if (endIndex !== -1) {\n        newContent =\n          gitignoreContent.substring(0, startIndex) + gitignoreContent.substring(endIndex);\n      } else {\n        // Claude Flow section is at the end\n        newContent = gitignoreContent.substring(0, startIndex);\n      }\n    }\n\n    // Add Claude Flow entries\n    if (!newContent.endsWith('\\n') && newContent.length > 0) {\n      newContent += '\\n';\n    }\n    newContent += CLAUDE_FLOW_GITIGNORE_ENTRIES;\n\n    // Write the file\n    if (!dryRun) {\n      await writeTextFile(gitignorePath, newContent);\n    }\n\n    return {\n      success: true,\n      message: fileExists\n        ? (dryRun ? '[DRY RUN] Would update' : 'Updated') +\n          ' existing .gitignore with Claude Flow entries'\n        : (dryRun ? '[DRY RUN] Would create' : 'Created') + ' .gitignore with Claude Flow entries',\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to update .gitignore: ${error.message}`,\n    };\n  }\n}\n\n/**\n * Check if gitignore needs updating\n * @param {string} workingDir - The working directory\n * @returns {Promise<boolean>}\n */\nexport async function needsGitignoreUpdate(workingDir) {\n  const gitignorePath = `${workingDir}/.gitignore`;\n\n  if (!existsSync(gitignorePath)) {\n    return true;\n  }\n\n  try {\n    const content = await readTextFile(gitignorePath);\n    return !content.includes('# Claude Flow generated files');\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Get list of files that should be gitignored\n * @returns {string[]}\n */\nexport function getGitignorePatterns() {\n  return CLAUDE_FLOW_GITIGNORE_ENTRIES.split('\\n')\n    .filter((line) => line.trim() && !line.startsWith('#') && !line.startsWith('!'))\n    .map((line) => line.trim());\n}\n"],"names":["existsSync","readTextFile","writeTextFile","CLAUDE_FLOW_GITIGNORE_ENTRIES","updateGitignore","workingDir","force","dryRun","gitignorePath","gitignoreContent","fileExists","claudeFlowMarker","includes","success","message","newContent","startIndex","indexOf","endIndex","substring","endsWith","length","error","needsGitignoreUpdate","content","getGitignorePatterns","split","filter","line","trim","startsWith","map"],"mappings":"AAKA,SAASA,UAAU,EAAEC,YAAY,EAAEC,aAAa,QAAQ,uBAAuB;AAK/E,MAAMC,gCAAgC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BvC,CAAC;AASD,OAAO,eAAeC,gBAAgBC,UAAU,EAAEC,QAAQ,KAAK,EAAEC,SAAS,KAAK;IAC7E,MAAMC,gBAAgB,GAAGH,WAAW,WAAW,CAAC;IAEhD,IAAI;QACF,IAAII,mBAAmB;QACvB,IAAIC,aAAa;QAGjB,IAAIV,WAAWQ,gBAAgB;YAC7BE,aAAa;YACbD,mBAAmB,MAAMR,aAAaO;QACxC;QAGA,MAAMG,mBAAmB;QACzB,IAAIF,iBAAiBG,QAAQ,CAACD,qBAAqB,CAACL,OAAO;YACzD,OAAO;gBACLO,SAAS;gBACTC,SAAS;YACX;QACF;QAGA,IAAIC,aAAaN;QAGjB,IAAIH,SAASG,iBAAiBG,QAAQ,CAACD,mBAAmB;YACxD,MAAMK,aAAaP,iBAAiBQ,OAAO,CAACN;YAC5C,MAAMO,WAAWT,iBAAiBQ,OAAO,CAAC,QAAQD,aAAa;YAC/D,IAAIE,aAAa,CAAC,GAAG;gBACnBH,aACEN,iBAAiBU,SAAS,CAAC,GAAGH,cAAcP,iBAAiBU,SAAS,CAACD;YAC3E,OAAO;gBAELH,aAAaN,iBAAiBU,SAAS,CAAC,GAAGH;YAC7C;QACF;QAGA,IAAI,CAACD,WAAWK,QAAQ,CAAC,SAASL,WAAWM,MAAM,GAAG,GAAG;YACvDN,cAAc;QAChB;QACAA,cAAcZ;QAGd,IAAI,CAACI,QAAQ;YACX,MAAML,cAAcM,eAAeO;QACrC;QAEA,OAAO;YACLF,SAAS;YACTC,SAASJ,aACL,AAACH,CAAAA,SAAS,2BAA2B,SAAQ,IAC7C,kDACA,AAACA,CAAAA,SAAS,2BAA2B,SAAQ,IAAK;QACxD;IACF,EAAE,OAAOe,OAAO;QACd,OAAO;YACLT,SAAS;YACTC,SAAS,CAAC,6BAA6B,EAAEQ,MAAMR,OAAO,EAAE;QAC1D;IACF;AACF;AAOA,OAAO,eAAeS,qBAAqBlB,UAAU;IACnD,MAAMG,gBAAgB,GAAGH,WAAW,WAAW,CAAC;IAEhD,IAAI,CAACL,WAAWQ,gBAAgB;QAC9B,OAAO;IACT;IAEA,IAAI;QACF,MAAMgB,UAAU,MAAMvB,aAAaO;QACnC,OAAO,CAACgB,QAAQZ,QAAQ,CAAC;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAMA,OAAO,SAASa;IACd,OAAOtB,8BAA8BuB,KAAK,CAAC,MACxCC,MAAM,CAAC,CAACC,OAASA,KAAKC,IAAI,MAAM,CAACD,KAAKE,UAAU,CAAC,QAAQ,CAACF,KAAKE,UAAU,CAAC,MAC1EC,GAAG,CAAC,CAACH,OAASA,KAAKC,IAAI;AAC5B"}