{"version":3,"sources":["../../../../../src/cli/simple-commands/init/template-copier.js"],"sourcesContent":["// template-copier.js - Copy template files instead of generating them dynamically\n\nimport { existsSync } from '../../node-compat.js';\nimport { promises as fs } from 'fs';\nimport { dirname, join, relative } from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n/**\n * Copy template files from the templates directory to the target directory\n * @param {string} targetDir - The directory to copy templates to\n * @param {Object} options - Options for template copying\n * @param {boolean} options.sparc - Whether to include SPARC templates\n * @param {boolean} options.enhanced - Whether to use enhanced templates\n * @param {boolean} options.minimal - Whether to use minimal templates\n * @param {boolean} options.optimized - Whether to use optimized templates\n * @param {boolean} options.dryRun - Whether to perform a dry run\n * @param {boolean} options.force - Whether to overwrite existing files\n * @param {string[]} options.selectedModes - Selected SPARC modes to copy\n * @returns {Promise<{success: boolean, copiedFiles: string[], errors: string[]}>}\n */\nexport async function copyTemplates(targetDir, options = {}) {\n  const results = {\n    success: true,\n    copiedFiles: [],\n    errors: [],\n  };\n\n  try {\n    const templatesDir = join(__dirname, 'templates');\n    \n    // Determine which template variants to use\n    const templateVariant = (options.verify || options.pair) ? 'verification' :\n                          options.optimized ? 'optimized' : \n                          options.enhanced ? 'enhanced' :\n                          options.minimal ? 'minimal' : \n                          options.sparc ? 'sparc' : 'full';\n\n    // Core files to copy\n    const coreFiles = [\n      { \n        source: 'CLAUDE.md', \n        destination: 'CLAUDE.md',\n        useVariant: true \n      },\n      { \n        source: 'memory-bank.md', \n        destination: 'memory-bank.md',\n        useVariant: true \n      },\n      { \n        source: 'coordination.md', \n        destination: 'coordination.md',\n        useVariant: true \n      },\n    ];\n\n    // Copy core files\n    for (const file of coreFiles) {\n      // Skip files if requested\n      if (options.skipClaudeMd && file.destination === 'CLAUDE.md') continue;\n      if (options.skipSettings && file.destination.includes('settings')) continue;\n      \n      const sourceFile = file.useVariant && existsSync(join(templatesDir, `${file.source}.${templateVariant}`)) \n        ? `${file.source}.${templateVariant}`\n        : file.source;\n      \n      const sourcePath = join(templatesDir, sourceFile);\n      const destPath = join(targetDir, file.destination);\n      \n      if (await copyFile(sourcePath, destPath, options)) {\n        results.copiedFiles.push(file.destination);\n      } else if (!options.dryRun) {\n        results.errors.push(`Failed to copy ${file.destination}`);\n      }\n    }\n\n    // Copy .claude directory structure\n    if (options.enhanced || !options.minimal) {\n      const claudeDir = join(targetDir, '.claude');\n      \n      // Copy settings.json unless skipped\n      if (!options.skipSettings) {\n        const settingsSource = (options.verify || options.pair) ? 'settings.json.verification' :\n                               options.enhanced ? 'settings.json.enhanced' : 'settings.json';\n        const settingsPath = join(templatesDir, settingsSource);\n        const settingsDest = join(claudeDir, 'settings.json');\n        \n        if (!options.dryRun) {\n          await fs.mkdir(claudeDir, { recursive: true });\n        }\n        \n        if (await copyFile(settingsPath, settingsDest, options)) {\n          results.copiedFiles.push('.claude/settings.json');\n        }\n\n        // Copy statusline script\n        const statuslineSource = join(templatesDir, 'statusline-command.sh');\n        const statuslineDest = join(claudeDir, 'statusline-command.sh');\n        if (existsSync(statuslineSource)) {\n          if (await copyFile(statuslineSource, statuslineDest, options)) {\n            // Make executable\n            if (!options.dryRun) {\n              await fs.chmod(statuslineDest, 0o755);\n            }\n            results.copiedFiles.push('.claude/statusline-command.sh');\n          }\n        }\n      } else if (!options.dryRun) {\n        // Still create the directory even if skipping settings\n        await fs.mkdir(claudeDir, { recursive: true });\n      }\n\n      // Copy command templates\n      if (options.sparc || options.enhanced) {\n        await copyCommandTemplates(templatesDir, targetDir, options, results);\n      }\n\n      // Copy helper scripts (enhanced mode only)\n      if (options.enhanced) {\n        await copyHelperScripts(templatesDir, targetDir, options, results);\n      }\n    }\n\n    // Copy SPARC-specific files\n    if (options.sparc) {\n      await copySparcTemplates(templatesDir, targetDir, options, results);\n    }\n\n    // Copy wrapper scripts\n    await copyWrapperScripts(templatesDir, targetDir, options, results);\n\n    // Create directory structure\n    await createDirectoryStructure(targetDir, options);\n\n    // Create README files for memory directories\n    await createMemoryReadmeFiles(targetDir, options, results);\n\n  } catch (err) {\n    results.success = false;\n    results.errors.push(`Template copy failed: ${err.message}`);\n  }\n\n  return results;\n}\n\n/**\n * Copy a single file with options\n */\nasync function copyFile(source, destination, options) {\n  try {\n    // Check if source exists\n    if (!existsSync(source)) {\n      // Try reading from templates directory as fallback\n      const templateContent = await getTemplateContent(source);\n      if (templateContent) {\n        if (!options.dryRun) {\n          await fs.writeFile(destination, templateContent);\n        }\n        console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} ${relative(process.cwd(), destination)}`);\n        return true;\n      }\n      console.log(`  ⚠️  Template not found: ${relative(process.cwd(), source)}`);\n      return false;\n    }\n\n    // Check if destination exists and handle force flag\n    if (existsSync(destination) && !options.force) {\n      console.log(`  ⚠️  File already exists: ${relative(process.cwd(), destination)} (use --force to overwrite)`);\n      return false;\n    }\n\n    if (!options.dryRun) {\n      // Ensure destination directory exists\n      await fs.mkdir(dirname(destination), { recursive: true });\n      \n      // Copy the file\n      const content = await fs.readFile(source, 'utf8');\n      await fs.writeFile(destination, content);\n      \n      // Preserve file permissions for executable scripts\n      if (source.endsWith('.sh') || source.includes('claude-flow')) {\n        await fs.chmod(destination, 0o755);\n      }\n    }\n\n    console.log(`  ${options.dryRun ? '[DRY RUN] Would copy' : '✓ Copied'} ${relative(process.cwd(), destination)}`);\n    return true;\n  } catch (err) {\n    console.log(`  ❌ Failed to copy ${relative(process.cwd(), destination)}: ${err.message}`);\n    return false;\n  }\n}\n\n/**\n * Copy command templates\n */\nasync function copyCommandTemplates(templatesDir, targetDir, options, results) {\n  const commandsSourceDir = join(templatesDir, 'commands');\n  const commandsDestDir = join(targetDir, '.claude', 'commands');\n\n  if (!existsSync(commandsSourceDir)) {\n    // Use generated command templates as fallback\n    return await generateCommandTemplates(targetDir, options, results);\n  }\n\n  try {\n    if (!options.dryRun) {\n      await fs.mkdir(commandsDestDir, { recursive: true });\n    }\n\n    // Copy command categories\n    const categories = await fs.readdir(commandsSourceDir);\n    \n    for (const category of categories) {\n      const categoryPath = join(commandsSourceDir, category);\n      const stat = await fs.stat(categoryPath);\n      \n      if (stat.isDirectory()) {\n        const destCategoryPath = join(commandsDestDir, category);\n        \n        if (!options.dryRun) {\n          await fs.mkdir(destCategoryPath, { recursive: true });\n        }\n\n        // Copy files in category\n        const files = await fs.readdir(categoryPath);\n        for (const file of files) {\n          const sourcePath = join(categoryPath, file);\n          const destPath = join(destCategoryPath, file);\n          \n          if (await copyFile(sourcePath, destPath, options)) {\n            results.copiedFiles.push(join('.claude', 'commands', category, file));\n          }\n        }\n      }\n    }\n  } catch (err) {\n    results.errors.push(`Failed to copy command templates: ${err.message}`);\n  }\n}\n\n/**\n * Copy SPARC templates\n */\nasync function copySparcTemplates(templatesDir, targetDir, options, results) {\n  const sparcDir = join(targetDir, '.claude', 'commands', 'sparc');\n  \n  try {\n    if (!options.dryRun) {\n      await fs.mkdir(sparcDir, { recursive: true });\n    }\n\n    // Get SPARC mode templates\n    const { createSparcModeTemplates, createSparcModesOverview } = await import('./templates/sparc-modes.js');\n    const sparcTemplates = createSparcModeTemplates();\n    \n    // Filter templates if selectedModes is specified\n    const templatesToCreate = options.selectedModes \n      ? Object.entries(sparcTemplates).filter(([filename]) => {\n          const mode = filename.replace('.md', '');\n          return options.selectedModes.includes(mode);\n        })\n      : Object.entries(sparcTemplates);\n\n    // Write SPARC mode files\n    for (const [filename, content] of templatesToCreate) {\n      const destPath = join(sparcDir, filename);\n      \n      if (!options.dryRun) {\n        await fs.writeFile(destPath, content);\n      }\n      \n      console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} .claude/commands/sparc/${filename}`);\n      results.copiedFiles.push(join('.claude', 'commands', 'sparc', filename));\n    }\n\n    // Create sparc-modes.md overview\n    const overviewPath = join(sparcDir, 'sparc-modes.md');\n    if (!options.dryRun) {\n      await fs.writeFile(overviewPath, createSparcModesOverview());\n    }\n    console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} .claude/commands/sparc/sparc-modes.md`);\n    results.copiedFiles.push('.claude/commands/sparc/sparc-modes.md');\n\n    // Copy swarm templates\n    await copySwarmTemplates(templatesDir, targetDir, options, results);\n\n  } catch (err) {\n    results.errors.push(`Failed to copy SPARC templates: ${err.message}`);\n  }\n}\n\n/**\n * Copy swarm strategy templates\n */\nasync function copySwarmTemplates(templatesDir, targetDir, options, results) {\n  const swarmDir = join(targetDir, '.claude', 'commands', 'swarm');\n  \n  try {\n    if (!options.dryRun) {\n      await fs.mkdir(swarmDir, { recursive: true });\n    }\n\n    // Get swarm strategy templates\n    const { createSwarmStrategyTemplates } = await import('./templates/sparc-modes.js');\n    const swarmTemplates = createSwarmStrategyTemplates();\n\n    // Write swarm strategy files\n    for (const [filename, content] of Object.entries(swarmTemplates)) {\n      const destPath = join(swarmDir, filename);\n      \n      if (!options.dryRun) {\n        await fs.writeFile(destPath, content);\n      }\n      \n      console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} .claude/commands/swarm/${filename}`);\n      results.copiedFiles.push(join('.claude', 'commands', 'swarm', filename));\n    }\n  } catch (err) {\n    results.errors.push(`Failed to copy swarm templates: ${err.message}`);\n  }\n}\n\n/**\n * Copy helper scripts (enhanced mode)\n */\nasync function copyHelperScripts(templatesDir, targetDir, options, results) {\n  const helpersDir = join(targetDir, '.claude', 'helpers');\n  \n  try {\n    if (!options.dryRun) {\n      await fs.mkdir(helpersDir, { recursive: true });\n    }\n\n    const helpers = ['setup-mcp.sh', 'quick-start.sh', 'github-setup.sh', 'github-safe.js', 'checkpoint-manager.sh', 'standard-checkpoint-hooks.sh'];\n    const { createHelperScript } = await import('./templates/enhanced-templates.js');\n    \n    for (const helper of helpers) {\n      const content = createHelperScript(helper);\n      if (content) {\n        const destPath = join(helpersDir, helper);\n        \n        if (!options.dryRun) {\n          await fs.writeFile(destPath, content);\n          await fs.chmod(destPath, 0o755);\n        }\n        \n        console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} .claude/helpers/${helper}`);\n        results.copiedFiles.push(join('.claude', 'helpers', helper));\n      }\n    }\n  } catch (err) {\n    results.errors.push(`Failed to copy helper scripts: ${err.message}`);\n  }\n}\n\n/**\n * Copy wrapper scripts\n */\nasync function copyWrapperScripts(templatesDir, targetDir, options, results) {\n  try {\n    // Unix wrapper\n    const unixWrapperPath = join(targetDir, 'claude-flow');\n    const unixWrapperSource = join(templatesDir, 'claude-flow-universal');\n    \n    if (await copyFile(unixWrapperSource, unixWrapperPath, options)) {\n      if (!options.dryRun) {\n        await fs.chmod(unixWrapperPath, 0o755);\n      }\n      results.copiedFiles.push('claude-flow');\n    }\n\n    // Windows batch wrapper\n    const batchWrapperPath = join(targetDir, 'claude-flow.bat');\n    const batchWrapperSource = join(templatesDir, 'claude-flow.bat');\n    \n    if (await copyFile(batchWrapperSource, batchWrapperPath, options)) {\n      results.copiedFiles.push('claude-flow.bat');\n    }\n\n    // PowerShell wrapper\n    const psWrapperPath = join(targetDir, 'claude-flow.ps1');\n    const psWrapperSource = join(templatesDir, 'claude-flow.ps1');\n    \n    if (await copyFile(psWrapperSource, psWrapperPath, options)) {\n      results.copiedFiles.push('claude-flow.ps1');\n    }\n  } catch (err) {\n    results.errors.push(`Failed to copy wrapper scripts: ${err.message}`);\n  }\n}\n\n/**\n * Create directory structure\n */\nasync function createDirectoryStructure(targetDir, options) {\n  const directories = [\n    'memory',\n    'memory/agents',\n    'memory/sessions',\n    'coordination',\n    'coordination/memory_bank',\n    'coordination/subtasks',\n    'coordination/orchestration',\n    '.claude',\n    '.claude/commands',\n    '.claude/logs',\n    '.swarm', // For memory persistence\n  ];\n\n  if (options.sparc) {\n    directories.push(\n      '.claude/commands/sparc',\n      '.claude/commands/swarm'\n    );\n  }\n\n  for (const dir of directories) {\n    const dirPath = join(targetDir, dir);\n    try {\n      if (!options.dryRun) {\n        await fs.mkdir(dirPath, { recursive: true });\n      }\n      console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} ${dir}/ directory`);\n    } catch (err) {\n      if (err.code !== 'EEXIST') {\n        console.log(`  ❌ Failed to create ${dir}/: ${err.message}`);\n      }\n    }\n  }\n}\n\n/**\n * Create README files for memory directories\n */\nasync function createMemoryReadmeFiles(targetDir, options, results) {\n  const { createAgentsReadme, createSessionsReadme } = await import('./templates/readme-files.js');\n  \n  const readmeFiles = [\n    { path: 'memory/agents/README.md', content: createAgentsReadme() },\n    { path: 'memory/sessions/README.md', content: createSessionsReadme() },\n  ];\n\n  for (const { path, content } of readmeFiles) {\n    const fullPath = join(targetDir, path);\n    \n    try {\n      if (!options.dryRun) {\n        await fs.mkdir(dirname(fullPath), { recursive: true });\n        await fs.writeFile(fullPath, content);\n      }\n      console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} ${path}`);\n      results.copiedFiles.push(path);\n    } catch (err) {\n      results.errors.push(`Failed to create ${path}: ${err.message}`);\n    }\n  }\n\n  // Initialize persistence database\n  const dbPath = join(targetDir, 'memory', 'claude-flow-data.json');\n  const initialData = {\n    agents: [],\n    tasks: [],\n    lastUpdated: Date.now(),\n  };\n\n  try {\n    if (!options.dryRun) {\n      await fs.writeFile(dbPath, JSON.stringify(initialData, null, 2));\n    }\n    console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} memory/claude-flow-data.json (persistence database)`);\n    results.copiedFiles.push('memory/claude-flow-data.json');\n  } catch (err) {\n    results.errors.push(`Failed to create persistence database: ${err.message}`);\n  }\n}\n\n/**\n * Get template content as fallback (for backwards compatibility)\n */\nasync function getTemplateContent(templatePath) {\n  const filename = templatePath.split('/').pop();\n  \n  // Map template files to their generator functions\n  const templateGenerators = {\n    'CLAUDE.md': async () => {\n      const { createFullClaudeMd } = await import('./templates/claude-md.js');\n      return createFullClaudeMd();\n    },\n    'CLAUDE.md.sparc': async () => {\n      const { createSparcClaudeMd } = await import('./templates/claude-md.js');\n      return createSparcClaudeMd();\n    },\n    'CLAUDE.md.minimal': async () => {\n      const { createMinimalClaudeMd } = await import('./templates/claude-md.js');\n      return createMinimalClaudeMd();\n    },\n    'CLAUDE.md.optimized': async () => {\n      const { createOptimizedSparcClaudeMd } = await import('./templates/claude-md.js');\n      return createOptimizedSparcClaudeMd();\n    },\n    'CLAUDE.md.enhanced': async () => {\n      const { createEnhancedClaudeMd } = await import('./templates/enhanced-templates.js');\n      return createEnhancedClaudeMd();\n    },\n    'CLAUDE.md.verification': async () => {\n      const { createVerificationClaudeMd } = await import('./templates/verification-claude-md.js');\n      return createVerificationClaudeMd();\n    },\n    'memory-bank.md': async () => {\n      const { createFullMemoryBankMd } = await import('./templates/memory-bank-md.js');\n      return createFullMemoryBankMd();\n    },\n    'memory-bank.md.minimal': async () => {\n      const { createMinimalMemoryBankMd } = await import('./templates/memory-bank-md.js');\n      return createMinimalMemoryBankMd();\n    },\n    'memory-bank.md.optimized': async () => {\n      const { createOptimizedMemoryBankMd } = await import('./templates/memory-bank-md.js');\n      return createOptimizedMemoryBankMd();\n    },\n    'coordination.md': async () => {\n      const { createFullCoordinationMd } = await import('./templates/coordination-md.js');\n      return createFullCoordinationMd();\n    },\n    'coordination.md.minimal': async () => {\n      const { createMinimalCoordinationMd } = await import('./templates/coordination-md.js');\n      return createMinimalCoordinationMd();\n    },\n    'coordination.md.optimized': async () => {\n      const { createOptimizedCoordinationMd } = await import('./templates/coordination-md.js');\n      return createOptimizedCoordinationMd();\n    },\n    'settings.json': async () => {\n      return await fs.readFile(join(__dirname, 'templates', 'settings.json'), 'utf8');\n    },\n    'settings.json.enhanced': async () => {\n      const { createEnhancedSettingsJson } = await import('./templates/enhanced-templates.js');\n      return createEnhancedSettingsJson();\n    },\n    'settings.json.verification': async () => {\n      const { createVerificationSettingsJson } = await import('./templates/verification-claude-md.js');\n      return createVerificationSettingsJson();\n    },\n    'claude-flow-universal': async () => {\n      return await fs.readFile(join(__dirname, 'templates', 'claude-flow-universal'), 'utf8');\n    },\n    // Removed Windows wrapper templates per user request\n  };\n\n  const generator = templateGenerators[filename] || templateGenerators[filename.replace(/\\.(sparc|minimal|optimized|enhanced)$/, '')];\n  \n  if (generator) {\n    try {\n      return await generator();\n    } catch (err) {\n      console.log(`  ⚠️  Failed to generate template content for ${filename}: ${err.message}`);\n      return null;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate command templates as fallback\n */\nasync function generateCommandTemplates(targetDir, options, results) {\n  const { COMMAND_STRUCTURE, createCommandDoc } = await import('./templates/enhanced-templates.js');\n  \n  for (const [category, commands] of Object.entries(COMMAND_STRUCTURE)) {\n    const categoryDir = join(targetDir, '.claude', 'commands', category);\n    \n    try {\n      if (!options.dryRun) {\n        await fs.mkdir(categoryDir, { recursive: true });\n        \n        // Create category README\n        const categoryReadme = `# ${category.charAt(0).toUpperCase() + category.slice(1)} Commands\n\nCommands for ${category} operations in Claude Flow.\n\n## Available Commands\n\n${commands.map(cmd => `- [${cmd}](./${cmd}.md)`).join('\\n')}\n`;\n        await fs.writeFile(join(categoryDir, 'README.md'), categoryReadme);\n      }\n\n      // Create individual command docs\n      for (const command of commands) {\n        const doc = createCommandDoc(category, command);\n        if (doc) {\n          const docPath = join(categoryDir, `${command}.md`);\n          if (!options.dryRun) {\n            await fs.writeFile(docPath, doc);\n          }\n          results.copiedFiles.push(join('.claude', 'commands', category, `${command}.md`));\n        }\n      }\n\n      console.log(`  ${options.dryRun ? '[DRY RUN] Would create' : '✓ Created'} ${commands.length} ${category} command docs`);\n    } catch (err) {\n      results.errors.push(`Failed to generate ${category} command templates: ${err.message}`);\n    }\n  }\n}"],"names":["existsSync","promises","fs","dirname","join","relative","fileURLToPath","__filename","url","__dirname","copyTemplates","targetDir","options","results","success","copiedFiles","errors","templatesDir","templateVariant","verify","pair","optimized","enhanced","minimal","sparc","coreFiles","source","destination","useVariant","file","skipClaudeMd","skipSettings","includes","sourceFile","sourcePath","destPath","copyFile","push","dryRun","claudeDir","settingsSource","settingsPath","settingsDest","mkdir","recursive","statuslineSource","statuslineDest","chmod","copyCommandTemplates","copyHelperScripts","copySparcTemplates","copyWrapperScripts","createDirectoryStructure","createMemoryReadmeFiles","err","message","templateContent","getTemplateContent","writeFile","console","log","process","cwd","force","content","readFile","endsWith","commandsSourceDir","commandsDestDir","generateCommandTemplates","categories","readdir","category","categoryPath","stat","isDirectory","destCategoryPath","files","sparcDir","createSparcModeTemplates","createSparcModesOverview","sparcTemplates","templatesToCreate","selectedModes","Object","entries","filter","filename","mode","replace","overviewPath","copySwarmTemplates","swarmDir","createSwarmStrategyTemplates","swarmTemplates","helpersDir","helpers","createHelperScript","helper","unixWrapperPath","unixWrapperSource","batchWrapperPath","batchWrapperSource","psWrapperPath","psWrapperSource","directories","dir","dirPath","code","createAgentsReadme","createSessionsReadme","readmeFiles","path","fullPath","dbPath","initialData","agents","tasks","lastUpdated","Date","now","JSON","stringify","templatePath","split","pop","templateGenerators","createFullClaudeMd","createSparcClaudeMd","createMinimalClaudeMd","createOptimizedSparcClaudeMd","createEnhancedClaudeMd","createVerificationClaudeMd","createFullMemoryBankMd","createMinimalMemoryBankMd","createOptimizedMemoryBankMd","createFullCoordinationMd","createMinimalCoordinationMd","createOptimizedCoordinationMd","createEnhancedSettingsJson","createVerificationSettingsJson","generator","COMMAND_STRUCTURE","createCommandDoc","commands","categoryDir","categoryReadme","charAt","toUpperCase","slice","map","cmd","command","doc","docPath","length"],"mappings":"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"}