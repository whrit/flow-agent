{"version":3,"sources":["../../../../../src/cli/simple-commands/init/copy-revised-templates.js"],"sourcesContent":["// copy-revised-templates.js - Copy the revised template files from repository\n\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Source directory for revised templates (repository root .claude/commands)\nconst REPO_TEMPLATES_DIR = path.join(__dirname, '../../../../.claude/commands');\n// Source directory for init templates\nconst INIT_TEMPLATES_DIR = path.join(__dirname, './templates');\n\n/**\n * Copy revised template files from repository to target project\n */\nexport async function copyRevisedTemplates(targetDir, options = {}) {\n  const results = {\n    success: true,\n    copiedFiles: [],\n    skippedFiles: [],\n    errors: []\n  };\n\n  const targetCommandsDir = path.join(targetDir, '.claude/commands');\n\n  try {\n    // Ensure target directory exists\n    await fs.promises.mkdir(targetCommandsDir, { recursive: true });\n\n    // Copy all template files recursively\n    await copyDirectoryRecursive(REPO_TEMPLATES_DIR, targetCommandsDir, options, results);\n\n    // Copy additional .claude files if they exist\n    const additionalFiles = [\n      { source: REPO_TEMPLATES_DIR, relative: '../config.json', target: '.claude/config.json' },\n      { source: REPO_TEMPLATES_DIR, relative: '../settings.json', target: '.claude/settings.json' },\n      { source: INIT_TEMPLATES_DIR, relative: 'statusline-command.sh', target: '.claude/statusline-command.sh', executable: true }\n    ];\n\n    for (const file of additionalFiles) {\n      const sourcePath = path.join(file.source, file.relative);\n      const targetPath = path.join(targetDir, file.target);\n\n      if (fs.existsSync(sourcePath)) {\n        try {\n          const targetDirPath = path.dirname(targetPath);\n          await fs.promises.mkdir(targetDirPath, { recursive: true });\n          \n          if (!fs.existsSync(targetPath) || options.force) {\n            await fs.promises.copyFile(sourcePath, targetPath);\n            // Make file executable if flagged\n            if (file.executable) {\n              await fs.promises.chmod(targetPath, 0o755);\n            }\n            results.copiedFiles.push(file.target);\n            if (!options.dryRun) {\n              console.log(`  ✓ Copied ${file.target}`);\n            }\n          } else {\n            results.skippedFiles.push(file.target);\n            if (!options.dryRun) {\n              console.log(`  ⏭️  Skipped ${file.target} (already exists)`);\n            }\n          }\n        } catch (err) {\n          results.errors.push(`Failed to copy ${file.target}: ${err.message}`);\n        }\n      }\n    }\n\n    results.success = results.errors.length === 0;\n  } catch (err) {\n    results.success = false;\n    results.errors.push(`Failed to copy revised templates: ${err.message}`);\n  }\n\n  return results;\n}\n\n/**\n * Recursively copy directory contents\n */\nasync function copyDirectoryRecursive(sourceDir, targetDir, options, results) {\n  try {\n    const entries = await fs.promises.readdir(sourceDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const sourcePath = path.join(sourceDir, entry.name);\n      const targetPath = path.join(targetDir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Create directory and recurse\n        await fs.promises.mkdir(targetPath, { recursive: true });\n        await copyDirectoryRecursive(sourcePath, targetPath, options, results);\n      } else if (entry.isFile() && entry.name.endsWith('.md')) {\n        // Copy markdown files\n        try {\n          if (!fs.existsSync(targetPath) || options.force) {\n            if (!options.dryRun) {\n              await fs.promises.copyFile(sourcePath, targetPath);\n            }\n            const relativePath = path.relative(targetDir, targetPath);\n            results.copiedFiles.push(relativePath);\n            if (!options.dryRun && options.verbose) {\n              console.log(`  ✓ Copied ${relativePath}`);\n            }\n          } else {\n            const relativePath = path.relative(targetDir, targetPath);\n            results.skippedFiles.push(relativePath);\n            if (!options.dryRun && options.verbose) {\n              console.log(`  ⏭️  Skipped ${relativePath} (already exists)`);\n            }\n          }\n        } catch (err) {\n          results.errors.push(`Failed to copy ${entry.name}: ${err.message}`);\n        }\n      }\n    }\n  } catch (err) {\n    results.errors.push(`Failed to read directory ${sourceDir}: ${err.message}`);\n  }\n}\n\n/**\n * Copy only specific categories\n */\nexport async function copyRevisedTemplatesByCategory(targetDir, categories, options = {}) {\n  const results = {\n    success: true,\n    copiedFiles: [],\n    skippedFiles: [],\n    errors: []\n  };\n\n  for (const category of categories) {\n    const sourceCategoryDir = path.join(REPO_TEMPLATES_DIR, category);\n    const targetCategoryDir = path.join(targetDir, '.claude/commands', category);\n\n    if (fs.existsSync(sourceCategoryDir)) {\n      await fs.promises.mkdir(targetCategoryDir, { recursive: true });\n      await copyDirectoryRecursive(sourceCategoryDir, targetCategoryDir, options, results);\n    } else {\n      results.errors.push(`Category '${category}' not found in templates`);\n    }\n  }\n\n  results.success = results.errors.length === 0;\n  return results;\n}\n\n/**\n * Validate that source templates exist\n */\nexport function validateTemplatesExist() {\n  if (!fs.existsSync(REPO_TEMPLATES_DIR)) {\n    return {\n      valid: false,\n      error: `Template directory not found: ${REPO_TEMPLATES_DIR}`\n    };\n  }\n\n  const requiredCategories = ['analysis', 'github', 'sparc', 'coordination'];\n  const missingCategories = [];\n\n  for (const category of requiredCategories) {\n    const categoryPath = path.join(REPO_TEMPLATES_DIR, category);\n    if (!fs.existsSync(categoryPath)) {\n      missingCategories.push(category);\n    }\n  }\n\n  if (missingCategories.length > 0) {\n    return {\n      valid: false,\n      error: `Missing required template categories: ${missingCategories.join(', ')}`\n    };\n  }\n\n  return { valid: true };\n}"],"names":["fs","path","fileURLToPath","__filename","url","__dirname","dirname","REPO_TEMPLATES_DIR","join","INIT_TEMPLATES_DIR","copyRevisedTemplates","targetDir","options","results","success","copiedFiles","skippedFiles","errors","targetCommandsDir","promises","mkdir","recursive","copyDirectoryRecursive","additionalFiles","source","relative","target","executable","file","sourcePath","targetPath","existsSync","targetDirPath","force","copyFile","chmod","push","dryRun","console","log","err","message","length","sourceDir","entries","readdir","withFileTypes","entry","name","isDirectory","isFile","endsWith","relativePath","verbose","copyRevisedTemplatesByCategory","categories","category","sourceCategoryDir","targetCategoryDir","validateTemplatesExist","valid","error","requiredCategories","missingCategories","categoryPath"],"mappings":"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"}