{"version":3,"sources":["../../../../../../src/cli/simple-commands/init/validation/mode-validator.js"],"sourcesContent":["import { promises as fs } from 'fs';\n// mode-validator.js - SPARC mode functionality testing\n\nexport class ModeValidator {\n  constructor(workingDir) {\n    this.workingDir = workingDir;\n  }\n\n  /**\n   * Test all SPARC modes for basic functionality\n   */\n  async testAllModes() {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      modes: {},\n    };\n\n    try {\n      // First, check if SPARC is initialized\n      const sparcInitialized = await this.checkSparcInitialization();\n      if (!sparcInitialized.initialized) {\n        result.warnings.push('SPARC not initialized - mode testing skipped');\n        return result;\n      }\n\n      // Get available modes\n      const availableModes = await this.getAvailableModes();\n      if (availableModes.length === 0) {\n        result.warnings.push('No SPARC modes found for testing');\n        return result;\n      }\n\n      // Test each mode\n      for (const mode of availableModes) {\n        const modeTest = await this.testMode(mode);\n        result.modes[mode] = modeTest;\n\n        if (!modeTest.success) {\n          result.success = false;\n          result.errors.push(`Mode ${mode} failed testing: ${modeTest.error}`);\n        }\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Mode testing failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Test a specific SPARC mode\n   */\n  async testMode(modeName) {\n    const result = {\n      success: true,\n      error: null,\n      checks: {\n        accessible: false,\n        configValid: false,\n        executable: false,\n      },\n    };\n\n    try {\n      // Test 1: Check if mode is accessible via CLI\n      const accessTest = await this.testModeAccess(modeName);\n      result.checks.accessible = accessTest.success;\n      if (!accessTest.success) {\n        result.success = false;\n        result.error = accessTest.error;\n        return result;\n      }\n\n      // Test 2: Validate mode configuration\n      const configTest = await this.testModeConfig(modeName);\n      result.checks.configValid = configTest.success;\n      if (!configTest.success) {\n        result.success = false;\n        result.error = configTest.error;\n        return result;\n      }\n\n      // Test 3: Test mode execution (dry run)\n      const execTest = await this.testModeExecution(modeName);\n      result.checks.executable = execTest.success;\n      if (!execTest.success) {\n        result.success = false;\n        result.error = execTest.error;\n        return result;\n      }\n    } catch (error) {\n      result.success = false;\n      result.error = error.message;\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if SPARC is properly initialized\n   */\n  async checkSparcInitialization() {\n    const result = {\n      initialized: false,\n      hasRoomodes: false,\n      hasExecutable: false,\n      error: null,\n    };\n\n    try {\n      // Check for .roomodes file\n      try {\n        const stat = await Deno.stat(`${this.workingDir}/.roomodes`);\n        result.hasRoomodes = stat.isFile;\n      } catch {\n        result.error = '.roomodes file not found';\n      }\n\n      // Check for claude-flow executable\n      try {\n        const stat = await Deno.stat(`${this.workingDir}/claude-flow`);\n        result.hasExecutable = stat.isFile;\n      } catch {\n        result.error = 'claude-flow executable not found';\n      }\n\n      result.initialized = result.hasRoomodes && result.hasExecutable;\n    } catch (error) {\n      result.error = error.message;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get list of available SPARC modes\n   */\n  async getAvailableModes() {\n    const modes = [];\n\n    try {\n      // Try to get modes from .roomodes\n      const roomodesPath = `${this.workingDir}/.roomodes`;\n      const content = await fs.readFile(roomodesPath, 'utf8');\n      const config = JSON.parse(content);\n\n      if (config.modes && typeof config.modes === 'object') {\n        modes.push(...Object.keys(config.modes));\n      }\n    } catch (error) {\n      // Fallback to common modes\n      modes.push(\n        'architect',\n        'code',\n        'tdd',\n        'spec-pseudocode',\n        'integration',\n        'debug',\n        'docs-writer',\n      );\n    }\n\n    return modes;\n  }\n\n  /**\n   * Test if a mode is accessible via CLI\n   */\n  async testModeAccess(modeName) {\n    const result = {\n      success: false,\n      error: null,\n    };\n\n    try {\n      // Test with sparc info command\n      const command = new Deno.Command('./claude-flow', {\n        args: ['sparc', 'info', modeName],\n        cwd: this.workingDir,\n        stdout: 'piped',\n        stderr: 'piped',\n      });\n\n      const { success, stdout, stderr } = await command.output();\n\n      if (success) {\n        result.success = true;\n      } else {\n        const errorOutput = new TextDecoder().decode(stderr);\n        result.error = `Mode not accessible: ${errorOutput}`;\n      }\n    } catch (error) {\n      result.error = `Failed to test mode access: ${error.message}`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Test mode configuration validity\n   */\n  async testModeConfig(modeName) {\n    const result = {\n      success: false,\n      error: null,\n    };\n\n    try {\n      // Read .roomodes and validate mode config\n      const roomodesPath = `${this.workingDir}/.roomodes`;\n      const content = await fs.readFile(roomodesPath, 'utf8');\n      const config = JSON.parse(content);\n\n      if (!config.modes || !config.modes[modeName]) {\n        result.error = `Mode ${modeName} not found in configuration`;\n        return result;\n      }\n\n      const modeConfig = config.modes[modeName];\n\n      // Basic validation\n      if (typeof modeConfig !== 'object') {\n        result.error = `Invalid configuration for mode ${modeName}`;\n        return result;\n      }\n\n      // Check for required fields\n      const requiredFields = ['description'];\n      for (const field of requiredFields) {\n        if (!modeConfig[field]) {\n          result.error = `Mode ${modeName} missing required field: ${field}`;\n          return result;\n        }\n      }\n\n      result.success = true;\n    } catch (error) {\n      result.error = `Configuration validation failed: ${error.message}`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Test mode execution with a safe dry run\n   */\n  async testModeExecution(modeName) {\n    const result = {\n      success: false,\n      error: null,\n    };\n\n    try {\n      // Test with a safe, non-destructive command\n      const command = new Deno.Command('./claude-flow', {\n        args: ['sparc', 'run', modeName, 'test validation', '--dry-run'],\n        cwd: this.workingDir,\n        stdout: 'piped',\n        stderr: 'piped',\n      });\n\n      const { success, stdout, stderr } = await command.output();\n\n      if (success) {\n        result.success = true;\n      } else {\n        // Check if it's just because --dry-run isn't supported\n        const errorOutput = new TextDecoder().decode(stderr);\n        if (errorOutput.includes('dry-run') || errorOutput.includes('unknown flag')) {\n          // Try without dry-run but with a safe test task\n          const testCommand = new Deno.Command('./claude-flow', {\n            args: ['sparc', 'modes'],\n            cwd: this.workingDir,\n            stdout: 'piped',\n            stderr: 'piped',\n          });\n\n          const testResult = await testCommand.output();\n          if (testResult.success) {\n            const output = new TextDecoder().decode(testResult.stdout);\n            result.success = output.includes(modeName);\n            if (!result.success) {\n              result.error = `Mode ${modeName} not listed in available modes`;\n            }\n          } else {\n            result.error = `Mode execution test failed: ${errorOutput}`;\n          }\n        } else {\n          result.error = `Mode execution failed: ${errorOutput}`;\n        }\n      }\n    } catch (error) {\n      result.error = `Execution test failed: ${error.message}`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Test SPARC workflow functionality\n   */\n  async testWorkflowFunctionality() {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      workflows: {},\n    };\n\n    try {\n      // Check for workflow files\n      const workflowDir = `${this.workingDir}/.roo/workflows`;\n\n      try {\n        const entries = [];\n        for await (const entry of Deno.readDir(workflowDir)) {\n          if (entry.isFile && entry.name.endsWith('.json')) {\n            entries.push(entry.name);\n          }\n        }\n\n        // Test each workflow file\n        for (const workflowFile of entries) {\n          const workflowTest = await this.testWorkflowFile(workflowFile);\n          result.workflows[workflowFile] = workflowTest;\n\n          if (!workflowTest.success) {\n            result.warnings.push(`Workflow ${workflowFile} has issues: ${workflowTest.error}`);\n          }\n        }\n\n        if (entries.length === 0) {\n          result.warnings.push('No workflow files found');\n        }\n      } catch {\n        result.warnings.push('Workflow directory not accessible');\n      }\n    } catch (error) {\n      result.errors.push(`Workflow testing failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Test a specific workflow file\n   */\n  async testWorkflowFile(filename) {\n    const result = {\n      success: true,\n      error: null,\n    };\n\n    try {\n      const workflowPath = `${this.workingDir}/.roo/workflows/${filename}`;\n      const content = await fs.readFile(workflowPath, 'utf8');\n\n      // Parse JSON\n      const workflow = JSON.parse(content);\n\n      // Basic validation\n      if (typeof workflow !== 'object' || workflow === null) {\n        result.success = false;\n        result.error = 'Workflow must be a JSON object';\n        return result;\n      }\n\n      // Check for recommended fields\n      const recommendedFields = ['name', 'description', 'steps'];\n      for (const field of recommendedFields) {\n        if (!(field in workflow)) {\n          result.success = false;\n          result.error = `Missing recommended field: ${field}`;\n          return result;\n        }\n      }\n    } catch (error) {\n      result.success = false;\n      result.error = `Workflow validation failed: ${error.message}`;\n    }\n\n    return result;\n  }\n}\n"],"names":["promises","fs","ModeValidator","workingDir","testAllModes","result","success","errors","warnings","modes","sparcInitialized","checkSparcInitialization","initialized","push","availableModes","getAvailableModes","length","mode","modeTest","testMode","error","message","modeName","checks","accessible","configValid","executable","accessTest","testModeAccess","configTest","testModeConfig","execTest","testModeExecution","hasRoomodes","hasExecutable","stat","Deno","isFile","roomodesPath","content","readFile","config","JSON","parse","Object","keys","command","Command","args","cwd","stdout","stderr","output","errorOutput","TextDecoder","decode","modeConfig","requiredFields","field","includes","testCommand","testResult","testWorkflowFunctionality","workflows","workflowDir","entries","entry","readDir","name","endsWith","workflowFile","workflowTest","testWorkflowFile","filename","workflowPath","workflow","recommendedFields"],"mappings":"AAAA,SAASA,YAAYC,EAAE,QAAQ,KAAK;AAGpC,OAAO,MAAMC;IACX,YAAYC,UAAU,CAAE;QACtB,IAAI,CAACA,UAAU,GAAGA;IACpB;IAKA,MAAMC,eAAe;QACnB,MAAMC,SAAS;YACbC,SAAS;YACTC,QAAQ,EAAE;YACVC,UAAU,EAAE;YACZC,OAAO,CAAC;QACV;QAEA,IAAI;YAEF,MAAMC,mBAAmB,MAAM,IAAI,CAACC,wBAAwB;YAC5D,IAAI,CAACD,iBAAiBE,WAAW,EAAE;gBACjCP,OAAOG,QAAQ,CAACK,IAAI,CAAC;gBACrB,OAAOR;YACT;YAGA,MAAMS,iBAAiB,MAAM,IAAI,CAACC,iBAAiB;YACnD,IAAID,eAAeE,MAAM,KAAK,GAAG;gBAC/BX,OAAOG,QAAQ,CAACK,IAAI,CAAC;gBACrB,OAAOR;YACT;YAGA,KAAK,MAAMY,QAAQH,eAAgB;gBACjC,MAAMI,WAAW,MAAM,IAAI,CAACC,QAAQ,CAACF;gBACrCZ,OAAOI,KAAK,CAACQ,KAAK,GAAGC;gBAErB,IAAI,CAACA,SAASZ,OAAO,EAAE;oBACrBD,OAAOC,OAAO,GAAG;oBACjBD,OAAOE,MAAM,CAACM,IAAI,CAAC,CAAC,KAAK,EAAEI,KAAK,iBAAiB,EAAEC,SAASE,KAAK,EAAE;gBACrE;YACF;QACF,EAAE,OAAOA,OAAO;YACdf,OAAOC,OAAO,GAAG;YACjBD,OAAOE,MAAM,CAACM,IAAI,CAAC,CAAC,qBAAqB,EAAEO,MAAMC,OAAO,EAAE;QAC5D;QAEA,OAAOhB;IACT;IAKA,MAAMc,SAASG,QAAQ,EAAE;QACvB,MAAMjB,SAAS;YACbC,SAAS;YACTc,OAAO;YACPG,QAAQ;gBACNC,YAAY;gBACZC,aAAa;gBACbC,YAAY;YACd;QACF;QAEA,IAAI;YAEF,MAAMC,aAAa,MAAM,IAAI,CAACC,cAAc,CAACN;YAC7CjB,OAAOkB,MAAM,CAACC,UAAU,GAAGG,WAAWrB,OAAO;YAC7C,IAAI,CAACqB,WAAWrB,OAAO,EAAE;gBACvBD,OAAOC,OAAO,GAAG;gBACjBD,OAAOe,KAAK,GAAGO,WAAWP,KAAK;gBAC/B,OAAOf;YACT;YAGA,MAAMwB,aAAa,MAAM,IAAI,CAACC,cAAc,CAACR;YAC7CjB,OAAOkB,MAAM,CAACE,WAAW,GAAGI,WAAWvB,OAAO;YAC9C,IAAI,CAACuB,WAAWvB,OAAO,EAAE;gBACvBD,OAAOC,OAAO,GAAG;gBACjBD,OAAOe,KAAK,GAAGS,WAAWT,KAAK;gBAC/B,OAAOf;YACT;YAGA,MAAM0B,WAAW,MAAM,IAAI,CAACC,iBAAiB,CAACV;YAC9CjB,OAAOkB,MAAM,CAACG,UAAU,GAAGK,SAASzB,OAAO;YAC3C,IAAI,CAACyB,SAASzB,OAAO,EAAE;gBACrBD,OAAOC,OAAO,GAAG;gBACjBD,OAAOe,KAAK,GAAGW,SAASX,KAAK;gBAC7B,OAAOf;YACT;QACF,EAAE,OAAOe,OAAO;YACdf,OAAOC,OAAO,GAAG;YACjBD,OAAOe,KAAK,GAAGA,MAAMC,OAAO;QAC9B;QAEA,OAAOhB;IACT;IAKA,MAAMM,2BAA2B;QAC/B,MAAMN,SAAS;YACbO,aAAa;YACbqB,aAAa;YACbC,eAAe;YACfd,OAAO;QACT;QAEA,IAAI;YAEF,IAAI;gBACF,MAAMe,OAAO,MAAMC,KAAKD,IAAI,CAAC,GAAG,IAAI,CAAChC,UAAU,CAAC,UAAU,CAAC;gBAC3DE,OAAO4B,WAAW,GAAGE,KAAKE,MAAM;YAClC,EAAE,OAAM;gBACNhC,OAAOe,KAAK,GAAG;YACjB;YAGA,IAAI;gBACF,MAAMe,OAAO,MAAMC,KAAKD,IAAI,CAAC,GAAG,IAAI,CAAChC,UAAU,CAAC,YAAY,CAAC;gBAC7DE,OAAO6B,aAAa,GAAGC,KAAKE,MAAM;YACpC,EAAE,OAAM;gBACNhC,OAAOe,KAAK,GAAG;YACjB;YAEAf,OAAOO,WAAW,GAAGP,OAAO4B,WAAW,IAAI5B,OAAO6B,aAAa;QACjE,EAAE,OAAOd,OAAO;YACdf,OAAOe,KAAK,GAAGA,MAAMC,OAAO;QAC9B;QAEA,OAAOhB;IACT;IAKA,MAAMU,oBAAoB;QACxB,MAAMN,QAAQ,EAAE;QAEhB,IAAI;YAEF,MAAM6B,eAAe,GAAG,IAAI,CAACnC,UAAU,CAAC,UAAU,CAAC;YACnD,MAAMoC,UAAU,MAAMtC,GAAGuC,QAAQ,CAACF,cAAc;YAChD,MAAMG,SAASC,KAAKC,KAAK,CAACJ;YAE1B,IAAIE,OAAOhC,KAAK,IAAI,OAAOgC,OAAOhC,KAAK,KAAK,UAAU;gBACpDA,MAAMI,IAAI,IAAI+B,OAAOC,IAAI,CAACJ,OAAOhC,KAAK;YACxC;QACF,EAAE,OAAOW,OAAO;YAEdX,MAAMI,IAAI,CACR,aACA,QACA,OACA,mBACA,eACA,SACA;QAEJ;QAEA,OAAOJ;IACT;IAKA,MAAMmB,eAAeN,QAAQ,EAAE;QAC7B,MAAMjB,SAAS;YACbC,SAAS;YACTc,OAAO;QACT;QAEA,IAAI;YAEF,MAAM0B,UAAU,IAAIV,KAAKW,OAAO,CAAC,iBAAiB;gBAChDC,MAAM;oBAAC;oBAAS;oBAAQ1B;iBAAS;gBACjC2B,KAAK,IAAI,CAAC9C,UAAU;gBACpB+C,QAAQ;gBACRC,QAAQ;YACV;YAEA,MAAM,EAAE7C,OAAO,EAAE4C,MAAM,EAAEC,MAAM,EAAE,GAAG,MAAML,QAAQM,MAAM;YAExD,IAAI9C,SAAS;gBACXD,OAAOC,OAAO,GAAG;YACnB,OAAO;gBACL,MAAM+C,cAAc,IAAIC,cAAcC,MAAM,CAACJ;gBAC7C9C,OAAOe,KAAK,GAAG,CAAC,qBAAqB,EAAEiC,aAAa;YACtD;QACF,EAAE,OAAOjC,OAAO;YACdf,OAAOe,KAAK,GAAG,CAAC,4BAA4B,EAAEA,MAAMC,OAAO,EAAE;QAC/D;QAEA,OAAOhB;IACT;IAKA,MAAMyB,eAAeR,QAAQ,EAAE;QAC7B,MAAMjB,SAAS;YACbC,SAAS;YACTc,OAAO;QACT;QAEA,IAAI;YAEF,MAAMkB,eAAe,GAAG,IAAI,CAACnC,UAAU,CAAC,UAAU,CAAC;YACnD,MAAMoC,UAAU,MAAMtC,GAAGuC,QAAQ,CAACF,cAAc;YAChD,MAAMG,SAASC,KAAKC,KAAK,CAACJ;YAE1B,IAAI,CAACE,OAAOhC,KAAK,IAAI,CAACgC,OAAOhC,KAAK,CAACa,SAAS,EAAE;gBAC5CjB,OAAOe,KAAK,GAAG,CAAC,KAAK,EAAEE,SAAS,2BAA2B,CAAC;gBAC5D,OAAOjB;YACT;YAEA,MAAMmD,aAAaf,OAAOhC,KAAK,CAACa,SAAS;YAGzC,IAAI,OAAOkC,eAAe,UAAU;gBAClCnD,OAAOe,KAAK,GAAG,CAAC,+BAA+B,EAAEE,UAAU;gBAC3D,OAAOjB;YACT;YAGA,MAAMoD,iBAAiB;gBAAC;aAAc;YACtC,KAAK,MAAMC,SAASD,eAAgB;gBAClC,IAAI,CAACD,UAAU,CAACE,MAAM,EAAE;oBACtBrD,OAAOe,KAAK,GAAG,CAAC,KAAK,EAAEE,SAAS,yBAAyB,EAAEoC,OAAO;oBAClE,OAAOrD;gBACT;YACF;YAEAA,OAAOC,OAAO,GAAG;QACnB,EAAE,OAAOc,OAAO;YACdf,OAAOe,KAAK,GAAG,CAAC,iCAAiC,EAAEA,MAAMC,OAAO,EAAE;QACpE;QAEA,OAAOhB;IACT;IAKA,MAAM2B,kBAAkBV,QAAQ,EAAE;QAChC,MAAMjB,SAAS;YACbC,SAAS;YACTc,OAAO;QACT;QAEA,IAAI;YAEF,MAAM0B,UAAU,IAAIV,KAAKW,OAAO,CAAC,iBAAiB;gBAChDC,MAAM;oBAAC;oBAAS;oBAAO1B;oBAAU;oBAAmB;iBAAY;gBAChE2B,KAAK,IAAI,CAAC9C,UAAU;gBACpB+C,QAAQ;gBACRC,QAAQ;YACV;YAEA,MAAM,EAAE7C,OAAO,EAAE4C,MAAM,EAAEC,MAAM,EAAE,GAAG,MAAML,QAAQM,MAAM;YAExD,IAAI9C,SAAS;gBACXD,OAAOC,OAAO,GAAG;YACnB,OAAO;gBAEL,MAAM+C,cAAc,IAAIC,cAAcC,MAAM,CAACJ;gBAC7C,IAAIE,YAAYM,QAAQ,CAAC,cAAcN,YAAYM,QAAQ,CAAC,iBAAiB;oBAE3E,MAAMC,cAAc,IAAIxB,KAAKW,OAAO,CAAC,iBAAiB;wBACpDC,MAAM;4BAAC;4BAAS;yBAAQ;wBACxBC,KAAK,IAAI,CAAC9C,UAAU;wBACpB+C,QAAQ;wBACRC,QAAQ;oBACV;oBAEA,MAAMU,aAAa,MAAMD,YAAYR,MAAM;oBAC3C,IAAIS,WAAWvD,OAAO,EAAE;wBACtB,MAAM8C,SAAS,IAAIE,cAAcC,MAAM,CAACM,WAAWX,MAAM;wBACzD7C,OAAOC,OAAO,GAAG8C,OAAOO,QAAQ,CAACrC;wBACjC,IAAI,CAACjB,OAAOC,OAAO,EAAE;4BACnBD,OAAOe,KAAK,GAAG,CAAC,KAAK,EAAEE,SAAS,8BAA8B,CAAC;wBACjE;oBACF,OAAO;wBACLjB,OAAOe,KAAK,GAAG,CAAC,4BAA4B,EAAEiC,aAAa;oBAC7D;gBACF,OAAO;oBACLhD,OAAOe,KAAK,GAAG,CAAC,uBAAuB,EAAEiC,aAAa;gBACxD;YACF;QACF,EAAE,OAAOjC,OAAO;YACdf,OAAOe,KAAK,GAAG,CAAC,uBAAuB,EAAEA,MAAMC,OAAO,EAAE;QAC1D;QAEA,OAAOhB;IACT;IAKA,MAAMyD,4BAA4B;QAChC,MAAMzD,SAAS;YACbC,SAAS;YACTC,QAAQ,EAAE;YACVC,UAAU,EAAE;YACZuD,WAAW,CAAC;QACd;QAEA,IAAI;YAEF,MAAMC,cAAc,GAAG,IAAI,CAAC7D,UAAU,CAAC,eAAe,CAAC;YAEvD,IAAI;gBACF,MAAM8D,UAAU,EAAE;gBAClB,WAAW,MAAMC,SAAS9B,KAAK+B,OAAO,CAACH,aAAc;oBACnD,IAAIE,MAAM7B,MAAM,IAAI6B,MAAME,IAAI,CAACC,QAAQ,CAAC,UAAU;wBAChDJ,QAAQpD,IAAI,CAACqD,MAAME,IAAI;oBACzB;gBACF;gBAGA,KAAK,MAAME,gBAAgBL,QAAS;oBAClC,MAAMM,eAAe,MAAM,IAAI,CAACC,gBAAgB,CAACF;oBACjDjE,OAAO0D,SAAS,CAACO,aAAa,GAAGC;oBAEjC,IAAI,CAACA,aAAajE,OAAO,EAAE;wBACzBD,OAAOG,QAAQ,CAACK,IAAI,CAAC,CAAC,SAAS,EAAEyD,aAAa,aAAa,EAAEC,aAAanD,KAAK,EAAE;oBACnF;gBACF;gBAEA,IAAI6C,QAAQjD,MAAM,KAAK,GAAG;oBACxBX,OAAOG,QAAQ,CAACK,IAAI,CAAC;gBACvB;YACF,EAAE,OAAM;gBACNR,OAAOG,QAAQ,CAACK,IAAI,CAAC;YACvB;QACF,EAAE,OAAOO,OAAO;YACdf,OAAOE,MAAM,CAACM,IAAI,CAAC,CAAC,yBAAyB,EAAEO,MAAMC,OAAO,EAAE;QAChE;QAEA,OAAOhB;IACT;IAKA,MAAMmE,iBAAiBC,QAAQ,EAAE;QAC/B,MAAMpE,SAAS;YACbC,SAAS;YACTc,OAAO;QACT;QAEA,IAAI;YACF,MAAMsD,eAAe,GAAG,IAAI,CAACvE,UAAU,CAAC,gBAAgB,EAAEsE,UAAU;YACpE,MAAMlC,UAAU,MAAMtC,GAAGuC,QAAQ,CAACkC,cAAc;YAGhD,MAAMC,WAAWjC,KAAKC,KAAK,CAACJ;YAG5B,IAAI,OAAOoC,aAAa,YAAYA,aAAa,MAAM;gBACrDtE,OAAOC,OAAO,GAAG;gBACjBD,OAAOe,KAAK,GAAG;gBACf,OAAOf;YACT;YAGA,MAAMuE,oBAAoB;gBAAC;gBAAQ;gBAAe;aAAQ;YAC1D,KAAK,MAAMlB,SAASkB,kBAAmB;gBACrC,IAAI,CAAElB,CAAAA,SAASiB,QAAO,GAAI;oBACxBtE,OAAOC,OAAO,GAAG;oBACjBD,OAAOe,KAAK,GAAG,CAAC,2BAA2B,EAAEsC,OAAO;oBACpD,OAAOrD;gBACT;YACF;QACF,EAAE,OAAOe,OAAO;YACdf,OAAOC,OAAO,GAAG;YACjBD,OAAOe,KAAK,GAAG,CAAC,4BAA4B,EAAEA,MAAMC,OAAO,EAAE;QAC/D;QAEA,OAAOhB;IACT;AACF"}