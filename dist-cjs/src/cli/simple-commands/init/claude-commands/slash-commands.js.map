{"version":3,"sources":["../../../../../../src/cli/simple-commands/init/claude-commands/slash-commands.js"],"sourcesContent":["// slash-commands.js - Create Claude Code slash commands\n\nimport { createSparcSlashCommand, createMainSparcCommand } from './sparc-commands.js';\nimport { createClaudeFlowCommands } from './claude-flow-commands.js';\nimport { copyTemplates } from '../template-copier.js';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\n\n// Create Claude Code slash commands for SPARC modes\nexport async function createClaudeSlashCommands(workingDir) {\n  try {\n    console.log('\\nüìù Creating Claude Code slash commands...');\n\n    // Use template copier for SPARC slash commands\n    const slashCommandOptions = {\n      sparc: true,\n      force: true,\n      dryRun: false,\n    };\n\n    // Check if .roomodes exists for dynamic generation\n    const roomodesPath = `${workingDir}/.roomodes`;\n    try {\n      const roomodesContent = await fs.readFile(roomodesPath, 'utf8');\n      const roomodes = JSON.parse(roomodesContent);\n\n      // Create slash commands for each SPARC mode\n      for (const mode of roomodes.customModes) {\n        const commandPath = join(workingDir, '.claude', 'commands', 'sparc', `${mode.slug}.md`);\n        const commandContent = createSparcSlashCommand(mode);\n\n        await fs.mkdir(join(workingDir, '.claude', 'commands', 'sparc'), { recursive: true });\n        await fs.writeFile(commandPath, commandContent);\n        console.log(`  ‚úì Created slash command: /sparc-${mode.slug}`);\n      }\n\n      // Create main SPARC command\n      const mainSparcCommand = createMainSparcCommand(roomodes.customModes);\n      await fs.writeFile(join(workingDir, '.claude', 'commands', 'sparc.md'), mainSparcCommand);\n      console.log('  ‚úì Created main slash command: /sparc');\n    } catch (err) {\n      // Fallback to template copier if .roomodes doesn't exist\n      console.log('  üîÑ Using template copier for SPARC commands...');\n      const copyResults = await copyTemplates(workingDir, slashCommandOptions);\n      \n      if (!copyResults.success) {\n        console.log(`  ‚ö†Ô∏è  Template copier failed: ${copyResults.errors.join(', ')}`);\n      }\n    }\n\n    // Create claude-flow specific commands\n    await createClaudeFlowCommands(workingDir);\n  } catch (err) {\n    // Legacy slash command creation - silently skip if it fails\n    // SPARC slash commands are already created successfully\n  }\n}\n"],"names":["createSparcSlashCommand","createMainSparcCommand","createClaudeFlowCommands","copyTemplates","promises","fs","join","createClaudeSlashCommands","workingDir","console","log","slashCommandOptions","sparc","force","dryRun","roomodesPath","roomodesContent","readFile","roomodes","JSON","parse","mode","customModes","commandPath","slug","commandContent","mkdir","recursive","writeFile","mainSparcCommand","err","copyResults","success","errors"],"mappings":"AAEA,SAASA,uBAAuB,EAAEC,sBAAsB,QAAQ,sBAAsB;AACtF,SAASC,wBAAwB,QAAQ,4BAA4B;AACrE,SAASC,aAAa,QAAQ,wBAAwB;AACtD,SAASC,YAAYC,EAAE,QAAQ,KAAK;AACpC,SAASC,IAAI,QAAQ,OAAO;AAG5B,OAAO,eAAeC,0BAA0BC,UAAU;IACxD,IAAI;QACFC,QAAQC,GAAG,CAAC;QAGZ,MAAMC,sBAAsB;YAC1BC,OAAO;YACPC,OAAO;YACPC,QAAQ;QACV;QAGA,MAAMC,eAAe,GAAGP,WAAW,UAAU,CAAC;QAC9C,IAAI;YACF,MAAMQ,kBAAkB,MAAMX,GAAGY,QAAQ,CAACF,cAAc;YACxD,MAAMG,WAAWC,KAAKC,KAAK,CAACJ;YAG5B,KAAK,MAAMK,QAAQH,SAASI,WAAW,CAAE;gBACvC,MAAMC,cAAcjB,KAAKE,YAAY,WAAW,YAAY,SAAS,GAAGa,KAAKG,IAAI,CAAC,GAAG,CAAC;gBACtF,MAAMC,iBAAiBzB,wBAAwBqB;gBAE/C,MAAMhB,GAAGqB,KAAK,CAACpB,KAAKE,YAAY,WAAW,YAAY,UAAU;oBAAEmB,WAAW;gBAAK;gBACnF,MAAMtB,GAAGuB,SAAS,CAACL,aAAaE;gBAChChB,QAAQC,GAAG,CAAC,CAAC,kCAAkC,EAAEW,KAAKG,IAAI,EAAE;YAC9D;YAGA,MAAMK,mBAAmB5B,uBAAuBiB,SAASI,WAAW;YACpE,MAAMjB,GAAGuB,SAAS,CAACtB,KAAKE,YAAY,WAAW,YAAY,aAAaqB;YACxEpB,QAAQC,GAAG,CAAC;QACd,EAAE,OAAOoB,KAAK;YAEZrB,QAAQC,GAAG,CAAC;YACZ,MAAMqB,cAAc,MAAM5B,cAAcK,YAAYG;YAEpD,IAAI,CAACoB,YAAYC,OAAO,EAAE;gBACxBvB,QAAQC,GAAG,CAAC,CAAC,8BAA8B,EAAEqB,YAAYE,MAAM,CAAC3B,IAAI,CAAC,OAAO;YAC9E;QACF;QAGA,MAAMJ,yBAAyBM;IACjC,EAAE,OAAOsB,KAAK,CAGd;AACF"}