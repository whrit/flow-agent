{"version":3,"sources":["../../../../../../src/cli/simple-commands/init/rollback/backup-manager.js"],"sourcesContent":["// backup-manager.js - Backup creation and management\n\n// Node.js compatible import\nimport fs from 'fs';\nimport { errors } from '../../../node-compat.js';\n\n// Polyfill for Deno's ensureDirSync\nfunction ensureDirSync(dirPath) {\n  try {\n    fs.mkdirSync(dirPath, { recursive: true });\n  } catch (error) {\n    if (error.code !== 'EEXIST') throw error;\n  }\n}\n\nexport class BackupManager {\n  constructor(workingDir) {\n    this.workingDir = workingDir;\n    this.backupDir = `${workingDir}/.claude-flow-backups`;\n  }\n\n  /**\n   * Create a backup of the current state\n   */\n  async createBackup(type = 'manual', description = '') {\n    const result = {\n      success: true,\n      id: null,\n      location: null,\n      errors: [],\n      warnings: [],\n      files: [],\n    };\n\n    try {\n      // Generate backup ID\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const backupId = `${type}-${timestamp}`;\n      result.id = backupId;\n\n      // Create backup directory\n      const backupPath = `${this.backupDir}/${backupId}`;\n      result.location = backupPath;\n\n      await this.ensureBackupDir();\n      await Deno.mkdir(backupPath, { recursive: true });\n\n      // Create backup manifest\n      const manifest = {\n        id: backupId,\n        type,\n        description,\n        timestamp: Date.now(),\n        workingDir: this.workingDir,\n        files: [],\n        directories: [],\n      };\n\n      // Backup critical files\n      const criticalFiles = await this.getCriticalFiles();\n      for (const file of criticalFiles) {\n        const backupResult = await this.backupFile(file, backupPath);\n        if (backupResult.success) {\n          manifest.files.push(backupResult.fileInfo);\n          result.files.push(file);\n        } else {\n          result.warnings.push(`Failed to backup file: ${file}`);\n        }\n      }\n\n      // Backup critical directories\n      const criticalDirs = await this.getCriticalDirectories();\n      for (const dir of criticalDirs) {\n        const backupResult = await this.backupDirectory(dir, backupPath);\n        if (backupResult.success) {\n          manifest.directories.push(backupResult.dirInfo);\n        } else {\n          result.warnings.push(`Failed to backup directory: ${dir}`);\n        }\n      }\n\n      // Save manifest\n      await Deno.writeTextFile(`${backupPath}/manifest.json`, JSON.stringify(manifest, null, 2));\n\n      // Create backup metadata\n      const metadata = {\n        created: Date.now(),\n        size: await this.calculateBackupSize(backupPath),\n        fileCount: manifest.files.length,\n        dirCount: manifest.directories.length,\n      };\n\n      await Deno.writeTextFile(`${backupPath}/metadata.json`, JSON.stringify(metadata, null, 2));\n\n      console.log(`  âœ“ Backup created: ${backupId}`);\n      console.log(`  ðŸ“ Files backed up: ${result.files.length}`);\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Backup creation failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Restore from backup\n   */\n  async restoreBackup(backupId) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      restored: [],\n    };\n\n    try {\n      const backupPath = `${this.backupDir}/${backupId}`;\n\n      // Check if backup exists\n      try {\n        await Deno.stat(backupPath);\n      } catch {\n        result.success = false;\n        result.errors.push(`Backup not found: ${backupId}`);\n        return result;\n      }\n\n      // Read manifest\n      const manifestPath = `${backupPath}/manifest.json`;\n      const manifestContent = await fs.readFile(manifestPath, 'utf8');\n      const manifest = JSON.parse(manifestContent);\n\n      // Restore files\n      for (const fileInfo of manifest.files) {\n        const restoreResult = await this.restoreFile(fileInfo, backupPath);\n        if (restoreResult.success) {\n          result.restored.push(fileInfo.originalPath);\n        } else {\n          result.warnings.push(`Failed to restore file: ${fileInfo.originalPath}`);\n        }\n      }\n\n      // Restore directories\n      for (const dirInfo of manifest.directories) {\n        const restoreResult = await this.restoreDirectory(dirInfo, backupPath);\n        if (restoreResult.success) {\n          result.restored.push(dirInfo.originalPath);\n        } else {\n          result.warnings.push(`Failed to restore directory: ${dirInfo.originalPath}`);\n        }\n      }\n\n      console.log(`  âœ“ Backup restored: ${backupId}`);\n      console.log(`  ðŸ“ Items restored: ${result.restored.length}`);\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Backup restoration failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * List available backups\n   */\n  async listBackups() {\n    const backups = [];\n\n    try {\n      await this.ensureBackupDir();\n\n      for await (const entry of Deno.readDir(this.backupDir)) {\n        if (entry.isDirectory) {\n          try {\n            const metadataPath = `${this.backupDir}/${entry.name}/metadata.json`;\n            const manifestPath = `${this.backupDir}/${entry.name}/manifest.json`;\n\n            const metadata = JSON.parse(await fs.readFile(metadataPath, 'utf8'));\n            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));\n\n            backups.push({\n              id: entry.name,\n              type: manifest.type,\n              description: manifest.description,\n              created: metadata.created,\n              size: metadata.size,\n              fileCount: metadata.fileCount,\n              dirCount: metadata.dirCount,\n            });\n          } catch {\n            // Skip invalid backup directories\n          }\n        }\n      }\n    } catch {\n      // Backup directory doesn't exist or can't be read\n    }\n\n    return backups.sort((a, b) => b.created - a.created);\n  }\n\n  /**\n   * Delete a backup\n   */\n  async deleteBackup(backupId) {\n    const result = {\n      success: true,\n      errors: [],\n    };\n\n    try {\n      const backupPath = `${this.backupDir}/${backupId}`;\n      await Deno.remove(backupPath, { recursive: true });\n      console.log(`  ðŸ—‘ï¸  Deleted backup: ${backupId}`);\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Failed to delete backup: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Clean up old backups\n   */\n  async cleanupOldBackups(keepCount = 5) {\n    const result = {\n      success: true,\n      cleaned: [],\n      errors: [],\n    };\n\n    try {\n      const backups = await this.listBackups();\n\n      if (backups.length > keepCount) {\n        const toDelete = backups.slice(keepCount);\n\n        for (const backup of toDelete) {\n          const deleteResult = await this.deleteBackup(backup.id);\n          if (deleteResult.success) {\n            result.cleaned.push(backup.id);\n          } else {\n            result.errors.push(...deleteResult.errors);\n          }\n        }\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Cleanup failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate backup system\n   */\n  async validateBackupSystem() {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n    };\n\n    try {\n      // Check backup directory\n      await this.ensureBackupDir();\n\n      // Test backup creation\n      const testBackup = await this.createTestBackup();\n      if (!testBackup.success) {\n        result.success = false;\n        result.errors.push('Cannot create test backup');\n      } else {\n        // Clean up test backup\n        await this.deleteBackup(testBackup.id);\n      }\n\n      // Check disk space\n      const spaceCheck = await this.checkBackupDiskSpace();\n      if (!spaceCheck.adequate) {\n        result.warnings.push('Low disk space for backups');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Backup system validation failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  // Helper methods\n\n  async ensureBackupDir() {\n    try {\n      await Deno.mkdir(this.backupDir, { recursive: true });\n    } catch (error) {\n      if (!(error instanceof errors.AlreadyExists)) {\n        throw error;\n      }\n    }\n  }\n\n  async getCriticalFiles() {\n    const files = [];\n    const potentialFiles = [\n      'CLAUDE.md',\n      'memory-bank.md',\n      'coordination.md',\n      'package.json',\n      'package-lock.json',\n      '.roomodes',\n      'claude-flow',\n      'memory/claude-flow-data.json',\n    ];\n\n    for (const file of potentialFiles) {\n      try {\n        const stat = await Deno.stat(`${this.workingDir}/${file}`);\n        if (stat.isFile) {\n          files.push(file);\n        }\n      } catch {\n        // File doesn't exist\n      }\n    }\n\n    return files;\n  }\n\n  async getCriticalDirectories() {\n    const dirs = [];\n    const potentialDirs = ['.claude', '.roo', 'memory/agents', 'memory/sessions', 'coordination'];\n\n    for (const dir of potentialDirs) {\n      try {\n        const stat = await Deno.stat(`${this.workingDir}/${dir}`);\n        if (stat.isDirectory) {\n          dirs.push(dir);\n        }\n      } catch {\n        // Directory doesn't exist\n      }\n    }\n\n    return dirs;\n  }\n\n  async backupFile(relativePath, backupPath) {\n    const result = {\n      success: true,\n      fileInfo: null,\n    };\n\n    try {\n      const sourcePath = `${this.workingDir}/${relativePath}`;\n      const destPath = `${backupPath}/${relativePath}`;\n\n      // Ensure destination directory exists\n      const destDir = destPath.split('/').slice(0, -1).join('/');\n      await Deno.mkdir(destDir, { recursive: true });\n\n      // Copy file\n      await Deno.copyFile(sourcePath, destPath);\n\n      // Get file info\n      const stat = await Deno.stat(sourcePath);\n      result.fileInfo = {\n        originalPath: relativePath,\n        backupPath: destPath,\n        size: stat.size,\n        modified: stat.mtime?.getTime() || 0,\n      };\n    } catch (error) {\n      result.success = false;\n      result.error = error.message;\n    }\n\n    return result;\n  }\n\n  async backupDirectory(relativePath, backupPath) {\n    const result = {\n      success: true,\n      dirInfo: null,\n    };\n\n    try {\n      const sourcePath = `${this.workingDir}/${relativePath}`;\n      const destPath = `${backupPath}/${relativePath}`;\n\n      // Create destination directory\n      await Deno.mkdir(destPath, { recursive: true });\n\n      // Copy directory contents recursively\n      await this.copyDirectoryRecursive(sourcePath, destPath);\n\n      result.dirInfo = {\n        originalPath: relativePath,\n        backupPath: destPath,\n      };\n    } catch (error) {\n      result.success = false;\n      result.error = error.message;\n    }\n\n    return result;\n  }\n\n  async copyDirectoryRecursive(source, dest) {\n    for await (const entry of Deno.readDir(source)) {\n      const sourcePath = `${source}/${entry.name}`;\n      const destPath = `${dest}/${entry.name}`;\n\n      if (entry.isFile) {\n        await Deno.copyFile(sourcePath, destPath);\n      } else if (entry.isDirectory) {\n        await Deno.mkdir(destPath, { recursive: true });\n        await this.copyDirectoryRecursive(sourcePath, destPath);\n      }\n    }\n  }\n\n  async restoreFile(fileInfo, backupPath) {\n    const result = {\n      success: true,\n    };\n\n    try {\n      const sourcePath = fileInfo.backupPath;\n      const destPath = `${this.workingDir}/${fileInfo.originalPath}`;\n\n      // Ensure destination directory exists\n      const destDir = destPath.split('/').slice(0, -1).join('/');\n      await Deno.mkdir(destDir, { recursive: true });\n\n      // Copy file back\n      await Deno.copyFile(sourcePath, destPath);\n    } catch (error) {\n      result.success = false;\n      result.error = error.message;\n    }\n\n    return result;\n  }\n\n  async restoreDirectory(dirInfo, backupPath) {\n    const result = {\n      success: true,\n    };\n\n    try {\n      const sourcePath = dirInfo.backupPath;\n      const destPath = `${this.workingDir}/${dirInfo.originalPath}`;\n\n      // Remove existing directory if it exists\n      try {\n        await Deno.remove(destPath, { recursive: true });\n      } catch {\n        // Directory might not exist\n      }\n\n      // Create destination directory\n      await Deno.mkdir(destPath, { recursive: true });\n\n      // Copy directory contents back\n      await this.copyDirectoryRecursive(sourcePath, destPath);\n    } catch (error) {\n      result.success = false;\n      result.error = error.message;\n    }\n\n    return result;\n  }\n\n  async calculateBackupSize(backupPath) {\n    let totalSize = 0;\n\n    try {\n      for await (const entry of Deno.readDir(backupPath)) {\n        const entryPath = `${backupPath}/${entry.name}`;\n        const stat = await Deno.stat(entryPath);\n\n        if (stat.isFile) {\n          totalSize += stat.size;\n        } else if (stat.isDirectory) {\n          totalSize += await this.calculateBackupSize(entryPath);\n        }\n      }\n    } catch {\n      // Error calculating size\n    }\n\n    return totalSize;\n  }\n\n  async createTestBackup() {\n    try {\n      return await this.createBackup('test', 'System validation test');\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n\n  async checkBackupDiskSpace() {\n    const result = {\n      adequate: true,\n      available: 0,\n    };\n\n    try {\n      const command = new Deno.Command('df', {\n        args: ['-k', this.backupDir],\n        stdout: 'piped',\n      });\n\n      const { stdout, success } = await command.output();\n\n      if (success) {\n        const output = new TextDecoder().decode(stdout);\n        const lines = output.trim().split('\\n');\n\n        if (lines.length >= 2) {\n          const parts = lines[1].split(/\\s+/);\n          if (parts.length >= 4) {\n            result.available = parseInt(parts[3]) / 1024; // MB\n            result.adequate = result.available > 500; // At least 500MB for backups\n          }\n        }\n      }\n    } catch {\n      // Can't check - assume adequate\n      result.adequate = true;\n    }\n\n    return result;\n  }\n}\n"],"names":["fs","errors","ensureDirSync","dirPath","mkdirSync","recursive","error","code","BackupManager","workingDir","backupDir","createBackup","type","description","result","success","id","location","warnings","files","timestamp","Date","toISOString","replace","backupId","backupPath","ensureBackupDir","Deno","mkdir","manifest","now","directories","criticalFiles","getCriticalFiles","file","backupResult","backupFile","push","fileInfo","criticalDirs","getCriticalDirectories","dir","backupDirectory","dirInfo","writeTextFile","JSON","stringify","metadata","created","size","calculateBackupSize","fileCount","length","dirCount","console","log","message","restoreBackup","restored","stat","manifestPath","manifestContent","readFile","parse","restoreResult","restoreFile","originalPath","restoreDirectory","listBackups","backups","entry","readDir","isDirectory","metadataPath","name","sort","a","b","deleteBackup","remove","cleanupOldBackups","keepCount","cleaned","toDelete","slice","backup","deleteResult","validateBackupSystem","testBackup","createTestBackup","spaceCheck","checkBackupDiskSpace","adequate","AlreadyExists","potentialFiles","isFile","dirs","potentialDirs","relativePath","sourcePath","destPath","destDir","split","join","copyFile","modified","mtime","getTime","copyDirectoryRecursive","source","dest","totalSize","entryPath","available","command","Command","args","stdout","output","TextDecoder","decode","lines","trim","parts","parseInt"],"mappings":"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"}