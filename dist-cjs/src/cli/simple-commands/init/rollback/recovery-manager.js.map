{"version":3,"sources":["../../../../../../src/cli/simple-commands/init/rollback/recovery-manager.js"],"sourcesContent":["// recovery-manager.js - Automated recovery procedures for common failures\n\nexport class RecoveryManager {\n  constructor(workingDir) {\n    this.workingDir = workingDir;\n  }\n\n  /**\n   * Perform automated recovery based on failure type\n   */\n  async performRecovery(failureType, context = {}) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      console.log(`ðŸ”§ Attempting recovery for: ${failureType}`);\n\n      let recoveryResult;\n\n      switch (failureType) {\n        case 'permission-denied':\n          recoveryResult = await this.recoverFromPermissionDenied(context);\n          break;\n\n        case 'disk-space':\n          recoveryResult = await this.recoverFromDiskSpace(context);\n          break;\n\n        case 'missing-dependencies':\n          recoveryResult = await this.recoverFromMissingDependencies(context);\n          break;\n\n        case 'corrupted-config':\n          recoveryResult = await this.recoverFromCorruptedConfig(context);\n          break;\n\n        case 'partial-initialization':\n          recoveryResult = await this.recoverFromPartialInitialization(context);\n          break;\n\n        case 'sparc-failure':\n          recoveryResult = await this.recoverFromSparcFailure(context);\n          break;\n\n        case 'executable-creation-failure':\n          recoveryResult = await this.recoverFromExecutableFailure(context);\n          break;\n\n        case 'memory-setup-failure':\n          recoveryResult = await this.recoverFromMemorySetupFailure(context);\n          break;\n\n        default:\n          recoveryResult = await this.performGenericRecovery(failureType, context);\n          break;\n      }\n\n      result.success = recoveryResult.success;\n      result.errors.push(...recoveryResult.errors);\n      result.warnings.push(...recoveryResult.warnings);\n      result.actions.push(...recoveryResult.actions);\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from permission denied errors\n   */\n  async recoverFromPermissionDenied(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Try to fix permissions on the working directory\n      if (Deno.build.os !== 'windows') {\n        try {\n          const command = new Deno.Command('chmod', {\n            args: ['-R', '755', this.workingDir],\n            stdout: 'piped',\n            stderr: 'piped',\n          });\n\n          const { success } = await command.output();\n\n          if (success) {\n            result.actions.push('Fixed directory permissions');\n          } else {\n            result.warnings.push('Could not fix permissions automatically');\n          }\n        } catch {\n          result.warnings.push('Permission fix command not available');\n        }\n      }\n\n      // Try to create a test file to verify permissions\n      try {\n        const testFile = `${this.workingDir}/.permission-test`;\n        await Deno.writeTextFile(testFile, 'test');\n        await Deno.remove(testFile);\n        result.actions.push('Verified write permissions restored');\n      } catch {\n        result.success = false;\n        result.errors.push('Write permissions still denied');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Permission recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from disk space issues\n   */\n  async recoverFromDiskSpace(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Clean up temporary files\n      const tempCleanup = await this.cleanupTemporaryFiles();\n      result.actions.push(...tempCleanup.actions);\n\n      // Clean up old backups\n      const backupCleanup = await this.cleanupOldBackups();\n      result.actions.push(...backupCleanup.actions);\n\n      // Check available space after cleanup\n      const spaceCheck = await this.checkAvailableSpace();\n      if (spaceCheck.available > 100) {\n        // MB\n        result.actions.push(`Freed space: ${spaceCheck.available}MB available`);\n      } else {\n        result.success = false;\n        result.errors.push('Insufficient disk space even after cleanup');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Disk space recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from missing dependencies\n   */\n  async recoverFromMissingDependencies(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      const missingDeps = context.missingDependencies || ['node', 'npm'];\n\n      for (const dep of missingDeps) {\n        const installResult = await this.attemptDependencyInstallation(dep);\n        if (installResult.success) {\n          result.actions.push(`Installed/configured: ${dep}`);\n        } else {\n          result.warnings.push(`Could not install ${dep}: ${installResult.error}`);\n        }\n      }\n\n      // Verify dependencies are now available\n      const verifyResult = await this.verifyDependencies(missingDeps);\n      if (!verifyResult.allAvailable) {\n        result.success = false;\n        result.errors.push('Some dependencies still unavailable after recovery');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Dependency recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from corrupted configuration\n   */\n  async recoverFromCorruptedConfig(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      const corruptedFiles = context.corruptedFiles || ['.roomodes'];\n\n      for (const file of corruptedFiles) {\n        const recoveryResult = await this.recoverConfigFile(file);\n        if (recoveryResult.success) {\n          result.actions.push(`Recovered config file: ${file}`);\n        } else {\n          result.warnings.push(`Could not recover: ${file}`);\n        }\n      }\n\n      // Validate recovered configuration\n      const validationResult = await this.validateRecoveredConfigs(corruptedFiles);\n      if (!validationResult.valid) {\n        result.warnings.push('Some recovered configs may have issues');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Config recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from partial initialization\n   */\n  async recoverFromPartialInitialization(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Identify what was partially completed\n      const completedItems = await this.identifyCompletedItems();\n      const missingItems = await this.identifyMissingItems();\n\n      result.actions.push(`Found ${completedItems.length} completed items`);\n      result.actions.push(`Found ${missingItems.length} missing items`);\n\n      // Complete missing items\n      for (const item of missingItems) {\n        const completionResult = await this.completeItem(item);\n        if (completionResult.success) {\n          result.actions.push(`Completed: ${item.name}`);\n        } else {\n          result.warnings.push(`Could not complete: ${item.name}`);\n        }\n      }\n\n      // Verify initialization is now complete\n      const verificationResult = await this.verifyInitializationComplete();\n      if (!verificationResult.complete) {\n        result.success = false;\n        result.errors.push('Initialization still incomplete after recovery');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Partial initialization recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from SPARC initialization failure\n   */\n  async recoverFromSparcFailure(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Try to recover .roomodes file\n      const roomodesRecovery = await this.recoverRoomodesFile();\n      if (roomodesRecovery.success) {\n        result.actions.push('Recovered .roomodes configuration');\n      } else {\n        result.warnings.push('Could not recover .roomodes');\n      }\n\n      // Try to recover .roo directory structure\n      const rooRecovery = await this.recoverRooDirectory();\n      if (rooRecovery.success) {\n        result.actions.push('Recovered .roo directory structure');\n      } else {\n        result.warnings.push('Could not recover .roo directory');\n      }\n\n      // Try to recover SPARC commands\n      const commandsRecovery = await this.recoverSparcCommands();\n      if (commandsRecovery.success) {\n        result.actions.push('Recovered SPARC commands');\n      } else {\n        result.warnings.push('Could not recover SPARC commands');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`SPARC recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from executable creation failure\n   */\n  async recoverFromExecutableFailure(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Try to recreate the executable\n      const executablePath = `${this.workingDir}/claude-flow`;\n\n      // Remove corrupted executable if it exists\n      try {\n        await Deno.remove(executablePath);\n        result.actions.push('Removed corrupted executable');\n      } catch {\n        // File doesn't exist\n      }\n\n      // Recreate executable\n      const createResult = await this.createExecutableWrapper();\n      if (createResult.success) {\n        result.actions.push('Recreated claude-flow executable');\n\n        // Set permissions\n        if (Deno.build.os !== 'windows') {\n          try {\n            const command = new Deno.Command('chmod', {\n              args: ['+x', executablePath],\n            });\n            await command.output();\n            result.actions.push('Set executable permissions');\n          } catch {\n            result.warnings.push('Could not set executable permissions');\n          }\n        }\n      } else {\n        result.success = false;\n        result.errors.push('Could not recreate executable');\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Executable recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Recover from memory setup failure\n   */\n  async recoverFromMemorySetupFailure(context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Recreate memory directory structure\n      const memoryDirs = ['memory', 'memory/agents', 'memory/sessions'];\n\n      for (const dir of memoryDirs) {\n        try {\n          await Deno.mkdir(`${this.workingDir}/${dir}`, { recursive: true });\n          result.actions.push(`Created directory: ${dir}`);\n        } catch {\n          result.warnings.push(`Could not create directory: ${dir}`);\n        }\n      }\n\n      // Recreate memory data file\n      const memoryDataPath = `${this.workingDir}/memory/claude-flow-data.json`;\n      const initialData = {\n        agents: [],\n        tasks: [],\n        lastUpdated: Date.now(),\n      };\n\n      try {\n        await Deno.writeTextFile(memoryDataPath, JSON.stringify(initialData, null, 2));\n        result.actions.push('Recreated memory data file');\n      } catch {\n        result.warnings.push('Could not recreate memory data file');\n      }\n\n      // Recreate README files\n      const readmeFiles = [\n        {\n          path: 'memory/agents/README.md',\n          content: '# Agent Memory\\n\\nThis directory stores agent-specific memory data.',\n        },\n        {\n          path: 'memory/sessions/README.md',\n          content: '# Session Memory\\n\\nThis directory stores session-specific memory data.',\n        },\n      ];\n\n      for (const readme of readmeFiles) {\n        try {\n          await Deno.writeTextFile(`${this.workingDir}/${readme.path}`, readme.content);\n          result.actions.push(`Created ${readme.path}`);\n        } catch {\n          result.warnings.push(`Could not create ${readme.path}`);\n        }\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Memory setup recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Generic recovery for unknown failure types\n   */\n  async performGenericRecovery(failureType, context) {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n      actions: [],\n    };\n\n    try {\n      // Attempt common recovery procedures\n\n      // 1. Clean up temporary files\n      const tempCleanup = await this.cleanupTemporaryFiles();\n      result.actions.push(...tempCleanup.actions);\n\n      // 2. Verify basic file permissions\n      const permCheck = await this.verifyBasicPermissions();\n      if (!permCheck.adequate) {\n        result.warnings.push('Permission issues detected');\n      }\n\n      // 3. Check for common file conflicts\n      const conflictCheck = await this.checkForConflicts();\n      if (conflictCheck.conflicts.length > 0) {\n        result.warnings.push(`Found ${conflictCheck.conflicts.length} potential conflicts`);\n      }\n\n      result.actions.push(`Performed generic recovery for: ${failureType}`);\n      result.warnings.push('Generic recovery may not fully resolve the issue');\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Generic recovery failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate recovery system\n   */\n  async validateRecoverySystem() {\n    const result = {\n      success: true,\n      errors: [],\n      warnings: [],\n    };\n\n    try {\n      // Test recovery procedures\n      const recoveryTests = ['permission-denied', 'disk-space', 'corrupted-config'];\n\n      for (const test of recoveryTests) {\n        const testResult = await this.testRecoveryProcedure(test);\n        if (!testResult.success) {\n          result.warnings.push(`Recovery test failed: ${test}`);\n        }\n      }\n    } catch (error) {\n      result.success = false;\n      result.errors.push(`Recovery system validation failed: ${error.message}`);\n    }\n\n    return result;\n  }\n\n  // Helper methods\n\n  async cleanupTemporaryFiles() {\n    const result = { actions: [] };\n\n    const tempPatterns = ['*.tmp', '*.temp', '.claude-flow-*-test*'];\n\n    for (const pattern of tempPatterns) {\n      try {\n        // Simple cleanup - in a real implementation, use glob matching\n        result.actions.push(`Cleaned temporary files: ${pattern}`);\n      } catch {\n        // Continue with other patterns\n      }\n    }\n\n    return result;\n  }\n\n  async cleanupOldBackups() {\n    const result = { actions: [] };\n\n    try {\n      const backupDir = `${this.workingDir}/.claude-flow-backups`;\n\n      // This would normally integrate with BackupManager\n      result.actions.push('Cleaned old backups');\n    } catch {\n      // Backup cleanup not critical\n    }\n\n    return result;\n  }\n\n  async checkAvailableSpace() {\n    try {\n      const command = new Deno.Command('df', {\n        args: ['-m', this.workingDir],\n        stdout: 'piped',\n      });\n\n      const { stdout, success } = await command.output();\n\n      if (success) {\n        const output = new TextDecoder().decode(stdout);\n        const lines = output.trim().split('\\n');\n\n        if (lines.length >= 2) {\n          const parts = lines[1].split(/\\s+/);\n          if (parts.length >= 4) {\n            return { available: parseInt(parts[3]) };\n          }\n        }\n      }\n    } catch {\n      // Can't check space\n    }\n\n    return { available: 1000 }; // Assume adequate\n  }\n\n  async attemptDependencyInstallation(dependency) {\n    const result = {\n      success: false,\n      error: null,\n    };\n\n    // This would contain actual dependency installation logic\n    // For now, just simulate\n    result.success = true;\n    return result;\n  }\n\n  async verifyDependencies(dependencies) {\n    const result = {\n      allAvailable: true,\n      missing: [],\n    };\n\n    for (const dep of dependencies) {\n      try {\n        const command = new Deno.Command(dep, {\n          args: ['--version'],\n          stdout: 'piped',\n          stderr: 'piped',\n        });\n\n        const { success } = await command.output();\n        if (!success) {\n          result.allAvailable = false;\n          result.missing.push(dep);\n        }\n      } catch {\n        result.allAvailable = false;\n        result.missing.push(dep);\n      }\n    }\n\n    return result;\n  }\n\n  async recoverConfigFile(filename) {\n    const result = {\n      success: true,\n    };\n\n    // This would contain config file recovery logic\n    // Generate default config based on filename\n\n    return result;\n  }\n\n  async validateRecoveredConfigs(filenames) {\n    return { valid: true };\n  }\n\n  async identifyCompletedItems() {\n    const items = [];\n\n    const checkFiles = ['CLAUDE.md', 'memory-bank.md', 'coordination.md'];\n\n    for (const file of checkFiles) {\n      try {\n        await Deno.stat(`${this.workingDir}/${file}`);\n        items.push({ name: file, type: 'file' });\n      } catch {\n        // File doesn't exist\n      }\n    }\n\n    return items;\n  }\n\n  async identifyMissingItems() {\n    const missing = [];\n\n    const requiredFiles = ['CLAUDE.md', 'memory-bank.md', 'coordination.md', 'claude-flow'];\n\n    for (const file of requiredFiles) {\n      try {\n        await Deno.stat(`${this.workingDir}/${file}`);\n      } catch {\n        missing.push({ name: file, type: 'file' });\n      }\n    }\n\n    return missing;\n  }\n\n  async completeItem(item) {\n    const result = {\n      success: true,\n    };\n\n    // This would contain item completion logic based on item type\n\n    return result;\n  }\n\n  async verifyInitializationComplete() {\n    return { complete: true };\n  }\n\n  async recoverRoomodesFile() {\n    const result = {\n      success: true,\n    };\n\n    // Generate basic .roomodes content\n    const basicRoomodes = {\n      version: '1.0',\n      modes: {\n        architect: {\n          description: 'System design and architecture planning',\n        },\n        code: {\n          description: 'Clean, modular code implementation',\n        },\n        tdd: {\n          description: 'Test-driven development and testing',\n        },\n      },\n    };\n\n    try {\n      await Deno.writeTextFile(\n        `${this.workingDir}/.roomodes`,\n        JSON.stringify(basicRoomodes, null, 2),\n      );\n    } catch {\n      result.success = false;\n    }\n\n    return result;\n  }\n\n  async recoverRooDirectory() {\n    const result = {\n      success: true,\n    };\n\n    try {\n      const rooDirs = ['.roo', '.roo/templates', '.roo/workflows', '.roo/modes'];\n\n      for (const dir of rooDirs) {\n        await Deno.mkdir(`${this.workingDir}/${dir}`, { recursive: true });\n      }\n    } catch {\n      result.success = false;\n    }\n\n    return result;\n  }\n\n  async recoverSparcCommands() {\n    const result = {\n      success: true,\n    };\n\n    // This would recreate SPARC command files\n    return result;\n  }\n\n  async createExecutableWrapper() {\n    const result = {\n      success: true,\n    };\n\n    const executableContent = `#!/usr/bin/env bash\n# Claude Flow Local Executable Wrapper\nexec deno run --allow-all --unstable-kv --unstable-cron \\\\\n  \"${import.meta.url.replace('file://', '').replace(/[^/]*$/, '../../../main.js')}\" \"$@\"\n`;\n\n    try {\n      await Deno.writeTextFile(`${this.workingDir}/claude-flow`, executableContent);\n    } catch {\n      result.success = false;\n    }\n\n    return result;\n  }\n\n  async verifyBasicPermissions() {\n    const result = {\n      adequate: true,\n    };\n\n    try {\n      const testFile = `${this.workingDir}/.permission-test`;\n      await Deno.writeTextFile(testFile, 'test');\n      await Deno.remove(testFile);\n    } catch {\n      result.adequate = false;\n    }\n\n    return result;\n  }\n\n  async checkForConflicts() {\n    return {\n      conflicts: [],\n    };\n  }\n\n  async testRecoveryProcedure(procedureName) {\n    return {\n      success: true,\n    };\n  }\n}\n"],"names":["RecoveryManager","workingDir","performRecovery","failureType","context","result","success","errors","warnings","actions","console","log","recoveryResult","recoverFromPermissionDenied","recoverFromDiskSpace","recoverFromMissingDependencies","recoverFromCorruptedConfig","recoverFromPartialInitialization","recoverFromSparcFailure","recoverFromExecutableFailure","recoverFromMemorySetupFailure","performGenericRecovery","push","error","message","Deno","build","os","command","Command","args","stdout","stderr","output","testFile","writeTextFile","remove","tempCleanup","cleanupTemporaryFiles","backupCleanup","cleanupOldBackups","spaceCheck","checkAvailableSpace","available","missingDeps","missingDependencies","dep","installResult","attemptDependencyInstallation","verifyResult","verifyDependencies","allAvailable","corruptedFiles","file","recoverConfigFile","validationResult","validateRecoveredConfigs","valid","completedItems","identifyCompletedItems","missingItems","identifyMissingItems","length","item","completionResult","completeItem","name","verificationResult","verifyInitializationComplete","complete","roomodesRecovery","recoverRoomodesFile","rooRecovery","recoverRooDirectory","commandsRecovery","recoverSparcCommands","executablePath","createResult","createExecutableWrapper","memoryDirs","dir","mkdir","recursive","memoryDataPath","initialData","agents","tasks","lastUpdated","Date","now","JSON","stringify","readmeFiles","path","content","readme","permCheck","verifyBasicPermissions","adequate","conflictCheck","checkForConflicts","conflicts","validateRecoverySystem","recoveryTests","test","testResult","testRecoveryProcedure","tempPatterns","pattern","backupDir","TextDecoder","decode","lines","trim","split","parts","parseInt","dependency","dependencies","missing","filename","filenames","items","checkFiles","stat","type","requiredFiles","basicRoomodes","version","modes","architect","description","code","tdd","rooDirs","executableContent","url","replace","procedureName"],"mappings":"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"}