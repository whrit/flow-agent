{"version":3,"sources":["../../../../src/cli/simple-commands/training-pipeline.js"],"sourcesContent":["#!/usr/bin/env node\n/**\n * Training Pipeline with Real Task Execution\n * Executes actual code and learns from real test results\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { execSync, spawn } from 'child_process';\nimport { promisify } from 'util';\nimport { exec } from 'child_process';\n\nconst execAsync = promisify(exec);\n\n/**\n * Training Pipeline that executes real tasks and learns from actual results\n */\nexport class TrainingPipeline {\n  constructor() {\n    this.pipelineConfig = '.claude-flow/pipeline-config.json';\n    this.trainingLog = '.claude-flow/training/pipeline-log.jsonl';\n    this.improvementMetrics = '.claude-flow/metrics/improvements.json';\n    this.agentProfiles = '.claude-flow/agents/profiles.json';\n    this.realTasksDir = '.claude-flow/training/real-tasks';\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the training pipeline\n   */\n  async initialize() {\n    // Create necessary directories\n    const dirs = [\n      '.claude-flow/pipeline',\n      '.claude-flow/training',\n      '.claude-flow/training/real-tasks',\n      '.claude-flow/metrics',\n      '.claude-flow/agents',\n      '.claude-flow/validation',\n      '.claude-flow/benchmarks'\n    ];\n\n    for (const dir of dirs) {\n      await fs.mkdir(dir, { recursive: true });\n    }\n\n    // Load or create pipeline configuration\n    await this.loadPipelineConfig();\n    \n    console.log('üöÄ Training Pipeline initialized');\n    this.initialized = true;\n  }\n\n  /**\n   * STAGE 1: Generate Training Tasks\n   * Creates actual code files that can be tested\n   */\n  async generateTrainingTasks(complexity = 'medium') {\n    const taskId = Date.now();\n    const taskDir = path.join(this.realTasksDir, `task-${taskId}`);\n    await fs.mkdir(taskDir, { recursive: true });\n\n    const tasks = {\n      easy: [\n        {\n          type: 'function',\n          name: 'validateEmail',\n          task: 'Create email validation function',\n          code: `function validateEmail(email) {\n  const regex = /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/;\n  return regex.test(email);\n}\n\nmodule.exports = { validateEmail };`,\n          test: `\nconst { validateEmail } = require('./index');\n\ndescribe('validateEmail', () => {\n  test('validates correct email', () => {\n    expect(validateEmail('test@example.com')).toBe(true);\n  });\n  \n  test('rejects invalid email', () => {\n    expect(validateEmail('invalid')).toBe(false);\n  });\n});\n`\n        }\n      ],\n      medium: [\n        {\n          type: 'api',\n          name: 'userApi',\n          task: 'Build user API endpoint',\n          code: `\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\nconst users = [];\n\napp.get('/users', (req, res) => {\n  res.json(users);\n});\n\napp.post('/users', (req, res) => {\n  const { name, email } = req.body;\n  if (!name || !email) {\n    return res.status(400).json({ error: 'Name and email required' });\n  }\n  const user = { id: users.length + 1, name, email };\n  users.push(user);\n  res.status(201).json(user);\n});\n\nmodule.exports = app;\n`,\n          test: `\nconst request = require('supertest');\nconst app = require('./index');\n\ndescribe('User API', () => {\n  test('GET /users returns empty array initially', async () => {\n    const res = await request(app).get('/users');\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual([]);\n  });\n  \n  test('POST /users creates a user', async () => {\n    const res = await request(app)\n      .post('/users')\n      .send({ name: 'Test', email: 'test@test.com' });\n    expect(res.status).toBe(201);\n    expect(res.body.name).toBe('Test');\n  });\n});\n`\n        }\n      ],\n      hard: [\n        {\n          type: 'algorithm',\n          name: 'sortAlgorithm',\n          task: 'Implement efficient sorting',\n          code: `\nfunction quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left = arr.filter(x => x < pivot);\n  const middle = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  \n  return [...quickSort(left), ...middle, ...quickSort(right)];\n}\n\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  \n  const result = [];\n  let i = 0, j = 0;\n  \n  while (i < left.length && j < right.length) {\n    if (left[i] < right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n  \n  return result.concat(left.slice(i)).concat(right.slice(j));\n}\n\nmodule.exports = { quickSort, mergeSort };\n`,\n          test: `\nconst { quickSort, mergeSort } = require('./index');\n\ndescribe('Sorting Algorithms', () => {\n  const unsorted = [3, 1, 4, 1, 5, 9, 2, 6];\n  const sorted = [1, 1, 2, 3, 4, 5, 6, 9];\n  \n  test('quickSort sorts correctly', () => {\n    expect(quickSort(unsorted)).toEqual(sorted);\n  });\n  \n  test('mergeSort sorts correctly', () => {\n    expect(mergeSort(unsorted)).toEqual(sorted);\n  });\n  \n  test('handles empty arrays', () => {\n    expect(quickSort([])).toEqual([]);\n    expect(mergeSort([])).toEqual([]);\n  });\n});\n`\n        }\n      ]\n    };\n\n    const selectedTasks = tasks[complexity] || tasks.medium;\n    const realTasks = [];\n\n    // Create real task files\n    for (const task of selectedTasks) {\n      const projectDir = path.join(taskDir, task.name);\n      await fs.mkdir(projectDir, { recursive: true });\n      \n      // Write actual code file\n      await fs.writeFile(path.join(projectDir, 'index.js'), task.code);\n      \n      // Write test file\n      await fs.writeFile(path.join(projectDir, 'index.test.js'), task.test);\n      \n      // Create package.json with real dependencies\n      const packageJson = {\n        name: task.name,\n        version: \"1.0.0\",\n        scripts: {\n          test: \"jest --silent\",\n          lint: \"eslint index.js || true\",\n          typecheck: \"echo 'No TypeScript' || true\"\n        },\n        devDependencies: {\n          jest: \"^29.0.0\",\n          eslint: \"^8.0.0\",\n          supertest: \"^6.0.0\"\n        },\n        dependencies: {\n          express: task.type === 'api' ? \"^4.18.0\" : undefined\n        }\n      };\n      \n      await fs.writeFile(\n        path.join(projectDir, 'package.json'), \n        JSON.stringify(packageJson, null, 2)\n      );\n\n      realTasks.push({\n        ...task,\n        projectDir,\n        taskId\n      });\n    }\n\n    console.log(`üìù Generated ${realTasks.length} ${complexity} training tasks`);\n    return realTasks;\n  }\n\n  /**\n   * STAGE 2: Execute Tasks with Different Strategies\n   * Actually runs npm install, tests, and measures real performance\n   */\n  async executeTrainingRun(tasks, agentConfig = {}) {\n    const results = [];\n    \n    for (const task of tasks) {\n      console.log(`\\nüîÑ Executing task: ${task.task}`);\n      \n      // Install dependencies (only once per task)\n      try {\n        console.log(`   üì¶ Installing dependencies...`);\n        execSync('npm install --silent', { \n          cwd: task.projectDir,\n          stdio: 'pipe'\n        });\n      } catch (e) {\n        console.log(`   ‚ö†Ô∏è Install warning: ${e.message.slice(0, 50)}`);\n      }\n\n      // Test different strategies with REAL variations\n      const strategies = agentConfig.strategies || ['conservative', 'balanced', 'aggressive'];\n      \n      for (const strategy of strategies) {\n        const result = await this.executeTaskWithStrategy(task, strategy);\n        results.push({\n          task: task.task,\n          type: task.type,\n          strategy,\n          ...result,\n          timestamp: new Date().toISOString()\n        });\n      }\n    }\n\n    // Save real results\n    const resultsFile = `.claude-flow/training/real-results-${Date.now()}.json`;\n    await fs.writeFile(resultsFile, JSON.stringify(results, null, 2));\n\n    return results;\n  }\n\n  /**\n   * Execute a task with a specific strategy\n   * Strategies affect how we modify and test the code\n   */\n  async executeTaskWithStrategy(task, strategy) {\n    const startTime = Date.now();\n    const checks = {};\n    \n    // Save original code\n    const originalCode = await fs.readFile(path.join(task.projectDir, 'index.js'), 'utf8');\n    \n    // Modify code based on strategy (but more carefully!)\n    if (strategy === 'aggressive') {\n      // Aggressive: Skip some validation (but keep valid syntax)\n      const aggressiveCode = originalCode.replace(\n        /if \\(!(\\w+)\\)/g, \n        'if (false && !$1)'\n      );\n      await fs.writeFile(path.join(task.projectDir, 'index.js'), aggressiveCode);\n    } else if (strategy === 'conservative') {\n      // Conservative: Add validation at the top of functions\n      const conservativeCode = originalCode.replace(\n        /function (\\w+)\\((.*?)\\) {/g,\n        'function $1($2) {\\n  // Extra validation for conservative strategy\\n  if (arguments.length === 0) throw new Error(\"No arguments provided\");'\n      );\n      await fs.writeFile(path.join(task.projectDir, 'index.js'), conservativeCode);\n    }\n    // Balanced: Keep original code\n\n    // Run REAL tests\n    try {\n      const testResult = execSync('npm test', { \n        cwd: task.projectDir,\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      checks.test = { \n        passed: true, \n        score: 1.0,\n        output: testResult.slice(0, 100)\n      };\n    } catch (e) {\n      checks.test = { \n        passed: false, \n        score: 0.3,\n        error: e.message.slice(0, 100)\n      };\n    }\n\n    // Run REAL lint\n    try {\n      const lintResult = execSync('npm run lint', { \n        cwd: task.projectDir,\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      const hasErrors = lintResult.includes('error');\n      checks.lint = { \n        passed: !hasErrors, \n        score: hasErrors ? 0.5 : 1.0\n      };\n    } catch (e) {\n      checks.lint = { \n        passed: false, \n        score: 0.3\n      };\n    }\n\n    // Restore original code after testing\n    await fs.writeFile(path.join(task.projectDir, 'index.js'), originalCode);\n    \n    // Calculate REAL performance metrics\n    const executionTime = Date.now() - startTime;\n    const successRate = Object.values(checks).filter(c => c.passed).length / Object.values(checks).length;\n    \n    // Strategy-specific scoring based on REAL results\n    let strategyBonus = 0;\n    if (strategy === 'aggressive' && executionTime < 1000) {\n      strategyBonus = 0.2; // Bonus for fast execution\n    } else if (strategy === 'conservative' && successRate === 1.0) {\n      strategyBonus = 0.3; // Bonus for perfect reliability\n    } else if (strategy === 'balanced' && successRate > 0.5 && executionTime < 2000) {\n      strategyBonus = 0.25; // Bonus for good balance\n    }\n    \n    const score = (successRate * 60) + (Math.max(0, 1 - executionTime/5000) * 20) + (strategyBonus * 20);\n    \n    return {\n      executionTime,\n      successRate,\n      checks,\n      strategy,\n      score,\n      real: true // Mark as real execution\n    };\n  }\n\n  /**\n   * STAGE 3: Learn from Results\n   * Updates profiles based on actual performance\n   */\n  async learnFromResults(results) {\n    console.log('\\nüß† Learning from results...');\n    \n    // Load current agent profiles\n    let profiles = {};\n    try {\n      const data = await fs.readFile(this.agentProfiles, 'utf8');\n      profiles = JSON.parse(data);\n    } catch {\n      profiles = this.getDefaultProfiles();\n    }\n\n    // Analyze REAL results by strategy\n    const strategyPerformance = {};\n    for (const result of results) {\n      if (!strategyPerformance[result.strategy]) {\n        strategyPerformance[result.strategy] = {\n          totalScore: 0,\n          count: 0,\n          avgExecutionTime: 0,\n          successRate: 0,\n          realExecutions: 0\n        };\n      }\n      \n      const perf = strategyPerformance[result.strategy];\n      perf.totalScore += result.score;\n      perf.count++;\n      perf.avgExecutionTime += result.executionTime;\n      perf.successRate += result.successRate;\n      if (result.real) perf.realExecutions++;\n    }\n\n    // Calculate averages and update profiles with REAL data\n    for (const [strategy, perf] of Object.entries(strategyPerformance)) {\n      perf.avgScore = perf.totalScore / perf.count;\n      perf.avgExecutionTime = perf.avgExecutionTime / perf.count;\n      perf.successRate = perf.successRate / perf.count;\n\n      // Update with stronger learning for real executions\n      const learningRate = perf.realExecutions > 0 ? 0.4 : 0.1;\n      this.updateAgentProfile(profiles, strategy, perf, learningRate);\n    }\n\n    // Save updated profiles\n    await fs.writeFile(this.agentProfiles, JSON.stringify(profiles, null, 2));\n\n    // Generate recommendations based on performance\n    const recommendations = this.generateRecommendations(strategyPerformance);\n    \n    console.log('\\nüìä Learning Results:');\n    for (const [strategy, perf] of Object.entries(strategyPerformance)) {\n      console.log(`   ${strategy}: Score ${perf.avgScore.toFixed(2)}, Success ${(perf.successRate * 100).toFixed(1)}%, Time ${perf.avgExecutionTime.toFixed(0)}ms`);\n    }\n\n    return { profiles, recommendations };\n  }\n\n  updateAgentProfile(profiles, strategy, performance, learningRate = 0.3) {\n    if (!profiles[strategy]) {\n      profiles[strategy] = {\n        successRate: 0.5,\n        avgScore: 50,\n        avgExecutionTime: 2000,\n        uses: 0,\n        realExecutions: 0\n      };\n    }\n\n    const profile = profiles[strategy];\n    \n    // Update with exponential moving average\n    profile.successRate = profile.successRate * (1 - learningRate) + performance.successRate * learningRate;\n    profile.avgScore = profile.avgScore * (1 - learningRate) + performance.avgScore * learningRate;\n    profile.avgExecutionTime = profile.avgExecutionTime * (1 - learningRate) + performance.avgExecutionTime * learningRate;\n    profile.uses++;\n    if (performance.realExecutions) {\n      profile.realExecutions = (profile.realExecutions || 0) + performance.realExecutions;\n    }\n\n    // Add performance trend\n    if (!profile.trend) profile.trend = [];\n    profile.trend.push({\n      score: performance.avgScore,\n      timestamp: new Date().toISOString(),\n      real: performance.realExecutions > 0\n    });\n    if (profile.trend.length > 20) {\n      profile.trend = profile.trend.slice(-20);\n    }\n\n    // Mark improvement\n    if (profile.trend.length > 1) {\n      const recent = profile.trend.slice(-5).reduce((sum, t) => sum + t.score, 0) / Math.min(5, profile.trend.length);\n      const older = profile.trend.slice(0, -5).reduce((sum, t) => sum + t.score, 0) / Math.max(1, profile.trend.length - 5);\n      profile.improving = recent > older;\n      profile.improvementRate = ((recent - older) / older * 100).toFixed(1);\n    }\n  }\n\n  generateRecommendations(strategyPerformance) {\n    const recommendations = [];\n\n    for (const [strategy, perf] of Object.entries(strategyPerformance)) {\n      if (perf.successRate < 0.7) {\n        recommendations.push({\n          type: 'improve_reliability',\n          strategy,\n          action: `${strategy} needs better error handling (${(perf.successRate * 100).toFixed(1)}% success)`,\n          priority: 'high'\n        });\n      }\n\n      if (perf.avgExecutionTime > 3000) {\n        recommendations.push({\n          type: 'optimize_speed',\n          strategy,\n          action: `${strategy} is too slow (${perf.avgExecutionTime.toFixed(0)}ms avg)`,\n          priority: 'medium'\n        });\n      }\n\n      if (perf.avgScore > 75) {\n        recommendations.push({\n          type: 'good_performance',\n          strategy,\n          action: `${strategy} performing well (${perf.avgScore.toFixed(1)} score)`,\n          priority: 'info'\n        });\n      }\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Full Training Pipeline Execution\n   */\n  async runFullPipeline(options = {}) {\n    const {\n      complexity = 'medium',\n      iterations = 3,\n      validate = true\n    } = options;\n\n    console.log('üéØ Starting Training Pipeline');\n    console.log('‚îÅ'.repeat(50));\n\n    await this.initialize();\n\n    // Capture baseline metrics\n    const baselineMetrics = await this.captureMetrics();\n    \n    let cumulativeResults = [];\n    \n    for (let i = 1; i <= iterations; i++) {\n      console.log(`\\nüìç Iteration ${i}/${iterations}`);\n      console.log('‚îÄ'.repeat(40));\n\n      // Stage 1: Generate tasks\n      const tasks = await this.generateTrainingTasks(complexity);\n\n      // Stage 2: Execute with real code\n      const results = await this.executeTrainingRun(tasks);\n      cumulativeResults = [...cumulativeResults, ...results];\n\n      // Stage 3: Learn from results\n      const { profiles, recommendations } = await this.learnFromResults(results);\n\n      // Show recommendations\n      if (recommendations.length > 0) {\n        console.log('\\nüí° Recommendations:');\n        for (const rec of recommendations.slice(0, 3)) {\n          console.log(`   ‚Ä¢ ${rec.action}`);\n        }\n      }\n\n      // Stage 4: Validate if enabled\n      if (validate && i === iterations) {\n        const currentMetrics = await this.captureMetrics();\n        const validation = await this.validateImprovements(baselineMetrics, currentMetrics);\n        \n        if (validation.summary.overallImprovement) {\n          console.log('‚úÖ Improvement detected!');\n        } else {\n          console.log('‚ö†Ô∏è  More training needed for significant improvement');\n        }\n      }\n    }\n\n    // Generate final report\n    const report = await this.generateFinalReport(cumulativeResults);\n    console.log('\\n' + report);\n\n    return {\n      success: true,\n      totalTasks: cumulativeResults.length,\n      realExecutions: cumulativeResults.filter(r => r.real).length,\n      improvements: await this.calculateOverallImprovement(baselineMetrics)\n    };\n  }\n\n  // Reuse helper methods from original\n  async captureMetrics() {\n    try {\n      const data = await fs.readFile(this.agentProfiles, 'utf8');\n      const profiles = JSON.parse(data);\n      \n      // Calculate weighted average from all strategies\n      let totalScore = 0;\n      let totalSuccess = 0;\n      let totalTime = 0;\n      let count = 0;\n      \n      for (const profile of Object.values(profiles)) {\n        if (profile.uses > 0) {\n          totalScore += profile.avgScore;\n          totalSuccess += profile.successRate;\n          totalTime += profile.avgExecutionTime;\n          count++;\n        }\n      }\n      \n      return {\n        successRate: count > 0 ? totalSuccess / count : 0,\n        executionTime: count > 0 ? totalTime / count : 0,\n        score: count > 0 ? totalScore / count : 0\n      };\n    } catch {\n      return {\n        successRate: 0,\n        executionTime: 0,\n        score: 0\n      };\n    }\n  }\n\n  async validateImprovements(beforeMetrics, afterMetrics) {\n    const validation = {\n      improved: [],\n      declined: [],\n      unchanged: [],\n      summary: {}\n    };\n\n    const metrics = ['successRate', 'executionTime', 'score'];\n    \n    for (const metric of metrics) {\n      const before = beforeMetrics[metric] || 0.01; // Avoid division by zero\n      const after = afterMetrics[metric] || 0;\n      const change = after - before;\n      const percentChange = (change / before) * 100;\n\n      if (percentChange > 5) {\n        validation.improved.push({ metric, change: percentChange });\n      } else if (percentChange < -5) {\n        validation.declined.push({ metric, change: percentChange });\n      } else {\n        validation.unchanged.push({ metric, change: percentChange });\n      }\n    }\n\n    validation.summary = {\n      overallImprovement: validation.improved.length > validation.declined.length,\n      improvementScore: validation.improved.length - validation.declined.length,\n      timestamp: new Date().toISOString()\n    };\n\n    console.log(`\\n‚úÖ Validating improvements...`);\n    console.log(`   Improved: ${validation.improved.length} metrics`);\n    console.log(`   Declined: ${validation.declined.length} metrics`);\n    console.log(`   Unchanged: ${validation.unchanged.length} metrics`);\n\n    return validation;\n  }\n\n  async calculateOverallImprovement(baselineMetrics) {\n    const currentMetrics = await this.captureMetrics();\n    \n    const base = {\n      successRate: baselineMetrics.successRate || 0.01,\n      executionTime: baselineMetrics.executionTime || 1,\n      score: baselineMetrics.score || 0.01\n    };\n    \n    return {\n      successRate: ((currentMetrics.successRate - base.successRate) / base.successRate) * 100,\n      executionTime: ((base.executionTime - currentMetrics.executionTime) / base.executionTime) * 100,\n      score: ((currentMetrics.score - base.score) / base.score) * 100\n    };\n  }\n\n  async generateFinalReport(results) {\n    const realResults = results.filter(r => r.real);\n    const successRates = {};\n    const scores = {};\n    const times = {};\n    \n    for (const result of realResults) {\n      if (!successRates[result.strategy]) {\n        successRates[result.strategy] = [];\n        scores[result.strategy] = [];\n        times[result.strategy] = [];\n      }\n      successRates[result.strategy].push(result.successRate);\n      scores[result.strategy].push(result.score);\n      times[result.strategy].push(result.executionTime);\n    }\n\n    let report = 'üìä Training Pipeline Report\\n';\n    report += '‚îÅ'.repeat(50) + '\\n\\n';\n    \n    for (const strategy of Object.keys(successRates)) {\n      const avgSuccess = successRates[strategy].reduce((a, b) => a + b, 0) / successRates[strategy].length;\n      const avgScore = scores[strategy].reduce((a, b) => a + b, 0) / scores[strategy].length;\n      const avgTime = times[strategy].reduce((a, b) => a + b, 0) / times[strategy].length;\n      \n      report += `Strategy: ${strategy}\\n`;\n      report += `  Average Success Rate: ${(avgSuccess * 100).toFixed(1)}%\\n`;\n      report += `  Average Score: ${avgScore.toFixed(2)}\\n`;\n      report += `  Average Time: ${avgTime.toFixed(0)}ms\\n`;\n      report += `  Real Executions: ${successRates[strategy].length}\\n`;\n      report += '\\n';\n    }\n\n    return report;\n  }\n\n  getDefaultProfiles() {\n    return {\n      conservative: {\n        successRate: 0.5,\n        avgScore: 50,\n        avgExecutionTime: 3000,\n        uses: 0,\n        realExecutions: 0\n      },\n      balanced: {\n        successRate: 0.5,\n        avgScore: 50,\n        avgExecutionTime: 2000,\n        uses: 0,\n        realExecutions: 0\n      },\n      aggressive: {\n        successRate: 0.5,\n        avgScore: 50,\n        avgExecutionTime: 1000,\n        uses: 0,\n        realExecutions: 0\n      }\n    };\n  }\n\n  async loadPipelineConfig() {\n    try {\n      const data = await fs.readFile(this.pipelineConfig, 'utf8');\n      return JSON.parse(data);\n    } catch {\n      const defaultConfig = {\n        version: '2.0.0',\n        strategies: ['conservative', 'balanced', 'aggressive'],\n        learningRate: 0.4,\n        minSamplesForUpdate: 3,\n        useRealExecution: true,\n        created: new Date().toISOString()\n      };\n      \n      await fs.writeFile(this.pipelineConfig, JSON.stringify(defaultConfig, null, 2));\n      return defaultConfig;\n    }\n  }\n}\n\n/**\n * CLI Command Handler\n */\nexport async function trainingPipelineCommand(args, flags) {\n  const pipeline = new TrainingPipeline();\n  const subcommand = args[0] || 'run';\n\n  switch (subcommand) {\n    case 'run':\n      // Run real pipeline\n      const options = {\n        complexity: flags.complexity || 'medium',\n        iterations: parseInt(flags.iterations) || 3,\n        validate: flags.validate !== false\n      };\n      \n      console.log('üöÄ Starting Training Pipeline');\n      console.log(`   Complexity: ${options.complexity}`);\n      console.log(`   Iterations: ${options.iterations}`);\n      console.log(`   Validation: ${options.validate ? 'Enabled' : 'Disabled'}`);\n      \n      const result = await pipeline.runFullPipeline(options);\n      \n      if (result.success) {\n        console.log('\\n‚úÖ Training Pipeline completed');\n        console.log(`   Total tasks: ${result.totalTasks}`);\n        console.log(`   Real executions: ${result.realExecutions}`);\n        \n        if (result.improvements) {\n          console.log('\\nüìà Improvements:');\n          console.log(`   Success Rate: ${result.improvements.successRate > 0 ? '+' : ''}${result.improvements.successRate.toFixed(1)}%`);\n          console.log(`   Execution Time: ${result.improvements.executionTime > 0 ? '+' : ''}${result.improvements.executionTime.toFixed(1)}%`);\n          console.log(`   Score: ${result.improvements.score > 0 ? '+' : ''}${result.improvements.score.toFixed(1)}%`);\n        }\n      }\n      break;\n\n    case 'status':\n      // Show real pipeline status\n      await pipeline.initialize();\n      \n      let profiles = {};\n      try {\n        const data = await fs.readFile(pipeline.agentProfiles, 'utf8');\n        profiles = JSON.parse(data);\n      } catch {\n        profiles = pipeline.getDefaultProfiles();\n      }\n\n      console.log('\\nüìä Training Pipeline Status');\n      console.log('‚îÅ'.repeat(50));\n      \n      console.log('\\nü§ñ Strategy Profiles:');\n      for (const [strategy, profile] of Object.entries(profiles)) {\n        console.log(`   ${strategy}:`);\n        console.log(`     Success Rate: ${(profile.successRate * 100).toFixed(1)}%`);\n        console.log(`     Average Score: ${profile.avgScore.toFixed(2)}`);\n        console.log(`     Execution Time: ${profile.avgExecutionTime.toFixed(0)}ms`);\n        console.log(`     Total Uses: ${profile.uses}`);\n        console.log(`     Real Executions: ${profile.realExecutions || 0}`);\n        if (profile.improving !== undefined) {\n          console.log(`     Trend: ${profile.improving ? 'üìà Improving' : 'üìâ Declining'} (${profile.improvementRate}%)`);\n        }\n      }\n      break;\n\n    case 'validate':\n      // Validate current performance\n      await pipeline.initialize();\n      const metrics = await pipeline.captureMetrics();\n      console.log('\\nüìä Current Performance:');\n      console.log(`   Success Rate: ${(metrics.successRate * 100).toFixed(1)}%`);\n      console.log(`   Avg Execution Time: ${metrics.executionTime.toFixed(0)}ms`);\n      console.log(`   Average Score: ${metrics.score.toFixed(2)}`);\n      break;\n\n    default:\n      console.log('Usage: train-pipeline <command> [options]');\n      console.log('\\nCommands:');\n      console.log('  run       - Run training pipeline with real code');\n      console.log('  status    - Show pipeline status');\n      console.log('  validate  - Check current performance');\n      console.log('\\nOptions:');\n      console.log('  --complexity <level>  - easy/medium/hard');\n      console.log('  --iterations <n>      - Training cycles');\n  }\n}\n\nexport default TrainingPipeline;"],"names":["fs","path","execSync","promisify","exec","execAsync","TrainingPipeline","pipelineConfig","trainingLog","improvementMetrics","agentProfiles","realTasksDir","initialized","initialize","dirs","dir","mkdir","recursive","loadPipelineConfig","console","log","generateTrainingTasks","complexity","taskId","Date","now","taskDir","join","tasks","easy","type","name","task","code","test","medium","hard","selectedTasks","realTasks","projectDir","writeFile","packageJson","version","scripts","lint","typecheck","devDependencies","jest","eslint","supertest","dependencies","express","undefined","JSON","stringify","push","length","executeTrainingRun","agentConfig","results","cwd","stdio","e","message","slice","strategies","strategy","result","executeTaskWithStrategy","timestamp","toISOString","resultsFile","startTime","checks","originalCode","readFile","aggressiveCode","replace","conservativeCode","testResult","encoding","passed","score","output","error","lintResult","hasErrors","includes","executionTime","successRate","Object","values","filter","c","strategyBonus","Math","max","real","learnFromResults","profiles","data","parse","getDefaultProfiles","strategyPerformance","totalScore","count","avgExecutionTime","realExecutions","perf","entries","avgScore","learningRate","updateAgentProfile","recommendations","generateRecommendations","toFixed","performance","uses","profile","trend","recent","reduce","sum","t","min","older","improving","improvementRate","action","priority","runFullPipeline","options","iterations","validate","repeat","baselineMetrics","captureMetrics","cumulativeResults","i","rec","currentMetrics","validation","validateImprovements","summary","overallImprovement","report","generateFinalReport","success","totalTasks","r","improvements","calculateOverallImprovement","totalSuccess","totalTime","beforeMetrics","afterMetrics","improved","declined","unchanged","metrics","metric","before","after","change","percentChange","improvementScore","base","realResults","successRates","scores","times","keys","avgSuccess","a","b","avgTime","conservative","balanced","aggressive","defaultConfig","minSamplesForUpdate","useRealExecution","created","trainingPipelineCommand","args","flags","pipeline","subcommand","parseInt"],"mappings":"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"}