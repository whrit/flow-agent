{"version":3,"sources":["../../../../src/cli/simple-commands/memory-consolidation.js"],"sourcesContent":["// memory-consolidation.js - Database consolidation utility\nimport { printSuccess, printError, printWarning, printInfo } from '../utils.js';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { existsSync } from '../node-compat.js';\n// Dynamic imports for optional dependencies\nlet sqlite3;\nlet sqliteOpen;\n\nasync function loadSqliteModules() {\n  try {\n    const sqlite3Module = await import('sqlite3');\n    sqlite3 = sqlite3Module.default;\n    const sqliteModule = await import('sqlite');\n    sqliteOpen = sqliteModule.open;\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n/**\n * Memory database consolidation strategy\n * Consolidates multiple memory storage locations into a unified structure\n */\nexport class MemoryConsolidator {\n  constructor() {\n    this.primaryLocations = {\n      json: './memory/memory-store.json',\n      sqlite: './.claude-flow/memory/unified-memory.db',\n      backup: './.claude-flow/memory/backups/'\n    };\n\n    this.knownLocations = [\n      // JSON stores\n      './memory/memory-store.json',\n      './.claude-flow/memory/store.json',\n      \n      // SQLite databases\n      './.swarm/memory.db',\n      './.hive-mind/memory.db',\n      './.hive-mind/hive.db',\n      './.ruv-swarm/swarm.db',\n      './data/hive-mind.db',\n      \n      // Legacy locations\n      './memory.json',\n      './data/memory.json'\n    ];\n  }\n\n  /**\n   * Scan for all memory storage locations\n   */\n  async scanMemoryLocations() {\n    const found = {\n      json: [],\n      sqlite: [],\n      total: 0,\n      sizeBytes: 0\n    };\n\n    // Check known locations\n    for (const location of this.knownLocations) {\n      if (existsSync(location)) {\n        const stats = await fs.stat(location);\n        const type = location.endsWith('.db') ? 'sqlite' : 'json';\n        \n        found[type].push({\n          path: location,\n          size: stats.size,\n          modified: stats.mtime\n        });\n        \n        found.total++;\n        found.sizeBytes += stats.size;\n      }\n    }\n\n    // Scan for additional .db files\n    try {\n      const dbFiles = await this.findDatabaseFiles('.');\n      for (const dbFile of dbFiles) {\n        if (!this.knownLocations.includes(dbFile)) {\n          const stats = await fs.stat(dbFile);\n          found.sqlite.push({\n            path: dbFile,\n            size: stats.size,\n            modified: stats.mtime\n          });\n          found.total++;\n          found.sizeBytes += stats.size;\n        }\n      }\n    } catch (err) {\n      // Ignore scan errors\n    }\n\n    return found;\n  }\n\n  /**\n   * Find all .db files recursively\n   */\n  async findDatabaseFiles(dir, files = []) {\n    try {\n      const items = await fs.readdir(dir);\n      \n      for (const item of items) {\n        // Skip node_modules and hidden directories\n        if (item === 'node_modules' || item.startsWith('.git')) continue;\n        \n        const fullPath = path.join(dir, item);\n        const stat = await fs.stat(fullPath);\n        \n        if (stat.isDirectory() && item.startsWith('.')) {\n          // Check hidden directories for db files\n          await this.findDatabaseFiles(fullPath, files);\n        } else if (item.endsWith('.db')) {\n          files.push(fullPath);\n        }\n      }\n    } catch (err) {\n      // Ignore permission errors\n    }\n    \n    return files;\n  }\n\n  /**\n   * Create consolidation plan\n   */\n  async createConsolidationPlan(locations) {\n    const plan = {\n      steps: [],\n      estimatedTime: 0,\n      totalData: locations.sizeBytes,\n      backupRequired: locations.total > 0\n    };\n\n    // Step 1: Backup existing data\n    if (plan.backupRequired) {\n      plan.steps.push({\n        action: 'backup',\n        description: 'Create backups of all existing memory stores',\n        sources: [...locations.json, ...locations.sqlite].map(l => l.path),\n        destination: this.primaryLocations.backup\n      });\n      plan.estimatedTime += 2; // seconds\n    }\n\n    // Step 2: Convert JSON stores to unified format\n    if (locations.json.length > 0) {\n      plan.steps.push({\n        action: 'convert-json',\n        description: 'Convert JSON memory stores to unified format',\n        sources: locations.json.map(l => l.path),\n        destination: this.primaryLocations.sqlite\n      });\n      plan.estimatedTime += locations.json.length * 1;\n    }\n\n    // Step 3: Merge SQLite databases\n    if (locations.sqlite.length > 0) {\n      plan.steps.push({\n        action: 'merge-sqlite',\n        description: 'Merge SQLite databases into unified store',\n        sources: locations.sqlite.map(l => l.path),\n        destination: this.primaryLocations.sqlite\n      });\n      plan.estimatedTime += locations.sqlite.length * 2;\n    }\n\n    // Step 4: Create indices for performance\n    plan.steps.push({\n      action: 'optimize',\n      description: 'Create indices and optimize unified database',\n      destination: this.primaryLocations.sqlite\n    });\n    plan.estimatedTime += 1;\n\n    // Step 5: Update configuration\n    plan.steps.push({\n      action: 'update-config',\n      description: 'Update memory configuration to use unified store',\n      config: {\n        memoryStore: this.primaryLocations.sqlite,\n        backupLocation: this.primaryLocations.backup,\n        legacySupport: true\n      }\n    });\n\n    return plan;\n  }\n\n  /**\n   * Execute consolidation plan\n   */\n  async executeConsolidation(plan, options = {}) {\n    const results = {\n      success: false,\n      stepsCompleted: 0,\n      errors: [],\n      backupPath: null,\n      newStorePath: null\n    };\n\n    try {\n      for (const step of plan.steps) {\n        printInfo(`Executing: ${step.description}`);\n        \n        switch (step.action) {\n          case 'backup':\n            results.backupPath = await this.createBackups(step.sources, step.destination);\n            break;\n            \n          case 'convert-json':\n            await this.convertJsonToSqlite(step.sources, step.destination);\n            break;\n            \n          case 'merge-sqlite':\n            await this.mergeSqliteDatabases(step.sources, step.destination);\n            break;\n            \n          case 'optimize':\n            await this.optimizeDatabase(step.destination);\n            break;\n            \n          case 'update-config':\n            await this.updateConfiguration(step.config);\n            break;\n        }\n        \n        results.stepsCompleted++;\n        printSuccess(`âœ“ ${step.description}`);\n      }\n      \n      results.success = true;\n      results.newStorePath = this.primaryLocations.sqlite;\n      \n    } catch (err) {\n      results.errors.push(err.message);\n      printError(`Failed at step ${results.stepsCompleted + 1}: ${err.message}`);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Create backups of all memory stores\n   */\n  async createBackups(sources, backupDir) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupPath = path.join(backupDir, `backup-${timestamp}`);\n    \n    await fs.mkdir(backupPath, { recursive: true });\n    \n    for (const source of sources) {\n      if (existsSync(source)) {\n        const filename = path.basename(source);\n        const dest = path.join(backupPath, filename);\n        await fs.copyFile(source, dest);\n      }\n    }\n    \n    return backupPath;\n  }\n\n  /**\n   * Convert JSON memory stores to SQLite\n   */\n  async convertJsonToSqlite(jsonFiles, dbPath) {\n    if (!sqlite3 || !sqliteOpen) {\n      throw new Error('SQLite modules not available. Install sqlite3 and sqlite packages.');\n    }\n    \n    await fs.mkdir(path.dirname(dbPath), { recursive: true });\n    \n    const db = await sqliteOpen({\n      filename: dbPath,\n      driver: sqlite3.Database\n    });\n    \n    // Create unified schema\n    await db.exec(`\n      CREATE TABLE IF NOT EXISTS memory_entries (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        key TEXT NOT NULL,\n        value TEXT NOT NULL,\n        namespace TEXT NOT NULL DEFAULT 'default',\n        timestamp INTEGER NOT NULL,\n        source TEXT,\n        UNIQUE(key, namespace)\n      );\n      \n      CREATE INDEX IF NOT EXISTS idx_namespace ON memory_entries(namespace);\n      CREATE INDEX IF NOT EXISTS idx_timestamp ON memory_entries(timestamp);\n      CREATE INDEX IF NOT EXISTS idx_key ON memory_entries(key);\n    `);\n    \n    // Import each JSON file\n    for (const jsonFile of jsonFiles) {\n      if (!existsSync(jsonFile)) continue;\n      \n      try {\n        const content = await fs.readFile(jsonFile, 'utf8');\n        const data = JSON.parse(content);\n        \n        const stmt = await db.prepare(`\n          INSERT OR REPLACE INTO memory_entries (key, value, namespace, timestamp, source)\n          VALUES (?, ?, ?, ?, ?)\n        `);\n        \n        for (const [namespace, entries] of Object.entries(data)) {\n          for (const entry of entries) {\n            await stmt.run(\n              entry.key,\n              entry.value,\n              entry.namespace || namespace,\n              entry.timestamp,\n              jsonFile\n            );\n          }\n        }\n        \n        await stmt.finalize();\n      } catch (err) {\n        printWarning(`Failed to import ${jsonFile}: ${err.message}`);\n      }\n    }\n    \n    await db.close();\n  }\n\n  /**\n   * Merge multiple SQLite databases\n   */\n  async mergeSqliteDatabases(dbFiles, targetDb) {\n    if (!sqlite3 || !sqliteOpen) {\n      throw new Error('SQLite modules not available. Install sqlite3 and sqlite packages.');\n    }\n    \n    const db = await sqliteOpen({\n      filename: targetDb,\n      driver: sqlite3.Database\n    });\n    \n    for (const dbFile of dbFiles) {\n      if (!existsSync(dbFile) || dbFile === targetDb) continue;\n      \n      try {\n        // Attach the source database\n        const alias = `db_${path.basename(dbFile, '.db')}`;\n        await db.exec(`ATTACH DATABASE '${dbFile}' AS ${alias}`);\n        \n        // Get tables from source database\n        const tables = await db.all(`\n          SELECT name FROM ${alias}.sqlite_master \n          WHERE type='table' AND name LIKE '%memory%'\n        `);\n        \n        // Copy data from each memory-related table\n        for (const table of tables) {\n          try {\n            await db.exec(`\n              INSERT OR IGNORE INTO memory_entries (key, value, namespace, timestamp, source)\n              SELECT \n                COALESCE(key, ''), \n                COALESCE(value, ''), \n                COALESCE(namespace, 'default'),\n                COALESCE(timestamp, strftime('%s', 'now') * 1000),\n                '${dbFile}'\n              FROM ${alias}.${table.name}\n              WHERE key IS NOT NULL AND value IS NOT NULL\n            `);\n          } catch (err) {\n            // Table structure might be different, skip\n          }\n        }\n        \n        await db.exec(`DETACH DATABASE ${alias}`);\n      } catch (err) {\n        printWarning(`Failed to merge ${dbFile}: ${err.message}`);\n      }\n    }\n    \n    await db.close();\n  }\n\n  /**\n   * Optimize the unified database\n   */\n  async optimizeDatabase(dbPath) {\n    if (!sqlite3 || !sqliteOpen) {\n      throw new Error('SQLite modules not available. Install sqlite3 and sqlite packages.');\n    }\n    \n    const db = await sqliteOpen({\n      filename: dbPath,\n      driver: sqlite3.Database\n    });\n    \n    // Add performance optimizations\n    await db.exec(`\n      -- Enable Write-Ahead Logging for better performance\n      PRAGMA journal_mode = WAL;\n      PRAGMA synchronous = NORMAL;\n      \n      -- Optimize database\n      VACUUM;\n      ANALYZE;\n      \n      -- Create additional indices for common queries\n      CREATE INDEX IF NOT EXISTS idx_key_value ON memory_entries(key, value);\n      CREATE INDEX IF NOT EXISTS idx_namespace_timestamp ON memory_entries(namespace, timestamp);\n    `);\n    \n    await db.close();\n  }\n\n  /**\n   * Update configuration to use unified store\n   */\n  async updateConfiguration(config) {\n    const configPath = './.claude-flow/memory-config.json';\n    \n    await fs.mkdir(path.dirname(configPath), { recursive: true });\n    await fs.writeFile(configPath, JSON.stringify(config, null, 2));\n    \n    // Create symlinks for backward compatibility\n    if (config.legacySupport) {\n      try {\n        // Create symlink from old JSON location to new\n        if (existsSync('./memory/memory-store.json')) {\n          await fs.rename('./memory/memory-store.json', './memory/memory-store.json.old');\n        }\n        // Note: We don't create actual symlinks to SQLite as JSON/SQLite formats differ\n        // Instead, the memory manager will check the config and use the unified store\n      } catch (err) {\n        // Ignore symlink errors\n      }\n    }\n  }\n\n  /**\n   * Generate consolidation report\n   */\n  generateReport(scanResults, plan, executionResults) {\n    const report = [];\n    \n    report.push('ğŸ“Š Memory Consolidation Report');\n    report.push('================================\\n');\n    \n    report.push('ğŸ“ Discovered Memory Stores:');\n    report.push(`  â€¢ JSON files: ${scanResults.json.length}`);\n    report.push(`  â€¢ SQLite databases: ${scanResults.sqlite.length}`);\n    report.push(`  â€¢ Total size: ${(scanResults.sizeBytes / 1024 / 1024).toFixed(2)} MB\\n`);\n    \n    report.push('ğŸ“‹ Consolidation Plan:');\n    for (const step of plan.steps) {\n      report.push(`  âœ“ ${step.description}`);\n    }\n    report.push(`  â€¢ Estimated time: ${plan.estimatedTime} seconds\\n`);\n    \n    if (executionResults) {\n      report.push('âœ… Execution Results:');\n      report.push(`  â€¢ Success: ${executionResults.success ? 'Yes' : 'No'}`);\n      report.push(`  â€¢ Steps completed: ${executionResults.stepsCompleted}/${plan.steps.length}`);\n      \n      if (executionResults.backupPath) {\n        report.push(`  â€¢ Backup location: ${executionResults.backupPath}`);\n      }\n      \n      if (executionResults.newStorePath) {\n        report.push(`  â€¢ Unified store: ${executionResults.newStorePath}`);\n      }\n      \n      if (executionResults.errors.length > 0) {\n        report.push('\\nâŒ Errors:');\n        for (const error of executionResults.errors) {\n          report.push(`  â€¢ ${error}`);\n        }\n      }\n    }\n    \n    return report.join('\\n');\n  }\n}\n\n/**\n * Memory consolidation command\n */\nexport async function memoryConsolidationCommand(subArgs, flags) {\n  // Load SQLite modules if available\n  const sqliteAvailable = await loadSqliteModules();\n  \n  const consolidator = new MemoryConsolidator();\n  const action = subArgs[0];\n  \n  switch (action) {\n    case 'scan':\n      await scanMemoryStores(consolidator);\n      break;\n      \n    case 'plan':\n      await createConsolidationPlan(consolidator);\n      break;\n      \n    case 'execute':\n      await executeConsolidation(consolidator, flags);\n      break;\n      \n    case 'report':\n      await generateConsolidationReport(consolidator);\n      break;\n      \n    default:\n      showConsolidationHelp();\n  }\n}\n\nasync function scanMemoryStores(consolidator) {\n  printInfo('Scanning for memory storage locations...');\n  \n  const results = await consolidator.scanMemoryLocations();\n  \n  printSuccess(`Found ${results.total} memory storage locations:`);\n  \n  if (results.json.length > 0) {\n    console.log('\\nğŸ“„ JSON Stores:');\n    for (const store of results.json) {\n      console.log(`  â€¢ ${store.path} (${(store.size / 1024).toFixed(1)} KB)`);\n    }\n  }\n  \n  if (results.sqlite.length > 0) {\n    console.log('\\nğŸ—„ï¸ SQLite Databases:');\n    for (const db of results.sqlite) {\n      console.log(`  â€¢ ${db.path} (${(db.size / 1024).toFixed(1)} KB)`);\n    }\n  }\n  \n  console.log(`\\nğŸ’¾ Total size: ${(results.sizeBytes / 1024 / 1024).toFixed(2)} MB`);\n}\n\nasync function createConsolidationPlan(consolidator) {\n  const scanResults = await consolidator.scanMemoryLocations();\n  const plan = await consolidator.createConsolidationPlan(scanResults);\n  \n  printSuccess('ğŸ“‹ Consolidation Plan Created:');\n  \n  for (let i = 0; i < plan.steps.length; i++) {\n    const step = plan.steps[i];\n    console.log(`\\n${i + 1}. ${step.description}`);\n    \n    if (step.sources) {\n      console.log('   Sources:');\n      for (const source of step.sources) {\n        console.log(`   â€¢ ${source}`);\n      }\n    }\n    \n    if (step.destination) {\n      console.log(`   Destination: ${step.destination}`);\n    }\n  }\n  \n  console.log(`\\nâ±ï¸ Estimated time: ${plan.estimatedTime} seconds`);\n  console.log('\\nRun \"memory-consolidate execute\" to perform consolidation');\n}\n\nasync function executeConsolidation(consolidator, flags) {\n  const sqliteAvailable = await loadSqliteModules();\n  \n  if (!sqliteAvailable) {\n    printError('SQLite modules not available.');\n    printInfo('Install required packages: npm install sqlite3 sqlite');\n    return;\n  }\n  \n  const scanResults = await consolidator.scanMemoryLocations();\n  \n  if (scanResults.total === 0) {\n    printWarning('No memory stores found to consolidate');\n    return;\n  }\n  \n  const plan = await consolidator.createConsolidationPlan(scanResults);\n  \n  if (!flags.force) {\n    printWarning('This will consolidate all memory stores into a unified database.');\n    printWarning('A backup will be created before any changes are made.');\n    console.log('\\nUse --force flag to proceed without confirmation');\n    return;\n  }\n  \n  printInfo('Starting memory consolidation...');\n  const results = await consolidator.executeConsolidation(plan);\n  \n  const report = consolidator.generateReport(scanResults, plan, results);\n  console.log('\\n' + report);\n  \n  if (results.success) {\n    printSuccess('\\nâœ… Memory consolidation completed successfully!');\n    console.log(`Unified store location: ${results.newStorePath}`);\n  } else {\n    printError('\\nâŒ Memory consolidation failed');\n    console.log('Check the errors above and try again');\n  }\n}\n\nasync function generateConsolidationReport(consolidator) {\n  const scanResults = await consolidator.scanMemoryLocations();\n  const plan = await consolidator.createConsolidationPlan(scanResults);\n  \n  const report = consolidator.generateReport(scanResults, plan);\n  console.log(report);\n}\n\nfunction showConsolidationHelp() {\n  console.log('Memory consolidation commands:');\n  console.log('  scan       Scan for all memory storage locations');\n  console.log('  plan       Create a consolidation plan');\n  console.log('  execute    Execute the consolidation (use --force to skip confirmation)');\n  console.log('  report     Generate a consolidation report');\n  console.log();\n  console.log('Examples:');\n  console.log('  memory-consolidate scan');\n  console.log('  memory-consolidate plan');\n  console.log('  memory-consolidate execute --force');\n  console.log('  memory-consolidate report');\n}"],"names":["printSuccess","printError","printWarning","printInfo","promises","fs","path","existsSync","sqlite3","sqliteOpen","loadSqliteModules","sqlite3Module","default","sqliteModule","open","err","MemoryConsolidator","primaryLocations","json","sqlite","backup","knownLocations","scanMemoryLocations","found","total","sizeBytes","location","stats","stat","type","endsWith","push","size","modified","mtime","dbFiles","findDatabaseFiles","dbFile","includes","dir","files","items","readdir","item","startsWith","fullPath","join","isDirectory","createConsolidationPlan","locations","plan","steps","estimatedTime","totalData","backupRequired","action","description","sources","map","l","destination","length","config","memoryStore","backupLocation","legacySupport","executeConsolidation","options","results","success","stepsCompleted","errors","backupPath","newStorePath","step","createBackups","convertJsonToSqlite","mergeSqliteDatabases","optimizeDatabase","updateConfiguration","message","backupDir","timestamp","Date","toISOString","replace","mkdir","recursive","source","filename","basename","dest","copyFile","jsonFiles","dbPath","Error","dirname","db","driver","Database","exec","jsonFile","content","readFile","data","JSON","parse","stmt","prepare","namespace","entries","Object","entry","run","key","value","finalize","close","targetDb","alias","tables","all","table","name","configPath","writeFile","stringify","rename","generateReport","scanResults","executionResults","report","toFixed","error","memoryConsolidationCommand","subArgs","flags","sqliteAvailable","consolidator","scanMemoryStores","generateConsolidationReport","showConsolidationHelp","console","log","store","i","force"],"mappings":"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"}