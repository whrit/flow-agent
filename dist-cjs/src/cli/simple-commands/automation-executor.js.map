{"version":3,"sources":["../../../../src/cli/simple-commands/automation-executor.js"],"sourcesContent":["/**\n * Modular Automation Executor for Claude Flow\n * \n * This module provides the core infrastructure for executing automation\n * workflows with Claude CLI integration, while preserving existing \n * swarm and hive-mind functionality.\n */\n\nimport { promises as fs } from 'fs';\nimport { spawn } from 'child_process';\nimport { join, dirname } from 'path';\nimport { printSuccess, printError, printWarning } from '../utils.js';\n\n// Simple ID generator\nfunction generateId(prefix = 'id') {\n  return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * WorkflowExecutor - Core class for executing automation workflows\n */\nexport class WorkflowExecutor {\n  constructor(options = {}) {\n    this.options = {\n      enableClaude: false,\n      nonInteractive: false,\n      outputFormat: 'text',\n      maxConcurrency: 3,\n      timeout: 3600000, // 1 hour default\n      logLevel: 'info',\n      ...options\n    };\n    \n    // Increase timeout for ML workflows\n    if (options.workflowType === 'ml' || options.workflowName?.toLowerCase().includes('mle')) {\n      this.options.timeout = 7200000; // 2 hours for ML workflows\n    }\n    \n    // Execution state\n    this.executionId = generateId('workflow-exec');\n    this.startTime = Date.now();\n    this.activeTasks = new Map();\n    this.claudeInstances = new Map();\n    this.results = new Map();\n    this.errors = [];\n    this.currentWorkflow = null;\n    \n    // Stream chaining support\n    this.taskOutputStreams = new Map(); // Store output streams for chaining\n    this.enableChaining = options.enableChaining !== false; // Default to true\n    \n    // Hooks integration\n    this.hooksEnabled = true;\n    this.sessionId = generateId('automation-session');\n  }\n\n  /**\n   * Execute a workflow from JSON definition\n   */\n  async executeWorkflow(workflowData, variables = {}) {\n    try {\n      // Store workflow for reference\n      this.currentWorkflow = workflowData;\n      \n      if (this.options.logLevel === 'quiet') {\n        console.log(`🚀 Executing workflow: ${this.executionId}`);\n      } else {\n        console.log(`🚀 Starting workflow execution: ${this.executionId}`);\n        console.log(`📋 Workflow: ${workflowData.name}`);\n        console.log(`🎯 Strategy: MLE-STAR Machine Learning Engineering`);\n        \n        if (this.options.enableClaude) {\n          console.log(`🤖 Claude CLI Integration: Enabled`);\n        }\n        \n        if (this.options.nonInteractive) {\n          console.log(`🖥️  Non-Interactive Mode: Enabled`);\n          if (this.options.outputFormat === 'stream-json') {\n            console.log();\n            console.log('● Running MLE-STAR workflow with Claude CLI integration');\n            console.log('  ⎿  Command format: claude --print --output-format stream-json --verbose --dangerously-skip-permissions');\n            console.log('  ⎿  Each agent will show real-time stream output below');\n            console.log('  ⎿  Interactive-style formatting enabled');\n          }\n        }\n      }\n      \n      console.log();\n\n      // Pre-execution hooks\n      if (this.hooksEnabled) {\n        await this.executeHook('pre-task', {\n          description: `Execute workflow: ${workflowData.name}`,\n          sessionId: this.sessionId\n        });\n      }\n\n      // Validate workflow\n      this.validateWorkflow(workflowData);\n      \n      // Apply variable substitutions\n      const processedWorkflow = this.applyVariables(workflowData, variables);\n      \n      // Initialize agents if Claude integration is enabled\n      if (this.options.enableClaude) {\n        await this.initializeClaudeAgents(processedWorkflow.agents);\n      }\n      \n      // Execute workflow phases\n      const result = await this.executeWorkflowTasks(processedWorkflow);\n      \n      // Post-execution hooks\n      if (this.hooksEnabled) {\n        await this.executeHook('post-task', {\n          taskId: this.executionId,\n          sessionId: this.sessionId,\n          result: result.success ? 'success' : 'failure'\n        });\n      }\n      \n      const duration = Date.now() - this.startTime;\n      \n      if (result.success) {\n        printSuccess(`✅ Workflow completed successfully in ${this.formatDuration(duration)}`);\n        console.log(`📊 Tasks: ${result.completedTasks}/${result.totalTasks} completed`);\n        console.log(`🆔 Execution ID: ${this.executionId}`);\n      } else {\n        printError(`❌ Workflow failed after ${this.formatDuration(duration)}`);\n        console.log(`📊 Tasks: ${result.completedTasks}/${result.totalTasks} completed`);\n        console.log(`❌ Errors: ${this.errors.length}`);\n      }\n      \n      // Cleanup Claude instances\n      if (this.options.enableClaude) {\n        await this.cleanupClaudeInstances();\n      }\n      \n      return result;\n      \n    } catch (error) {\n      printError(`Workflow execution failed: ${error.message}`);\n      await this.cleanupClaudeInstances();\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize Claude CLI instances for agents\n   */\n  async initializeClaudeAgents(agents) {\n    if (!agents || agents.length === 0) {\n      return;\n    }\n    \n    // Check if Claude CLI is available\n    if (!await this.isClaudeAvailable()) {\n      throw new Error('Claude CLI not found. Please install Claude Code: https://claude.ai/code');\n    }\n\n    if (this.options.nonInteractive) {\n      // Non-interactive mode: agents are spawned per task instead\n      if (this.options.logLevel !== 'quiet') {\n        console.log(`🤖 Non-interactive mode: Claude instances will be spawned per task`);\n        console.log(`📋 Each task will launch its own Claude process with specific prompts`);\n      }\n      return;\n    } else {\n      // Interactive mode: spawn single Claude instance with master coordination prompt\n      console.log(`🤖 Interactive mode: Initializing single Claude instance for workflow coordination...`);\n      \n      try {\n        // Create master coordination prompt for all agents and workflow\n        const masterPrompt = this.createMasterCoordinationPrompt(agents);\n        \n        // Spawn single Claude instance for workflow coordination\n        const claudeProcess = await this.spawnClaudeInstance({\n          id: 'master-coordinator',\n          name: 'Workflow Coordinator',\n          type: 'coordinator'\n        }, masterPrompt);\n        \n        // Store as master coordinator\n        this.claudeInstances.set('master-coordinator', {\n          process: claudeProcess,\n          agent: { id: 'master-coordinator', name: 'Workflow Coordinator', type: 'coordinator' },\n          status: 'active',\n          startTime: Date.now(),\n          agents: agents // Store agent definitions for reference\n        });\n        \n        console.log(`  ✅ Master Workflow Coordinator (PID: ${claudeProcess.pid})`);\n        console.log(`  🎯 Coordinating ${agents.length} sub-agents via concurrent streams`);\n        console.log(`  📋 Agents: ${agents.map(a => a.name).join(', ')}`);\n        \n      } catch (error) {\n        console.error(`  ❌ Failed to initialize master coordinator: ${error.message}`);\n        this.errors.push({\n          type: 'master_coordinator_initialization',\n          error: error.message,\n          timestamp: new Date()\n        });\n      }\n      \n      console.log();\n    }\n  }\n\n  /**\n   * Check if Claude CLI is available\n   */\n  async isClaudeAvailable() {\n    try {\n      const { execSync } = await import('child_process');\n      execSync('which claude', { stdio: 'ignore' });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Spawn a Claude CLI instance for an agent\n   * @param {Object} agent - The agent configuration\n   * @param {string} prompt - The prompt for the agent\n   * @param {Object} options - Additional options\n   * @param {Stream} options.inputStream - Optional input stream from previous agent\n   * @param {boolean} options.enableChaining - Whether to enable stream-json chaining\n   */\n  async spawnClaudeInstance(agent, prompt, options = {}) {\n    const claudeArgs = [];\n    \n    // Add flags based on mode\n    if (this.options.nonInteractive) {\n      // Non-interactive mode: use --print with stream-json output\n      claudeArgs.push('--print');\n      if (this.options.outputFormat === 'stream-json') {\n        claudeArgs.push('--output-format', 'stream-json');\n        claudeArgs.push('--verbose'); // Required for stream-json\n        \n        // Add input format if we're chaining from a previous agent\n        if (options.inputStream) {\n          claudeArgs.push('--input-format', 'stream-json');\n        }\n      }\n    }\n    \n    // Always skip permissions for automated workflows (both interactive and non-interactive)\n    claudeArgs.push('--dangerously-skip-permissions');\n    \n    // Always add the prompt as the final argument\n    claudeArgs.push(prompt);\n    \n    // Only show command details in verbose mode\n    if (this.options.logLevel === 'debug') {\n      const displayPrompt = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;\n      const flagsDisplay = this.options.nonInteractive ? \n        (this.options.outputFormat === 'stream-json' ? \n          (options.inputStream ? '--print --input-format stream-json --output-format stream-json --verbose --dangerously-skip-permissions' : '--print --output-format stream-json --verbose --dangerously-skip-permissions') : \n          '--print --dangerously-skip-permissions') : \n        '--dangerously-skip-permissions';\n      console.log(`    🤖 Spawning Claude for ${agent.name}: claude ${flagsDisplay} \"${displayPrompt}\"`);\n    } else if (this.options.logLevel !== 'quiet') {\n      console.log(`    🚀 Starting ${agent.name}`);\n    }\n    \n    // Determine stdio configuration based on mode and chaining\n    const stdioConfig = this.options.nonInteractive ? \n      [options.inputStream ? 'pipe' : 'inherit', 'pipe', 'pipe'] : // Non-interactive: pipe for chaining\n      ['inherit', 'inherit', 'inherit']; // Interactive: inherit all for normal Claude interaction\n    \n    // Spawn Claude process\n    const claudeProcess = spawn('claude', claudeArgs, {\n      stdio: stdioConfig,\n      shell: false,\n    });\n    \n    // If we have an input stream, pipe it to Claude's stdin\n    if (options.inputStream && claudeProcess.stdin) {\n      console.log(`    🔗 Chaining: Piping output from previous agent to ${agent.name}`);\n      options.inputStream.pipe(claudeProcess.stdin);\n    }\n    \n    // Handle stdout with stream processor for better formatting (only in non-interactive mode)\n    if (this.options.nonInteractive && this.options.outputFormat === 'stream-json' && claudeProcess.stdout) {\n      // Import and use stream processor\n      const { createStreamProcessor } = await import('./stream-processor.js');\n      const streamProcessor = createStreamProcessor(\n        agent.name,\n        this.getAgentIcon(agent.id),\n        {\n          verbose: this.options.logLevel === 'debug',\n          logLevel: this.options.logLevel,\n          taskId: agent.taskId,\n          agentId: agent.id,\n          display: null // Interactive-style formatting instead of concurrent display\n        }\n      );\n      \n      // Pipe stdout through processor\n      claudeProcess.stdout.pipe(streamProcessor);\n      \n      // Handle stderr for non-interactive mode\n      claudeProcess.stderr.on('data', (data) => {\n        const message = data.toString().trim();\n        if (message) {\n          console.error(`    ❌ [${agent.name}] Error: ${message}`);\n        }\n      });\n    } else if (this.options.nonInteractive && this.options.outputFormat !== 'stream-json') {\n      // For non-interactive non-stream-json output, show stdout directly\n      claudeProcess.stdout.on('data', (data) => {\n        console.log(data.toString().trimEnd());\n      });\n      \n      claudeProcess.stderr.on('data', (data) => {\n        console.error(data.toString().trimEnd());\n      });\n    }\n    // Note: In interactive mode, stdio is inherited so Claude handles its own I/O\n    \n    // Handle process events\n    claudeProcess.on('error', (error) => {\n      console.error(`❌ Claude instance error for ${agent.name}:`, error.message);\n      this.errors.push({\n        type: 'claude_instance_error',\n        agent: agent.id,\n        error: error.message,\n        timestamp: new Date()\n      });\n    });\n    \n    claudeProcess.on('exit', (code) => {\n      const instance = this.claudeInstances.get(agent.id);\n      if (instance) {\n        instance.status = code === 0 ? 'completed' : 'failed';\n        instance.exitCode = code;\n        instance.endTime = Date.now();\n      }\n    });\n    \n    return claudeProcess;\n  }\n\n  /**\n   * Handle Claude stream events\n   */\n  handleClaudeStreamEvent(agent, event) {\n    if (this.options.outputFormat === 'stream-json') {\n      // Create concise formatted JSON with summary\n      const summary = this.getEventSummary(event);\n      const icon = this.getEventIcon(event.type);\n      \n      // Simplified output for better readability\n      const output = {\n        t: new Date().toISOString().split('T')[1].split('.')[0], // HH:MM:SS\n        agent: `${this.getAgentIcon(agent.id)} ${agent.name}`,\n        phase: this.currentPhase,\n        event: `${icon} ${summary}`\n      };\n      \n      // Add relevant details based on event type\n      if (event.type === 'tool_use' && event.name) {\n        output.tool = event.name;\n      } else if (event.type === 'error' && event.error) {\n        output.error = event.error;\n      }\n      \n      console.log(JSON.stringify(output));\n    } else {\n      // Format output for text mode\n      switch (event.type) {\n        case 'tool_use':\n          console.log(`    [${agent.name}] 🔧 Using tool: ${event.name}`);\n          break;\n        case 'message':\n          console.log(`    [${agent.name}] 💬 ${event.content}`);\n          break;\n        case 'completion':\n          console.log(`    [${agent.name}] ✅ Task completed`);\n          break;\n        case 'error':\n          console.error(`    [${agent.name}] ❌ Error: ${event.error}`);\n          break;\n        default:\n          // Log other events in debug mode\n          if (this.options.logLevel === 'debug') {\n            console.log(`    [${agent.name}] ${event.type}: ${JSON.stringify(event)}`);\n          }\n      }\n    }\n  }\n  \n  /**\n   * Get a brief summary of an event\n   */\n  getEventSummary(event) {\n    switch (event.type) {\n      case 'tool_use':\n        return `Using ${event.name} tool`;\n      case 'message':\n        return event.content?.substring(0, 100) + (event.content?.length > 100 ? '...' : '');\n      case 'completion':\n        return 'Task completed successfully';\n      case 'error':\n        return `Error: ${event.error}`;\n      case 'status':\n        return event.status || 'Status update';\n      default:\n        return event.type;\n    }\n  }\n  \n  /**\n   * Get icon for event type\n   */\n  getEventIcon(eventType) {\n    const icons = {\n      'tool_use': '🔧',\n      'message': '💬',\n      'completion': '✅',\n      'error': '❌',\n      'status': '📊',\n      'init': '🚀',\n      'thinking': '🤔',\n      'result': '📋'\n    };\n    return icons[eventType] || '📌';\n  }\n\n  /**\n   * Create task-specific Claude prompt with comprehensive MLE-STAR instructions\n   */\n  createTaskPrompt(task, agent, workflow) {\n    // Use the claudePrompt from the task if available\n    if (task.claudePrompt) {\n      // Apply variable substitutions to the prompt\n      let basePrompt = task.claudePrompt;\n      const allVariables = { ...workflow.variables, ...task.input };\n      \n      for (const [key, value] of Object.entries(allVariables)) {\n        const pattern = new RegExp(`\\\\$\\\\{${key}\\\\}`, 'g');\n        basePrompt = basePrompt.replace(pattern, value);\n      }\n      \n      // Create comprehensive task prompt with MLE-STAR methodology\n      return `🎯 MLE-STAR AGENT TASK EXECUTION\n\nYou are the **${agent.name}** (${agent.type}) in a coordinated MLE-STAR automation workflow.\n\n📋 IMMEDIATE TASK:\n${basePrompt}\n\n🤖 AGENT ROLE & SPECIALIZATION:\n${this.getAgentRoleDescription(agent.type)}\n\n🎯 AGENT CAPABILITIES:\n${agent.config?.capabilities?.join(', ') || 'general automation'}\n\n🔬 MLE-STAR METHODOLOGY FOCUS:\n${this.getMethodologyGuidance(agent.type)}\n\n🔧 COORDINATION REQUIREMENTS:\n1. **HOOKS INTEGRATION** (CRITICAL):\n   - BEFORE starting: \\`npx claude-flow@alpha hooks pre-task --description \"${task.description}\"\\`\n   - AFTER each file operation: \\`npx claude-flow@alpha hooks post-edit --file \"[filepath]\"\\`\n   - WHEN complete: \\`npx claude-flow@alpha hooks post-task --task-id \"${task.id}\"\\`\n\n2. **MEMORY STORAGE** (CRITICAL):\n   - Store findings: \\`npx claude-flow@alpha memory store \"agent/${agent.id}/findings\" \"[your_findings]\"\\`\n   - Store results: \\`npx claude-flow@alpha memory store \"agent/${agent.id}/results\" \"[your_results]\"\\`\n   - Check other agents: \\`npx claude-flow@alpha memory search \"agent/*\"\\`\n\n3. **SESSION COORDINATION**:\n   - Session ID: ${this.sessionId}\n   - Execution ID: ${this.executionId}\n   - Task ID: ${task.id}\n   - Agent ID: ${agent.id}\n\n4. **WORKFLOW PIPELINE AWARENESS**:\n   - Your position: ${this.getAgentPositionInPipeline(agent.type)}\n   - Coordinate with: ${this.getCoordinationPartners(agent.type)}\n   - File naming: Use \\`${agent.id}_[component].[ext]\\` convention\n\n5. **OUTPUT REQUIREMENTS**:\n   - Use detailed progress reporting\n   - Document methodology decisions\n   - Provide clear deliverables\n   - Follow MLE-STAR best practices for your role\n\n🚀 EXECUTION INSTRUCTIONS:\n1. Start with hooks pre-task command\n2. Execute your specialized MLE-STAR role\n3. Store all findings and results in memory\n4. Coordinate with other agents as needed\n5. Complete with hooks post-task command\n6. Exit when task is fully complete\n\n🎯 SUCCESS CRITERIA:\n- Task objective completed according to MLE-STAR methodology\n- All coordination hooks executed successfully  \n- Results stored in memory for other agents\n- Clear documentation of approach and findings\n- Ready for next pipeline phase\n\nBegin execution now with the hooks pre-task command.`;\n    } else {\n      // Fallback to full agent prompt\n      return this.createAgentPrompt(agent);\n    }\n  }\n\n  /**\n   * Create agent-specific Claude prompt\n   */\n  createAgentPrompt(agent) {\n    const { config } = agent;\n    const capabilities = config?.capabilities?.join(', ') || 'general automation';\n    \n    return `You are the ${agent.name} in a coordinated MLE-STAR automation workflow.\n\n🎯 AGENT ROLE: ${agent.type.toUpperCase()}\n📋 CAPABILITIES: ${capabilities}\n🆔 AGENT ID: ${agent.id}\n\nCRITICAL COORDINATION REQUIREMENTS:\n1. HOOKS: Use claude-flow hooks for coordination:\n   - Run \"npx claude-flow@alpha hooks pre-task --description '[your task]'\" before starting\n   - Run \"npx claude-flow@alpha hooks post-edit --file '[file]'\" after each file operation  \n   - Run \"npx claude-flow@alpha hooks post-task --task-id '${agent.id}'\" when complete\n\n2. MEMORY: Store all findings and results:\n   - Use \"npx claude-flow@alpha memory store 'agent/${agent.id}/[key]' '[value]'\" for important data\n   - Check \"npx claude-flow@alpha memory search 'agent/*'\" for coordination with other agents\n\n3. SESSION: Maintain session coordination:\n   - Session ID: ${this.sessionId}\n   - Execution ID: ${this.executionId}\n\nAGENT-SPECIFIC CONFIGURATION:\n${JSON.stringify(config, null, 2)}\n\nMLE-STAR METHODOLOGY FOCUS:\n${this.getMethodologyGuidance(agent.type)}\n\nWORKFLOW COORDINATION:\n- Work with other agents in the pipeline: Search → Foundation → Refinement → Ensemble → Validation\n- Share findings through memory system\n- Use proper file naming conventions: ${agent.id}_[component].[ext]\n- Follow MLE-STAR best practices for your role\n\nExecute your role in the MLE-STAR workflow with full coordination and hook integration.`;\n  }\n\n  /**\n   * Create master coordination prompt for interactive mode\n   */\n  createMasterCoordinationPrompt(agents) {\n    const workflowData = this.currentWorkflow || { name: 'MLE-STAR Workflow', description: 'Machine Learning Engineering via Search and Targeted Refinement' };\n    \n    return `🚀 MLE-STAR WORKFLOW COORDINATION MASTER\n\nYou are the MASTER COORDINATOR for a comprehensive MLE-STAR (Machine Learning Engineering via Search and Targeted Refinement) workflow. \n\n📋 WORKFLOW: ${workflowData.name}\n🎯 DESCRIPTION: ${workflowData.description}\n🆔 EXECUTION ID: ${this.executionId}\n🔄 SESSION ID: ${this.sessionId}\n\n🤖 SUB-AGENTS TO COORDINATE (${agents.length} total):\n${agents.map((agent, index) => `\n${index + 1}. ${agent.name} (${agent.type})\n   🎯 Role: ${this.getAgentRoleDescription(agent.type)}\n   📋 Capabilities: ${agent.config?.capabilities?.join(', ') || 'general automation'}\n   🆔 ID: ${agent.id}`).join('')}\n\n🔧 CRITICAL: USE CONCURRENT STREAMS FOR PARALLEL EXECUTION\n\nYou MUST coordinate these agents using Claude's concurrent execution capabilities:\n\n1. **USE TASK TOOL FOR CONCURRENT AGENTS**: \n   For each sub-agent, use the Task tool to spawn them with detailed prompts:\n   \n   Task(\"You are ${agent.name}. ${detailed_role_prompt}\", \"${agent.id}\", \"agent-${agent.type}\")\n\n2. **PARALLEL EXECUTION PATTERN**:\n   Execute multiple agents simultaneously using the Task tool in a single response:\n   \n   \\`\\`\\`\n   Task(\"Detailed prompt for Search Agent...\", \"search_agent\", \"researcher\")\n   Task(\"Detailed prompt for Foundation Agent...\", \"foundation_agent\", \"coder\") \n   Task(\"Detailed prompt for Refinement Agent...\", \"refinement_agent\", \"optimizer\")\n   Task(\"Detailed prompt for Ensemble Agent...\", \"ensemble_agent\", \"analyst\")\n   Task(\"Detailed prompt for Validation Agent...\", \"validation_agent\", \"tester\")\n   \\`\\`\\`\n\n3. **DETAILED SUB-AGENT PROMPTS**:\n   Each Task call should include comprehensive instructions:\n   - Specific MLE-STAR role and responsibilities\n   - Required actions and deliverables\n   - Coordination requirements with other agents\n   - Output format specifications\n   - Use of --output-format stream-json for progress tracking\n\n4. **COORDINATION WORKFLOW**:\n   Phase 1: Search & Foundation (parallel)\n   Phase 2: Refinement & Optimization (depends on Phase 1)\n   Phase 3: Ensemble & Validation (depends on Phase 2)\n\n5. **OUTPUT MANAGEMENT**:\n   Instruct each agent to use appropriate Claude CLI flags:\n   - Use --print --output-format stream-json --verbose for real-time progress\n   - Coordinate results through file system and memory\n\n🎯 YOUR MISSION:\n1. Launch all ${agents.length} sub-agents using concurrent Task calls\n2. Provide detailed, specific prompts for each agent's MLE-STAR role\n3. Coordinate the workflow execution phases\n4. Monitor progress and provide updates\n5. Synthesize final results\n\nMETHODOLOGY PHASES:\n${this.getMasterMethodologyGuide()}\n\n🚀 BEGIN: Start by deploying all sub-agents with detailed prompts using the Task tool for concurrent execution. Each agent should receive comprehensive instructions for their specific MLE-STAR role.`;\n  }\n\n  /**\n   * Get agent role description for coordination\n   */\n  getAgentRoleDescription(agentType) {\n    const roles = {\n      researcher: 'Web Search & Foundation Discovery - Find state-of-the-art approaches',\n      coder: 'Model Implementation & Training Pipeline - Build foundation models',  \n      optimizer: 'Performance Tuning & Architecture Refinement - Optimize models',\n      analyst: 'Ensemble Methods & Meta-Learning - Combine multiple approaches',\n      tester: 'Validation & Debugging - Ensure quality and performance',\n      coordinator: 'Workflow Orchestration - Manage overall pipeline'\n    };\n    return roles[agentType] || 'Specialized automation task execution';\n  }\n\n  /**\n   * Get comprehensive methodology guide for master coordinator\n   */\n  getMasterMethodologyGuide() {\n    return `\nPHASE 1 - SEARCH & FOUNDATION (Parallel):\n🔬 Search Agent: Research ML approaches, algorithms, and best practices\n💻 Foundation Agent: Implement baseline models and training infrastructure\n\nPHASE 2 - REFINEMENT (Sequential, depends on Phase 1):\n⚡ Refinement Agent: Optimize models, tune hyperparameters, improve performance\n\nPHASE 3 - ENSEMBLE & VALIDATION (Parallel, depends on Phase 2):\n🏛️ Ensemble Agent: Combine models, implement voting/stacking strategies\n🧪 Validation Agent: Test, debug, validate performance, generate reports\n\nCOORDINATION KEY POINTS:\n- Use shared file system for intermediate results\n- Maintain communication through progress updates\n- Each phase builds on previous phases\n- Final deliverable: Production-ready ML pipeline`;\n  }\n\n  /**\n   * Get agent position in MLE-STAR pipeline\n   */\n  getAgentPositionInPipeline(agentType) {\n    const positions = {\n      researcher: 'Phase 1: Search & Foundation Discovery (Parallel with Foundation)',\n      coder: 'Phase 1: Foundation Model Building (Parallel with Search)',\n      optimizer: 'Phase 2: Refinement & Optimization (Sequential, depends on Phase 1)',\n      analyst: 'Phase 3: Ensemble & Meta-Learning (Parallel with Validation)',\n      tester: 'Phase 3: Validation & Debugging (Parallel with Ensemble)',\n      coordinator: 'All Phases: Workflow Orchestration & Coordination'\n    };\n    return positions[agentType] || 'Specialized task execution';\n  }\n\n  /**\n   * Get coordination partners for agent type\n   */\n  getCoordinationPartners(agentType) {\n    const partners = {\n      researcher: 'Foundation Agent (parallel), Refinement Agent (handoff)',\n      coder: 'Search Agent (parallel), Refinement Agent (handoff)',\n      optimizer: 'Search & Foundation Agents (input), Ensemble & Validation Agents (handoff)',\n      analyst: 'Refinement Agent (input), Validation Agent (parallel)',\n      tester: 'All previous agents (validation), Ensemble Agent (parallel)',\n      coordinator: 'All agents (orchestration and monitoring)'\n    };\n    return partners[agentType] || 'Other workflow agents as needed';\n  }\n\n  /**\n   * Get methodology guidance for agent type\n   */\n  getMethodologyGuidance(agentType) {\n    const guidance = {\n      researcher: `SEARCH PHASE - Web Research & Foundation Discovery:\n- Search for state-of-the-art ML approaches for the problem domain\n- Find winning Kaggle solutions and benchmark results\n- Identify promising model architectures and techniques\n- Document implementation examples and model cards\n- Focus on proven, recent approaches with good performance`,\n\n      coder: `FOUNDATION PHASE - Initial Model Building:\n- Analyze dataset characteristics and problem type\n- Implement baseline models based on research findings\n- Create robust preprocessing pipelines\n- Build modular, testable code components\n- Establish performance baselines for comparison`,\n\n      optimizer: `REFINEMENT PHASE - Targeted Component Optimization:\n- Perform ablation analysis to identify high-impact components\n- Focus deep optimization on most impactful pipeline elements\n- Use iterative improvement with structured feedback\n- Implement advanced feature engineering techniques\n- Optimize hyperparameters systematically`,\n\n      architect: `ENSEMBLE PHASE - Intelligent Model Combination:\n- Create sophisticated ensemble strategies beyond simple averaging\n- Implement stacking with meta-learners\n- Use dynamic weighting and mixture of experts\n- Apply Bayesian model averaging where appropriate\n- Optimize ensemble composition for maximum performance`,\n\n      tester: `VALIDATION PHASE - Comprehensive Testing & Debugging:\n- Implement rigorous cross-validation strategies\n- Detect and prevent data leakage\n- Perform error analysis and debugging\n- Validate model robustness and generalization\n- Ensure production readiness with quality checks`,\n\n      coordinator: `ORCHESTRATION PHASE - Workflow Management:\n- Coordinate between all agents and phases\n- Monitor progress and performance metrics\n- Manage resource allocation and scheduling\n- Handle error recovery and workflow adaptation\n- Prepare final deployment and documentation`\n    };\n\n    return guidance[agentType] || 'Focus on your specialized capabilities and coordinate with other agents.';\n  }\n\n  /**\n   * Execute workflow tasks with dependency management\n   */\n  async executeWorkflowTasks(workflow) {\n    const { tasks, dependencies = {} } = workflow;\n    \n    let completedTasks = 0;\n    let failedTasks = 0;\n    const totalTasks = tasks.length;\n    \n    // Task status tracking\n    const taskStatuses = new Map();\n    tasks.forEach(task => {\n      taskStatuses.set(task.id, {\n        name: task.name || task.id,\n        status: 'pending',\n        agent: task.assignTo,\n        startTime: null,\n        endTime: null,\n        summary: ''\n      });\n    });\n    \n    // Create task execution plan based on dependencies\n    const executionPlan = this.createExecutionPlan(tasks, dependencies);\n    \n    console.log(`📋 Executing ${totalTasks} tasks in ${executionPlan.length} phases...`);\n    console.log();\n    \n    // Note: Concurrent display disabled in favor of interactive-style stream processing\n    let concurrentDisplay = null;\n    // if (this.options.nonInteractive && this.options.outputFormat === 'stream-json') {\n    //   const { createConcurrentDisplay } = await import('./concurrent-display.js');\n    //   \n    //   // Get all agents and their tasks\n    //   const agentTasks = workflow.agents?.map(agent => ({\n    //     id: agent.id,\n    //     name: agent.name,\n    //     type: agent.type,\n    //     tasks: tasks.filter(t => t.assignTo === agent.id).map(t => t.name)\n    //   })) || [];\n    //   \n    //   concurrentDisplay = createConcurrentDisplay(agentTasks);\n    //   concurrentDisplay.start();\n    //   \n    //   // Store reference for stream processors\n    //   this.concurrentDisplay = concurrentDisplay;\n    // }\n    \n    // Execute tasks phase by phase\n    for (const [phaseIndex, phaseTasks] of executionPlan.entries()) {\n      this.currentPhase = `Phase ${phaseIndex + 1}`;\n      \n      // Show regular task board or update concurrent display\n      if (!concurrentDisplay) {\n        if (this.options.logLevel === 'quiet') {\n          console.log(`\\n🔄 Phase ${phaseIndex + 1}: Running ${phaseTasks.length} tasks`);\n        } else {\n          console.log(`\\n🔄 Phase ${phaseIndex + 1}: ${phaseTasks.length} concurrent tasks`);\n        }\n        this.displayTaskBoard(taskStatuses, phaseTasks);\n      }\n      \n      // Mark tasks as in-progress\n      phaseTasks.forEach(task => {\n        const status = taskStatuses.get(task.id);\n        status.status = 'in-progress';\n        status.startTime = Date.now();\n      });\n      \n      // Execute tasks in this phase (potentially in parallel)\n      const phasePromises = phaseTasks.map(async (task) => {\n        const taskStatus = taskStatuses.get(task.id);\n        \n        try {\n          // Show task starting\n          console.log(`\\n  🚀 Starting: ${task.name || task.id}`);\n          console.log(`     Agent: ${task.assignTo}`);\n          console.log(`     Description: ${task.description?.substring(0, 80)}...`);\n          \n          const result = await this.executeTask(task, workflow);\n          \n          taskStatus.status = result.success ? 'completed' : 'failed';\n          taskStatus.endTime = Date.now();\n          taskStatus.summary = result.success ? \n            `✅ Completed in ${this.formatDuration(result.duration)}` :\n            `❌ Failed: ${result.error?.message || 'Unknown error'}`;\n          \n          return result;\n        } catch (error) {\n          taskStatus.status = 'failed';\n          taskStatus.endTime = Date.now();\n          taskStatus.summary = `❌ Error: ${error.message}`;\n          throw error;\n        }\n      });\n      \n      // Wait for all phase tasks to complete\n      const phaseResults = await Promise.allSettled(phasePromises);\n      \n      // Process phase results\n      for (const [taskIndex, result] of phaseResults.entries()) {\n        const task = phaseTasks[taskIndex];\n        const taskStatus = taskStatuses.get(task.id);\n        \n        if (result.status === 'fulfilled' && result.value.success) {\n          completedTasks++;\n          this.results.set(task.id, result.value);\n        } else {\n          failedTasks++;\n          const error = result.status === 'rejected' ? result.reason : result.value.error;\n          this.errors.push({\n            type: 'task_execution',\n            task: task.id,\n            error: error.message || error,\n            timestamp: new Date()\n          });\n          \n          // Check if we should fail fast\n          if (workflow.settings?.failurePolicy === 'fail-fast') {\n            console.log(`\\n🛑 Failing fast due to task failure`);\n            break;\n          }\n        }\n      }\n      \n      // Show updated task board\n      if (!concurrentDisplay) {\n        console.log(`\\n📊 Phase ${phaseIndex + 1} Complete:`);\n        this.displayTaskBoard(taskStatuses);\n      }\n      \n      // Stop if fail-fast and we have failures\n      if (workflow.settings?.failurePolicy === 'fail-fast' && failedTasks > 0) {\n        break;\n      }\n    }\n    \n    // Final summary\n    if (!concurrentDisplay) {\n      console.log(`\\n📊 Final Workflow Summary:`);\n      this.displayTaskBoard(taskStatuses);\n    } else {\n      // Stop concurrent display\n      concurrentDisplay.stop();\n      console.log(); // Add some space after display\n    }\n    \n    return {\n      success: failedTasks === 0,\n      totalTasks,\n      completedTasks,\n      failedTasks,\n      executionId: this.executionId,\n      duration: Date.now() - this.startTime,\n      results: Object.fromEntries(this.results),\n      errors: this.errors\n    };\n  }\n  \n  /**\n   * Display task board showing current status\n   */\n  displayTaskBoard(taskStatuses, highlightTasks = []) {\n    // In quiet mode, just show simple progress\n    if (this.options.logLevel === 'quiet') {\n      const totalTasks = taskStatuses.size;\n      const completedTasks = Array.from(taskStatuses.values()).filter(s => s.status === 'completed').length;\n      const activeTasks = Array.from(taskStatuses.values()).filter(s => s.status === 'in-progress').length;\n      console.log(`📊 Progress: ${completedTasks}/${totalTasks} completed, ${activeTasks} active`);\n      return;\n    }\n    \n    const frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];\n    const frameIndex = Math.floor(Date.now() / 100) % frames.length;\n    const spinner = frames[frameIndex];\n    \n    console.log('\\n╔═══════════════════════════════════════════════════════════════╗');\n    console.log('║                    🤖 CONCURRENT TASK STATUS                   ║');\n    console.log('╠═══════════════════════════════════════════════════════════════╣');\n    \n    // Group by status\n    const statusGroups = {\n      'in-progress': [],\n      'completed': [],\n      'failed': [],\n      'pending': []\n    };\n    \n    taskStatuses.forEach((status, taskId) => {\n      statusGroups[status.status].push({ taskId, ...status });\n    });\n    \n    // Show in-progress tasks with animation\n    if (statusGroups['in-progress'].length > 0) {\n      console.log(`║ ${spinner} RUNNING (${statusGroups['in-progress'].length} agents):                                      ║`);\n      statusGroups['in-progress'].forEach(task => {\n        const duration = task.startTime ? this.formatDuration(Date.now() - task.startTime) : '';\n        const progress = this.getProgressBar(Date.now() - task.startTime, 60000); // 1 min expected\n        const agentIcon = this.getAgentIcon(task.agent);\n        console.log(`║   ${agentIcon} ${task.name.padEnd(25)} ${progress} ${duration.padStart(8)} ║`);\n      });\n    }\n    \n    // Show completed tasks\n    if (statusGroups['completed'].length > 0) {\n      console.log(`║ ✅ COMPLETED (${statusGroups['completed'].length}):                                           ║`);\n      statusGroups['completed'].forEach(task => {\n        const duration = task.endTime && task.startTime ? \n          this.formatDuration(task.endTime - task.startTime) : '';\n        console.log(`║   ✓ ${task.name.padEnd(35)} ${duration.padStart(10)} ║`);\n      });\n    }\n    \n    // Show failed tasks\n    if (statusGroups['failed'].length > 0) {\n      console.log(`║ ❌ FAILED (${statusGroups['failed'].length}):                                              ║`);\n      statusGroups['failed'].forEach(task => {\n        const errorMsg = (task.summary || '').substring(0, 25);\n        console.log(`║   ✗ ${task.name.padEnd(25)} ${errorMsg.padEnd(20)} ║`);\n      });\n    }\n    \n    // Show pending tasks count\n    if (statusGroups['pending'].length > 0) {\n      console.log(`║ ⏳ QUEUED: ${statusGroups['pending'].length} tasks waiting                                 ║`);\n    }\n    \n    // Summary stats\n    const total = taskStatuses.size;\n    const completed = statusGroups['completed'].length;\n    const failed = statusGroups['failed'].length;\n    const progress = total > 0 ? Math.floor((completed + failed) / total * 100) : 0;\n    \n    console.log('╠═══════════════════════════════════════════════════════════════╣');\n    console.log(`║ 📊 Progress: ${progress}% (${completed}/${total}) │ ⚡ Active: ${statusGroups['in-progress'].length} │ ❌ Failed: ${failed}  ║`);\n    console.log('╚═══════════════════════════════════════════════════════════════╝');\n  }\n  \n  /**\n   * Get progress bar visualization\n   */\n  getProgressBar(elapsed, expected) {\n    const progress = Math.min(elapsed / expected, 1);\n    const filled = Math.floor(progress * 10);\n    const empty = 10 - filled;\n    return '[' + '█'.repeat(filled) + '░'.repeat(empty) + ']';\n  }\n  \n  /**\n   * Get agent icon based on type\n   */\n  getAgentIcon(agentId) {\n    const icons = {\n      'search': '🔍',\n      'foundation': '🏗️',\n      'refinement': '🔧',\n      'ensemble': '🎯',\n      'validation': '✅',\n      'coordinator': '🎮',\n      'researcher': '🔬',\n      'coder': '💻',\n      'optimizer': '⚡',\n      'architect': '🏛️',\n      'tester': '🧪'\n    };\n    \n    // Extract agent type from ID\n    const type = agentId?.split('_')[0] || 'default';\n    return icons[type] || '🤖';\n  }\n\n  /**\n   * Execute a single task\n   */\n  async executeTask(task, workflow) {\n    const startTime = Date.now();\n    \n    try {\n      // Store task execution in memory if hooks enabled\n      if (this.hooksEnabled) {\n        await this.executeHook('notify', {\n          message: `Starting task: ${task.name || task.id}`,\n          sessionId: this.sessionId\n        });\n      }\n      \n      if (this.options.nonInteractive && this.options.outputFormat === 'stream-json') {\n        console.log(`\\n● ${task.name || task.id} - Starting Execution`);\n        console.log(`  ⎿  ${task.description}`);\n        console.log(`  ⎿  Agent: ${task.assignTo}`);\n      } else {\n        console.log(`    🔄 Executing: ${task.description}`);\n      }\n      \n      // For demonstration/testing mode (when Claude integration is disabled)\n      // we simulate successful task completion\n      if (!this.options.enableClaude) {\n        // Simulate variable execution time\n        const executionTime = Math.min(\n          1000 + Math.random() * 3000, // 1-4 seconds simulation\n          task.timeout || 30000\n        );\n        \n        await new Promise(resolve => setTimeout(resolve, executionTime));\n        \n        // Simulate successful completion for demo/testing\n        const result = {\n          success: true,\n          taskId: task.id,\n          duration: Date.now() - startTime,\n          output: {\n            status: 'completed',\n            agent: task.assignTo,\n            executionTime: Date.now() - startTime,\n            metadata: {\n              timestamp: new Date().toISOString(),\n              executionId: this.executionId,\n              mode: 'simulation'\n            }\n          }\n        };\n        \n        // Store result in memory\n        if (this.hooksEnabled) {\n          await this.storeTaskResult(task.id, result.output);\n        }\n        \n        return result;\n      } else {\n        // When Claude integration is enabled, delegate to actual Claude instance\n        \n        // Check if we have a master coordinator (interactive mode)\n        const masterCoordinator = this.claudeInstances.get('master-coordinator');\n        if (masterCoordinator && !this.options.nonInteractive) {\n          // Interactive mode: All tasks are coordinated by the master coordinator\n          console.log(`    🎯 Task delegated to Master Coordinator: ${task.description}`);\n          \n          // In interactive mode, the master coordinator handles all tasks\n          // We just wait for the master coordinator process to complete\n          const completionPromise = new Promise((resolve, reject) => {\n            masterCoordinator.process.on('exit', (code) => {\n              if (code === 0) {\n                resolve({ success: true, code });\n              } else {\n                reject(new Error(`Master coordinator exited with code ${code}`));\n              }\n            });\n            \n            masterCoordinator.process.on('error', (err) => {\n              reject(err);\n            });\n          });\n          \n          // For interactive mode, we use a longer timeout since user interaction is involved\n          const timeout = Math.max(this.options.timeout, 1800000); // 30 minutes minimum for interactive\n          const timeoutPromise = new Promise((_, reject) => {\n            setTimeout(() => reject(new Error('Interactive session timeout')), timeout);\n          });\n          \n          try {\n            await Promise.race([completionPromise, timeoutPromise]);\n            \n            const result = {\n              success: true,\n              taskId: task.id,\n              duration: Date.now() - startTime,\n              output: {\n                status: 'completed',\n                agent: 'master-coordinator',\n                executionTime: Date.now() - startTime,\n                metadata: {\n                  timestamp: new Date().toISOString(),\n                  executionId: this.executionId,\n                  mode: 'interactive-coordination'\n                }\n              }\n            };\n            \n            // Store result in memory\n            if (this.hooksEnabled) {\n              await this.storeTaskResult(task.id, result.output);\n            }\n            \n            return result;\n            \n          } catch (error) {\n            throw new Error(`Task execution failed: ${error.message}`);\n          }\n        }\n        \n        // Non-interactive mode or no master coordinator: use individual Claude instances\n        const claudeInstance = this.claudeInstances.get(task.assignTo);\n        if (!claudeInstance) {\n          // If no pre-spawned instance, create one for this task\n          const agent = workflow.agents.find(a => a.id === task.assignTo);\n          if (!agent) {\n            throw new Error(`No agent definition found for: ${task.assignTo}`);\n          }\n          \n          // Create task-specific prompt\n          const taskPrompt = this.createTaskPrompt(task, agent, workflow);\n          \n          // Check if we should chain from a previous task\n          let chainOptions = {};\n          if (this.enableChaining && this.options.outputFormat === 'stream-json' && task.depends?.length > 0) {\n            // Get the output stream from the last dependency\n            const lastDependency = task.depends[task.depends.length - 1];\n            const dependencyStream = this.taskOutputStreams.get(lastDependency);\n            if (dependencyStream) {\n              console.log(`    🔗 Enabling stream chaining from ${lastDependency} to ${task.id}`);\n              chainOptions.inputStream = dependencyStream;\n            }\n          }\n          \n          // Spawn Claude instance for this specific task\n          const taskClaudeProcess = await this.spawnClaudeInstance(agent, taskPrompt, chainOptions);\n          \n          // Store the output stream for potential chaining\n          if (this.enableChaining && this.options.outputFormat === 'stream-json' && taskClaudeProcess.stdout) {\n            this.taskOutputStreams.set(task.id, taskClaudeProcess.stdout);\n          }\n          \n          // Store the instance\n          this.claudeInstances.set(agent.id, {\n            process: taskClaudeProcess,\n            agent: agent,\n            status: 'active',\n            startTime: Date.now(),\n            taskId: task.id\n          });\n          \n          // Wait for task completion or timeout\n          // Use longer timeout for ML tasks\n          const baseTimeout = this.options.timeout || 60000;\n          const isMLTask = task.type?.toLowerCase().includes('ml') || \n                          task.type?.toLowerCase().includes('model') ||\n                          task.type?.toLowerCase().includes('search') ||\n                          task.type?.toLowerCase().includes('analysis') ||\n                          this.options.workflowType === 'ml';\n          const timeout = task.timeout || (isMLTask ? Math.max(baseTimeout, 300000) : baseTimeout); // Min 5 minutes for ML tasks\n          \n          if (this.options.logLevel === 'debug' || this.options.verbose) {\n            console.log(`    ⏱️  Timeout: ${this.formatDuration(timeout)} (Base: ${this.formatDuration(baseTimeout)}, ML Task: ${isMLTask})`);\n          }\n          \n          const completionPromise = new Promise((resolve, reject) => {\n            taskClaudeProcess.on('exit', (code) => {\n              if (code === 0) {\n                resolve({ success: true, code });\n              } else {\n                reject(new Error(`Process exited with code ${code}`));\n              }\n            });\n            \n            taskClaudeProcess.on('error', (err) => {\n              reject(err);\n            });\n          });\n          \n          const timeoutPromise = new Promise((_, reject) => {\n            // Use a much longer timeout for ML tasks since Claude is actively working\n            const actualTimeout = isMLTask ? Math.max(timeout, 600000) : timeout; // 10 min minimum for ML\n            setTimeout(() => reject(new Error('Task timeout')), actualTimeout);\n          });\n          \n          try {\n            await Promise.race([completionPromise, timeoutPromise]);\n            \n            const result = {\n              success: true,\n              taskId: task.id,\n              duration: Date.now() - startTime,\n              output: {\n                status: 'completed',\n                agent: task.assignTo,\n                executionTime: Date.now() - startTime,\n                metadata: {\n                  timestamp: new Date().toISOString(),\n                  executionId: this.executionId,\n                  mode: 'claude-task-execution'\n                }\n              }\n            };\n            \n            // Store result in memory\n            if (this.hooksEnabled) {\n              await this.storeTaskResult(task.id, result.output);\n            }\n            \n            return result;\n          } catch (error) {\n            throw error;\n          }\n        } else {\n          // Use existing Claude instance\n          // In a full implementation, this would send the task to the running instance\n          // For now, we'll spawn a new instance per task for simplicity\n          \n          const agent = claudeInstance.agent;\n          const taskPrompt = this.createTaskPrompt(task, agent, workflow);\n          \n          // Check if we should chain from a previous task\n          let chainOptions = {};\n          if (this.enableChaining && this.options.outputFormat === 'stream-json' && task.depends?.length > 0) {\n            // Get the output stream from the last dependency\n            const lastDependency = task.depends[task.depends.length - 1];\n            const dependencyStream = this.taskOutputStreams.get(lastDependency);\n            if (dependencyStream) {\n              console.log(`    🔗 Enabling stream chaining from ${lastDependency} to ${task.id}`);\n              chainOptions.inputStream = dependencyStream;\n            }\n          }\n          \n          // For now, spawn a new instance for each task\n          const taskClaudeProcess = await this.spawnClaudeInstance(agent, taskPrompt, chainOptions);\n          \n          // Store the output stream for potential chaining\n          if (this.enableChaining && this.options.outputFormat === 'stream-json' && taskClaudeProcess.stdout) {\n            this.taskOutputStreams.set(task.id, taskClaudeProcess.stdout);\n          }\n          \n          // Wait for completion\n          // Use longer timeout for ML tasks\n          const baseTimeout = this.options.timeout || 60000;\n          const isMLTask = task.type?.toLowerCase().includes('ml') || \n                          task.type?.toLowerCase().includes('model') ||\n                          task.type?.toLowerCase().includes('search') ||\n                          task.type?.toLowerCase().includes('analysis') ||\n                          this.options.workflowType === 'ml';\n          const timeout = task.timeout || (isMLTask ? Math.max(baseTimeout, 300000) : baseTimeout); // Min 5 minutes for ML tasks\n          \n          if (this.options.logLevel === 'debug' || this.options.verbose) {\n            console.log(`    ⏱️  Timeout: ${this.formatDuration(timeout)} (Base: ${this.formatDuration(baseTimeout)}, ML Task: ${isMLTask})`);\n          }\n          \n          const completionPromise = new Promise((resolve, reject) => {\n            taskClaudeProcess.on('exit', (code) => {\n              if (code === 0) {\n                resolve({ success: true, code });\n              } else {\n                reject(new Error(`Process exited with code ${code}`));\n              }\n            });\n            \n            taskClaudeProcess.on('error', (err) => {\n              reject(err);\n            });\n          });\n          \n          const timeoutPromise = new Promise((_, reject) => {\n            // Use a much longer timeout for ML tasks since Claude is actively working\n            const actualTimeout = isMLTask ? Math.max(timeout, 600000) : timeout; // 10 min minimum for ML\n            setTimeout(() => reject(new Error('Task timeout')), actualTimeout);\n          });\n          \n          try {\n            await Promise.race([completionPromise, timeoutPromise]);\n            \n            const result = {\n              success: true,\n              taskId: task.id,\n              duration: Date.now() - startTime,\n              output: {\n                status: 'completed',\n                agent: task.assignTo,\n                executionTime: Date.now() - startTime,\n                metadata: {\n                  timestamp: new Date().toISOString(),\n                  executionId: this.executionId,\n                  mode: 'claude-task-execution'\n                }\n              }\n            };\n            \n            // Store result in memory\n            if (this.hooksEnabled) {\n              await this.storeTaskResult(task.id, result.output);\n            }\n            \n            return result;\n          } catch (error) {\n            throw error;\n          }\n        }\n      }\n      \n    } catch (error) {\n      return {\n        success: false,\n        taskId: task.id,\n        duration: Date.now() - startTime,\n        error: error\n      };\n    }\n  }\n\n  /**\n   * Create execution plan based on task dependencies\n   */\n  createExecutionPlan(tasks, dependencies) {\n    const taskMap = new Map(tasks.map(task => [task.id, task]));\n    const completed = new Set();\n    const phases = [];\n    \n    while (completed.size < tasks.length) {\n      const readyTasks = tasks.filter(task => {\n        if (completed.has(task.id)) return false;\n        \n        const deps = task.depends || dependencies[task.id] || [];\n        return deps.every(dep => completed.has(dep));\n      });\n      \n      if (readyTasks.length === 0) {\n        throw new Error('Circular dependency detected or invalid dependencies');\n      }\n      \n      phases.push(readyTasks);\n      readyTasks.forEach(task => completed.add(task.id));\n    }\n    \n    return phases;\n  }\n\n  /**\n   * Execute a hook command\n   */\n  async executeHook(hookType, params) {\n    try {\n      const { execSync } = await import('child_process');\n      \n      let hookCommand = `npx claude-flow@alpha hooks ${hookType}`;\n      \n      if (params.description) {\n        hookCommand += ` --description \"${params.description}\"`;\n      }\n      if (params.file) {\n        hookCommand += ` --file \"${params.file}\"`;\n      }\n      if (params.taskId) {\n        hookCommand += ` --task-id \"${params.taskId}\"`;\n      }\n      if (params.sessionId) {\n        hookCommand += ` --session-id \"${params.sessionId}\"`;\n      }\n      if (params.message) {\n        hookCommand += ` --message \"${params.message}\"`;\n      }\n      \n      execSync(hookCommand, { stdio: 'pipe' });\n      \n    } catch (error) {\n      // Hooks are optional, don't fail the workflow if they fail\n      console.debug(`Hook ${hookType} failed:`, error.message);\n    }\n  }\n\n  /**\n   * Store task result in memory\n   */\n  async storeTaskResult(taskId, result) {\n    try {\n      const { execSync } = await import('child_process');\n      const resultJson = JSON.stringify(result);\n      \n      execSync(`npx claude-flow@alpha memory store \"workflow/${this.executionId}/${taskId}\" '${resultJson}'`, {\n        stdio: 'pipe'\n      });\n      \n    } catch (error) {\n      console.debug(`Failed to store task result for ${taskId}:`, error.message);\n    }\n  }\n\n  /**\n   * Validate workflow definition\n   */\n  validateWorkflow(workflow) {\n    if (!workflow.name) {\n      throw new Error('Workflow name is required');\n    }\n    \n    if (!workflow.tasks || workflow.tasks.length === 0) {\n      throw new Error('Workflow must contain at least one task');\n    }\n    \n    // Validate task structure\n    for (const task of workflow.tasks) {\n      if (!task.id || !task.type || !task.description) {\n        throw new Error(`Task ${task.id || 'unknown'} is missing required fields`);\n      }\n    }\n    \n    // Validate agent assignments\n    if (workflow.agents) {\n      const agentIds = new Set(workflow.agents.map(a => a.id));\n      for (const task of workflow.tasks) {\n        if (task.assignTo && !agentIds.has(task.assignTo)) {\n          throw new Error(`Task ${task.id} assigned to unknown agent: ${task.assignTo}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply variable substitutions to workflow\n   */\n  applyVariables(workflow, variables) {\n    const allVariables = { ...workflow.variables, ...variables };\n    const workflowStr = JSON.stringify(workflow);\n    \n    // Simple variable substitution\n    let processedStr = workflowStr;\n    for (const [key, value] of Object.entries(allVariables)) {\n      const pattern = new RegExp(`\\\\$\\\\{${key}\\\\}`, 'g');\n      processedStr = processedStr.replace(pattern, value);\n    }\n    \n    return JSON.parse(processedStr);\n  }\n\n  /**\n   * Cleanup Claude instances\n   */\n  async cleanupClaudeInstances() {\n    if (this.claudeInstances.size === 0) return;\n    \n    console.log('🧹 Cleaning up Claude instances...');\n    \n    for (const [agentId, instance] of this.claudeInstances.entries()) {\n      try {\n        if (instance.process && !instance.process.killed) {\n          instance.process.kill('SIGTERM');\n          \n          // Wait for graceful shutdown, then force kill if needed\n          setTimeout(() => {\n            if (!instance.process.killed) {\n              instance.process.kill('SIGKILL');\n            }\n          }, 5000);\n        }\n        \n        console.log(`  ✅ Cleaned up ${instance.agent.name}`);\n        \n      } catch (error) {\n        console.error(`  ❌ Error cleaning up ${instance.agent.name}:`, error.message);\n      }\n    }\n    \n    this.claudeInstances.clear();\n  }\n\n  /**\n   * Format duration in human readable format\n   */\n  formatDuration(ms) {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n}\n\n/**\n * Load workflow from file\n */\nexport async function loadWorkflowFromFile(filePath) {\n  try {\n    const content = await fs.readFile(filePath, 'utf-8');\n    \n    if (filePath.endsWith('.json')) {\n      return JSON.parse(content);\n    } else if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {\n      // For now, just return error - YAML support can be added later\n      throw new Error('YAML workflows not yet supported');\n    } else {\n      throw new Error('Unsupported workflow file format. Use .json or .yaml');\n    }\n    \n  } catch (error) {\n    throw new Error(`Failed to load workflow: ${error.message}`);\n  }\n}\n\n/**\n * Get default MLE-STAR workflow path\n */\nexport function getMLEStarWorkflowPath() {\n  return join(process.cwd(), 'src', 'cli', 'simple-commands', 'templates', 'mle-star-workflow.json');\n}"],"names":["promises","fs","spawn","join","printSuccess","printError","generateId","prefix","Date","now","Math","random","toString","substr","WorkflowExecutor","options","enableClaude","nonInteractive","outputFormat","maxConcurrency","timeout","logLevel","workflowType","workflowName","toLowerCase","includes","executionId","startTime","activeTasks","Map","claudeInstances","results","errors","currentWorkflow","taskOutputStreams","enableChaining","hooksEnabled","sessionId","executeWorkflow","workflowData","variables","console","log","name","executeHook","description","validateWorkflow","processedWorkflow","applyVariables","initializeClaudeAgents","agents","result","executeWorkflowTasks","taskId","success","duration","formatDuration","completedTasks","totalTasks","length","cleanupClaudeInstances","error","message","isClaudeAvailable","Error","masterPrompt","createMasterCoordinationPrompt","claudeProcess","spawnClaudeInstance","id","type","set","process","agent","status","pid","map","a","push","timestamp","execSync","stdio","prompt","claudeArgs","inputStream","displayPrompt","substring","flagsDisplay","stdioConfig","shell","stdin","pipe","stdout","createStreamProcessor","streamProcessor","getAgentIcon","verbose","agentId","display","stderr","on","data","trim","trimEnd","code","instance","get","exitCode","endTime","handleClaudeStreamEvent","event","summary","getEventSummary","icon","getEventIcon","output","t","toISOString","split","phase","currentPhase","tool","JSON","stringify","content","eventType","icons","createTaskPrompt","task","workflow","claudePrompt","basePrompt","allVariables","input","key","value","Object","entries","pattern","RegExp","replace","getAgentRoleDescription","config","capabilities","getMethodologyGuidance","getAgentPositionInPipeline","getCoordinationPartners","createAgentPrompt","toUpperCase","index","detailed_role_prompt","getMasterMethodologyGuide","agentType","roles","researcher","coder","optimizer","analyst","tester","coordinator","positions","partners","guidance","architect","tasks","dependencies","failedTasks","taskStatuses","forEach","assignTo","executionPlan","createExecutionPlan","concurrentDisplay","phaseIndex","phaseTasks","displayTaskBoard","phasePromises","taskStatus","executeTask","phaseResults","Promise","allSettled","taskIndex","reason","settings","failurePolicy","stop","fromEntries","highlightTasks","size","Array","from","values","filter","s","frames","frameIndex","floor","spinner","statusGroups","progress","getProgressBar","agentIcon","padEnd","padStart","errorMsg","total","completed","failed","elapsed","expected","min","filled","empty","repeat","executionTime","resolve","setTimeout","metadata","mode","storeTaskResult","masterCoordinator","completionPromise","reject","err","max","timeoutPromise","_","race","claudeInstance","find","taskPrompt","chainOptions","depends","lastDependency","dependencyStream","taskClaudeProcess","baseTimeout","isMLTask","actualTimeout","taskMap","Set","phases","readyTasks","has","deps","every","dep","add","hookType","params","hookCommand","file","debug","resultJson","agentIds","workflowStr","processedStr","parse","killed","kill","clear","ms","seconds","minutes","hours","loadWorkflowFromFile","filePath","readFile","endsWith","getMLEStarWorkflowPath","cwd"],"mappings":"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"}