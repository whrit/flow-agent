{"version":3,"sources":["../../../../src/cli/simple-commands/tool-execution-framework.js"],"sourcesContent":["/**\n * Tool Execution Framework\n * Provides unified interface for executing all Claude-Flow MCP tools\n * Handles progress tracking, cancellation, and result formatting\n */\n\nimport MCPIntegrationLayer from './mcp-integration-layer.js';\n\nexport class ToolExecutionFramework {\n  constructor(ui) {\n    this.ui = ui;\n    this.mcpLayer = new MCPIntegrationLayer(ui);\n    this.executionQueue = [];\n    this.maxConcurrentExecutions = 5;\n    this.currentExecutions = 0;\n    this.resultFormatters = new Map();\n\n    this.initializeFormatters();\n  }\n\n  /**\n   * Initialize result formatters for different tool types\n   */\n  initializeFormatters() {\n    // Swarm tools formatters\n    this.resultFormatters.set('swarm_init', (result) => ({\n      title: 'Swarm Initialized',\n      summary: `${result.topology} topology with ${result.maxAgents} max agents`,\n      details: [\n        `Swarm ID: ${result.swarmId}`,\n        `Strategy: ${result.strategy}`,\n        `Status: ${result.status}`,\n      ],\n      status: result.success ? 'success' : 'error',\n    }));\n\n    this.resultFormatters.set('neural_train', (result) => ({\n      title: 'Neural Training Complete',\n      summary: `${result.pattern_type} model trained with ${result.accuracy.toFixed(2)} accuracy`,\n      details: [\n        `Model ID: ${result.modelId}`,\n        `Epochs: ${result.epochs}`,\n        `Training time: ${result.training_time.toFixed(1)}s`,\n        `Accuracy: ${(result.accuracy * 100).toFixed(1)}%`,\n      ],\n      status: result.success ? 'success' : 'error',\n      metrics: {\n        accuracy: result.accuracy,\n        epochs: result.epochs,\n        time: result.training_time,\n      },\n    }));\n\n    this.resultFormatters.set('performance_report', (result) => ({\n      title: 'Performance Report',\n      summary: `${result.timeframe} analysis - ${result.metrics.success_rate.toFixed(1)}% success rate`,\n      details: [\n        `Tasks executed: ${result.metrics.tasks_executed}`,\n        `Average execution time: ${result.metrics.avg_execution_time.toFixed(1)}s`,\n        `Agents spawned: ${result.metrics.agents_spawned}`,\n        `Memory efficiency: ${(result.metrics.memory_efficiency * 100).toFixed(1)}%`,\n      ],\n      status: 'success',\n      charts: {\n        successRate: result.metrics.success_rate,\n        memoryEfficiency: result.metrics.memory_efficiency,\n      },\n    }));\n\n    this.resultFormatters.set('memory_usage', (result) => ({\n      title: 'Memory Operation',\n      summary: `${result.action} operation on key \"${result.key}\"`,\n      details: [\n        `Namespace: ${result.namespace}`,\n        `Action: ${result.action}`,\n        `Status: ${result.action === 'store' ? 'Stored' : 'Retrieved'}`,\n      ],\n      status: result.success ? 'success' : 'error',\n    }));\n\n    // Default formatter for unknown tools\n    this.resultFormatters.set('default', (result) => ({\n      title: `Tool: ${result.tool || 'Unknown'}`,\n      summary: result.message || 'Tool executed successfully',\n      details: Object.entries(result).map(\n        ([key, value]) => `${key}: ${typeof value === 'object' ? JSON.stringify(value) : value}`,\n      ),\n      status: result.success ? 'success' : 'error',\n    }));\n  }\n\n  /**\n   * Execute a single tool with comprehensive tracking\n   */\n  async executeTool(toolName, parameters = {}, options = {}) {\n    try {\n      // Validate tool exists\n      if (!this.isToolAvailable(toolName)) {\n        throw new Error(`Tool \"${toolName}\" is not available`);\n      }\n\n      // Create execution context\n      const execution = {\n        id: `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        toolName,\n        parameters,\n        options,\n        startTime: Date.now(),\n        status: 'queued',\n        progress: 0,\n      };\n\n      // Add to queue or execute immediately\n      if (this.currentExecutions >= this.maxConcurrentExecutions) {\n        this.executionQueue.push(execution);\n        this.ui.addLog('info', `Tool ${toolName} queued (${this.executionQueue.length} in queue)`);\n      } else {\n        await this.executeToolDirect(execution);\n      }\n\n      return execution;\n    } catch (error) {\n      this.ui.addLog('error', `Failed to execute ${toolName}: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute tool directly\n   */\n  async executeToolDirect(execution) {\n    this.currentExecutions++;\n    execution.status = 'running';\n    execution.startTime = Date.now();\n\n    try {\n      this.ui.addLog('info', `Executing ${execution.toolName}...`);\n\n      // Execute via MCP layer\n      const result = await this.mcpLayer.executeTool(\n        execution.toolName,\n        execution.parameters,\n        execution.options,\n      );\n\n      // Format result\n      const formattedResult = this.formatResult(execution.toolName, result.result);\n\n      // Update execution\n      execution.status = 'completed';\n      execution.endTime = Date.now();\n      execution.duration = execution.endTime - execution.startTime;\n      execution.result = formattedResult;\n\n      // Log success\n      this.ui.addLog('success', `${execution.toolName} completed in ${execution.duration}ms`);\n\n      // Process queue\n      this.processQueue();\n\n      return execution;\n    } catch (error) {\n      execution.status = 'failed';\n      execution.endTime = Date.now();\n      execution.error = error.message;\n\n      this.ui.addLog('error', `${execution.toolName} failed: ${error.message}`);\n\n      // Process queue\n      this.processQueue();\n\n      throw error;\n    } finally {\n      this.currentExecutions--;\n    }\n  }\n\n  /**\n   * Process execution queue\n   */\n  async processQueue() {\n    if (this.executionQueue.length > 0 && this.currentExecutions < this.maxConcurrentExecutions) {\n      const nextExecution = this.executionQueue.shift();\n      await this.executeToolDirect(nextExecution);\n    }\n  }\n\n  /**\n   * Execute multiple tools in batch\n   */\n  async executeToolsBatch(toolExecutions, options = {}) {\n    const batchId = `batch_${Date.now()}`;\n    const results = [];\n\n    this.ui.addLog('info', `Starting batch execution: ${toolExecutions.length} tools`);\n\n    try {\n      if (options.parallel) {\n        // Execute in parallel\n        const promises = toolExecutions.map(({ toolName, parameters, toolOptions }) =>\n          this.executeTool(toolName, parameters, toolOptions),\n        );\n\n        const settled = await Promise.allSettled(promises);\n\n        settled.forEach((result, index) => {\n          if (result.status === 'fulfilled') {\n            results.push({ success: true, execution: result.value });\n          } else {\n            results.push({\n              success: false,\n              error: result.reason.message,\n              toolName: toolExecutions[index].toolName,\n            });\n          }\n        });\n      } else {\n        // Execute sequentially\n        for (let i = 0; i < toolExecutions.length; i++) {\n          const { toolName, parameters, toolOptions } = toolExecutions[i];\n\n          try {\n            const execution = await this.executeTool(toolName, parameters, toolOptions);\n            results.push({ success: true, execution });\n\n            // Report progress\n            if (options.progressCallback) {\n              options.progressCallback({\n                completed: i + 1,\n                total: toolExecutions.length,\n                progress: ((i + 1) / toolExecutions.length) * 100,\n                currentTool: toolName,\n              });\n            }\n          } catch (error) {\n            results.push({\n              success: false,\n              error: error.message,\n              toolName,\n            });\n\n            // Stop on first error if configured\n            if (options.stopOnError) {\n              break;\n            }\n          }\n        }\n      }\n\n      const successful = results.filter((r) => r.success).length;\n      this.ui.addLog(\n        'success',\n        `Batch ${batchId} completed: ${successful}/${results.length} successful`,\n      );\n\n      return {\n        batchId,\n        results,\n        summary: {\n          total: results.length,\n          successful,\n          failed: results.length - successful,\n        },\n      };\n    } catch (error) {\n      this.ui.addLog('error', `Batch ${batchId} failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute workflow (sequence of dependent tools)\n   */\n  async executeWorkflow(workflow, options = {}) {\n    const workflowId = `workflow_${Date.now()}`;\n    const context = {}; // Shared context between steps\n    const results = [];\n\n    this.ui.addLog('info', `Starting workflow: ${workflow.name || workflowId}`);\n\n    try {\n      for (let i = 0; i < workflow.steps.length; i++) {\n        const step = workflow.steps[i];\n\n        // Resolve parameters using context\n        const resolvedParameters = this.resolveParameters(step.parameters, context);\n\n        // Execute step\n        const execution = await this.executeTool(step.toolName, resolvedParameters, step.options);\n\n        // Update context with results\n        if (step.outputVariable && execution.result) {\n          context[step.outputVariable] = execution.result;\n        }\n\n        results.push(execution);\n\n        // Check for step failure\n        if (execution.status === 'failed' && step.required !== false) {\n          throw new Error(`Required step ${step.toolName} failed: ${execution.error}`);\n        }\n\n        // Report progress\n        if (options.progressCallback) {\n          options.progressCallback({\n            completed: i + 1,\n            total: workflow.steps.length,\n            progress: ((i + 1) / workflow.steps.length) * 100,\n            currentStep: step.toolName,\n          });\n        }\n      }\n\n      this.ui.addLog('success', `Workflow ${workflowId} completed successfully`);\n\n      return {\n        workflowId,\n        results,\n        context,\n        summary: {\n          totalSteps: workflow.steps.length,\n          completedSteps: results.filter((r) => r.status === 'completed').length,\n          failedSteps: results.filter((r) => r.status === 'failed').length,\n        },\n      };\n    } catch (error) {\n      this.ui.addLog('error', `Workflow ${workflowId} failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Resolve parameters using context variables\n   */\n  resolveParameters(parameters, context) {\n    if (typeof parameters !== 'object' || parameters === null) {\n      return parameters;\n    }\n\n    const resolved = {};\n\n    for (const [key, value] of Object.entries(parameters)) {\n      if (typeof value === 'string' && value.startsWith('$')) {\n        // Context variable reference\n        const varName = value.substring(1);\n        resolved[key] = context[varName] || value;\n      } else if (typeof value === 'object') {\n        resolved[key] = this.resolveParameters(value, context);\n      } else {\n        resolved[key] = value;\n      }\n    }\n\n    return resolved;\n  }\n\n  /**\n   * Format tool result for display\n   */\n  formatResult(toolName, result) {\n    const formatter = this.resultFormatters.get(toolName) || this.resultFormatters.get('default');\n    return formatter(result);\n  }\n\n  /**\n   * Check if tool is available\n   */\n  isToolAvailable(toolName) {\n    const allTools = Object.values(this.mcpLayer.toolCategories).flat();\n    return allTools.includes(toolName);\n  }\n\n  /**\n   * Get tools by category\n   */\n  getToolsByCategory(category) {\n    return this.mcpLayer.getToolsByCategory(category);\n  }\n\n  /**\n   * Get all available categories\n   */\n  getCategories() {\n    return this.mcpLayer.getToolCategories();\n  }\n\n  /**\n   * Get execution status\n   */\n  getExecutionStatus() {\n    return {\n      currentExecutions: this.currentExecutions,\n      queuedExecutions: this.executionQueue.length,\n      maxConcurrent: this.maxConcurrentExecutions,\n    };\n  }\n\n  /**\n   * Cancel execution\n   */\n  async cancelExecution(executionId) {\n    // Try to remove from queue first\n    const queueIndex = this.executionQueue.findIndex((e) => e.id === executionId);\n    if (queueIndex !== -1) {\n      this.executionQueue.splice(queueIndex, 1);\n      this.ui.addLog('info', `Cancelled queued execution ${executionId}`);\n      return true;\n    }\n\n    // Cancel running execution via MCP layer\n    return await this.mcpLayer.cancelExecution(executionId);\n  }\n\n  /**\n   * Get predefined workflows\n   */\n  getPredefinedWorkflows() {\n    return {\n      neural_training_pipeline: {\n        name: 'Neural Training Pipeline',\n        description: 'Complete neural network training with evaluation',\n        steps: [\n          {\n            toolName: 'neural_train',\n            parameters: {\n              pattern_type: 'coordination',\n              epochs: 100,\n              training_data: 'recent_swarm_data',\n            },\n            outputVariable: 'trainedModel',\n            required: true,\n          },\n          {\n            toolName: 'neural_predict',\n            parameters: {\n              modelId: '$trainedModel.modelId',\n              input: 'test_coordination_scenario',\n            },\n            outputVariable: 'prediction',\n            required: true,\n          },\n          {\n            toolName: 'neural_explain',\n            parameters: {\n              modelId: '$trainedModel.modelId',\n              prediction: '$prediction',\n            },\n            required: false,\n          },\n        ],\n      },\n\n      swarm_deployment: {\n        name: 'Swarm Deployment',\n        description: 'Initialize and deploy a complete swarm',\n        steps: [\n          {\n            toolName: 'swarm_init',\n            parameters: {\n              topology: 'hierarchical',\n              maxAgents: 8,\n              strategy: 'adaptive',\n            },\n            outputVariable: 'swarm',\n            required: true,\n          },\n          {\n            toolName: 'agent_spawn',\n            parameters: {\n              type: 'coordinator',\n              swarmId: '$swarm.swarmId',\n            },\n            required: true,\n          },\n          {\n            toolName: 'agent_spawn',\n            parameters: {\n              type: 'researcher',\n              swarmId: '$swarm.swarmId',\n            },\n            required: true,\n          },\n          {\n            toolName: 'swarm_monitor',\n            parameters: {\n              swarmId: '$swarm.swarmId',\n              interval: 5000,\n            },\n            required: false,\n          },\n        ],\n      },\n\n      performance_analysis: {\n        name: 'Performance Analysis',\n        description: 'Comprehensive system performance analysis',\n        steps: [\n          {\n            toolName: 'performance_report',\n            parameters: {\n              timeframe: '24h',\n              format: 'detailed',\n            },\n            outputVariable: 'report',\n            required: true,\n          },\n          {\n            toolName: 'bottleneck_analyze',\n            parameters: {\n              component: 'system',\n            },\n            outputVariable: 'bottlenecks',\n            required: true,\n          },\n          {\n            toolName: 'trend_analysis',\n            parameters: {\n              metric: 'performance',\n              period: '7d',\n            },\n            required: false,\n          },\n        ],\n      },\n    };\n  }\n\n  /**\n   * Execute predefined workflow\n   */\n  async executePredefinedWorkflow(workflowName, options = {}) {\n    const workflows = this.getPredefinedWorkflows();\n    const workflow = workflows[workflowName];\n\n    if (!workflow) {\n      throw new Error(`Unknown workflow: ${workflowName}`);\n    }\n\n    return await this.executeWorkflow(workflow, options);\n  }\n\n  /**\n   * Get comprehensive status\n   */\n  getStatus() {\n    return {\n      ...this.getExecutionStatus(),\n      mcpStatus: this.mcpLayer.getStatus(),\n      availableTools: Object.values(this.mcpLayer.toolCategories).flat().length,\n      availableWorkflows: Object.keys(this.getPredefinedWorkflows()).length,\n    };\n  }\n}\n\nexport default ToolExecutionFramework;\n"],"names":["MCPIntegrationLayer","ToolExecutionFramework","ui","mcpLayer","executionQueue","maxConcurrentExecutions","currentExecutions","resultFormatters","Map","initializeFormatters","set","result","title","summary","topology","maxAgents","details","swarmId","strategy","status","success","pattern_type","accuracy","toFixed","modelId","epochs","training_time","metrics","time","timeframe","success_rate","tasks_executed","avg_execution_time","agents_spawned","memory_efficiency","charts","successRate","memoryEfficiency","action","key","namespace","tool","message","Object","entries","map","value","JSON","stringify","executeTool","toolName","parameters","options","isToolAvailable","Error","execution","id","Date","now","Math","random","toString","substr","startTime","progress","push","addLog","length","executeToolDirect","error","formattedResult","formatResult","endTime","duration","processQueue","nextExecution","shift","executeToolsBatch","toolExecutions","batchId","results","parallel","promises","toolOptions","settled","Promise","allSettled","forEach","index","reason","i","progressCallback","completed","total","currentTool","stopOnError","successful","filter","r","failed","executeWorkflow","workflow","workflowId","context","name","steps","step","resolvedParameters","resolveParameters","outputVariable","required","currentStep","totalSteps","completedSteps","failedSteps","resolved","startsWith","varName","substring","formatter","get","allTools","values","toolCategories","flat","includes","getToolsByCategory","category","getCategories","getToolCategories","getExecutionStatus","queuedExecutions","maxConcurrent","cancelExecution","executionId","queueIndex","findIndex","e","splice","getPredefinedWorkflows","neural_training_pipeline","description","training_data","input","prediction","swarm_deployment","type","interval","performance_analysis","format","component","metric","period","executePredefinedWorkflow","workflowName","workflows","getStatus","mcpStatus","availableTools","availableWorkflows","keys"],"mappings":"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"}