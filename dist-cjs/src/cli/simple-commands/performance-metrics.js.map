{"version":3,"sources":["../../../../src/cli/simple-commands/performance-metrics.js"],"sourcesContent":["/**\n * Real Performance Metrics Collection System\n * Tracks actual system performance, agent activity, and resource usage\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { performance } from 'perf_hooks';\n\n// Metrics storage path\nconst METRICS_DIR = path.join(process.cwd(), '.claude-flow', 'metrics');\nconst PERFORMANCE_FILE = path.join(METRICS_DIR, 'performance.json');\nconst AGENT_METRICS_FILE = path.join(METRICS_DIR, 'agent-metrics.json');\nconst TASK_METRICS_FILE = path.join(METRICS_DIR, 'task-metrics.json');\nconst SYSTEM_METRICS_FILE = path.join(METRICS_DIR, 'system-metrics.json');\n\n// In-memory metrics cache\nlet metricsCache = {\n  tasks: [],\n  agents: {},\n  system: [],\n  performance: {\n    startTime: Date.now(),\n    totalTasks: 0,\n    successfulTasks: 0,\n    failedTasks: 0,\n    totalAgents: 0,\n    activeAgents: 0,\n    neuralEvents: 0\n  }\n};\n\n// Store interval ID for cleanup\nlet systemMonitoringInterval = null;\n\n// Initialize metrics system\nexport async function initializeMetrics(startMonitoring = true) {\n  try {\n    await fs.mkdir(METRICS_DIR, { recursive: true });\n    \n    // Load existing metrics if available\n    await loadMetricsFromDisk();\n    \n    // Start system monitoring only if requested\n    if (startMonitoring) {\n      startSystemMonitoring();\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Failed to initialize metrics:', err);\n    return false;\n  }\n}\n\n// Load metrics from disk\nasync function loadMetricsFromDisk() {\n  try {\n    // Load performance metrics\n    if (await fileExists(PERFORMANCE_FILE)) {\n      const data = await fs.readFile(PERFORMANCE_FILE, 'utf8');\n      const saved = JSON.parse(data);\n      metricsCache.performance = { ...metricsCache.performance, ...saved };\n    }\n    \n    // Load task metrics\n    if (await fileExists(TASK_METRICS_FILE)) {\n      const data = await fs.readFile(TASK_METRICS_FILE, 'utf8');\n      metricsCache.tasks = JSON.parse(data);\n    }\n    \n    // Load agent metrics\n    if (await fileExists(AGENT_METRICS_FILE)) {\n      const data = await fs.readFile(AGENT_METRICS_FILE, 'utf8');\n      metricsCache.agents = JSON.parse(data);\n    }\n  } catch (err) {\n    // Ignore errors, start fresh\n  }\n}\n\n// Save metrics to disk\nasync function saveMetricsToDisk() {\n  try {\n    await fs.writeFile(PERFORMANCE_FILE, JSON.stringify(metricsCache.performance, null, 2));\n    await fs.writeFile(TASK_METRICS_FILE, JSON.stringify(metricsCache.tasks, null, 2));\n    await fs.writeFile(AGENT_METRICS_FILE, JSON.stringify(metricsCache.agents, null, 2));\n  } catch (err) {\n    // Ignore save errors\n  }\n}\n\n// Track task execution\nexport async function trackTaskExecution(taskId, taskType, success, duration, metadata = {}) {\n  const task = {\n    id: taskId,\n    type: taskType,\n    success,\n    duration,\n    timestamp: Date.now(),\n    metadata\n  };\n  \n  metricsCache.tasks.push(task);\n  metricsCache.performance.totalTasks++;\n  \n  if (success) {\n    metricsCache.performance.successfulTasks++;\n  } else {\n    metricsCache.performance.failedTasks++;\n  }\n  \n  // Keep only last 1000 tasks\n  if (metricsCache.tasks.length > 1000) {\n    metricsCache.tasks = metricsCache.tasks.slice(-1000);\n  }\n  \n  await saveMetricsToDisk();\n}\n\n// Track agent activity\nexport async function trackAgentActivity(agentId, agentType, action, duration, success = true) {\n  if (!metricsCache.agents[agentType]) {\n    metricsCache.agents[agentType] = {\n      total: 0,\n      successful: 0,\n      failed: 0,\n      totalDuration: 0,\n      actions: []\n    };\n  }\n  \n  const agent = metricsCache.agents[agentType];\n  agent.total++;\n  agent.totalDuration += duration;\n  \n  if (success) {\n    agent.successful++;\n  } else {\n    agent.failed++;\n  }\n  \n  agent.actions.push({\n    id: agentId,\n    action,\n    duration,\n    success,\n    timestamp: Date.now()\n  });\n  \n  // Keep only last 100 actions per agent type\n  if (agent.actions.length > 100) {\n    agent.actions = agent.actions.slice(-100);\n  }\n  \n  metricsCache.performance.totalAgents = Object.keys(metricsCache.agents).length;\n  \n  await saveMetricsToDisk();\n}\n\n// Track neural events\nexport async function trackNeuralEvent(eventType, metadata = {}) {\n  metricsCache.performance.neuralEvents++;\n  \n  await saveMetricsToDisk();\n}\n\n// Get performance report data\nexport async function getPerformanceReport(timeframe = '24h') {\n  const now = Date.now();\n  const timeframeMs = parseTimeframe(timeframe);\n  const cutoff = now - timeframeMs;\n  \n  // Filter tasks within timeframe\n  const recentTasks = metricsCache.tasks.filter(task => task.timestamp >= cutoff);\n  \n  // Calculate metrics\n  const totalTasks = recentTasks.length;\n  const successfulTasks = recentTasks.filter(t => t.success).length;\n  const successRate = totalTasks > 0 ? (successfulTasks / totalTasks) * 100 : 0;\n  const avgDuration = totalTasks > 0 \n    ? recentTasks.reduce((sum, t) => sum + t.duration, 0) / totalTasks \n    : 0;\n  \n  // Agent metrics\n  const agentMetrics = {};\n  Object.entries(metricsCache.agents).forEach(([type, data]) => {\n    const recentActions = data.actions.filter(a => a.timestamp >= cutoff);\n    if (recentActions.length > 0) {\n      const successCount = recentActions.filter(a => a.success).length;\n      const avgDur = recentActions.reduce((sum, a) => sum + a.duration, 0) / recentActions.length;\n      \n      agentMetrics[type] = {\n        total: recentActions.length,\n        successRate: (successCount / recentActions.length) * 100,\n        avgDuration: avgDur\n      };\n    }\n  });\n  \n  // System metrics\n  const systemMetrics = await getSystemMetrics();\n  \n  // Calculate trends (compare to previous period)\n  const prevCutoff = cutoff - timeframeMs;\n  const prevTasks = metricsCache.tasks.filter(t => t.timestamp >= prevCutoff && t.timestamp < cutoff);\n  const prevSuccessRate = prevTasks.length > 0 \n    ? (prevTasks.filter(t => t.success).length / prevTasks.length) * 100 \n    : 0;\n  const prevAvgDuration = prevTasks.length > 0\n    ? prevTasks.reduce((sum, t) => sum + t.duration, 0) / prevTasks.length\n    : 0;\n  \n  const trends = {\n    successRateChange: successRate - prevSuccessRate,\n    durationChange: avgDuration - prevAvgDuration,\n    taskVolumeChange: totalTasks - prevTasks.length\n  };\n  \n  return {\n    timeframe,\n    summary: {\n      totalTasks,\n      successRate,\n      avgDuration: avgDuration / 1000, // Convert to seconds\n      agentsSpawned: Object.values(agentMetrics).reduce((sum, m) => sum + m.total, 0),\n      memoryEfficiency: systemMetrics.memoryEfficiency,\n      neuralEvents: metricsCache.performance.neuralEvents\n    },\n    agentMetrics,\n    systemMetrics,\n    trends,\n    tasks: recentTasks.slice(-20) // Last 20 tasks\n  };\n}\n\n// Get bottleneck analysis data\nexport async function getBottleneckAnalysis(scope = 'system', target = 'all') {\n  const bottlenecks = [];\n  const recommendations = [];\n  \n  // Analyze task performance\n  if (scope === 'system' || scope === 'task') {\n    const slowTasks = metricsCache.tasks\n      .filter(t => t.duration > 10000) // Tasks taking more than 10s\n      .sort((a, b) => b.duration - a.duration)\n      .slice(0, 5);\n    \n    if (slowTasks.length > 0) {\n      bottlenecks.push({\n        severity: 'warning',\n        component: 'Task execution',\n        metric: `${slowTasks.length} slow tasks (>10s)`,\n        details: slowTasks.map(t => ({\n          id: t.id,\n          type: t.type,\n          duration: t.duration / 1000\n        }))\n      });\n      recommendations.push('Optimize slow task types or break them into smaller subtasks');\n    }\n  }\n  \n  // Analyze agent performance\n  if (scope === 'system' || scope === 'agent') {\n    Object.entries(metricsCache.agents).forEach(([type, data]) => {\n      const successRate = data.total > 0 ? (data.successful / data.total) * 100 : 100;\n      const avgDuration = data.total > 0 ? data.totalDuration / data.total : 0;\n      \n      if (successRate < 80) {\n        bottlenecks.push({\n          severity: 'critical',\n          component: `${type} agents`,\n          metric: `${successRate.toFixed(1)}% success rate`,\n          target: type\n        });\n        recommendations.push(`Investigate ${type} agent failures and improve error handling`);\n      }\n      \n      if (avgDuration > 15000) {\n        bottlenecks.push({\n          severity: 'warning',\n          component: `${type} agents`,\n          metric: `${(avgDuration / 1000).toFixed(1)}s avg duration`,\n          target: type\n        });\n        recommendations.push(`Optimize ${type} agent performance or increase parallelization`);\n      }\n    });\n  }\n  \n  // Analyze system resources\n  if (scope === 'system' || scope === 'memory') {\n    const systemMetrics = await getSystemMetrics();\n    \n    if (systemMetrics.memoryUsagePercent > 80) {\n      bottlenecks.push({\n        severity: 'critical',\n        component: 'Memory usage',\n        metric: `${systemMetrics.memoryUsagePercent}% utilization`\n      });\n      recommendations.push('Implement memory optimization or increase system resources');\n    }\n    \n    if (systemMetrics.cpuLoad > 0.8) {\n      bottlenecks.push({\n        severity: 'warning',\n        component: 'CPU usage',\n        metric: `${(systemMetrics.cpuLoad * 100).toFixed(1)}% load`\n      });\n      recommendations.push('Consider horizontal scaling or CPU optimization');\n    }\n  }\n  \n  // Add positive indicators\n  if (bottlenecks.length === 0) {\n    bottlenecks.push({\n      severity: 'good',\n      component: 'Overall system',\n      metric: 'No bottlenecks detected'\n    });\n  }\n  \n  return {\n    scope,\n    target,\n    bottlenecks,\n    recommendations,\n    analysisDuration: performance.now(),\n    confidenceScore: 0.85,\n    issuesDetected: bottlenecks.filter(b => b.severity !== 'good').length\n  };\n}\n\n// System monitoring\nfunction startSystemMonitoring() {\n  // Clear any existing interval\n  if (systemMonitoringInterval) {\n    clearInterval(systemMonitoringInterval);\n  }\n  \n  // Collect system metrics every 30 seconds\n  systemMonitoringInterval = setInterval(async () => {\n    const metrics = await getSystemMetrics();\n    \n    // Store system metrics\n    if (!metricsCache.system) {\n      metricsCache.system = [];\n    }\n    \n    metricsCache.system.push({\n      timestamp: Date.now(),\n      ...metrics\n    });\n    \n    // Keep only last 24 hours of system metrics\n    const dayAgo = Date.now() - (24 * 60 * 60 * 1000);\n    metricsCache.system = metricsCache.system.filter(m => m.timestamp > dayAgo);\n    \n    // Save to disk\n    try {\n      await fs.writeFile(SYSTEM_METRICS_FILE, JSON.stringify(metricsCache.system, null, 2));\n    } catch (err) {\n      // Ignore save errors\n    }\n  }, 30000);\n  \n  // Allow process to exit even with active interval\n  systemMonitoringInterval.unref();\n}\n\n// Stop system monitoring\nexport function stopSystemMonitoring() {\n  if (systemMonitoringInterval) {\n    clearInterval(systemMonitoringInterval);\n    systemMonitoringInterval = null;\n  }\n}\n\n// Get current system metrics\nasync function getSystemMetrics() {\n  const totalMem = os.totalmem();\n  const freeMem = os.freemem();\n  const usedMem = totalMem - freeMem;\n  const memoryUsagePercent = (usedMem / totalMem) * 100;\n  \n  const cpuLoad = os.loadavg()[0] / os.cpus().length; // 1-minute load average\n  \n  return {\n    memoryTotal: totalMem,\n    memoryUsed: usedMem,\n    memoryFree: freeMem,\n    memoryUsagePercent,\n    memoryEfficiency: 100 - memoryUsagePercent,\n    cpuCount: os.cpus().length,\n    cpuLoad,\n    platform: os.platform(),\n    uptime: os.uptime()\n  };\n}\n\n// Parse timeframe string to milliseconds\nfunction parseTimeframe(timeframe) {\n  const units = {\n    'h': 60 * 60 * 1000,\n    'd': 24 * 60 * 60 * 1000\n  };\n  \n  const match = timeframe.match(/^(\\d+)([hd])$/);\n  if (match) {\n    const value = parseInt(match[1]);\n    const unit = match[2];\n    return value * units[unit];\n  }\n  \n  // Default to 24 hours\n  return 24 * 60 * 60 * 1000;\n}\n\n// Check if file exists\nasync function fileExists(filepath) {\n  try {\n    await fs.access(filepath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// Cleanup function for graceful shutdown\nexport function cleanup() {\n  stopSystemMonitoring();\n}\n\n// Export metrics for reporting\nexport async function exportMetrics(format = 'json') {\n  const timestamp = Date.now();\n  const reportsDir = path.join(process.cwd(), 'analysis-reports');\n  \n  await fs.mkdir(reportsDir, { recursive: true });\n  \n  if (format === 'json') {\n    const reportPath = path.join(reportsDir, `performance-${timestamp}.json`);\n    const data = {\n      timestamp: new Date().toISOString(),\n      performance: metricsCache.performance,\n      tasks: metricsCache.tasks.slice(-100), // Last 100 tasks\n      agents: metricsCache.agents,\n      system: metricsCache.system.slice(-50) // Last 50 system snapshots\n    };\n    \n    await fs.writeFile(reportPath, JSON.stringify(data, null, 2));\n    return reportPath;\n  }\n  \n  if (format === 'csv') {\n    const reportPath = path.join(reportsDir, `performance-${timestamp}.csv`);\n    let csv = 'Timestamp,Type,Metric,Value\\n';\n    \n    // Add performance metrics\n    Object.entries(metricsCache.performance).forEach(([key, value]) => {\n      csv += `${new Date().toISOString()},performance,${key},${value}\\n`;\n    });\n    \n    // Add agent metrics\n    Object.entries(metricsCache.agents).forEach(([type, data]) => {\n      csv += `${new Date().toISOString()},agent,${type}_total,${data.total}\\n`;\n      csv += `${new Date().toISOString()},agent,${type}_success_rate,${data.total > 0 ? (data.successful / data.total) * 100 : 0}\\n`;\n      csv += `${new Date().toISOString()},agent,${type}_avg_duration,${data.total > 0 ? data.totalDuration / data.total : 0}\\n`;\n    });\n    \n    await fs.writeFile(reportPath, csv);\n    return reportPath;\n  }\n  \n  if (format === 'html') {\n    const reportPath = path.join(reportsDir, `performance-${timestamp}.html`);\n    const report = await getPerformanceReport('24h');\n    \n    const html = generateHTMLReport(report);\n    await fs.writeFile(reportPath, html);\n    return reportPath;\n  }\n  \n  throw new Error(`Unsupported format: ${format}`);\n}\n\n// Generate HTML report\nfunction generateHTMLReport(report) {\n  return `<!DOCTYPE html>\n<html>\n<head>\n  <title>Claude Flow Performance Report - ${new Date().toISOString()}</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    h1, h2 { color: #333; }\n    .metric { display: inline-block; margin: 10px 20px 10px 0; }\n    .metric-label { color: #666; font-size: 14px; }\n    .metric-value { font-size: 24px; font-weight: bold; color: #2196F3; }\n    .trend { font-size: 14px; margin-left: 10px; }\n    .trend.positive { color: #4CAF50; }\n    .trend.negative { color: #F44336; }\n    table { width: 100%; border-collapse: collapse; margin: 20px 0; }\n    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }\n    th { background: #f5f5f5; font-weight: bold; }\n    .chart { margin: 20px 0; height: 300px; background: #fafafa; border: 1px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #999; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>Claude Flow Performance Report</h1>\n    <p>Generated: ${new Date().toISOString()} | Timeframe: ${report.timeframe}</p>\n    \n    <h2>Summary Metrics</h2>\n    <div class=\"metrics\">\n      <div class=\"metric\">\n        <div class=\"metric-label\">Total Tasks</div>\n        <div class=\"metric-value\">${report.summary.totalTasks}</div>\n        ${report.trends.taskVolumeChange !== 0 ? `<span class=\"trend ${report.trends.taskVolumeChange > 0 ? 'positive' : 'negative'}\">${report.trends.taskVolumeChange > 0 ? '+' : ''}${report.trends.taskVolumeChange}</span>` : ''}\n      </div>\n      <div class=\"metric\">\n        <div class=\"metric-label\">Success Rate</div>\n        <div class=\"metric-value\">${report.summary.successRate.toFixed(1)}%</div>\n        ${report.trends.successRateChange !== 0 ? `<span class=\"trend ${report.trends.successRateChange > 0 ? 'positive' : 'negative'}\">${report.trends.successRateChange > 0 ? '+' : ''}${report.trends.successRateChange.toFixed(1)}%</span>` : ''}\n      </div>\n      <div class=\"metric\">\n        <div class=\"metric-label\">Avg Duration</div>\n        <div class=\"metric-value\">${report.summary.avgDuration.toFixed(1)}s</div>\n        ${report.trends.durationChange !== 0 ? `<span class=\"trend ${report.trends.durationChange < 0 ? 'positive' : 'negative'}\">${report.trends.durationChange > 0 ? '+' : ''}${(report.trends.durationChange / 1000).toFixed(1)}s</span>` : ''}\n      </div>\n      <div class=\"metric\">\n        <div class=\"metric-label\">Memory Efficiency</div>\n        <div class=\"metric-value\">${report.summary.memoryEfficiency.toFixed(0)}%</div>\n      </div>\n    </div>\n    \n    <h2>Agent Performance</h2>\n    <table>\n      <thead>\n        <tr>\n          <th>Agent Type</th>\n          <th>Total Actions</th>\n          <th>Success Rate</th>\n          <th>Avg Duration</th>\n        </tr>\n      </thead>\n      <tbody>\n        ${Object.entries(report.agentMetrics).map(([type, metrics]) => `\n          <tr>\n            <td>${type}</td>\n            <td>${metrics.total}</td>\n            <td>${metrics.successRate.toFixed(1)}%</td>\n            <td>${(metrics.avgDuration / 1000).toFixed(1)}s</td>\n          </tr>\n        `).join('')}\n      </tbody>\n    </table>\n    \n    <h2>Performance Trends</h2>\n    <div class=\"chart\">\n      <p>Interactive charts would be displayed here</p>\n    </div>\n    \n    <h2>Recent Tasks</h2>\n    <table>\n      <thead>\n        <tr>\n          <th>Task ID</th>\n          <th>Type</th>\n          <th>Status</th>\n          <th>Duration</th>\n          <th>Timestamp</th>\n        </tr>\n      </thead>\n      <tbody>\n        ${report.tasks.slice(-10).reverse().map(task => `\n          <tr>\n            <td>${task.id}</td>\n            <td>${task.type}</td>\n            <td>${task.success ? '✅ Success' : '❌ Failed'}</td>\n            <td>${(task.duration / 1000).toFixed(2)}s</td>\n            <td>${new Date(task.timestamp).toLocaleString()}</td>\n          </tr>\n        `).join('')}\n      </tbody>\n    </table>\n  </div>\n</body>\n</html>`;\n}"],"names":["promises","fs","path","os","performance","METRICS_DIR","join","process","cwd","PERFORMANCE_FILE","AGENT_METRICS_FILE","TASK_METRICS_FILE","SYSTEM_METRICS_FILE","metricsCache","tasks","agents","system","startTime","Date","now","totalTasks","successfulTasks","failedTasks","totalAgents","activeAgents","neuralEvents","systemMonitoringInterval","initializeMetrics","startMonitoring","mkdir","recursive","loadMetricsFromDisk","startSystemMonitoring","err","console","error","fileExists","data","readFile","saved","JSON","parse","saveMetricsToDisk","writeFile","stringify","trackTaskExecution","taskId","taskType","success","duration","metadata","task","id","type","timestamp","push","length","slice","trackAgentActivity","agentId","agentType","action","total","successful","failed","totalDuration","actions","agent","Object","keys","trackNeuralEvent","eventType","getPerformanceReport","timeframe","timeframeMs","parseTimeframe","cutoff","recentTasks","filter","t","successRate","avgDuration","reduce","sum","agentMetrics","entries","forEach","recentActions","a","successCount","avgDur","systemMetrics","getSystemMetrics","prevCutoff","prevTasks","prevSuccessRate","prevAvgDuration","trends","successRateChange","durationChange","taskVolumeChange","summary","agentsSpawned","values","m","memoryEfficiency","getBottleneckAnalysis","scope","target","bottlenecks","recommendations","slowTasks","sort","b","severity","component","metric","details","map","toFixed","memoryUsagePercent","cpuLoad","analysisDuration","confidenceScore","issuesDetected","clearInterval","setInterval","metrics","dayAgo","unref","stopSystemMonitoring","totalMem","totalmem","freeMem","freemem","usedMem","loadavg","cpus","memoryTotal","memoryUsed","memoryFree","cpuCount","platform","uptime","units","match","value","parseInt","unit","filepath","access","cleanup","exportMetrics","format","reportsDir","reportPath","toISOString","csv","key","report","html","generateHTMLReport","Error","reverse","toLocaleString"],"mappings":"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"}