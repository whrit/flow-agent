{"version":3,"sources":["../../../../src/cli/simple-commands/claude-telemetry.js"],"sourcesContent":["#!/usr/bin/env node\n\n/**\n * Claude Code Telemetry Integration\n * Captures real token usage from Claude Code CLI\n */\n\nimport { spawn } from 'child_process';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport os from 'os';\nimport readline from 'readline';\nimport { trackTokens } from './token-tracker.js';\n\n// Claude session data locations (platform-specific)\nconst CLAUDE_DATA_PATHS = [\n  path.join(os.homedir(), '.claude', 'sessions'),\n  path.join(os.homedir(), '.config', 'claude', 'sessions'),\n  path.join(os.homedir(), 'Library', 'Application Support', 'Claude', 'sessions'),\n];\n\n/**\n * Parse Claude session JSONL files for token usage\n */\nasync function parseClaudeSessionData(sessionId) {\n  for (const dataPath of CLAUDE_DATA_PATHS) {\n    try {\n      const sessionFile = path.join(dataPath, `${sessionId}.jsonl`);\n      const exists = await fs.access(sessionFile).then(() => true).catch(() => false);\n      \n      if (!exists) continue;\n      \n      const content = await fs.readFile(sessionFile, 'utf-8');\n      const lines = content.trim().split('\\n');\n      \n      let totalInput = 0;\n      let totalOutput = 0;\n      \n      for (const line of lines) {\n        try {\n          const data = JSON.parse(line);\n          if (data.usage) {\n            totalInput += data.usage.input_tokens || 0;\n            totalOutput += data.usage.output_tokens || 0;\n          }\n        } catch (e) {\n          // Skip invalid JSON lines\n        }\n      }\n      \n      return { inputTokens: totalInput, outputTokens: totalOutput };\n    } catch (error) {\n      // Continue to next path\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract token usage from Claude CLI output\n */\nfunction parseClaudeOutput(output) {\n  const tokenRegex = /(\\d+)\\s+tokens?\\s+\\((input|output|total)\\)/gi;\n  const costRegex = /\\$(\\d+\\.\\d+)/g;\n  \n  const tokens = { input: 0, output: 0, total: 0 };\n  const costs = [];\n  \n  let match;\n  while ((match = tokenRegex.exec(output)) !== null) {\n    const count = parseInt(match[1]);\n    const type = match[2].toLowerCase();\n    tokens[type] = count;\n  }\n  \n  while ((match = costRegex.exec(output)) !== null) {\n    costs.push(parseFloat(match[1]));\n  }\n  \n  return { tokens, costs };\n}\n\n/**\n * Wrap Claude CLI execution with telemetry\n */\nexport async function runClaudeWithTelemetry(args, options = {}) {\n  const sessionId = options.sessionId || `claude-${Date.now()}`;\n  const agentType = options.agentType || 'claude-cli';\n  const command = args.join(' ');\n  \n  // Enable telemetry environment variables\n  const env = {\n    ...process.env,\n    CLAUDE_CODE_ENABLE_TELEMETRY: '1',\n    OTEL_METRICS_EXPORTER: process.env.OTEL_METRICS_EXPORTER || 'console',\n    OTEL_LOGS_EXPORTER: process.env.OTEL_LOGS_EXPORTER || 'console',\n  };\n  \n  return new Promise((resolve, reject) => {\n    const claude = spawn('claude', args, {\n      env,\n      stdio: ['inherit', 'pipe', 'pipe']\n    });\n    \n    let stdout = '';\n    let stderr = '';\n    \n    // Create readline interface for real-time output\n    const rlOut = readline.createInterface({\n      input: claude.stdout,\n      terminal: false\n    });\n    \n    const rlErr = readline.createInterface({\n      input: claude.stderr,\n      terminal: false\n    });\n    \n    rlOut.on('line', (line) => {\n      console.log(line);\n      stdout += line + '\\n';\n      \n      // Look for token usage in real-time\n      const usage = parseClaudeOutput(line);\n      if (usage.tokens.input > 0 || usage.tokens.output > 0) {\n        trackTokens({\n          sessionId,\n          agentType,\n          command,\n          inputTokens: usage.tokens.input,\n          outputTokens: usage.tokens.output,\n          metadata: { costs: usage.costs }\n        }).catch(console.error);\n      }\n    });\n    \n    rlErr.on('line', (line) => {\n      console.error(line);\n      stderr += line + '\\n';\n    });\n    \n    claude.on('exit', async (code) => {\n      // Try to parse session data after completion\n      const sessionData = await parseClaudeSessionData(sessionId);\n      if (sessionData) {\n        await trackTokens({\n          sessionId,\n          agentType,\n          command,\n          inputTokens: sessionData.inputTokens,\n          outputTokens: sessionData.outputTokens,\n          metadata: { source: 'session_file' }\n        });\n      }\n      \n      // Also parse full output for any missed tokens\n      const fullUsage = parseClaudeOutput(stdout + stderr);\n      if (fullUsage.tokens.input > 0 || fullUsage.tokens.output > 0) {\n        await trackTokens({\n          sessionId,\n          agentType,\n          command,\n          inputTokens: fullUsage.tokens.input,\n          outputTokens: fullUsage.tokens.output,\n          metadata: { source: 'output_parse', costs: fullUsage.costs }\n        });\n      }\n      \n      resolve({ code, stdout, stderr });\n    });\n    \n    claude.on('error', reject);\n  });\n}\n\n/**\n * Monitor Claude session for token usage\n */\nexport async function monitorClaudeSession(sessionId, interval = 5000) {\n  console.log(`ðŸ“Š Monitoring Claude session: ${sessionId}`);\n  console.log(`   Checking every ${interval / 1000} seconds for token updates...\\n`);\n  \n  let lastTokens = { input: 0, output: 0 };\n  \n  const monitor = setInterval(async () => {\n    const data = await parseClaudeSessionData(sessionId);\n    \n    if (data) {\n      const inputDiff = data.inputTokens - lastTokens.input;\n      const outputDiff = data.outputTokens - lastTokens.output;\n      \n      if (inputDiff > 0 || outputDiff > 0) {\n        console.log(`ðŸ”„ Token Update Detected:`);\n        console.log(`   Input:  +${inputDiff} (Total: ${data.inputTokens})`);\n        console.log(`   Output: +${outputDiff} (Total: ${data.outputTokens})`);\n        \n        await trackTokens({\n          sessionId,\n          agentType: 'claude-monitor',\n          command: 'session_monitor',\n          inputTokens: inputDiff,\n          outputTokens: outputDiff,\n          metadata: { \n            totalInput: data.inputTokens,\n            totalOutput: data.outputTokens \n          }\n        });\n        \n        lastTokens = data;\n      }\n    }\n  }, interval);\n  \n  // Return stop function\n  return () => {\n    clearInterval(monitor);\n    console.log(`\\nâœ… Stopped monitoring session: ${sessionId}`);\n  };\n}\n\n/**\n * Extract token usage from /cost command\n */\nexport async function extractCostCommand() {\n  return new Promise((resolve, reject) => {\n    const claude = spawn('claude', ['/cost'], {\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n    \n    claude.stdin.write('\\n');\n    claude.stdin.end();\n    \n    let output = '';\n    \n    claude.stdout.on('data', (data) => {\n      output += data.toString();\n    });\n    \n    claude.stderr.on('data', (data) => {\n      output += data.toString();\n    });\n    \n    claude.on('exit', () => {\n      const usage = parseClaudeOutput(output);\n      resolve(usage);\n    });\n    \n    claude.on('error', reject);\n  });\n}\n\n// CLI interface\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const command = process.argv[2];\n  \n  switch (command) {\n    case 'wrap':\n      // Wrap Claude command with telemetry\n      const claudeArgs = process.argv.slice(3);\n      runClaudeWithTelemetry(claudeArgs)\n        .then(result => process.exit(result.code))\n        .catch(error => {\n          console.error('Error:', error);\n          process.exit(1);\n        });\n      break;\n      \n    case 'monitor':\n      // Monitor a session\n      const sessionId = process.argv[3] || 'current';\n      const stopMonitor = await monitorClaudeSession(sessionId);\n      \n      // Handle graceful shutdown\n      process.on('SIGINT', () => {\n        stopMonitor();\n        process.exit(0);\n      });\n      break;\n      \n    case 'cost':\n      // Extract current session cost\n      const costData = await extractCostCommand();\n      console.log('\\nðŸ“Š Current Session Usage:');\n      console.log(`   Input Tokens:  ${costData.tokens.input || 0}`);\n      console.log(`   Output Tokens: ${costData.tokens.output || 0}`);\n      console.log(`   Total Tokens:  ${costData.tokens.total || 0}`);\n      if (costData.costs.length > 0) {\n        console.log(`   Estimated Cost: $${costData.costs[0]}`);\n      }\n      break;\n      \n    default:\n      console.log(`\nClaude Telemetry Integration\n\nUsage:\n  claude-telemetry wrap <claude-args>    Run Claude with telemetry\n  claude-telemetry monitor [session-id]  Monitor session for tokens\n  claude-telemetry cost                  Get current session cost\n\nExamples:\n  claude-telemetry wrap chat \"Hello\"\n  claude-telemetry monitor claude-123456\n  claude-telemetry cost\n`);\n  }\n}"],"names":["spawn","fs","path","os","readline","trackTokens","CLAUDE_DATA_PATHS","join","homedir","parseClaudeSessionData","sessionId","dataPath","sessionFile","exists","access","then","catch","content","readFile","lines","trim","split","totalInput","totalOutput","line","data","JSON","parse","usage","input_tokens","output_tokens","e","inputTokens","outputTokens","error","parseClaudeOutput","output","tokenRegex","costRegex","tokens","input","total","costs","match","exec","count","parseInt","type","toLowerCase","push","parseFloat","runClaudeWithTelemetry","args","options","Date","now","agentType","command","env","process","CLAUDE_CODE_ENABLE_TELEMETRY","OTEL_METRICS_EXPORTER","OTEL_LOGS_EXPORTER","Promise","resolve","reject","claude","stdio","stdout","stderr","rlOut","createInterface","terminal","rlErr","on","console","log","metadata","code","sessionData","source","fullUsage","monitorClaudeSession","interval","lastTokens","monitor","setInterval","inputDiff","outputDiff","clearInterval","extractCostCommand","stdin","write","end","toString","url","argv","claudeArgs","slice","result","exit","stopMonitor","costData","length"],"mappings":"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"}