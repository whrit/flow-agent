{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/core.js"],"sourcesContent":["/**\n * Hive Mind Core System\n * Central orchestration and coordination logic\n */\n\nimport EventEmitter from 'events';\nimport { MCPToolWrapper } from './mcp-wrapper.js';\nimport { PerformanceOptimizer } from './performance-optimizer.js';\n\n/**\n * HiveMindCore - Main orchestration class\n */\nexport class HiveMindCore extends EventEmitter {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      objective: '',\n      name: `hive-${Date.now()}`,\n      queenType: 'strategic',\n      maxWorkers: 8,\n      consensusAlgorithm: 'majority',\n      autoScale: true,\n      encryption: false,\n      memorySize: 100, // MB\n      taskTimeout: 60, // minutes\n      ...config,\n    };\n\n    this.state = {\n      status: 'initializing',\n      swarmId: null,\n      queen: null,\n      workers: new Map(),\n      tasks: new Map(),\n      memory: new Map(),\n      decisions: new Map(),\n      metrics: {\n        tasksCreated: 0,\n        tasksCompleted: 0,\n        decisionsReached: 0,\n        memoryUsage: 0,\n      },\n    };\n\n    this.mcpWrapper = new MCPToolWrapper({\n      parallel: true,\n      timeout: this.config.taskTimeout * 60 * 1000,\n    });\n\n    // Initialize performance optimizer\n    this.performanceOptimizer = new PerformanceOptimizer({\n      enableAsyncQueue: true,\n      enableBatchProcessing: true,\n      enableAutoTuning: true,\n      asyncQueueConcurrency: Math.min(this.config.maxWorkers * 2, 20),\n      batchMaxSize: 50,\n      metricsInterval: 30000,\n    });\n\n    this._initializeEventHandlers();\n    this._initializePerformanceMonitoring();\n  }\n\n  /**\n   * Initialize event handlers\n   */\n  _initializeEventHandlers() {\n    this.on('task:created', (task) => {\n      this.state.metrics.tasksCreated++;\n      this._checkAutoScale();\n    });\n\n    this.on('task:completed', (task) => {\n      this.state.metrics.tasksCompleted++;\n      this._updatePerformanceMetrics();\n    });\n\n    this.on('task:failed', (data) => {\n      console.warn(`Task failed: ${data.task.id}`, data.error);\n      this._handleTaskFailure(data.task, data.error);\n    });\n\n    this.on('decision:reached', (decision) => {\n      this.state.metrics.decisionsReached++;\n    });\n\n    this.on('worker:idle', (workerId) => {\n      this._assignNextTask(workerId);\n    });\n\n    this.on('error', (error) => {\n      console.error('Hive Mind Error:', error);\n      this._handleError(error);\n    });\n  }\n\n  /**\n   * Initialize performance monitoring\n   */\n  _initializePerformanceMonitoring() {\n    // Listen to performance optimizer events\n    this.performanceOptimizer.on('auto_tune', (data) => {\n      this.emit('performance:auto_tuned', data);\n    });\n\n    this.performanceOptimizer.on('error', (error) => {\n      console.error('Performance optimizer error:', error);\n      this.emit('error', { type: 'performance_optimizer_error', error });\n    });\n\n    // Periodic performance reporting\n    setInterval(() => {\n      const stats = this.performanceOptimizer.getPerformanceStats();\n      this.emit('performance:stats', stats);\n\n      // Log performance warnings\n      if (parseFloat(stats.asyncQueue.utilization) > 90) {\n        console.warn('High async queue utilization:', stats.asyncQueue.utilization + '%');\n      }\n\n      if (parseFloat(stats.asyncQueue.successRate) < 95) {\n        console.warn('Low async operation success rate:', stats.asyncQueue.successRate + '%');\n      }\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Handle task failure with recovery logic\n   */\n  _handleTaskFailure(task, error) {\n    // Update metrics\n    this.state.metrics.tasksFailed = (this.state.metrics.tasksFailed || 0) + 1;\n\n    // Attempt task retry for recoverable failures\n    if (task.retryCount < 2 && this._isRecoverableError(error)) {\n      task.retryCount = (task.retryCount || 0) + 1;\n      task.status = 'pending';\n\n      // Find another worker for retry\n      setTimeout(() => {\n        const worker = this._findBestWorker(task);\n        if (worker) {\n          this._assignTask(worker.id, task.id);\n        }\n      }, 5000); // Wait 5 seconds before retry\n\n      console.log(`Retrying task ${task.id} (attempt ${task.retryCount})`);\n    }\n  }\n\n  /**\n   * Check if error is recoverable\n   */\n  _isRecoverableError(error) {\n    const recoverableErrors = ['timeout', 'network', 'temporary', 'connection'];\n\n    return recoverableErrors.some((type) => error.message.toLowerCase().includes(type));\n  }\n\n  /**\n   * Initialize the hive mind swarm\n   */\n  async initialize() {\n    try {\n      this.state.status = 'initializing';\n\n      // Initialize swarm with MCP tools\n      const [swarmInit, memoryInit, neuralInit] = await this.mcpWrapper.initializeSwarm({\n        topology: this._determineTopology(),\n        maxAgents: this.config.maxWorkers + 1, // +1 for queen\n        swarmId: this.config.name,\n      });\n\n      this.state.swarmId = swarmInit.swarmId;\n\n      // Store initial configuration in memory\n      await this.mcpWrapper.storeMemory(this.state.swarmId, 'config', this.config, 'system');\n\n      this.state.status = 'ready';\n      this.emit('initialized', { swarmId: this.state.swarmId });\n\n      return this.state.swarmId;\n    } catch (error) {\n      this.state.status = 'error';\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Determine optimal topology based on objective\n   */\n  _determineTopology() {\n    const objective = this.config.objective.toLowerCase();\n\n    // Heuristic topology selection\n    if (objective.includes('research') || objective.includes('analysis')) {\n      return 'mesh'; // Peer-to-peer for collaborative research\n    } else if (objective.includes('build') || objective.includes('develop')) {\n      return 'hierarchical'; // Clear command structure for development\n    } else if (objective.includes('monitor') || objective.includes('maintain')) {\n      return 'ring'; // Circular for continuous monitoring\n    } else if (objective.includes('coordinate') || objective.includes('orchestrate')) {\n      return 'star'; // Centralized for coordination\n    }\n\n    return 'hierarchical'; // Default\n  }\n\n  /**\n   * Spawn the queen coordinator\n   */\n  async spawnQueen(queenData) {\n    const [spawnResult] = await this.mcpWrapper.spawnAgents(['coordinator'], this.state.swarmId);\n\n    this.state.queen = {\n      id: queenData.id,\n      agentId: spawnResult.agentId,\n      type: this.config.queenType,\n      status: 'active',\n      decisions: 0,\n      tasks: 0,\n    };\n\n    // Store queen info in memory\n    await this.mcpWrapper.storeMemory(this.state.swarmId, 'queen', this.state.queen, 'system');\n\n    this.emit('queen:spawned', this.state.queen);\n    return this.state.queen;\n  }\n\n  /**\n   * Spawn worker agents with batch optimization\n   */\n  async spawnWorkers(workerTypes) {\n    const startTime = Date.now();\n\n    try {\n      // Batch spawn agents in parallel with optimized chunking\n      const chunkSize = Math.min(workerTypes.length, 5); // Optimal batch size\n      const chunks = [];\n\n      for (let i = 0; i < workerTypes.length; i += chunkSize) {\n        chunks.push(workerTypes.slice(i, i + chunkSize));\n      }\n\n      // Process chunks in parallel with Promise.all\n      const allResults = await Promise.all(\n        chunks.map((chunk) => this.mcpWrapper.spawnAgents(chunk, this.state.swarmId)),\n      );\n\n      // Flatten results\n      const spawnResults = allResults.flat();\n\n      // Batch create worker objects\n      const workers = [];\n      const workerUpdates = [];\n\n      spawnResults.forEach((result, index) => {\n        const worker = {\n          id: `worker-${index}`,\n          agentId: result.agentId,\n          type: workerTypes[index],\n          status: 'idle',\n          tasksCompleted: 0,\n          currentTask: null,\n          spawnedAt: Date.now(),\n          performance: {\n            avgTaskTime: 0,\n            successRate: 1.0,\n          },\n        };\n\n        workers.push(worker);\n        this.state.workers.set(worker.id, worker);\n\n        workerUpdates.push({\n          type: 'worker_spawned',\n          workerId: worker.id,\n          workerType: worker.type,\n          timestamp: worker.spawnedAt,\n        });\n      });\n\n      // Batch memory operations\n      await Promise.all([\n        this.mcpWrapper.storeMemory(this.state.swarmId, 'workers', workers, 'system'),\n        this.mcpWrapper.storeMemory(\n          this.state.swarmId,\n          'worker_spawn_batch',\n          {\n            count: workers.length,\n            types: workerTypes,\n            spawnTime: Date.now() - startTime,\n            updates: workerUpdates,\n          },\n          'metrics',\n        ),\n      ]);\n\n      // Emit batch completion event\n      this.emit('workers:spawned', {\n        count: this.state.workers.size,\n        batchSize: workers.length,\n        spawnTime: Date.now() - startTime,\n        workers: workers,\n      });\n\n      return workers;\n    } catch (error) {\n      this.emit('error', {\n        type: 'spawn_batch_failed',\n        error,\n        workerTypes,\n        spawnTime: Date.now() - startTime,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Create and distribute task with performance optimization\n   */\n  async createTask(description, priority = 5, metadata = {}) {\n    const timestamp = Date.now();\n    const randomPart = Math.random().toString(36).substring(2, 11); // Use substring instead of substr\n    const taskId = `task-${timestamp}-${randomPart}`;\n    const createdAt = Date.now();\n\n    const task = {\n      id: taskId,\n      swarmId: this.state.swarmId,\n      description,\n      priority,\n      status: 'pending',\n      createdAt: new Date(createdAt).toISOString(),\n      assignedTo: null,\n      result: null,\n      metadata: {\n        estimatedDuration: this._estimateTaskDuration(description),\n        complexity: this._analyzeTaskComplexity(description),\n        ...metadata,\n      },\n    };\n\n    // Parallel operations: task storage, orchestration, and worker finding\n    const [orchestrateResult, bestWorker] = await Promise.all([\n      this.mcpWrapper.orchestrateTask(description, 'adaptive'),\n      this._findBestWorkerAsync(task),\n      // Store task immediately in parallel\n      (async () => {\n        this.state.tasks.set(task.id, task);\n        await this.mcpWrapper.storeMemory(this.state.swarmId, `task-${task.id}`, task, 'task');\n      })(),\n    ]);\n\n    task.orchestrationId = orchestrateResult[0].taskId;\n\n    this.emit('task:created', task);\n\n    // Assign task if worker available\n    if (bestWorker) {\n      // Use non-blocking assignment\n      setImmediate(() => this._assignTask(bestWorker.id, task.id));\n    }\n\n    return task;\n  }\n\n  /**\n   * Estimate task duration based on description analysis\n   */\n  _estimateTaskDuration(description) {\n    const words = description.toLowerCase().split(/\\s+/);\n    const complexityKeywords = {\n      simple: ['list', 'show', 'display', 'get', 'read'],\n      medium: ['create', 'update', 'modify', 'change', 'build'],\n      complex: ['analyze', 'optimize', 'refactor', 'implement', 'design'],\n    };\n\n    let score = 1;\n    for (const word of words) {\n      if (complexityKeywords.complex.includes(word)) score += 3;\n      else if (complexityKeywords.medium.includes(word)) score += 2;\n      else if (complexityKeywords.simple.includes(word)) score += 1;\n    }\n\n    return Math.min(score * 5000, 60000); // Cap at 1 minute\n  }\n\n  /**\n   * Analyze task complexity\n   */\n  _analyzeTaskComplexity(description) {\n    const words = description.toLowerCase().split(/\\s+/);\n    const indicators = {\n      high: ['optimize', 'refactor', 'architecture', 'design', 'algorithm'],\n      medium: ['implement', 'build', 'create', 'develop', 'integrate'],\n      low: ['list', 'show', 'get', 'read', 'display'],\n    };\n\n    for (const [level, keywords] of Object.entries(indicators)) {\n      if (keywords.some((keyword) => words.includes(keyword))) {\n        return level;\n      }\n    }\n\n    return 'medium';\n  }\n\n  /**\n   * Find best worker for task (optimized async version)\n   */\n  async _findBestWorkerAsync(task) {\n    const availableWorkers = Array.from(this.state.workers.values()).filter(\n      (w) => w.status === 'idle',\n    );\n\n    if (availableWorkers.length === 0) {\n      return null;\n    }\n\n    // Use cached analysis if available\n    const cacheKey = `worker_match_${task.description.substring(0, 50)}`;\n    const cachedMatch = await this.mcpWrapper.retrieveMemory(this.state.swarmId, cacheKey);\n\n    if (cachedMatch && cachedMatch.timestamp > Date.now() - 300000) {\n      // 5 min cache\n      const cachedWorker = availableWorkers.find((w) => w.type === cachedMatch.workerType);\n      if (cachedWorker) return cachedWorker;\n    }\n\n    // Enhanced matching algorithm with performance scoring\n    const taskLower = task.description.toLowerCase();\n    const taskWords = taskLower.split(/\\s+/);\n\n    // Enhanced priority mapping with weights\n    const priorityMap = {\n      researcher: {\n        keywords: ['research', 'investigate', 'analyze', 'study', 'explore'],\n        weight: 1.2,\n      },\n      coder: {\n        keywords: ['code', 'implement', 'build', 'develop', 'fix', 'create', 'program'],\n        weight: 1.0,\n      },\n      analyst: {\n        keywords: ['analyze', 'data', 'metrics', 'performance', 'report', 'statistics'],\n        weight: 1.1,\n      },\n      tester: { keywords: ['test', 'validate', 'check', 'verify', 'quality', 'qa'], weight: 1.0 },\n      architect: {\n        keywords: ['design', 'architecture', 'structure', 'plan', 'system'],\n        weight: 1.3,\n      },\n      reviewer: { keywords: ['review', 'feedback', 'improve', 'refactor', 'audit'], weight: 1.0 },\n      optimizer: {\n        keywords: ['optimize', 'performance', 'speed', 'efficiency', 'enhance'],\n        weight: 1.4,\n      },\n      documenter: { keywords: ['document', 'explain', 'write', 'describe', 'manual'], weight: 0.9 },\n    };\n\n    // Calculate scores for each worker\n    const workerScores = availableWorkers.map((worker) => {\n      const typeInfo = priorityMap[worker.type] || { keywords: [], weight: 1.0 };\n\n      // Keyword matching score\n      const keywordScore = typeInfo.keywords.reduce((score, keyword) => {\n        return score + (taskWords.includes(keyword) ? 1 : 0);\n      }, 0);\n\n      // Performance history score\n      const performanceScore = worker.performance\n        ? worker.performance.successRate * 0.5 + (1 / (worker.performance.avgTaskTime + 1)) * 0.5\n        : 0.5;\n\n      // Task completion rate\n      const completionScore =\n        worker.tasksCompleted > 0 ? Math.min(worker.tasksCompleted / 10, 1) : 0;\n\n      // Combined score\n      const totalScore =\n        (keywordScore * 2 + // Keyword relevance\n          performanceScore * 1.5 + // Historical performance\n          completionScore * 1.0) * // Experience\n        typeInfo.weight;\n\n      return {\n        worker,\n        score: totalScore,\n        breakdown: {\n          keyword: keywordScore,\n          performance: performanceScore,\n          completion: completionScore,\n          weight: typeInfo.weight,\n        },\n      };\n    });\n\n    // Sort by score and select best\n    workerScores.sort((a, b) => b.score - a.score);\n    const bestMatch = workerScores[0];\n\n    // Cache the result for future use\n    if (bestMatch.score > 0) {\n      setImmediate(async () => {\n        await this.mcpWrapper.storeMemory(\n          this.state.swarmId,\n          cacheKey,\n          {\n            workerType: bestMatch.worker.type,\n            score: bestMatch.score,\n            timestamp: Date.now(),\n          },\n          'cache',\n        );\n      });\n    }\n\n    return bestMatch ? bestMatch.worker : availableWorkers[0];\n  }\n\n  /**\n   * Synchronous version for backward compatibility\n   */\n  _findBestWorker(task) {\n    const availableWorkers = Array.from(this.state.workers.values()).filter(\n      (w) => w.status === 'idle',\n    );\n\n    if (availableWorkers.length === 0) {\n      return null;\n    }\n\n    // Simplified scoring for sync version\n    const taskLower = task.description.toLowerCase();\n    const priorityMap = {\n      researcher: ['research', 'investigate', 'analyze', 'study'],\n      coder: ['code', 'implement', 'build', 'develop', 'fix', 'create'],\n      analyst: ['analyze', 'data', 'metrics', 'performance', 'report'],\n      tester: ['test', 'validate', 'check', 'verify', 'quality'],\n      architect: ['design', 'architecture', 'structure', 'plan'],\n      reviewer: ['review', 'feedback', 'improve', 'refactor'],\n      optimizer: ['optimize', 'performance', 'speed', 'efficiency'],\n      documenter: ['document', 'explain', 'write', 'describe'],\n    };\n\n    let bestWorker = null;\n    let bestScore = 0;\n\n    for (const worker of availableWorkers) {\n      const keywords = priorityMap[worker.type] || [];\n      const keywordScore = keywords.filter((k) => taskLower.includes(k)).length;\n      const performanceBonus = worker.performance ? worker.performance.successRate * 0.5 : 0;\n      const totalScore = keywordScore + performanceBonus;\n\n      if (totalScore > bestScore) {\n        bestScore = totalScore;\n        bestWorker = worker;\n      }\n    }\n\n    return bestWorker || availableWorkers[0];\n  }\n\n  /**\n   * Assign task to worker\n   */\n  async _assignTask(workerId, taskId) {\n    const worker = this.state.workers.get(workerId);\n    const task = this.state.tasks.get(taskId);\n\n    if (!worker || !task) return;\n\n    worker.status = 'busy';\n    worker.currentTask = taskId;\n    task.status = 'in_progress';\n    task.assignedTo = workerId;\n\n    // Store assignment in memory\n    await this.mcpWrapper.storeMemory(\n      this.state.swarmId,\n      `assignment-${taskId}`,\n      { workerId, taskId, timestamp: Date.now() },\n      'task',\n    );\n\n    this.emit('task:assigned', { workerId, taskId });\n\n    // Simulate task execution\n    this._executeTask(workerId, taskId);\n  }\n\n  /**\n   * Execute task with performance optimization\n   */\n  async _executeTask(workerId, taskId) {\n    const worker = this.state.workers.get(workerId);\n    const task = this.state.tasks.get(taskId);\n    const startTime = Date.now();\n\n    try {\n      // Use performance optimizer for async execution\n      const result = await this.performanceOptimizer.optimizeAsyncOperation(\n        async () => {\n          // Simulate task execution based on complexity\n          const baseDuration = {\n            low: 5000,\n            medium: 15000,\n            high: 30000,\n          }[task.metadata?.complexity || 'medium'];\n\n          const duration = baseDuration + Math.random() * baseDuration * 0.5;\n\n          return new Promise((resolve) => {\n            setTimeout(() => {\n              resolve({\n                status: 'completed',\n                result: `Task completed by ${worker.type} worker`,\n                processingTime: Date.now() - startTime,\n                complexity: task.metadata?.complexity || 'medium',\n              });\n            }, duration);\n          });\n        },\n        { priority: task.priority },\n      );\n\n      // Update task and worker\n      task.status = 'completed';\n      task.completedAt = new Date().toISOString();\n      task.result = result.result;\n      task.actualDuration = result.processingTime;\n\n      worker.status = 'idle';\n      worker.currentTask = null;\n      worker.tasksCompleted++;\n\n      // Update worker performance metrics\n      if (!worker.performance.avgTaskTime) {\n        worker.performance.avgTaskTime = result.processingTime;\n      } else {\n        worker.performance.avgTaskTime =\n          (worker.performance.avgTaskTime * (worker.tasksCompleted - 1) + result.processingTime) /\n          worker.tasksCompleted;\n      }\n\n      // Batch store results for better performance\n      await this.performanceOptimizer.optimizeBatchOperation(\n        'task_results',\n        {\n          key: `result-${taskId}`,\n          value: task,\n          type: 'result',\n        },\n        async (items) => {\n          // Batch store all results\n          await Promise.all(\n            items.map((item) =>\n              this.mcpWrapper.storeMemory(this.state.swarmId, item.key, item.value, item.type),\n            ),\n          );\n          return items.map(() => ({ success: true }));\n        },\n      );\n\n      this.emit('task:completed', task);\n      this.emit('worker:idle', workerId);\n    } catch (error) {\n      // Handle task failure\n      task.status = 'failed';\n      task.error = error.message;\n      task.failedAt = new Date().toISOString();\n\n      worker.status = 'idle';\n      worker.currentTask = null;\n      worker.performance.successRate =\n        (worker.performance.successRate * worker.tasksCompleted) / (worker.tasksCompleted + 1);\n\n      this.emit('task:failed', { task, error });\n      this.emit('worker:idle', workerId);\n    }\n  }\n\n  /**\n   * Assign next task to idle worker\n   */\n  _assignNextTask(workerId) {\n    const pendingTasks = Array.from(this.state.tasks.values())\n      .filter((t) => t.status === 'pending')\n      .sort((a, b) => b.priority - a.priority);\n\n    if (pendingTasks.length > 0) {\n      this._assignTask(workerId, pendingTasks[0].id);\n    }\n  }\n\n  /**\n   * Build consensus for decision\n   */\n  async buildConsensus(topic, options) {\n    const decision = {\n      id: `decision-${Date.now()}`,\n      swarmId: this.state.swarmId,\n      topic,\n      options,\n      votes: new Map(),\n      algorithm: this.config.consensusAlgorithm,\n      status: 'voting',\n      createdAt: new Date().toISOString(),\n    };\n\n    this.state.decisions.set(decision.id, decision);\n\n    // Simulate voting process\n    const workers = Array.from(this.state.workers.values());\n    const votes = {};\n\n    // Each worker votes\n    workers.forEach((worker) => {\n      const vote = options[Math.floor(Math.random() * options.length)];\n      votes[worker.id] = vote;\n      decision.votes.set(worker.id, vote);\n    });\n\n    // Queen gets weighted vote\n    const queenVote = options[Math.floor(Math.random() * options.length)];\n    votes['queen'] = queenVote;\n    decision.votes.set('queen', queenVote);\n\n    // Calculate consensus\n    const result = this._calculateConsensus(decision);\n    decision.result = result.decision;\n    decision.confidence = result.confidence;\n    decision.status = 'completed';\n\n    // Convert Map to plain object for proper JSON serialization\n    const decisionForStorage = {\n      ...decision,\n      votes: decision.votes instanceof Map ? Object.fromEntries(decision.votes) : decision.votes,\n    };\n\n    // Store decision in memory\n    await this.mcpWrapper.storeMemory(\n      this.state.swarmId,\n      `decision-${decision.id}`,\n      decisionForStorage,\n      'consensus',\n    );\n\n    this.emit('decision:reached', decision);\n    return decision;\n  }\n\n  /**\n   * Calculate consensus based on algorithm\n   */\n  _calculateConsensus(decision) {\n    const votes = Array.from(decision.votes.values());\n    const voteCount = {};\n\n    // Count votes\n    votes.forEach((vote) => {\n      voteCount[vote] = (voteCount[vote] || 0) + 1;\n    });\n\n    switch (decision.algorithm) {\n      case 'majority':\n        // Simple majority\n        const sorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);\n        const winner = sorted[0];\n        return {\n          decision: winner[0],\n          confidence: winner[1] / votes.length,\n        };\n\n      case 'weighted':\n        // Weight queen vote more heavily\n        const queenVote = decision.votes.get('queen');\n        voteCount[queenVote] = (voteCount[queenVote] || 0) + 2; // Queen counts as 3 votes\n\n        const weightedSorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);\n        const weightedWinner = weightedSorted[0];\n        return {\n          decision: weightedWinner[0],\n          confidence: weightedWinner[1] / (votes.length + 2),\n        };\n\n      case 'byzantine':\n        // Requires 2/3 majority\n        const byzantineSorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);\n        const byzantineWinner = byzantineSorted[0];\n        const byzantineConfidence = byzantineWinner[1] / votes.length;\n\n        if (byzantineConfidence >= 0.67) {\n          return {\n            decision: byzantineWinner[0],\n            confidence: byzantineConfidence,\n          };\n        } else {\n          return {\n            decision: 'no_consensus',\n            confidence: 0,\n          };\n        }\n\n      default:\n        return {\n          decision: 'unknown',\n          confidence: 0,\n        };\n    }\n  }\n\n  /**\n   * Check if auto-scaling is needed\n   */\n  async _checkAutoScale() {\n    if (!this.config.autoScale) return;\n\n    const pendingTasks = Array.from(this.state.tasks.values()).filter(\n      (t) => t.status === 'pending',\n    ).length;\n\n    const idleWorkers = Array.from(this.state.workers.values()).filter(\n      (w) => w.status === 'idle',\n    ).length;\n\n    // Scale up if too many pending tasks\n    if (pendingTasks > idleWorkers * 2 && this.state.workers.size < this.config.maxWorkers) {\n      const newWorkerType = this._determineWorkerType();\n      await this.spawnWorkers([newWorkerType]);\n      console.log(`Auto-scaled: Added ${newWorkerType} worker`);\n    }\n\n    // Scale down if too many idle workers\n    if (idleWorkers > pendingTasks + 2 && this.state.workers.size > 2) {\n      // TODO: Implement worker removal\n    }\n  }\n\n  /**\n   * Determine worker type for auto-scaling\n   */\n  _determineWorkerType() {\n    // Analyze pending tasks to determine needed worker type\n    const pendingTasks = Array.from(this.state.tasks.values()).filter(\n      (t) => t.status === 'pending',\n    );\n\n    // Simple heuristic based on task descriptions\n    const typeScores = {};\n\n    pendingTasks.forEach((task) => {\n      const taskLower = task.description.toLowerCase();\n\n      if (taskLower.includes('code') || taskLower.includes('implement')) {\n        typeScores.coder = (typeScores.coder || 0) + 1;\n      }\n      if (taskLower.includes('test') || taskLower.includes('validate')) {\n        typeScores.tester = (typeScores.tester || 0) + 1;\n      }\n      if (taskLower.includes('analyze') || taskLower.includes('data')) {\n        typeScores.analyst = (typeScores.analyst || 0) + 1;\n      }\n      if (taskLower.includes('research') || taskLower.includes('investigate')) {\n        typeScores.researcher = (typeScores.researcher || 0) + 1;\n      }\n    });\n\n    // Return type with highest score\n    const sorted = Object.entries(typeScores).sort((a, b) => b[1] - a[1]);\n    return sorted.length > 0 ? sorted[0][0] : 'coder'; // Default to coder\n  }\n\n  /**\n   * Update performance metrics\n   */\n  async _updatePerformanceMetrics() {\n    // Calculate performance metrics\n    const completionRate = this.state.metrics.tasksCompleted / this.state.metrics.tasksCreated;\n    const avgTasksPerWorker = this.state.metrics.tasksCompleted / this.state.workers.size;\n\n    // Store metrics in memory\n    await this.mcpWrapper.storeMemory(\n      this.state.swarmId,\n      'metrics',\n      {\n        ...this.state.metrics,\n        completionRate,\n        avgTasksPerWorker,\n        timestamp: Date.now(),\n      },\n      'metrics',\n    );\n\n    // Analyze performance if needed\n    if (this.state.metrics.tasksCompleted % 10 === 0) {\n      await this.mcpWrapper.analyzePerformance(this.state.swarmId);\n    }\n  }\n\n  /**\n   * Handle errors\n   */\n  _handleError(error) {\n    // Log error to memory\n    this.mcpWrapper\n      .storeMemory(\n        this.state.swarmId,\n        `error-${Date.now()}`,\n        {\n          message: error.message,\n          stack: error.stack,\n          timestamp: Date.now(),\n        },\n        'error',\n      )\n      .catch(console.error);\n  }\n\n  /**\n   * Get current status with performance metrics\n   */\n  getStatus() {\n    const tasks = Array.from(this.state.tasks.values());\n    const workers = Array.from(this.state.workers.values());\n\n    return {\n      swarmId: this.state.swarmId,\n      status: this.state.status,\n      queen: this.state.queen,\n      workers: workers,\n      tasks: {\n        total: this.state.tasks.size,\n        pending: tasks.filter((t) => t.status === 'pending').length,\n        inProgress: tasks.filter((t) => t.status === 'in_progress').length,\n        completed: tasks.filter((t) => t.status === 'completed').length,\n        failed: tasks.filter((t) => t.status === 'failed').length,\n      },\n      metrics: {\n        ...this.state.metrics,\n        averageTaskTime: this._calculateAverageTaskTime(tasks),\n        workerEfficiency: this._calculateWorkerEfficiency(workers),\n        throughput: this._calculateThroughput(tasks),\n      },\n      decisions: this.state.decisions.size,\n      performance: this.performanceOptimizer.getPerformanceStats(),\n    };\n  }\n\n  /**\n   * Calculate average task completion time\n   */\n  _calculateAverageTaskTime(tasks) {\n    const completedTasks = tasks.filter((t) => t.status === 'completed' && t.actualDuration);\n    if (completedTasks.length === 0) return 0;\n\n    const totalTime = completedTasks.reduce((sum, task) => sum + task.actualDuration, 0);\n    return Math.round(totalTime / completedTasks.length);\n  }\n\n  /**\n   * Calculate worker efficiency\n   */\n  _calculateWorkerEfficiency(workers) {\n    if (workers.length === 0) return 0;\n\n    const efficiencies = workers.map((worker) => worker.performance?.successRate || 1.0);\n    return ((efficiencies.reduce((sum, eff) => sum + eff, 0) / workers.length) * 100).toFixed(2);\n  }\n\n  /**\n   * Calculate system throughput (tasks per minute)\n   */\n  _calculateThroughput(tasks) {\n    const completedTasks = tasks.filter((t) => t.status === 'completed' && t.completedAt);\n    if (completedTasks.length < 2) return 0;\n\n    const firstCompleted = new Date(completedTasks[0].completedAt).getTime();\n    const lastCompleted = new Date(completedTasks[completedTasks.length - 1].completedAt).getTime();\n    const timeSpanMinutes = (lastCompleted - firstCompleted) / (1000 * 60);\n\n    return timeSpanMinutes > 0 ? (completedTasks.length / timeSpanMinutes).toFixed(2) : 0;\n  }\n\n  /**\n   * Shutdown hive mind with cleanup\n   */\n  async shutdown() {\n    this.state.status = 'shutting_down';\n\n    try {\n      // Generate final performance report\n      const performanceReport = this.performanceOptimizer.generatePerformanceReport();\n\n      // Save final state and performance report\n      await Promise.all([\n        this.mcpWrapper.storeMemory(this.state.swarmId, 'final_state', this.getStatus(), 'system'),\n        this.mcpWrapper.storeMemory(\n          this.state.swarmId,\n          'final_performance_report',\n          performanceReport,\n          'metrics',\n        ),\n      ]);\n\n      // Close performance optimizer\n      await this.performanceOptimizer.close();\n\n      // Destroy swarm\n      await this.mcpWrapper.destroySwarm(this.state.swarmId);\n\n      this.state.status = 'shutdown';\n      this.emit('shutdown', { performanceReport });\n    } catch (error) {\n      this.emit('error', { type: 'shutdown_failed', error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get performance insights and recommendations\n   */\n  getPerformanceInsights() {\n    return this.performanceOptimizer.generatePerformanceReport();\n  }\n}\n"],"names":["EventEmitter","MCPToolWrapper","PerformanceOptimizer","HiveMindCore","config","objective","name","Date","now","queenType","maxWorkers","consensusAlgorithm","autoScale","encryption","memorySize","taskTimeout","state","status","swarmId","queen","workers","Map","tasks","memory","decisions","metrics","tasksCreated","tasksCompleted","decisionsReached","memoryUsage","mcpWrapper","parallel","timeout","performanceOptimizer","enableAsyncQueue","enableBatchProcessing","enableAutoTuning","asyncQueueConcurrency","Math","min","batchMaxSize","metricsInterval","_initializeEventHandlers","_initializePerformanceMonitoring","on","task","_checkAutoScale","_updatePerformanceMetrics","data","console","warn","id","error","_handleTaskFailure","decision","workerId","_assignNextTask","_handleError","emit","type","setInterval","stats","getPerformanceStats","parseFloat","asyncQueue","utilization","successRate","tasksFailed","retryCount","_isRecoverableError","setTimeout","worker","_findBestWorker","_assignTask","log","recoverableErrors","some","message","toLowerCase","includes","initialize","swarmInit","memoryInit","neuralInit","initializeSwarm","topology","_determineTopology","maxAgents","storeMemory","spawnQueen","queenData","spawnResult","spawnAgents","agentId","spawnWorkers","workerTypes","startTime","chunkSize","length","chunks","i","push","slice","allResults","Promise","all","map","chunk","spawnResults","flat","workerUpdates","forEach","result","index","currentTask","spawnedAt","performance","avgTaskTime","set","workerType","timestamp","count","types","spawnTime","updates","size","batchSize","createTask","description","priority","metadata","randomPart","random","toString","substring","taskId","createdAt","toISOString","assignedTo","estimatedDuration","_estimateTaskDuration","complexity","_analyzeTaskComplexity","orchestrateResult","bestWorker","orchestrateTask","_findBestWorkerAsync","orchestrationId","setImmediate","words","split","complexityKeywords","simple","medium","complex","score","word","indicators","high","low","level","keywords","Object","entries","keyword","availableWorkers","Array","from","values","filter","w","cacheKey","cachedMatch","retrieveMemory","cachedWorker","find","taskLower","taskWords","priorityMap","researcher","weight","coder","analyst","tester","architect","reviewer","optimizer","documenter","workerScores","typeInfo","keywordScore","reduce","performanceScore","completionScore","totalScore","breakdown","completion","sort","a","b","bestMatch","bestScore","k","performanceBonus","get","_executeTask","optimizeAsyncOperation","baseDuration","duration","resolve","processingTime","completedAt","actualDuration","optimizeBatchOperation","key","value","items","item","success","failedAt","pendingTasks","t","buildConsensus","topic","options","votes","algorithm","vote","floor","queenVote","_calculateConsensus","confidence","decisionForStorage","fromEntries","voteCount","sorted","winner","weightedSorted","weightedWinner","byzantineSorted","byzantineWinner","byzantineConfidence","idleWorkers","newWorkerType","_determineWorkerType","typeScores","completionRate","avgTasksPerWorker","analyzePerformance","stack","catch","getStatus","total","pending","inProgress","completed","failed","averageTaskTime","_calculateAverageTaskTime","workerEfficiency","_calculateWorkerEfficiency","throughput","_calculateThroughput","completedTasks","totalTime","sum","round","efficiencies","eff","toFixed","firstCompleted","getTime","lastCompleted","timeSpanMinutes","shutdown","performanceReport","generatePerformanceReport","close","destroySwarm","getPerformanceInsights"],"mappings":"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"}