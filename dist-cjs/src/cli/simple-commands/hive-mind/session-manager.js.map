{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/session-manager.js"],"sourcesContent":["/**\n * Hive Mind Session Manager\n * Handles session persistence and resume functionality for swarms\n */\n\nimport path from 'path';\nimport { existsSync, mkdirSync } from 'fs';\nimport { readFile, writeFile } from 'fs/promises';\nimport chalk from 'chalk';\nimport { cwd } from '../../node-compat.js';\nimport { createDatabase, isSQLiteAvailable, isWindows } from '../../../memory/sqlite-wrapper.js';\nimport { sessionSerializer } from '../../../memory/enhanced-session-serializer.js';\nimport { SerializationError, DeserializationError } from '../../../memory/advanced-serializer.js';\n\nexport class HiveMindSessionManager {\n  constructor(hiveMindDir = null) {\n    this.hiveMindDir = hiveMindDir || path.join(cwd(), '.hive-mind');\n    this.sessionsDir = path.join(this.hiveMindDir, 'sessions');\n    this.dbPath = path.join(this.hiveMindDir, 'hive.db');\n    this.db = null;\n    this.isInMemory = false;\n    this.memoryStore = null;\n    this.initializationPromise = null;\n\n    // Ensure directories exist\n    this.ensureDirectories();\n\n    // Initialize database connection (store promise for later)\n    this.initializationPromise = this.initializeDatabase();\n  }\n\n  /**\n   * Initialize database with fallback support\n   */\n  async initializeDatabase() {\n    try {\n      const sqliteAvailable = await isSQLiteAvailable();\n      \n      if (!sqliteAvailable) {\n        console.warn('SQLite not available, using in-memory session storage');\n        this.initializeInMemoryFallback();\n        return;\n      }\n\n      this.db = await createDatabase(this.dbPath);\n      if (this.db) {\n        this.initializeSchema();\n      } else {\n        throw new Error('Failed to create database instance');\n      }\n    } catch (error) {\n      console.error('Failed to create SQLite database:', error.message);\n      console.warn('Falling back to in-memory session storage');\n      this.initializeInMemoryFallback();\n    }\n  }\n\n  /**\n   * Ensure database is initialized before use\n   */\n  async ensureInitialized() {\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n      this.initializationPromise = null;\n    }\n    \n    if (this.db === null && !this.isInMemory) {\n      await this.initializeDatabase();\n    }\n  }\n\n  /**\n   * Initialize in-memory fallback for session storage\n   */\n  initializeInMemoryFallback() {\n    this.isInMemory = true;\n    this.memoryStore = {\n      sessions: new Map(),\n      checkpoints: new Map(),\n      logs: new Map()\n    };\n    \n    if (isWindows()) {\n      console.info(`\nNote: Session data will not persist between runs on Windows without SQLite.\nTo enable persistence, see: https://github.com/ruvnet/claude-code-flow/docs/windows-installation.md\n`);\n    }\n  }\n\n  /**\n   * Ensure required directories exist\n   */\n  ensureDirectories() {\n    if (!existsSync(this.hiveMindDir)) {\n      mkdirSync(this.hiveMindDir, { recursive: true });\n    }\n    if (!existsSync(this.sessionsDir)) {\n      mkdirSync(this.sessionsDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Initialize database schema for sessions\n   */\n  initializeSchema() {\n    if (!this.db) {\n      console.error('Database not initialized');\n      return;\n    }\n    // Create the base schema\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS sessions (\n        id TEXT PRIMARY KEY,\n        swarm_id TEXT NOT NULL,\n        swarm_name TEXT NOT NULL,\n        objective TEXT,\n        status TEXT DEFAULT 'active',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        paused_at DATETIME,\n        resumed_at DATETIME,\n        completion_percentage REAL DEFAULT 0,\n        checkpoint_data TEXT,\n        metadata TEXT,\n        parent_pid INTEGER,\n        child_pids TEXT,\n        FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n      );\n\n      CREATE TABLE IF NOT EXISTS session_checkpoints (\n        id TEXT PRIMARY KEY,\n        session_id TEXT NOT NULL,\n        checkpoint_name TEXT NOT NULL,\n        checkpoint_data TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (session_id) REFERENCES sessions(id)\n      );\n\n      CREATE TABLE IF NOT EXISTS session_logs (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        session_id TEXT NOT NULL,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n        log_level TEXT DEFAULT 'info',\n        message TEXT,\n        agent_id TEXT,\n        data TEXT,\n        FOREIGN KEY (session_id) REFERENCES sessions(id)\n      );\n    `);\n\n    // Run migrations to add new columns\n    this.runMigrations();\n  }\n\n  /**\n   * Run database migrations\n   */\n  runMigrations() {\n    if (!this.db) {\n      console.error('Database not initialized for migrations');\n      return;\n    }\n    try {\n      // Check if required columns exist\n      const columns = this.db.prepare('PRAGMA table_info(sessions)').all();\n      \n      // Core columns\n      const hasObjective = columns.some((col) => col.name === 'objective');\n      const hasSwarmName = columns.some((col) => col.name === 'swarm_name');\n      const hasCheckpointData = columns.some((col) => col.name === 'checkpoint_data');\n      const hasMetadata = columns.some((col) => col.name === 'metadata');\n      const hasParentPid = columns.some((col) => col.name === 'parent_pid');\n      const hasChildPids = columns.some((col) => col.name === 'child_pids');\n      \n      // Timestamp columns\n      const hasUpdatedAt = columns.some((col) => col.name === 'updated_at');\n      const hasPausedAt = columns.some((col) => col.name === 'paused_at');\n      const hasResumedAt = columns.some((col) => col.name === 'resumed_at');\n      const hasCompletionPercentage = columns.some((col) => col.name === 'completion_percentage');\n\n      if (!hasObjective) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN objective TEXT');\n        console.log('Added objective column to sessions table');\n      }\n\n      if (!hasSwarmName) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN swarm_name TEXT');\n        console.log('Added swarm_name column to sessions table');\n      }\n\n      if (!hasCheckpointData) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN checkpoint_data TEXT');\n        console.log('Added checkpoint_data column to sessions table');\n      }\n\n      if (!hasMetadata) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN metadata TEXT');\n        console.log('Added metadata column to sessions table');\n      }\n\n      if (!hasParentPid) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN parent_pid INTEGER');\n        console.log('Added parent_pid column to sessions table');\n      }\n\n      if (!hasChildPids) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN child_pids TEXT');\n        console.log('Added child_pids column to sessions table');\n      }\n\n      if (!hasUpdatedAt) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');\n        console.log('Added updated_at column to sessions table');\n      }\n\n      if (!hasPausedAt) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN paused_at DATETIME');\n        console.log('Added paused_at column to sessions table');\n      }\n\n      if (!hasResumedAt) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN resumed_at DATETIME');\n        console.log('Added resumed_at column to sessions table');\n      }\n\n      if (!hasCompletionPercentage) {\n        this.db.exec('ALTER TABLE sessions ADD COLUMN completion_percentage REAL DEFAULT 0');\n        console.log('Added completion_percentage column to sessions table');\n      }\n    } catch (error) {\n      console.error('Migration error:', error);\n    }\n  }\n\n  /**\n   * Create a new session for a swarm\n   */\n  async createSession(swarmId, swarmName, objective, metadata = {}) {\n    await this.ensureInitialized();\n    \n    const sessionId = `session-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n\n    if (this.isInMemory) {\n      // Use in-memory storage\n      const sessionData = {\n        id: sessionId,\n        swarm_id: swarmId,\n        swarm_name: swarmName,\n        objective,\n        status: 'active',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        metadata: sessionSerializer.serializeMetadata(metadata),\n        parent_pid: process.pid,\n        child_pids: '[]'\n      };\n      this.memoryStore.sessions.set(sessionId, sessionData);\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        INSERT INTO sessions (id, swarm_id, swarm_name, objective, metadata, parent_pid)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `);\n\n      stmt.run(sessionId, swarmId, swarmName, objective, sessionSerializer.serializeMetadata(metadata), process.pid);\n    }\n\n    // Log session creation\n    await this.logSessionEvent(sessionId, 'info', 'Session created', null, {\n      swarmId,\n      swarmName,\n      objective,\n      parentPid: process.pid,\n    });\n\n    return sessionId;\n  }\n\n  /**\n   * Save session checkpoint\n   */\n  async saveCheckpoint(sessionId, checkpointName, checkpointData) {\n    await this.ensureInitialized();\n    \n    const checkpointId = `checkpoint-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n\n    if (this.isInMemory) {\n      // Use in-memory storage\n      const checkpointEntry = {\n        id: checkpointId,\n        session_id: sessionId,\n        checkpoint_name: checkpointName,\n        checkpoint_data: sessionSerializer.serializeCheckpointData(checkpointData),\n        created_at: new Date().toISOString()\n      };\n      \n      if (!this.memoryStore.checkpoints.has(sessionId)) {\n        this.memoryStore.checkpoints.set(sessionId, []);\n      }\n      this.memoryStore.checkpoints.get(sessionId).push(checkpointEntry);\n      \n      // Update session data\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (session) {\n        session.checkpoint_data = sessionSerializer.serializeCheckpointData(checkpointData);\n        session.updated_at = new Date().toISOString();\n      }\n    } else {\n      // Save to database\n      const stmt = this.db.prepare(`\n        INSERT INTO session_checkpoints (id, session_id, checkpoint_name, checkpoint_data)\n        VALUES (?, ?, ?, ?)\n      `);\n\n      stmt.run(checkpointId, sessionId, checkpointName, sessionSerializer.serializeCheckpointData(checkpointData));\n\n      // Update session checkpoint data and timestamp\n      const updateStmt = this.db.prepare(`\n        UPDATE sessions \n        SET checkpoint_data = ?, updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `);\n\n      updateStmt.run(sessionSerializer.serializeCheckpointData(checkpointData), sessionId);\n    }\n\n    // Save checkpoint file for backup\n    const checkpointFile = path.join(this.sessionsDir, `${sessionId}-${checkpointName}.json`);\n    await writeFile(\n      checkpointFile,\n      sessionSerializer.serializeSessionData({\n        sessionId,\n        checkpointId,\n        checkpointName,\n        timestamp: new Date().toISOString(),\n        data: checkpointData,\n      }),\n    );\n\n    await this.logSessionEvent(sessionId, 'info', `Checkpoint saved: ${checkpointName}`, null, {\n      checkpointId,\n    });\n\n    return checkpointId;\n  }\n\n  /**\n   * Get active sessions\n   */\n  async getActiveSessions() {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage with real counts\n      const sessions = [];\n      for (const [sessionId, session] of this.memoryStore.sessions) {\n        if (session.status === 'active' || session.status === 'paused') {\n          // Get real agent count from memory\n          const agentCount = this.memoryStore.agents \n            ? Array.from(this.memoryStore.agents.values()).filter(a => a.swarm_id === session.swarm_id).length \n            : 0;\n          \n          // Get real task counts from memory\n          const tasks = this.memoryStore.tasks \n            ? Array.from(this.memoryStore.tasks.values()).filter(t => t.swarm_id === session.swarm_id)\n            : [];\n          \n          const taskCount = tasks.length;\n          const completedTasks = tasks.filter(t => t.status === 'completed').length;\n          const inProgressTasks = tasks.filter(t => t.status === 'in_progress').length;\n          const pendingTasks = tasks.filter(t => t.status === 'pending').length;\n          \n          sessions.push({\n            ...session,\n            metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\n            checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\n            agent_count: agentCount,\n            task_count: taskCount,\n            completed_tasks: completedTasks,\n            in_progress_tasks: inProgressTasks,\n            pending_tasks: pendingTasks,\n            completion_percentage: taskCount > 0 ? Math.round((completedTasks / taskCount) * 100) : 0\n          });\n        }\n      }\n      return sessions.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        SELECT s.*, \n               COUNT(DISTINCT a.id) as agent_count,\n               COUNT(DISTINCT t.id) as task_count,\n               SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) as completed_tasks\n        FROM sessions s\n        LEFT JOIN agents a ON s.swarm_id = a.swarm_id\n        LEFT JOIN tasks t ON s.swarm_id = t.swarm_id\n        WHERE s.status = 'active' OR s.status = 'paused'\n        GROUP BY s.id\n        ORDER BY s.updated_at DESC\n      `);\n\n      const sessions = stmt.all();\n\n      // Parse JSON fields\n      return sessions.map((session) => ({\n        ...session,\n        metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\n        checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\n        completion_percentage:\n          session.task_count > 0\n            ? Math.round((session.completed_tasks / session.task_count) * 100)\n            : 0,\n      }));\n    }\n  }\n\n  /**\n   * Get session by ID with full details\n   */\n  async getSession(sessionId) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (!session) {\n        return null;\n      }\n      \n      // Return simplified session data for in-memory mode\n      return {\n        ...session,\n        metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\n        checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\n        swarm: null, // Not available in memory mode\n        agents: [], // Not available in memory mode\n        tasks: [], // Not available in memory mode\n        checkpoints: this.memoryStore.checkpoints.get(sessionId) || [],\n        recentLogs: this.memoryStore.logs.get(sessionId) || [],\n        statistics: {\n          totalAgents: 0,\n          activeAgents: 0,\n          totalTasks: 0,\n          completedTasks: 0,\n          pendingTasks: 0,\n          inProgressTasks: 0,\n          completionPercentage: session.completion_percentage || 0,\n        },\n      };\n    }\n\n    const session = this.db\n      .prepare(\n        `\n      SELECT * FROM sessions WHERE id = ?\n    `,\n      )\n      .get(sessionId);\n\n    if (!session) {\n      return null;\n    }\n\n    // Get associated swarm data\n    const swarm = this.db\n      .prepare(\n        `\n      SELECT * FROM swarms WHERE id = ?\n    `,\n      )\n      .get(session.swarm_id);\n\n    // Get agents\n    const agents = this.db\n      .prepare(\n        `\n      SELECT * FROM agents WHERE swarm_id = ?\n    `,\n      )\n      .all(session.swarm_id);\n\n    // Get tasks\n    const tasks = this.db\n      .prepare(\n        `\n      SELECT * FROM tasks WHERE swarm_id = ?\n    `,\n      )\n      .all(session.swarm_id);\n\n    // Get checkpoints\n    const checkpoints = this.db\n      .prepare(\n        `\n      SELECT * FROM session_checkpoints \n      WHERE session_id = ? \n      ORDER BY created_at DESC\n    `,\n      )\n      .all(sessionId);\n\n    // Get recent logs\n    const recentLogs = this.db\n      .prepare(\n        `\n      SELECT * FROM session_logs \n      WHERE session_id = ? \n      ORDER BY timestamp DESC \n      LIMIT 50\n    `,\n      )\n      .all(sessionId);\n\n    return {\n      ...session,\n      metadata: session.metadata ? sessionSerializer.deserializeMetadata(session.metadata) : {},\n      checkpoint_data: session.checkpoint_data ? sessionSerializer.deserializeCheckpointData(session.checkpoint_data) : null,\n      swarm,\n      agents,\n      tasks,\n      checkpoints: checkpoints.map((cp) => ({\n        ...cp,\n        checkpoint_data: sessionSerializer.deserializeCheckpointData(cp.checkpoint_data),\n      })),\n      recentLogs,\n      statistics: {\n        totalAgents: agents.length,\n        activeAgents: agents.filter((a) => a.status === 'active' || a.status === 'busy').length,\n        totalTasks: tasks.length,\n        completedTasks: tasks.filter((t) => t.status === 'completed').length,\n        pendingTasks: tasks.filter((t) => t.status === 'pending').length,\n        inProgressTasks: tasks.filter((t) => t.status === 'in_progress').length,\n        completionPercentage:\n          tasks.length > 0\n            ? Math.round(\n                (tasks.filter((t) => t.status === 'completed').length / tasks.length) * 100,\n              )\n            : 0,\n      },\n    };\n  }\n\n  /**\n   * Pause a session\n   */\n  async pauseSession(sessionId) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (session) {\n        session.status = 'paused';\n        session.paused_at = new Date().toISOString();\n        session.updated_at = new Date().toISOString();\n        \n        await this.logSessionEvent(sessionId, 'info', 'Session paused');\n        return true;\n      }\n      return false;\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        UPDATE sessions \n        SET status = 'paused', paused_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `);\n\n      const result = stmt.run(sessionId);\n\n      if (result.changes > 0) {\n        await this.logSessionEvent(sessionId, 'info', 'Session paused');\n\n        // Update swarm status\n        const session = this.db.prepare('SELECT swarm_id FROM sessions WHERE id = ?').get(sessionId);\n        if (session) {\n          this.db\n            .prepare('UPDATE swarms SET status = ? WHERE id = ?')\n            .run('paused', session.swarm_id);\n        }\n      }\n\n      return result.changes > 0;\n    }\n  }\n\n  /**\n   * Resume any previous session (paused, stopped, or inactive)\n   */\n  async resumeSession(sessionId) {\n    const session = await this.getSession(sessionId);\n\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    // Allow resuming any session regardless of status\n    console.log(`Resuming session ${sessionId} from status: ${session.status}`);\n\n    // If session was stopped, log that we're restarting it\n    if (session.status === 'stopped') {\n      await this.logSessionEvent(\n        sessionId,\n        'info',\n        `Restarting stopped session with original configuration`,\n      );\n    }\n\n    // Update session status\n    if (this.isInMemory) {\n      // Use in-memory storage\n      const sessionData = this.memoryStore.sessions.get(sessionId);\n      if (sessionData) {\n        sessionData.status = 'active';\n        sessionData.resumed_at = new Date().toISOString();\n        sessionData.updated_at = new Date().toISOString();\n      }\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        UPDATE sessions \n        SET status = 'active', resumed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `);\n\n      stmt.run(sessionId);\n\n      // Update swarm status\n      this.db.prepare('UPDATE swarms SET status = ? WHERE id = ?').run('active', session.swarm_id);\n\n      // Update agent statuses\n      this.db\n        .prepare(\n          `\n        UPDATE agents \n        SET status = CASE \n          WHEN role = 'queen' THEN 'active'\n          ELSE 'idle'\n        END\n        WHERE swarm_id = ?\n      `,\n        )\n        .run(session.swarm_id);\n    }\n\n    await this.logSessionEvent(sessionId, 'info', 'Session resumed', null, {\n      pausedDuration: session.paused_at ? new Date() - new Date(session.paused_at) : null,\n    });\n\n    return session;\n  }\n\n  /**\n   * Mark session as completed\n   */\n  async completeSession(sessionId) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (session) {\n        session.status = 'completed';\n        session.updated_at = new Date().toISOString();\n        session.completion_percentage = 100;\n        \n        await this.logSessionEvent(sessionId, 'info', 'Session completed');\n        return true;\n      }\n      return false;\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        UPDATE sessions \n        SET status = 'completed', updated_at = CURRENT_TIMESTAMP, completion_percentage = 100\n        WHERE id = ?\n      `);\n\n      const result = stmt.run(sessionId);\n\n      if (result.changes > 0) {\n        await this.logSessionEvent(sessionId, 'info', 'Session completed');\n\n        // Update swarm status\n        const session = this.db.prepare('SELECT swarm_id FROM sessions WHERE id = ?').get(sessionId);\n        if (session) {\n          this.db\n            .prepare('UPDATE swarms SET status = ? WHERE id = ?')\n            .run('completed', session.swarm_id);\n        }\n      }\n\n      return result.changes > 0;\n    }\n  }\n\n  /**\n   * Archive old sessions\n   */\n  async archiveSessions(daysOld = 30) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // In-memory mode doesn't support archiving\n      console.warn('Session archiving not supported in in-memory mode');\n      return 0;\n    }\n    \n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n    const sessionsToArchive = this.db\n      .prepare(\n        `\n      SELECT * FROM sessions \n      WHERE status = 'completed' AND updated_at < ?\n    `,\n      )\n      .all(cutoffDate.toISOString());\n\n    const archiveDir = path.join(this.sessionsDir, 'archive');\n    if (!existsSync(archiveDir)) {\n      mkdirSync(archiveDir, { recursive: true });\n    }\n\n    for (const session of sessionsToArchive) {\n      const sessionData = await this.getSession(session.id);\n      const archiveFile = path.join(archiveDir, `${session.id}-archive.json`);\n\n      await writeFile(archiveFile, sessionSerializer.serializeSessionData(sessionData));\n\n      // Remove from database\n      this.db.prepare('DELETE FROM session_logs WHERE session_id = ?').run(session.id);\n      this.db.prepare('DELETE FROM session_checkpoints WHERE session_id = ?').run(session.id);\n      this.db.prepare('DELETE FROM sessions WHERE id = ?').run(session.id);\n    }\n\n    return sessionsToArchive.length;\n  }\n\n  /**\n   * Log session event\n   */\n  async logSessionEvent(sessionId, logLevel, message, agentId = null, data = null) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage for logs\n      const logId = `log-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n      const logEntry = {\n        id: logId,\n        session_id: sessionId,\n        timestamp: new Date().toISOString(),\n        log_level: logLevel,\n        message,\n        agent_id: agentId,\n        data: data ? sessionSerializer.serializeLogData(data) : null\n      };\n      \n      if (!this.memoryStore.logs.has(sessionId)) {\n        this.memoryStore.logs.set(sessionId, []);\n      }\n      this.memoryStore.logs.get(sessionId).push(logEntry);\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        INSERT INTO session_logs (session_id, log_level, message, agent_id, data)\n        VALUES (?, ?, ?, ?, ?)\n      `);\n\n      stmt.run(sessionId, logLevel, message, agentId, data ? sessionSerializer.serializeLogData(data) : null);\n    }\n  }\n\n  /**\n   * Get session logs\n   */\n  async getSessionLogs(sessionId, limit = 100, offset = 0) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const logs = this.memoryStore.logs.get(sessionId) || [];\n      return logs.slice(offset, offset + limit).map((log) => ({\n        ...log,\n        data: log.data ? sessionSerializer.deserializeLogData(log.data) : null,\n      }));\n    }\n    \n    const stmt = this.db.prepare(`\n      SELECT * FROM session_logs \n      WHERE session_id = ? \n      ORDER BY timestamp DESC \n      LIMIT ? OFFSET ?\n    `);\n\n    const logs = stmt.all(sessionId, limit, offset);\n\n    return logs.map((log) => ({\n      ...log,\n      data: log.data ? sessionSerializer.deserializeLogData(log.data) : null,\n    }));\n  }\n\n  /**\n   * Update session progress\n   */\n  async updateSessionProgress(sessionId, completionPercentage) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (session) {\n        session.completion_percentage = completionPercentage;\n        session.updated_at = new Date().toISOString();\n      }\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        UPDATE sessions \n        SET completion_percentage = ?, updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `);\n\n      stmt.run(completionPercentage, sessionId);\n    }\n  }\n\n  /**\n   * Generate session summary\n   */\n  async generateSessionSummary(sessionId) {\n    const session = await this.getSession(sessionId);\n\n    if (!session) {\n      return null;\n    }\n\n    const duration =\n      session.paused_at && session.resumed_at\n        ? new Date(session.updated_at) -\n          new Date(session.created_at) -\n          (new Date(session.resumed_at) - new Date(session.paused_at))\n        : new Date(session.updated_at) - new Date(session.created_at);\n\n    const tasksByType = session.agents.reduce((acc, agent) => {\n      const agentTasks = session.tasks.filter((t) => t.agent_id === agent.id);\n      if (!acc[agent.type]) {\n        acc[agent.type] = {\n          total: 0,\n          completed: 0,\n          inProgress: 0,\n          pending: 0,\n        };\n      }\n      acc[agent.type].total += agentTasks.length;\n      acc[agent.type].completed += agentTasks.filter((t) => t.status === 'completed').length;\n      acc[agent.type].inProgress += agentTasks.filter((t) => t.status === 'in_progress').length;\n      acc[agent.type].pending += agentTasks.filter((t) => t.status === 'pending').length;\n      return acc;\n    }, {});\n\n    return {\n      sessionId: session.id,\n      swarmName: session.swarm_name,\n      objective: session.objective,\n      status: session.status,\n      duration: Math.round(duration / 1000 / 60), // minutes\n      statistics: session.statistics,\n      tasksByType,\n      checkpointCount: session.checkpoints.length,\n      lastCheckpoint: session.checkpoints[0] || null,\n      timeline: {\n        created: session.created_at,\n        lastUpdated: session.updated_at,\n        paused: session.paused_at,\n        resumed: session.resumed_at,\n      },\n    };\n  }\n\n  /**\n   * Export session data\n   */\n  async exportSession(sessionId, exportPath = null) {\n    const session = await this.getSession(sessionId);\n\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    const exportFile = exportPath || path.join(this.sessionsDir, `${sessionId}-export.json`);\n\n    await writeFile(exportFile, sessionSerializer.serializeSessionData(session));\n\n    return exportFile;\n  }\n\n  /**\n   * Import session data\n   */\n  async importSession(importPath) {\n    const sessionData = sessionSerializer.deserializeSessionData(await readFile(importPath, 'utf8'));\n\n    // Create new session with imported data\n    const newSessionId = this.createSession(\n      sessionData.swarm_id,\n      sessionData.swarm_name,\n      sessionData.objective,\n      sessionData.metadata,\n    );\n\n    // Import checkpoints\n    for (const checkpoint of sessionData.checkpoints || []) {\n      await this.saveCheckpoint(\n        newSessionId,\n        checkpoint.checkpoint_name,\n        checkpoint.checkpoint_data,\n      );\n    }\n\n    // Import logs\n    for (const log of sessionData.recentLogs || []) {\n      await this.logSessionEvent(\n        newSessionId,\n        log.log_level,\n        log.message,\n        log.agent_id,\n        log.data ? sessionSerializer.deserializeLogData(log.data) : null,\n      );\n    }\n\n    return newSessionId;\n  }\n\n  /**\n   * Add a child process PID to session\n   */\n  async addChildPid(sessionId, pid) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (!session) return false;\n      \n      const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\n      if (!childPids.includes(pid)) {\n        childPids.push(pid);\n      }\n      session.child_pids = sessionSerializer.serializeLogData(childPids);\n      session.updated_at = new Date().toISOString();\n      \n      await this.logSessionEvent(sessionId, 'info', 'Child process added', null, { pid });\n      return true;\n    }\n    \n    const session = this.db.prepare('SELECT child_pids FROM sessions WHERE id = ?').get(sessionId);\n    if (!session) return false;\n\n    const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\n    if (!childPids.includes(pid)) {\n      childPids.push(pid);\n    }\n\n    const stmt = this.db.prepare(`\n      UPDATE sessions \n      SET child_pids = ?, updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `);\n\n    stmt.run(sessionSerializer.serializeLogData(childPids), sessionId);\n\n    await this.logSessionEvent(sessionId, 'info', 'Child process added', null, { pid });\n    return true;\n  }\n\n  /**\n   * Remove a child process PID from session\n   */\n  async removeChildPid(sessionId, pid) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (!session) return false;\n      \n      const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\n      const index = childPids.indexOf(pid);\n      if (index > -1) {\n        childPids.splice(index, 1);\n      }\n      session.child_pids = sessionSerializer.serializeLogData(childPids);\n      session.updated_at = new Date().toISOString();\n      \n      await this.logSessionEvent(sessionId, 'info', 'Child process removed', null, { pid });\n      return true;\n    }\n    \n    // Check if database connection is still open before operations\n    if (!this.db || !this.db.open) {\n      console.warn('Database connection closed, cannot remove child PID during cleanup');\n      return false;\n    }\n    \n    const session = this.db.prepare('SELECT child_pids FROM sessions WHERE id = ?').get(sessionId);\n    if (!session) return false;\n\n    const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\n    const index = childPids.indexOf(pid);\n    if (index > -1) {\n      childPids.splice(index, 1);\n    }\n\n    const stmt = this.db.prepare(`\n      UPDATE sessions \n      SET child_pids = ?, updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `);\n\n    stmt.run(sessionSerializer.serializeLogData(childPids), sessionId);\n\n    await this.logSessionEvent(sessionId, 'info', 'Child process removed', null, { pid });\n    return true;\n  }\n\n  /**\n   * Get all child PIDs for a session\n   */\n  async getChildPids(sessionId) {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // Use in-memory storage\n      const session = this.memoryStore.sessions.get(sessionId);\n      if (!session || !session.child_pids) return [];\n      return sessionSerializer.deserializeLogData(session.child_pids);\n    } else {\n      // Check if database connection is still open\n      if (!this.db || !this.db.open) {\n        console.warn('Database connection closed, cannot get child PIDs during cleanup');\n        return [];\n      }\n      \n      // Use SQLite\n      const session = this.db.prepare('SELECT child_pids FROM sessions WHERE id = ?').get(sessionId);\n      if (!session || !session.child_pids) return [];\n      return sessionSerializer.deserializeLogData(session.child_pids);\n    }\n  }\n\n  /**\n   * Stop a session and terminate all child processes\n   */\n  async stopSession(sessionId) {\n    const session = await this.getSession(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    // Get child PIDs\n    const childPids = await this.getChildPids(sessionId);\n\n    // Terminate child processes\n    for (const pid of childPids) {\n      try {\n        process.kill(pid, 'SIGTERM');\n        await this.logSessionEvent(sessionId, 'info', 'Child process terminated', null, { pid });\n      } catch (err) {\n        // Process might already be dead\n        await this.logSessionEvent(sessionId, 'warning', 'Failed to terminate child process', null, {\n          pid,\n          error: err.message,\n        });\n      }\n    }\n\n    // Update session status\n    if (this.isInMemory) {\n      // Use in-memory storage\n      const sessionData = this.memoryStore.sessions.get(sessionId);\n      if (sessionData) {\n        sessionData.status = 'stopped';\n        sessionData.updated_at = new Date().toISOString();\n      }\n    } else {\n      // Use SQLite\n      const stmt = this.db.prepare(`\n        UPDATE sessions \n        SET status = 'stopped', updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `);\n\n      stmt.run(sessionId);\n\n      // Update swarm status\n      this.db.prepare('UPDATE swarms SET status = ? WHERE id = ?').run('stopped', session.swarm_id);\n    }\n\n    await this.logSessionEvent(sessionId, 'info', 'Session stopped');\n\n    return true;\n  }\n\n  /**\n   * Get active sessions with process information\n   */\n  async getActiveSessionsWithProcessInfo() {\n    const sessions = await this.getActiveSessions();\n\n    // Add process info to each session\n    return sessions.map((session) => {\n      const childPids = session.child_pids ? sessionSerializer.deserializeLogData(session.child_pids) : [];\n      const aliveChildPids = [];\n\n      // Check which child processes are still alive\n      for (const pid of childPids) {\n        try {\n          process.kill(pid, 0); // Signal 0 just checks if process exists\n          aliveChildPids.push(pid);\n        } catch (err) {\n          // Process is dead\n        }\n      }\n\n      return {\n        ...session,\n        parent_pid: session.parent_pid,\n        child_pids: aliveChildPids,\n        total_processes: 1 + aliveChildPids.length,\n      };\n    });\n  }\n\n  /**\n   * Clean up orphaned processes\n   */\n  async cleanupOrphanedProcesses() {\n    await this.ensureInitialized();\n    \n    if (this.isInMemory) {\n      // In-memory mode doesn't track orphaned processes\n      return 0;\n    }\n    \n    const sessions = this.db\n      .prepare(\n        `\n      SELECT * FROM sessions \n      WHERE status IN ('active', 'paused')\n    `,\n      )\n      .all();\n\n    let cleanedCount = 0;\n\n    for (const session of sessions) {\n      // Check if parent process is still alive\n      try {\n        process.kill(session.parent_pid, 0);\n      } catch (err) {\n        // Parent is dead, clean up session\n        await this.stopSession(session.id);\n        cleanedCount++;\n        await this.logSessionEvent(session.id, 'info', 'Orphaned session cleaned up');\n      }\n    }\n\n    return cleanedCount;\n  }\n\n  /**\n   * Clean up and close database connection\n   */\n  close() {\n    if (this.db && !this.isInMemory) {\n      this.db.close();\n    }\n  }\n}\n\n// Export for use in other modules\nexport default HiveMindSessionManager;\n"],"names":["path","existsSync","mkdirSync","readFile","writeFile","cwd","createDatabase","isSQLiteAvailable","isWindows","sessionSerializer","HiveMindSessionManager","hiveMindDir","join","sessionsDir","dbPath","db","isInMemory","memoryStore","initializationPromise","ensureDirectories","initializeDatabase","sqliteAvailable","console","warn","initializeInMemoryFallback","initializeSchema","Error","error","message","ensureInitialized","sessions","Map","checkpoints","logs","info","recursive","exec","runMigrations","columns","prepare","all","hasObjective","some","col","name","hasSwarmName","hasCheckpointData","hasMetadata","hasParentPid","hasChildPids","hasUpdatedAt","hasPausedAt","hasResumedAt","hasCompletionPercentage","log","createSession","swarmId","swarmName","objective","metadata","sessionId","Date","now","Math","random","toString","substring","sessionData","id","swarm_id","swarm_name","status","created_at","toISOString","updated_at","serializeMetadata","parent_pid","process","pid","child_pids","set","stmt","run","logSessionEvent","parentPid","saveCheckpoint","checkpointName","checkpointData","checkpointId","checkpointEntry","session_id","checkpoint_name","checkpoint_data","serializeCheckpointData","has","get","push","session","updateStmt","checkpointFile","serializeSessionData","timestamp","data","getActiveSessions","agentCount","agents","Array","from","values","filter","a","length","tasks","t","taskCount","completedTasks","inProgressTasks","pendingTasks","deserializeMetadata","deserializeCheckpointData","agent_count","task_count","completed_tasks","in_progress_tasks","pending_tasks","completion_percentage","round","sort","b","map","getSession","swarm","recentLogs","statistics","totalAgents","activeAgents","totalTasks","completionPercentage","cp","pauseSession","paused_at","result","changes","resumeSession","resumed_at","pausedDuration","completeSession","archiveSessions","daysOld","cutoffDate","setDate","getDate","sessionsToArchive","archiveDir","archiveFile","logLevel","agentId","logId","logEntry","log_level","agent_id","serializeLogData","getSessionLogs","limit","offset","slice","deserializeLogData","updateSessionProgress","generateSessionSummary","duration","tasksByType","reduce","acc","agent","agentTasks","type","total","completed","inProgress","pending","checkpointCount","lastCheckpoint","timeline","created","lastUpdated","paused","resumed","exportSession","exportPath","exportFile","importSession","importPath","deserializeSessionData","newSessionId","checkpoint","addChildPid","childPids","includes","removeChildPid","index","indexOf","splice","open","getChildPids","stopSession","kill","err","getActiveSessionsWithProcessInfo","aliveChildPids","total_processes","cleanupOrphanedProcesses","cleanedCount","close"],"mappings":"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"}