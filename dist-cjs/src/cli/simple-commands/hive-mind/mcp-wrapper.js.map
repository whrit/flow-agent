{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/mcp-wrapper.js"],"sourcesContent":["/**\n * MCP Tool Wrapper for Hive Mind System\n * Wraps all 87 MCP tools for coordinated swarm usage\n */\n\nimport { spawn } from 'child_process';\n\n/**\n * MCP Tool categories and their methods\n */\nconst MCP_TOOLS = {\n  swarm: [\n    'swarm_init',\n    'agent_spawn',\n    'task_orchestrate',\n    'swarm_status',\n    'agent_list',\n    'agent_metrics',\n    'swarm_monitor',\n    'topology_optimize',\n    'load_balance',\n    'coordination_sync',\n    'swarm_scale',\n    'swarm_destroy',\n  ],\n  neural: [\n    'neural_status',\n    'neural_train',\n    'neural_patterns',\n    'neural_predict',\n    'model_load',\n    'model_save',\n    'wasm_optimize',\n    'inference_run',\n    'pattern_recognize',\n    'cognitive_analyze',\n    'learning_adapt',\n    'neural_compress',\n    'ensemble_create',\n    'transfer_learn',\n    'neural_explain',\n  ],\n  memory: [\n    'memory_usage',\n    'memory_search',\n    'memory_persist',\n    'memory_namespace',\n    'memory_backup',\n    'memory_restore',\n    'memory_compress',\n    'memory_sync',\n    'cache_manage',\n    'state_snapshot',\n    'context_restore',\n    'memory_analytics',\n  ],\n  performance: [\n    'performance_report',\n    'bottleneck_analyze',\n    'token_usage',\n    'benchmark_run',\n    'metrics_collect',\n    'trend_analysis',\n    'cost_analysis',\n    'quality_assess',\n    'error_analysis',\n    'usage_stats',\n    'health_check',\n  ],\n  github: [\n    'github_repo_analyze',\n    'github_pr_manage',\n    'github_issue_track',\n    'github_release_coord',\n    'github_workflow_auto',\n    'github_code_review',\n    'github_sync_coord',\n    'github_metrics',\n  ],\n  workflow: [\n    'workflow_create',\n    'workflow_execute',\n    'workflow_export',\n    'automation_setup',\n    'pipeline_create',\n    'scheduler_manage',\n    'trigger_setup',\n    'workflow_template',\n    'batch_process',\n    'parallel_execute',\n  ],\n  daa: [\n    'daa_agent_create',\n    'daa_capability_match',\n    'daa_resource_alloc',\n    'daa_lifecycle_manage',\n    'daa_communication',\n    'daa_consensus',\n    'daa_fault_tolerance',\n    'daa_optimization',\n  ],\n  system: [\n    'terminal_execute',\n    'config_manage',\n    'features_detect',\n    'security_scan',\n    'backup_create',\n    'restore_system',\n    'log_analysis',\n    'diagnostic_run',\n  ],\n  sparc: ['sparc_mode'],\n  task: ['task_status', 'task_results'],\n};\n\n/**\n * MCPToolWrapper class for unified MCP tool access\n */\nexport class MCPToolWrapper {\n  constructor(config = {}) {\n    this.config = {\n      parallel: true,\n      timeout: 60000,\n      retryCount: 3,\n      ...config,\n    };\n\n    this.toolStats = new Map();\n    this.parallelQueue = [];\n    this.executing = false;\n\n    /** @type {import('better-sqlite3').Database | null} */\n    this.memoryDb = null;\n    \n    // Initialize memory store for fallback\n    this.memoryStore = new Map();\n\n    // Initialize real memory storage\n    this.initializeMemoryStorage();\n  }\n\n  /**\n   * Initialize real memory storage using SQLite\n   */\n  async initializeMemoryStorage() {\n    try {\n      const { createDatabase, isSQLiteAvailable } = await import('../../../memory/sqlite-wrapper.js');\n      const path = await import('path');\n      const fs = await import('fs');\n\n      // Check if SQLite is available\n      const sqliteAvailable = await isSQLiteAvailable();\n      if (!sqliteAvailable) {\n        throw new Error('SQLite not available');\n      }\n\n      // Create .hive-mind directory if it doesn't exist\n      const hiveMindDir = path.join(process.cwd(), '.hive-mind');\n      if (!fs.existsSync(hiveMindDir)) {\n        fs.mkdirSync(hiveMindDir, { recursive: true });\n      }\n\n      // Initialize SQLite database\n      const dbPath = path.join(hiveMindDir, 'memory.db');\n      this.memoryDb = await createDatabase(dbPath);\n\n      // Create memories table\n      this.memoryDb.exec(`\n        CREATE TABLE IF NOT EXISTS memories (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          namespace TEXT NOT NULL,\n          key TEXT NOT NULL,\n          value TEXT NOT NULL,\n          type TEXT DEFAULT 'knowledge',\n          timestamp INTEGER NOT NULL,\n          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          UNIQUE(namespace, key)\n        )\n      `);\n\n      // Real memory storage initialized with SQLite\n    } catch (error) {\n      console.warn(\n        'Failed to initialize SQLite storage, falling back to in-memory:',\n        error.message,\n      );\n      this.memoryDb = null;\n      this.memoryStore = new Map(); // Fallback to in-memory storage\n      \n      // Log Windows-specific help if applicable\n      if (process.platform === 'win32') {\n        console.info(`\nWindows users: For persistent storage, please see installation guide:\nhttps://github.com/ruvnet/claude-code-flow/docs/windows-installation.md\n`);\n      }\n    }\n  }\n\n  /**\n   * Execute MCP tool with automatic retry and error handling\n   */\n  async executeTool(toolName, params = {}) {\n    const startTime = Date.now();\n    let lastError = null;\n\n    for (let attempt = 1; attempt <= this.config.retryCount; attempt++) {\n      try {\n        const result = await this._executeToolInternal(toolName, params);\n\n        // Track statistics\n        this._trackToolUsage(toolName, Date.now() - startTime, true);\n\n        return result;\n      } catch (error) {\n        lastError = error;\n        console.error(`Attempt ${attempt} failed for ${toolName}:`, error.message);\n\n        if (attempt < this.config.retryCount) {\n          // Exponential backoff\n          await new Promise((resolve) => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n        }\n      }\n    }\n\n    // Track failure\n    this._trackToolUsage(toolName, Date.now() - startTime, false);\n\n    throw new Error(\n      `Failed to execute ${toolName} after ${this.config.retryCount} attempts: ${lastError.message}`,\n    );\n  }\n\n  /**\n   * Execute multiple tools in parallel with optimized batching\n   */\n  async executeParallel(toolCalls) {\n    if (!this.config.parallel) {\n      // Execute sequentially if parallel is disabled\n      const results = [];\n      for (const call of toolCalls) {\n        results.push(await this.executeTool(call.tool, call.params));\n      }\n      return results;\n    }\n\n    if (!Array.isArray(toolCalls) || toolCalls.length === 0) {\n      return [];\n    }\n\n    const startTime = Date.now();\n\n    // Intelligent concurrency limit based on tool types\n    const concurrencyLimit = this._calculateOptimalConcurrency(toolCalls);\n\n    // Group tools by priority and dependency\n    const toolGroups = this._groupToolsByPriority(toolCalls);\n    const allResults = [];\n\n    try {\n      // Execute high-priority tools first\n      for (const group of toolGroups) {\n        const groupResults = [];\n\n        for (let i = 0; i < group.length; i += concurrencyLimit) {\n          const batch = group.slice(i, i + concurrencyLimit);\n\n          // Execute batch with timeout and retry logic\n          const batchPromises = batch.map((call) =>\n            this._executeWithTimeout(call, this.config.timeout),\n          );\n\n          const batchResults = await Promise.allSettled(batchPromises);\n\n          // Process results and handle failures\n          for (let j = 0; j < batchResults.length; j++) {\n            const result = batchResults[j];\n            if (result.status === 'fulfilled') {\n              groupResults.push(result.value);\n            } else {\n              console.warn(`Tool execution failed: ${batch[j].tool}`, result.reason);\n              groupResults.push({ error: result.reason.message, tool: batch[j].tool });\n            }\n          }\n        }\n\n        allResults.push(...groupResults);\n      }\n\n      // Track performance metrics\n      const executionTime = Date.now() - startTime;\n      this._trackBatchPerformance(toolCalls.length, executionTime, concurrencyLimit);\n\n      return allResults;\n    } catch (error) {\n      console.error('Parallel execution failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate optimal concurrency based on tool types\n   */\n  _calculateOptimalConcurrency(toolCalls) {\n    const toolTypes = toolCalls.map((call) => this._getToolCategory(call.tool));\n    const uniqueTypes = new Set(toolTypes);\n\n    // Heavy operations (neural, github) need lower concurrency\n    const heavyTypes = ['neural', 'github', 'workflow'];\n    const hasHeavyOps = toolTypes.some((type) => heavyTypes.includes(type));\n\n    if (hasHeavyOps) {\n      return Math.min(3, Math.max(1, Math.floor(toolCalls.length / 2)));\n    }\n\n    // Light operations (memory, performance) can handle higher concurrency\n    return Math.min(8, Math.max(2, Math.floor(toolCalls.length / 1.5)));\n  }\n\n  /**\n   * Group tools by execution priority\n   */\n  _groupToolsByPriority(toolCalls) {\n    const priorities = {\n      critical: [], // swarm_init, swarm_destroy\n      high: [], // agent_spawn, memory operations\n      medium: [], // task operations, monitoring\n      low: [], // analytics, reporting\n    };\n\n    toolCalls.forEach((call) => {\n      const category = this._getToolCategory(call.tool);\n      const tool = call.tool;\n\n      if (['swarm_init', 'swarm_destroy', 'memory_backup'].includes(tool)) {\n        priorities.critical.push(call);\n      } else if (['agent_spawn', 'memory_usage', 'neural_train'].includes(tool)) {\n        priorities.high.push(call);\n      } else if (category === 'performance' || tool.includes('report')) {\n        priorities.low.push(call);\n      } else {\n        priorities.medium.push(call);\n      }\n    });\n\n    // Return groups in priority order, filtering empty groups\n    return [priorities.critical, priorities.high, priorities.medium, priorities.low].filter(\n      (group) => group.length > 0,\n    );\n  }\n\n  /**\n   * Execute tool with timeout wrapper\n   */\n  async _executeWithTimeout(call, timeout) {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Tool ${call.tool} timed out after ${timeout}ms`));\n      }, timeout);\n\n      this.executeTool(call.tool, call.params)\n        .then((result) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((error) => {\n          clearTimeout(timer);\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Track batch execution performance\n   */\n  _trackBatchPerformance(toolCount, executionTime, concurrency) {\n    if (!this.batchStats) {\n      this.batchStats = {\n        totalBatches: 0,\n        totalTools: 0,\n        totalTime: 0,\n        avgConcurrency: 0,\n        avgToolsPerBatch: 0,\n        avgTimePerTool: 0,\n      };\n    }\n\n    this.batchStats.totalBatches++;\n    this.batchStats.totalTools += toolCount;\n    this.batchStats.totalTime += executionTime;\n    this.batchStats.avgConcurrency =\n      (this.batchStats.avgConcurrency * (this.batchStats.totalBatches - 1) + concurrency) /\n      this.batchStats.totalBatches;\n    this.batchStats.avgToolsPerBatch = this.batchStats.totalTools / this.batchStats.totalBatches;\n    this.batchStats.avgTimePerTool = this.batchStats.totalTime / this.batchStats.totalTools;\n  }\n\n  /**\n   * Internal tool execution\n   */\n  async _executeToolInternal(toolName, params) {\n    const toolCategory = this._getToolCategory(toolName);\n    if (!toolCategory) {\n      throw new Error(`Unknown MCP tool: ${toolName}`);\n    }\n\n    // Handle memory operations with real storage\n    if (toolName === 'memory_usage') {\n      if (params.action === 'store') {\n        return await this.storeMemory(params.namespace, params.key, params.value, params.type);\n      } else if (params.action === 'retrieve') {\n        return await this.retrieveMemory(params.namespace, params.key);\n      }\n    } else if (toolName === 'memory_search') {\n      return await this.searchMemory(params.namespace, params.pattern);\n    } else if (toolName === 'swarm_status') {\n      return await this.getSwarmStatus(params);\n    }\n\n    // For other tools, use mock responses\n    console.log(`Executing MCP tool: mcp__claude-flow__${toolName} with params:`, params);\n\n    // Simulate async execution for non-memory tools\n    await new Promise((resolve) => setTimeout(resolve, Math.random() * 500));\n\n    // Mock response based on tool type\n    const mockResponse = this._getMockResponse(toolName, params);\n    return mockResponse;\n  }\n\n  /**\n   * Get tool category\n   */\n  _getToolCategory(toolName) {\n    for (const [category, tools] of Object.entries(MCP_TOOLS)) {\n      if (tools.includes(toolName)) {\n        return category;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get mock response for demonstration\n   */\n  _getMockResponse(toolName, params) {\n    // Mock responses for different tool types\n    const mockResponses = {\n      swarm_init: {\n        swarmId: `swarm-${Date.now()}`,\n        topology: params.topology || 'hierarchical',\n        status: 'initialized',\n      },\n      agent_spawn: {\n        agentId: `agent-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,\n        type: params.type,\n        status: 'active',\n      },\n      task_orchestrate: {\n        taskId: `task-${Date.now()}`,\n        status: 'orchestrated',\n        strategy: params.strategy || 'parallel',\n      },\n      memory_usage: {\n        action: params.action,\n        result: params.action === 'store' ? 'stored' : 'retrieved',\n        data: params.value || null,\n      },\n      neural_status: {\n        status: 'ready',\n        models: 27,\n        accuracy: 0.848,\n      },\n    };\n\n    return mockResponses[toolName] || { status: 'success', toolName };\n  }\n\n  /**\n   * Track tool usage statistics\n   */\n  _trackToolUsage(toolName, duration, success) {\n    if (!this.toolStats.has(toolName)) {\n      this.toolStats.set(toolName, {\n        calls: 0,\n        successes: 0,\n        failures: 0,\n        totalDuration: 0,\n        avgDuration: 0,\n      });\n    }\n\n    const stats = this.toolStats.get(toolName);\n    stats.calls++;\n    if (success) {\n      stats.successes++;\n    } else {\n      stats.failures++;\n    }\n    stats.totalDuration += duration;\n    stats.avgDuration = stats.totalDuration / stats.calls;\n  }\n\n  /**\n   * Get comprehensive tool statistics\n   */\n  getStatistics() {\n    const toolStats = {};\n    this.toolStats.forEach((value, key) => {\n      toolStats[key] = { ...value };\n    });\n\n    return {\n      tools: toolStats,\n      batch: this.batchStats || {\n        totalBatches: 0,\n        totalTools: 0,\n        totalTime: 0,\n        avgConcurrency: 0,\n        avgToolsPerBatch: 0,\n        avgTimePerTool: 0,\n      },\n      spawn: this.spawnStats || {\n        totalSpawns: 0,\n        totalAgents: 0,\n        totalTime: 0,\n        avgTimePerAgent: 0,\n        bestTime: 0,\n        worstTime: 0,\n      },\n      performance: {\n        totalCalls: Array.from(this.toolStats.values()).reduce((sum, stat) => sum + stat.calls, 0),\n        successRate: this._calculateOverallSuccessRate(),\n        avgLatency: this._calculateAvgLatency(),\n        throughput: this._calculateThroughput(),\n      },\n    };\n  }\n\n  /**\n   * Calculate overall success rate\n   */\n  _calculateOverallSuccessRate() {\n    const total = Array.from(this.toolStats.values()).reduce((sum, stat) => sum + stat.calls, 0);\n    const successes = Array.from(this.toolStats.values()).reduce(\n      (sum, stat) => sum + stat.successes,\n      0,\n    );\n\n    return total > 0 ? ((successes / total) * 100).toFixed(2) : 100;\n  }\n\n  /**\n   * Calculate average latency\n   */\n  _calculateAvgLatency() {\n    const stats = Array.from(this.toolStats.values()).filter((stat) => stat.calls > 0);\n    if (stats.length === 0) return 0;\n\n    const totalLatency = stats.reduce((sum, stat) => sum + stat.avgDuration, 0);\n    return (totalLatency / stats.length).toFixed(2);\n  }\n\n  /**\n   * Calculate throughput (operations per second)\n   */\n  _calculateThroughput() {\n    const batchStats = this.batchStats;\n    if (!batchStats || batchStats.totalTime === 0) return 0;\n\n    return (batchStats.totalTools / (batchStats.totalTime / 1000)).toFixed(2);\n  }\n\n  /**\n   * Create batch of tool calls for parallel execution\n   */\n  createBatch(calls) {\n    return calls.map((call) => ({\n      tool: call.tool,\n      params: call.params || {},\n    }));\n  }\n\n  /**\n   * Execute swarm initialization sequence with optimization\n   */\n  async initializeSwarm(config) {\n    const swarmId = config.swarmId || `swarm-${Date.now()}`;\n    const startTime = Date.now();\n\n    try {\n      // Phase 1: Critical initialization (sequential)\n      const criticalOps = [\n        {\n          tool: 'swarm_init',\n          params: {\n            topology: config.topology || 'hierarchical',\n            maxAgents: config.maxAgents || 8,\n            strategy: 'auto',\n            swarmId,\n          },\n        },\n      ];\n\n      const [swarmInitResult] = await this.executeParallel(criticalOps);\n\n      // Phase 2: Supporting services (parallel)\n      const supportingOps = [\n        {\n          tool: 'memory_namespace',\n          params: {\n            action: 'create',\n            namespace: swarmId,\n            maxSize: config.memorySize || 100,\n          },\n        },\n        { tool: 'neural_status', params: {} },\n        { tool: 'performance_report', params: { format: 'summary' } },\n        { tool: 'features_detect', params: { component: 'swarm' } },\n      ];\n\n      const supportingResults = await this.executeParallel(supportingOps);\n\n      // Store initialization metadata\n      const initTime = Date.now() - startTime;\n      await this.storeMemory(\n        swarmId,\n        'init_performance',\n        {\n          initTime,\n          topology: config.topology || 'hierarchical',\n          maxAgents: config.maxAgents || 8,\n          timestamp: Date.now(),\n        },\n        'metrics',\n      );\n\n      // Store swarm status\n      await this.storeMemory(\n        swarmId,\n        'status',\n        'active',\n        'status',\n      );\n\n      // Store swarm config\n      await this.storeMemory(\n        swarmId,\n        'config',\n        {\n          topology: config.topology || 'hierarchical',\n          maxAgents: config.maxAgents || 8,\n          strategy: config.strategy || 'auto',\n          createdAt: Date.now(),\n        },\n        'config',\n      );\n\n      return [swarmInitResult, ...supportingResults];\n    } catch (error) {\n      console.error('Swarm initialization failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Spawn multiple agents in parallel with optimization\n   */\n  async spawnAgents(types, swarmId) {\n    if (!Array.isArray(types) || types.length === 0) {\n      return [];\n    }\n\n    const startTime = Date.now();\n\n    // Optimize agent spawning by grouping similar types\n    const groupedTypes = this._groupAgentTypes(types);\n    const allResults = [];\n\n    try {\n      // Spawn each group in parallel\n      for (const group of groupedTypes) {\n        const batch = group.map((type) => ({\n          tool: 'agent_spawn',\n          params: {\n            type,\n            swarmId,\n            timestamp: Date.now(),\n            batchId: `batch-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          },\n        }));\n\n        const groupResults = await this.executeParallel(batch);\n        allResults.push(...groupResults);\n\n        // Store agent information in memory\n        for (const result of groupResults) {\n          if (result && result.agentId && !result.error) {\n            await this.storeMemory(\n              swarmId,\n              `agent-${result.agentId}`,\n              {\n                id: result.agentId,\n                type: result.type,\n                status: result.status || 'active',\n                createdAt: Date.now(),\n              },\n              'agent',\n            );\n          }\n        }\n      }\n\n      // Track spawn performance\n      const spawnTime = Date.now() - startTime;\n      this._trackSpawnPerformance(types.length, spawnTime);\n\n      return allResults;\n    } catch (error) {\n      console.error('Agent spawning failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Group agent types for optimized spawning\n   */\n  _groupAgentTypes(types) {\n    // Group complementary agent types that work well together\n    const groups = {\n      development: ['coder', 'architect', 'reviewer'],\n      analysis: ['researcher', 'analyst', 'optimizer'],\n      quality: ['tester', 'documenter'],\n      coordination: ['coordinator'],\n    };\n\n    const result = [];\n    const remaining = [...types];\n\n    // Create groups of complementary agents\n    Object.values(groups).forEach((groupTypes) => {\n      const groupAgents = remaining.filter((type) => groupTypes.includes(type));\n      if (groupAgents.length > 0) {\n        result.push(groupAgents);\n        groupAgents.forEach((type) => {\n          const index = remaining.indexOf(type);\n          if (index > -1) remaining.splice(index, 1);\n        });\n      }\n    });\n\n    // Add remaining agents as individual groups\n    remaining.forEach((type) => result.push([type]));\n\n    return result;\n  }\n\n  /**\n   * Track agent spawn performance\n   */\n  _trackSpawnPerformance(agentCount, spawnTime) {\n    if (!this.spawnStats) {\n      this.spawnStats = {\n        totalSpawns: 0,\n        totalAgents: 0,\n        totalTime: 0,\n        avgTimePerAgent: 0,\n        bestTime: Infinity,\n        worstTime: 0,\n      };\n    }\n\n    this.spawnStats.totalSpawns++;\n    this.spawnStats.totalAgents += agentCount;\n    this.spawnStats.totalTime += spawnTime;\n    this.spawnStats.avgTimePerAgent = this.spawnStats.totalTime / this.spawnStats.totalAgents;\n    this.spawnStats.bestTime = Math.min(this.spawnStats.bestTime, spawnTime);\n    this.spawnStats.worstTime = Math.max(this.spawnStats.worstTime, spawnTime);\n  }\n\n  /**\n   * Store data in collective memory (REAL IMPLEMENTATION)\n   */\n  async storeMemory(swarmId, key, value, type = 'knowledge') {\n    try {\n      // Don't reinitialize if we already have storage\n      if (!this.memoryDb && !this.memoryStore) {\n        await this.initializeMemoryStorage();\n      }\n\n      const timestamp = Date.now();\n      const valueStr = typeof value === 'string' ? value : JSON.stringify(value);\n\n      if (this.memoryDb) {\n        // SQLite storage\n        const stmt = this.memoryDb.prepare(`\n          INSERT OR REPLACE INTO memories (namespace, key, value, type, timestamp)\n          VALUES (?, ?, ?, ?, ?)\n        `);\n\n        const result = stmt.run(swarmId, key, valueStr, type, timestamp);\n\n        return {\n          success: true,\n          action: 'store',\n          namespace: swarmId,\n          key,\n          type,\n          timestamp,\n          id: result.lastInsertRowid,\n        };\n      } else {\n        // Fallback in-memory storage\n        const memoryKey = `${swarmId}:${key}`;\n        this.memoryStore.set(memoryKey, {\n          namespace: swarmId,\n          key,\n          value: valueStr,\n          type,\n          timestamp,\n        });\n\n        return {\n          success: true,\n          action: 'store',\n          namespace: swarmId,\n          key,\n          type,\n          timestamp,\n        };\n      }\n    } catch (error) {\n      console.error('Error storing memory:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from collective memory (REAL IMPLEMENTATION)\n   */\n  async retrieveMemory(swarmId, key) {\n    try {\n      // Don't reinitialize if we already have storage\n      if (!this.memoryDb && !this.memoryStore) {\n        await this.initializeMemoryStorage();\n      }\n\n      if (this.memoryDb) {\n        // SQLite retrieval\n        const stmt = this.memoryDb.prepare(`\n          SELECT * FROM memories WHERE namespace = ? AND key = ?\n        `);\n\n        const row = stmt.get(swarmId, key);\n        if (row) {\n          try {\n            return {\n              ...row,\n              value: JSON.parse(row.value),\n            };\n          } catch {\n            return row;\n          }\n        }\n      } else {\n        // Fallback in-memory retrieval\n        const memoryKey = `${swarmId}:${key}`;\n        const memory = this.memoryStore.get(memoryKey);\n        if (memory) {\n          try {\n            return {\n              ...memory,\n              value: JSON.parse(memory.value),\n            };\n          } catch {\n            return memory;\n          }\n        }\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error retrieving memory:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search collective memory (REAL IMPLEMENTATION)\n   */\n  async searchMemory(swarmId, pattern) {\n    try {\n      // Don't reinitialize if we already have storage\n      if (!this.memoryDb && !this.memoryStore) {\n        await this.initializeMemoryStorage();\n      }\n\n      let results = [];\n\n      if (this.memoryDb) {\n        // SQLite search\n        let query, params;\n\n        if (pattern && pattern.trim()) {\n          // Search with pattern\n          query = `\n            SELECT * FROM memories \n            WHERE namespace = ? AND (key LIKE ? OR value LIKE ? OR type LIKE ?)\n            ORDER BY timestamp DESC\n            LIMIT 50\n          `;\n          const searchPattern = `%${pattern}%`;\n          params = [swarmId, searchPattern, searchPattern, searchPattern];\n        } else {\n          // Get all memories for namespace\n          query = `\n            SELECT * FROM memories \n            WHERE namespace = ?\n            ORDER BY timestamp DESC\n            LIMIT 50\n          `;\n          params = [swarmId];\n        }\n\n        const stmt = this.memoryDb.prepare(query);\n        results = stmt.all(...params);\n\n        // Parse JSON values where possible\n        results = results.map((row) => {\n          try {\n            return {\n              ...row,\n              value: JSON.parse(row.value),\n            };\n          } catch {\n            return row;\n          }\n        });\n      } else {\n        // Fallback in-memory search\n        for (const [memKey, memory] of this.memoryStore) {\n          if (memory.namespace === swarmId) {\n            if (\n              !pattern ||\n              memory.key.includes(pattern) ||\n              memory.value.includes(pattern) ||\n              memory.type.includes(pattern)\n            ) {\n              try {\n                results.push({\n                  ...memory,\n                  value: JSON.parse(memory.value),\n                });\n              } catch {\n                results.push(memory);\n              }\n            }\n          }\n        }\n\n        // Sort by timestamp descending\n        results.sort((a, b) => b.timestamp - a.timestamp);\n        results = results.slice(0, 50);\n      }\n\n      return {\n        success: true,\n        namespace: swarmId,\n        pattern: pattern || '',\n        total: results.length,\n        results: results,\n      };\n    } catch (error) {\n      console.error('Error searching memory:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Orchestrate task with monitoring and optimization\n   */\n  async orchestrateTask(task, strategy = 'parallel', metadata = {}) {\n    const taskId = metadata.taskId || `task-${Date.now()}`;\n    const swarmId = metadata.swarmId || 'default-swarm';\n    const complexity = metadata.complexity || 'medium';\n\n    // Store task information\n    await this.storeMemory(\n      swarmId,\n      `task-${taskId}`,\n      {\n        id: taskId,\n        task,\n        strategy,\n        status: 'pending',\n        priority: metadata.priority || 5,\n        complexity,\n        createdAt: Date.now(),\n      },\n      'task',\n    );\n\n    // Adjust monitoring frequency based on task complexity\n    const monitoringInterval =\n      {\n        low: 10000,\n        medium: 5000,\n        high: 2000,\n      }[complexity] || 5000;\n\n    const batch = [\n      {\n        tool: 'task_orchestrate',\n        params: {\n          task,\n          strategy,\n          taskId,\n          priority: metadata.priority || 5,\n          estimatedDuration: metadata.estimatedDuration || 30000,\n        },\n      },\n      {\n        tool: 'swarm_monitor',\n        params: {\n          interval: monitoringInterval,\n          taskId,\n          metrics: ['performance', 'progress', 'bottlenecks'],\n        },\n      },\n      // Add performance tracking for high-priority tasks\n      ...(metadata.priority > 7\n        ? [\n            {\n              tool: 'performance_report',\n              params: { format: 'detailed', taskId },\n            },\n          ]\n        : []),\n    ];\n\n    const results = await this.executeParallel(batch);\n\n    // Update task status\n    await this.storeMemory(\n      swarmId,\n      `task-${taskId}`,\n      {\n        id: taskId,\n        task,\n        strategy,\n        status: 'in_progress',\n        priority: metadata.priority || 5,\n        complexity,\n        createdAt: Date.now(),\n      },\n      'task',\n    );\n\n    return results;\n  }\n\n  /**\n   * Analyze performance bottlenecks\n   */\n  async analyzePerformance(swarmId) {\n    const batch = [\n      { tool: 'bottleneck_analyze', params: { component: swarmId } },\n      { tool: 'performance_report', params: { format: 'detailed' } },\n      { tool: 'token_usage', params: { operation: swarmId } },\n    ];\n\n    return await this.executeParallel(batch);\n  }\n\n  /**\n   * GitHub integration for code operations\n   */\n  async githubOperations(repo, operation, params = {}) {\n    const githubTools = {\n      analyze: 'github_repo_analyze',\n      pr: 'github_pr_manage',\n      issue: 'github_issue_track',\n      review: 'github_code_review',\n    };\n\n    const tool = githubTools[operation];\n    if (!tool) {\n      throw new Error(`Unknown GitHub operation: ${operation}`);\n    }\n\n    return await this.executeTool(tool, { repo, ...params });\n  }\n\n  /**\n   * Neural network operations\n   */\n  async neuralOperation(operation, params = {}) {\n    const neuralTools = {\n      train: 'neural_train',\n      predict: 'neural_predict',\n      analyze: 'neural_patterns',\n      optimize: 'wasm_optimize',\n    };\n\n    const tool = neuralTools[operation];\n    if (!tool) {\n      throw new Error(`Unknown neural operation: ${operation}`);\n    }\n\n    return await this.executeTool(tool, params);\n  }\n\n  /**\n   * Clean up and destroy swarm\n   */\n  async destroySwarm(swarmId) {\n    const batch = [\n      { tool: 'swarm_destroy', params: { swarmId } },\n      {\n        tool: 'memory_namespace',\n        params: {\n          action: 'delete',\n          namespace: swarmId,\n        },\n      },\n      {\n        tool: 'cache_manage',\n        params: {\n          action: 'clear',\n          key: `swarm-${swarmId}`,\n        },\n      },\n    ];\n\n    return await this.executeParallel(batch);\n  }\n\n  /**\n   * Get real swarm status from memory storage\n   */\n  async getSwarmStatus(params = {}) {\n    try {\n      // Don't reinitialize if we already have storage\n      if (!this.memoryDb && !this.memoryStore) {\n        await this.initializeMemoryStorage();\n      }\n\n      const swarms = [];\n      let activeAgents = 0;\n      let totalTasks = 0;\n      let completedTasks = 0;\n\n      if (this.memoryDb) {\n        // Get all unique swarm namespaces\n        const namespacesQuery = this.memoryDb.prepare(`\n          SELECT DISTINCT namespace FROM memories \n          WHERE namespace LIKE 'swarm-%' OR namespace LIKE 'hive-%'\n          ORDER BY timestamp DESC\n        `);\n        const namespaces = namespacesQuery.all();\n\n        // For each swarm, gather its information\n        for (const { namespace } of namespaces) {\n          const swarmId = namespace;\n          \n          // Get swarm metadata\n          const metadataQuery = this.memoryDb.prepare(`\n            SELECT key, value, type, timestamp FROM memories \n            WHERE namespace = ? AND (\n              key IN ('init_performance', 'config', 'status', 'agents', 'tasks', 'topology')\n              OR key LIKE 'agent-%'\n              OR key LIKE 'task-%'\n            )\n          `);\n          const swarmData = metadataQuery.all(swarmId);\n\n          // Parse swarm information\n          let swarmInfo = {\n            id: swarmId,\n            name: swarmId,\n            status: 'unknown',\n            agents: 0,\n            tasks: { total: 0, completed: 0, pending: 0, failed: 0 },\n            topology: 'hierarchical',\n            createdAt: null,\n            lastActivity: null,\n            memoryUsage: swarmData.length\n          };\n\n          // Process swarm data\n          for (const record of swarmData) {\n            try {\n              const value = typeof record.value === 'string' ? JSON.parse(record.value) : record.value;\n              \n              switch (record.key) {\n                case 'init_performance':\n                  swarmInfo.createdAt = value.timestamp;\n                  swarmInfo.topology = value.topology || 'hierarchical';\n                  break;\n                case 'status':\n                  swarmInfo.status = value;\n                  break;\n                case 'config':\n                  swarmInfo.topology = value.topology || swarmInfo.topology;\n                  break;\n              }\n\n              // Count agents\n              if (record.key.startsWith('agent-')) {\n                swarmInfo.agents++;\n                activeAgents++;\n              }\n\n              // Count tasks\n              if (record.key.startsWith('task-')) {\n                swarmInfo.tasks.total++;\n                totalTasks++;\n                if (value.status === 'completed') {\n                  swarmInfo.tasks.completed++;\n                  completedTasks++;\n                } else if (value.status === 'failed') {\n                  swarmInfo.tasks.failed++;\n                } else if (value.status === 'pending' || value.status === 'in_progress') {\n                  swarmInfo.tasks.pending++;\n                }\n              }\n\n              // Track last activity\n              if (record.timestamp > (swarmInfo.lastActivity || 0)) {\n                swarmInfo.lastActivity = record.timestamp;\n              }\n            } catch (e) {\n              // Skip invalid JSON values\n            }\n          }\n\n          // Determine swarm status based on activity\n          if (swarmInfo.status === 'unknown') {\n            const now = Date.now();\n            const lastActivityAge = now - (swarmInfo.lastActivity || 0);\n            \n            if (lastActivityAge < 60000) { // Active within last minute\n              swarmInfo.status = 'active';\n            } else if (lastActivityAge < 300000) { // Active within last 5 minutes\n              swarmInfo.status = 'idle';\n            } else {\n              swarmInfo.status = 'inactive';\n            }\n          }\n\n          swarms.push(swarmInfo);\n        }\n\n        // Get recent activity logs\n        const activityQuery = this.memoryDb.prepare(`\n          SELECT namespace, key, type, timestamp FROM memories \n          WHERE (namespace LIKE 'swarm-%' OR namespace LIKE 'hive-%')\n          AND timestamp > ?\n          ORDER BY timestamp DESC\n          LIMIT 10\n        `);\n        const recentActivity = activityQuery.all(Date.now() - 300000); // Last 5 minutes\n\n        return {\n          swarms,\n          activeAgents,\n          totalTasks,\n          completedTasks,\n          pendingTasks: totalTasks - completedTasks,\n          recentActivity: recentActivity.map(r => ({\n            swarmId: r.namespace,\n            action: r.key,\n            type: r.type,\n            timestamp: r.timestamp\n          })),\n          summary: {\n            totalSwarms: swarms.length,\n            activeSwarms: swarms.filter(s => s.status === 'active').length,\n            idleSwarms: swarms.filter(s => s.status === 'idle').length,\n            inactiveSwarms: swarms.filter(s => s.status === 'inactive').length\n          }\n        };\n      } else {\n        // Fallback to in-memory storage\n        const swarmMap = new Map();\n        \n        for (const [key, memory] of this.memoryStore) {\n          const namespace = memory.namespace;\n          if (namespace && (namespace.startsWith('swarm-') || namespace.startsWith('hive-'))) {\n            if (!swarmMap.has(namespace)) {\n              swarmMap.set(namespace, {\n                id: namespace,\n                name: namespace,\n                status: 'active',\n                agents: 0,\n                tasks: { total: 0, completed: 0, pending: 0, failed: 0 },\n                memoryUsage: 0\n              });\n            }\n            \n            const swarm = swarmMap.get(namespace);\n            swarm.memoryUsage++;\n            \n            if (memory.key.startsWith('agent-')) {\n              swarm.agents++;\n              activeAgents++;\n            }\n            \n            if (memory.key.startsWith('task-')) {\n              swarm.tasks.total++;\n              totalTasks++;\n              try {\n                const taskData = JSON.parse(memory.value);\n                if (taskData.status === 'completed') {\n                  swarm.tasks.completed++;\n                  completedTasks++;\n                } else if (taskData.status === 'failed') {\n                  swarm.tasks.failed++;\n                } else if (taskData.status === 'pending' || taskData.status === 'in_progress') {\n                  swarm.tasks.pending++;\n                }\n              } catch (e) {\n                // Skip invalid JSON\n              }\n            }\n          }\n        }\n        \n        return {\n          swarms: Array.from(swarmMap.values()),\n          activeAgents,\n          totalTasks,\n          completedTasks,\n          pendingTasks: totalTasks - completedTasks,\n          summary: {\n            totalSwarms: swarmMap.size,\n            activeSwarms: swarmMap.size\n          }\n        };\n      }\n    } catch (error) {\n      console.error('Error getting swarm status:', error);\n      // Return empty status on error\n      return {\n        swarms: [],\n        activeAgents: 0,\n        totalTasks: 0,\n        completedTasks: 0,\n        pendingTasks: 0,\n        recentActivity: [],\n        summary: {\n          totalSwarms: 0,\n          activeSwarms: 0,\n          idleSwarms: 0,\n          inactiveSwarms: 0\n        },\n        error: error.message\n      };\n    }\n  }\n}\n\n// Export tool categories for reference\nexport { MCP_TOOLS };\n"],"names":["MCP_TOOLS","swarm","neural","memory","performance","github","workflow","daa","system","sparc","task","MCPToolWrapper","config","parallel","timeout","retryCount","toolStats","Map","parallelQueue","executing","memoryDb","memoryStore","initializeMemoryStorage","createDatabase","isSQLiteAvailable","path","fs","sqliteAvailable","Error","hiveMindDir","join","process","cwd","existsSync","mkdirSync","recursive","dbPath","exec","error","console","warn","message","platform","info","executeTool","toolName","params","startTime","Date","now","lastError","attempt","result","_executeToolInternal","_trackToolUsage","Promise","resolve","setTimeout","Math","pow","executeParallel","toolCalls","results","call","push","tool","Array","isArray","length","concurrencyLimit","_calculateOptimalConcurrency","toolGroups","_groupToolsByPriority","allResults","group","groupResults","i","batch","slice","batchPromises","map","_executeWithTimeout","batchResults","allSettled","j","status","value","reason","executionTime","_trackBatchPerformance","toolTypes","_getToolCategory","uniqueTypes","Set","heavyTypes","hasHeavyOps","some","type","includes","min","max","floor","priorities","critical","high","medium","low","forEach","category","filter","reject","timer","then","clearTimeout","catch","toolCount","concurrency","batchStats","totalBatches","totalTools","totalTime","avgConcurrency","avgToolsPerBatch","avgTimePerTool","toolCategory","action","storeMemory","namespace","key","retrieveMemory","searchMemory","pattern","getSwarmStatus","log","random","mockResponse","_getMockResponse","tools","Object","entries","mockResponses","swarm_init","swarmId","topology","agent_spawn","agentId","toString","substring","task_orchestrate","taskId","strategy","memory_usage","data","neural_status","models","accuracy","duration","success","has","set","calls","successes","failures","totalDuration","avgDuration","stats","get","getStatistics","spawn","spawnStats","totalSpawns","totalAgents","avgTimePerAgent","bestTime","worstTime","totalCalls","from","values","reduce","sum","stat","successRate","_calculateOverallSuccessRate","avgLatency","_calculateAvgLatency","throughput","_calculateThroughput","total","toFixed","totalLatency","createBatch","initializeSwarm","criticalOps","maxAgents","swarmInitResult","supportingOps","maxSize","memorySize","format","component","supportingResults","initTime","timestamp","createdAt","spawnAgents","types","groupedTypes","_groupAgentTypes","batchId","substr","id","spawnTime","_trackSpawnPerformance","groups","development","analysis","quality","coordination","remaining","groupTypes","groupAgents","index","indexOf","splice","agentCount","Infinity","valueStr","JSON","stringify","stmt","prepare","run","lastInsertRowid","memoryKey","row","parse","query","trim","searchPattern","all","memKey","sort","a","b","orchestrateTask","metadata","complexity","priority","monitoringInterval","estimatedDuration","interval","metrics","analyzePerformance","operation","githubOperations","repo","githubTools","analyze","pr","issue","review","neuralOperation","neuralTools","train","predict","optimize","destroySwarm","swarms","activeAgents","totalTasks","completedTasks","namespacesQuery","namespaces","metadataQuery","swarmData","swarmInfo","name","agents","tasks","completed","pending","failed","lastActivity","memoryUsage","record","startsWith","e","lastActivityAge","activityQuery","recentActivity","pendingTasks","r","summary","totalSwarms","activeSwarms","s","idleSwarms","inactiveSwarms","swarmMap","taskData","size"],"mappings":"AAUA,MAAMA,YAAY;IAChBC,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,QAAQ;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,QAAQ;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,aAAa;QACX;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,QAAQ;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,UAAU;QACR;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,KAAK;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,QAAQ;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACDC,OAAO;QAAC;KAAa;IACrBC,MAAM;QAAC;QAAe;KAAe;AACvC;AAKA,OAAO,MAAMC;IACX,YAAYC,SAAS,CAAC,CAAC,CAAE;QACvB,IAAI,CAACA,MAAM,GAAG;YACZC,UAAU;YACVC,SAAS;YACTC,YAAY;YACZ,GAAGH,MAAM;QACX;QAEA,IAAI,CAACI,SAAS,GAAG,IAAIC;QACrB,IAAI,CAACC,aAAa,GAAG,EAAE;QACvB,IAAI,CAACC,SAAS,GAAG;QAGjB,IAAI,CAACC,QAAQ,GAAG;QAGhB,IAAI,CAACC,WAAW,GAAG,IAAIJ;QAGvB,IAAI,CAACK,uBAAuB;IAC9B;IAKA,MAAMA,0BAA0B;QAC9B,IAAI;YACF,MAAM,EAAEC,cAAc,EAAEC,iBAAiB,EAAE,GAAG,MAAM,MAAM,CAAC;YAC3D,MAAMC,OAAO,MAAM,MAAM,CAAC;YAC1B,MAAMC,KAAK,MAAM,MAAM,CAAC;YAGxB,MAAMC,kBAAkB,MAAMH;YAC9B,IAAI,CAACG,iBAAiB;gBACpB,MAAM,IAAIC,MAAM;YAClB;YAGA,MAAMC,cAAcJ,KAAKK,IAAI,CAACC,QAAQC,GA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"}