{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/performance-optimizer.js"],"sourcesContent":["/**\n * Performance Optimizer for Hive Mind System\n * Implements advanced performance optimizations including:\n * - Async operation optimization\n * - Connection pooling management\n * - Batch operation coordination\n * - Performance monitoring and auto-tuning\n */\n\nimport EventEmitter from 'events';\nimport { performance } from 'perf_hooks';\n\n/**\n * AsyncOperationQueue for managing concurrent operations\n */\nclass AsyncOperationQueue {\n  constructor(maxConcurrency = 10, timeout = 30000) {\n    this.maxConcurrency = maxConcurrency;\n    this.timeout = timeout;\n    this.running = 0;\n    this.queue = [];\n    this.results = new Map();\n    this.metrics = {\n      processed: 0,\n      failures: 0,\n      avgProcessingTime: 0,\n      totalProcessingTime: 0,\n    };\n  }\n\n  async add(operation, priority = 5) {\n    return new Promise((resolve, reject) => {\n      const queueItem = {\n        operation,\n        priority,\n        resolve,\n        reject,\n        addedAt: Date.now(),\n        id: `op-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      };\n\n      // Insert based on priority (higher priority first)\n      const insertIndex = this.queue.findIndex((item) => item.priority < priority);\n      if (insertIndex === -1) {\n        this.queue.push(queueItem);\n      } else {\n        this.queue.splice(insertIndex, 0, queueItem);\n      }\n\n      this._processQueue();\n    });\n  }\n\n  async _processQueue() {\n    if (this.running >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n\n    const item = this.queue.shift();\n    this.running++;\n\n    const startTime = performance.now();\n\n    try {\n      // Add timeout wrapper\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Operation timeout')), this.timeout);\n      });\n\n      const result = await Promise.race([item.operation(), timeoutPromise]);\n\n      const processingTime = performance.now() - startTime;\n      this._updateMetrics(processingTime, true);\n\n      item.resolve(result);\n    } catch (error) {\n      const processingTime = performance.now() - startTime;\n      this._updateMetrics(processingTime, false);\n\n      item.reject(error);\n    } finally {\n      this.running--;\n      setImmediate(() => this._processQueue());\n    }\n  }\n\n  _updateMetrics(processingTime, success) {\n    this.metrics.processed++;\n    this.metrics.totalProcessingTime += processingTime;\n    this.metrics.avgProcessingTime = this.metrics.totalProcessingTime / this.metrics.processed;\n\n    if (!success) {\n      this.metrics.failures++;\n    }\n  }\n\n  getMetrics() {\n    return {\n      ...this.metrics,\n      successRate:\n        this.metrics.processed > 0\n          ? (\n              ((this.metrics.processed - this.metrics.failures) / this.metrics.processed) *\n              100\n            ).toFixed(2)\n          : 100,\n      queueSize: this.queue.length,\n      running: this.running,\n      utilization: ((this.running / this.maxConcurrency) * 100).toFixed(2),\n    };\n  }\n}\n\n/**\n * BatchProcessor for optimizing bulk operations\n */\nclass BatchProcessor extends EventEmitter {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      maxBatchSize: config.maxBatchSize || 50,\n      flushInterval: config.flushInterval || 1000,\n      maxWaitTime: config.maxWaitTime || 5000,\n      ...config,\n    };\n\n    this.batches = new Map();\n    this.timers = new Map();\n    this.metrics = {\n      batchesProcessed: 0,\n      itemsProcessed: 0,\n      avgBatchSize: 0,\n      avgProcessingTime: 0,\n    };\n\n    this._startPeriodicFlush();\n  }\n\n  async addToBatch(batchKey, item, processor) {\n    if (!this.batches.has(batchKey)) {\n      this.batches.set(batchKey, {\n        items: [],\n        processor,\n        createdAt: Date.now(),\n      });\n\n      // Set timeout for this batch\n      const timer = setTimeout(() => {\n        this._processBatch(batchKey);\n      }, this.config.maxWaitTime);\n\n      this.timers.set(batchKey, timer);\n    }\n\n    const batch = this.batches.get(batchKey);\n    batch.items.push(item);\n\n    // Process if batch is full\n    if (batch.items.length >= this.config.maxBatchSize) {\n      return this._processBatch(batchKey);\n    }\n\n    return new Promise((resolve, reject) => {\n      item._resolve = resolve;\n      item._reject = reject;\n    });\n  }\n\n  async _processBatch(batchKey) {\n    const batch = this.batches.get(batchKey);\n    if (!batch || batch.items.length === 0) return;\n\n    // Clear timer and remove from maps\n    const timer = this.timers.get(batchKey);\n    if (timer) clearTimeout(timer);\n\n    this.timers.delete(batchKey);\n    this.batches.delete(batchKey);\n\n    const startTime = performance.now();\n\n    try {\n      const results = await batch.processor(batch.items);\n      const processingTime = performance.now() - startTime;\n\n      // Update metrics\n      this.metrics.batchesProcessed++;\n      this.metrics.itemsProcessed += batch.items.length;\n      this.metrics.avgBatchSize = this.metrics.itemsProcessed / this.metrics.batchesProcessed;\n      this.metrics.avgProcessingTime =\n        (this.metrics.avgProcessingTime * (this.metrics.batchesProcessed - 1) + processingTime) /\n        this.metrics.batchesProcessed;\n\n      // Resolve individual item promises\n      batch.items.forEach((item, index) => {\n        if (item._resolve) {\n          item._resolve(results[index] || results);\n        }\n      });\n\n      this.emit('batch:processed', {\n        batchKey,\n        itemCount: batch.items.length,\n        processingTime,\n        results,\n      });\n\n      return results;\n    } catch (error) {\n      // Reject individual item promises\n      batch.items.forEach((item) => {\n        if (item._reject) {\n          item._reject(error);\n        }\n      });\n\n      this.emit('batch:error', { batchKey, error, itemCount: batch.items.length });\n      throw error;\n    }\n  }\n\n  _startPeriodicFlush() {\n    setInterval(() => {\n      const now = Date.now();\n\n      for (const [batchKey, batch] of this.batches.entries()) {\n        // Flush batches that have been waiting too long\n        if (now - batch.createdAt > this.config.flushInterval) {\n          this._processBatch(batchKey);\n        }\n      }\n    }, this.config.flushInterval);\n  }\n\n  getMetrics() {\n    return {\n      ...this.metrics,\n      pendingBatches: this.batches.size,\n      pendingItems: Array.from(this.batches.values()).reduce(\n        (sum, batch) => sum + batch.items.length,\n        0,\n      ),\n    };\n  }\n\n  close() {\n    // Process all remaining batches\n    const batchKeys = Array.from(this.batches.keys());\n    return Promise.all(batchKeys.map((key) => this._processBatch(key)));\n  }\n}\n\n/**\n * PerformanceOptimizer main class\n */\nexport class PerformanceOptimizer extends EventEmitter {\n  constructor(config = {}) {\n    super();\n\n    this.config = {\n      enableAsyncQueue: config.enableAsyncQueue !== false,\n      enableBatchProcessing: config.enableBatchProcessing !== false,\n      enableAutoTuning: config.enableAutoTuning !== false,\n      asyncQueueConcurrency: config.asyncQueueConcurrency || 10,\n      batchMaxSize: config.batchMaxSize || 50,\n      metricsInterval: config.metricsInterval || 30000,\n      ...config,\n    };\n\n    this.asyncQueue = new AsyncOperationQueue(\n      this.config.asyncQueueConcurrency,\n      this.config.asyncTimeout || 30000,\n    );\n\n    this.batchProcessor = new BatchProcessor({\n      maxBatchSize: this.config.batchMaxSize,\n      flushInterval: this.config.batchFlushInterval || 1000,\n      maxWaitTime: this.config.batchMaxWaitTime || 5000,\n    });\n\n    this.metrics = {\n      optimizations: {\n        asyncOperations: 0,\n        batchOperations: 0,\n        cacheHits: 0,\n        performanceGains: [],\n      },\n      system: {\n        cpuUsage: 0,\n        memoryUsage: 0,\n        throughput: 0,\n      },\n    };\n\n    this.cache = new Map();\n    this.performanceBaseline = null;\n\n    this._initialize();\n  }\n\n  _initialize() {\n    // Start performance monitoring\n    if (this.config.metricsInterval > 0) {\n      setInterval(() => this._collectSystemMetrics(), this.config.metricsInterval);\n    }\n\n    // Auto-tuning\n    if (this.config.enableAutoTuning) {\n      setInterval(() => this._autoTune(), 60000); // Every minute\n    }\n\n    this.emit('optimizer:initialized');\n  }\n\n  /**\n   * Optimize async operation execution\n   */\n  async optimizeAsyncOperation(operation, options = {}) {\n    if (!this.config.enableAsyncQueue) {\n      return await operation();\n    }\n\n    const startTime = performance.now();\n\n    try {\n      const result = await this.asyncQueue.add(operation, options.priority || 5);\n\n      const executionTime = performance.now() - startTime;\n      this.metrics.optimizations.asyncOperations++;\n\n      // Track performance gain vs baseline\n      if (this.performanceBaseline) {\n        const gain = Math.max(0, this.performanceBaseline.avgAsyncTime - executionTime);\n        this.metrics.optimizations.performanceGains.push(gain);\n      }\n\n      return result;\n    } catch (error) {\n      this.emit('error', { type: 'async_optimization_failed', error, operation: operation.name });\n      throw error;\n    }\n  }\n\n  /**\n   * Optimize batch operations\n   */\n  async optimizeBatchOperation(batchKey, item, processor, options = {}) {\n    if (!this.config.enableBatchProcessing) {\n      return await processor([item]);\n    }\n\n    this.metrics.optimizations.batchOperations++;\n\n    return await this.batchProcessor.addToBatch(batchKey, item, processor);\n  }\n\n  /**\n   * Optimized caching with automatic expiration\n   */\n  async optimizeWithCache(key, operation, ttl = 300000) {\n    // 5 minutes default\n    const cached = this.cache.get(key);\n\n    if (cached && Date.now() - cached.timestamp < ttl) {\n      this.metrics.optimizations.cacheHits++;\n      return cached.value;\n    }\n\n    const result = await operation();\n\n    this.cache.set(key, {\n      value: result,\n      timestamp: Date.now(),\n    });\n\n    // Clean old cache entries periodically\n    if (this.cache.size > 1000) {\n      this._cleanCache();\n    }\n\n    return result;\n  }\n\n  /**\n   * Optimize memory operations with connection pooling awareness\n   */\n  async optimizeMemoryOperation(operation, connectionPool) {\n    const startTime = performance.now();\n\n    let connection = null;\n    try {\n      connection = await connectionPool.acquire();\n      const result = await operation(connection);\n\n      const executionTime = performance.now() - startTime;\n\n      // Track connection efficiency\n      this.metrics.system.throughput =\n        this.metrics.system.throughput * 0.9 + (1000 / executionTime) * 0.1;\n\n      return result;\n    } finally {\n      if (connection) {\n        connectionPool.release(connection);\n      }\n    }\n  }\n\n  /**\n   * Optimize agent spawning with intelligent batching\n   */\n  async optimizeAgentSpawning(agentTypes, spawnFunction) {\n    // Group agents by complexity for optimal batching\n    const groups = this._groupAgentsByComplexity(agentTypes);\n    const results = [];\n\n    for (const group of groups) {\n      const batchResult = await this.optimizeBatchOperation('agent_spawn', group, spawnFunction);\n      results.push(...(Array.isArray(batchResult) ? batchResult : [batchResult]));\n    }\n\n    return results;\n  }\n\n  /**\n   * Group agents by complexity for optimal spawning\n   */\n  _groupAgentsByComplexity(agentTypes) {\n    const complexity = {\n      low: ['coordinator'],\n      medium: ['coder', 'tester', 'documenter'],\n      high: ['researcher', 'analyst', 'architect', 'optimizer', 'reviewer'],\n    };\n\n    const groups = [];\n\n    Object.entries(complexity).forEach(([level, types]) => {\n      const groupAgents = agentTypes.filter((type) => types.includes(type));\n      if (groupAgents.length > 0) {\n        groups.push(groupAgents);\n      }\n    });\n\n    return groups;\n  }\n\n  /**\n   * Auto-tune performance parameters based on metrics\n   */\n  _autoTune() {\n    const queueMetrics = this.asyncQueue.getMetrics();\n    const batchMetrics = this.batchProcessor.getMetrics();\n\n    // Adjust async queue concurrency based on utilization\n    if (queueMetrics.utilization > 90 && this.asyncQueue.maxConcurrency < 20) {\n      this.asyncQueue.maxConcurrency += 2;\n      this.emit('auto_tune', {\n        type: 'concurrency_increased',\n        newValue: this.asyncQueue.maxConcurrency,\n      });\n    } else if (queueMetrics.utilization < 30 && this.asyncQueue.maxConcurrency > 5) {\n      this.asyncQueue.maxConcurrency = Math.max(5, this.asyncQueue.maxConcurrency - 1);\n      this.emit('auto_tune', {\n        type: 'concurrency_decreased',\n        newValue: this.asyncQueue.maxConcurrency,\n      });\n    }\n\n    // Adjust batch sizes based on processing efficiency\n    if (batchMetrics.avgBatchSize > 30 && batchMetrics.avgProcessingTime > 5000) {\n      this.batchProcessor.config.maxBatchSize = Math.max(\n        20,\n        this.batchProcessor.config.maxBatchSize - 5,\n      );\n      this.emit('auto_tune', {\n        type: 'batch_size_decreased',\n        newValue: this.batchProcessor.config.maxBatchSize,\n      });\n    }\n  }\n\n  /**\n   * Clean old cache entries\n   */\n  _cleanCache() {\n    const now = Date.now();\n    const entries = Array.from(this.cache.entries());\n\n    // Remove oldest 20% of entries\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n    const toRemove = Math.floor(entries.length * 0.2);\n\n    for (let i = 0; i < toRemove; i++) {\n      this.cache.delete(entries[i][0]);\n    }\n  }\n\n  /**\n   * Collect system performance metrics\n   */\n  _collectSystemMetrics() {\n    // Simple CPU and memory usage estimation\n    const used = process.memoryUsage();\n    this.metrics.system.memoryUsage = (used.heapUsed / 1024 / 1024).toFixed(2); // MB\n\n    // Estimate throughput based on recent operations\n    const queueMetrics = this.asyncQueue.getMetrics();\n    this.metrics.system.throughput =\n      queueMetrics.processed > 0\n        ? (queueMetrics.processed / (queueMetrics.avgProcessingTime / 1000)).toFixed(2)\n        : 0;\n  }\n\n  /**\n   * Get comprehensive performance statistics\n   */\n  getPerformanceStats() {\n    return {\n      optimizer: this.metrics,\n      asyncQueue: this.asyncQueue.getMetrics(),\n      batchProcessor: this.batchProcessor.getMetrics(),\n      cache: {\n        size: this.cache.size,\n        hitRate:\n          this.metrics.optimizations.cacheHits > 0\n            ? (\n                (this.metrics.optimizations.cacheHits /\n                  (this.metrics.optimizations.asyncOperations +\n                    this.metrics.optimizations.cacheHits)) *\n                100\n              ).toFixed(2)\n            : 0,\n      },\n    };\n  }\n\n  /**\n   * Generate performance report with recommendations\n   */\n  generatePerformanceReport() {\n    const stats = this.getPerformanceStats();\n    const recommendations = [];\n\n    // Analyze and provide recommendations\n    if (stats.asyncQueue.utilization > 80) {\n      recommendations.push({\n        type: 'scaling',\n        priority: 'high',\n        message: 'Consider increasing async queue concurrency',\n        currentValue: this.asyncQueue.maxConcurrency,\n        suggestedValue: this.asyncQueue.maxConcurrency + 3,\n      });\n    }\n\n    if (stats.cache.hitRate < 60) {\n      recommendations.push({\n        type: 'caching',\n        priority: 'medium',\n        message: 'Cache hit rate is low, consider increasing cache TTL or size',\n        currentHitRate: stats.cache.hitRate,\n      });\n    }\n\n    if (stats.batchProcessor.avgBatchSize < 10) {\n      recommendations.push({\n        type: 'batching',\n        priority: 'medium',\n        message: 'Batch sizes are small, consider increasing batch wait time',\n        avgBatchSize: stats.batchProcessor.avgBatchSize,\n      });\n    }\n\n    return {\n      timestamp: new Date().toISOString(),\n      performance: stats,\n      recommendations,\n      summary: {\n        overallHealth: this._calculateOverallHealth(stats),\n        keyMetrics: {\n          throughput: stats.optimizer.system.throughput,\n          efficiency: stats.asyncQueue.successRate,\n          utilization: stats.asyncQueue.utilization,\n        },\n      },\n    };\n  }\n\n  /**\n   * Calculate overall system health score\n   */\n  _calculateOverallHealth(stats) {\n    const factors = [\n      Math.min(100, parseFloat(stats.asyncQueue.successRate)),\n      Math.min(100, 100 - parseFloat(stats.asyncQueue.utilization)), // Lower utilization is better\n      Math.min(100, parseFloat(stats.cache.hitRate)),\n      Math.min(100, (stats.batchProcessor.avgBatchSize / this.config.batchMaxSize) * 100),\n    ];\n\n    const avgScore = factors.reduce((sum, score) => sum + score, 0) / factors.length;\n\n    if (avgScore >= 80) return 'excellent';\n    if (avgScore >= 60) return 'good';\n    if (avgScore >= 40) return 'fair';\n    return 'poor';\n  }\n\n  /**\n   * Close optimizer and cleanup resources\n   */\n  async close() {\n    await this.batchProcessor.close();\n    this.cache.clear();\n    this.emit('optimizer:closed');\n  }\n}\n\nexport default PerformanceOptimizer;\n"],"names":["EventEmitter","performance","AsyncOperationQueue","maxConcurrency","timeout","running","queue","results","Map","metrics","processed","failures","avgProcessingTime","totalProcessingTime","add","operation","priority","Promise","resolve","reject","queueItem","addedAt","Date","now","id","Math","random","toString","substr","insertIndex","findIndex","item","push","splice","_processQueue","length","shift","startTime","timeoutPromise","_","setTimeout","Error","result","race","processingTime","_updateMetrics","error","setImmediate","success","getMetrics","successRate","toFixed","queueSize","utilization","BatchProcessor","config","maxBatchSize","flushInterval","maxWaitTime","batches","timers","batchesProcessed","itemsProcessed","avgBatchSize","_startPeriodicFlush","addToBatch","batchKey","processor","has","set","items","createdAt","timer","_processBatch","batch","get","_resolve","_reject","clearTimeout","delete","forEach","index","emit","itemCount","setInterval","entries","pendingBatches","size","pendingItems","Array","from","values","reduce","sum","close","batchKeys","keys","all","map","key","PerformanceOptimizer","enableAsyncQueue","enableBatchProcessing","enableAutoTuning","asyncQueueConcurrency","batchMaxSize","metricsInterval","asyncQueue","asyncTimeout","batchProcessor","batchFlushInterval","batchMaxWaitTime","optimizations","asyncOperations","batchOperations","cacheHits","performanceGains","system","cpuUsage","memoryUsage","throughput","cache","performanceBaseline","_initialize","_collectSystemMetrics","_autoTune","optimizeAsyncOperation","options","executionTime","gain","max","avgAsyncTime","type","name","optimizeBatchOperation","optimizeWithCache","ttl","cached","timestamp","value","_cleanCache","optimizeMemoryOperation","connectionPool","connection","acquire","release","optimizeAgentSpawning","agentTypes","spawnFunction","groups","_groupAgentsByComplexity","group","batchResult","isArray","complexity","low","medium","high","Object","level","types","groupAgents","filter","includes","queueMetrics","batchMetrics","newValue","sort","a","b","toRemove","floor","i","used","process","heapUsed","getPerformanceStats","optimizer","hitRate","generatePerformanceReport","stats","recommendations","message","currentValue","suggestedValue","currentHitRate","toISOString","summary","overallHealth","_calculateOverallHealth","keyMetrics","efficiency","factors","min","parseFloat","avgScore","score","clear"],"mappings":"AASA,OAAOA,kBAAkB,SAAS;AAClC,SAASC,WAAW,QAAQ,aAAa;AAKzC,IAAA,AAAMC,sBAAN,MAAMA;IACJ,YAAYC,iBAAiB,EAAE,EAAEC,UAAU,KAAK,CAAE;QAChD,IAAI,CAACD,cAAc,GAAGA;QACtB,IAAI,CAACC,OAAO,GAAGA;QACf,IAAI,CAACC,OAAO,GAAG;QACf,IAAI,CAACC,KAAK,GAAG,EAAE;QACf,IAAI,CAACC,OAAO,GAAG,IAAIC;QACnB,IAAI,CAACC,OAAO,GAAG;YACbC,WAAW;YACXC,UAAU;YACVC,mBAAmB;YACnBC,qBAAqB;QACvB;IACF;IAEA,MAAMC,IAAIC,SAAS,EAAEC,WAAW,CAAC,EAAE;QACjC,OAAO,IAAIC,QAAQ,CAACC,SAASC;YAC3B,MAAMC,YAAY;gBAChBL;gBACAC;gBACAE;gBACAC;gBACAE,SAASC,KAAKC,GAAG;gBACjBC,IAAI,CAAC,GAAG,EAAEF,KAAKC,GAAG,GAAG,CAAC,EAAEE,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,IAAI;YACnE;YAGA,MAAMC,cAAc,IAAI,CAACvB,KAAK,CAACwB,SAAS,CAAC,CAACC,OAASA,KAAKf,QAAQ,GAAGA;YACnE,IAAIa,gBAAgB,CAAC,GAAG;gBACtB,IAAI,CAACvB,KAAK,CAAC0B,IAAI,CAACZ;YAClB,OAAO;gBACL,IAAI,CAACd,KAAK,CAAC2B,MAAM,CAACJ,aAAa,GAAGT;YACpC;YAEA,IAAI,CAACc,aAAa;QACpB;IACF;IAEA,MAAMA,gBAAgB;QACpB,IAAI,IAAI,CAAC7B,OAAO,IAAI,IAAI,CAACF,cAAc,IAAI,IAAI,CAACG,KAAK,CAAC6B,MAAM,KAAK,GAAG;YAClE;QACF;QAEA,MAAMJ,OAAO,IAAI,CAACzB,KAAK,CAAC8B,KAAK;QAC7B,IAAI,CAAC/B,OAAO;QAEZ,MAAMgC,YAAYpC,YAAYsB,GAAG;QAEjC,IAAI;YAEF,MAAMe,iBAAiB,IAAIrB,QAAQ,CAACsB,GAAGpB;gBACrCqB,WAAW,IAAMrB,OAAO,IAAIsB,MAAM,uBAAuB,IAAI,CAACrC,OAAO;YACvE;YAEA,MAAMsC,SAAS,MAAMzB,QAAQ0B,IAAI,CAAC;gBAACZ,KAAKhB,SAAS;gBAAIuB;aAAe;YAEpE,MAAMM,iBAAiB3C,YAAYsB,GAAG,KAAKc;YAC3C,IAAI,CAACQ,cAAc,CAACD,gBAAgB;YAEpCb,KAAKb,OAAO,CAACwB;QACf,EAAE,OAAOI,OAAO;YACd,MAAMF,iBAAiB3C,YAAYsB,GAAG,KAAKc;YAC3C,IAAI,CAACQ,cAAc,CAACD,gBAAgB;YAEpCb,KAAKZ,MAAM,CAAC2B;QACd,SAAU;YACR,IAAI,CAACzC,OAAO;YACZ0C,aAAa,IAAM,IAAI,CAACb,aAAa;QACvC;IACF;IAEAW,eAAeD,cAAc,EAAEI,OAAO,EAAE;QACtC,IAAI,CAACvC,OAAO,CAACC,SAAS;QACtB,IAAI,CAACD,OAAO,CAACI,mBAAmB,IAAI+B;QACpC,IAAI,CAACnC,OAAO,CAACG,iBAAiB,GAAG,IAAI,CAACH,OAAO,CAACI,mBAAmB,GAAG,IAAI,CAACJ,OAAO,CAACC,SAAS;QAE1F,IAAI,CAACsC,SAAS;YACZ,IAAI,CAACvC,OAAO,CAACE,QAAQ;QACvB;IACF;IAEAsC,aAAa;QACX,OAAO;YACL,GAAG,IAAI,CAACxC,OAAO;YACfyC,aACE,IAAI,CAACzC,OAAO,CAACC,SAAS,GAAG,IACrB,AACE,CAAA,AAAE,CAAA,IAAI,CAACD,OAAO,CAACC,SAAS,GAAG,IAAI,CAACD,OAAO,CAACE,QAAQ,AAAD,IAAK,IAAI,CAACF,OAAO,CAACC,SAAS,GAC1E,GAAE,EACFyC,OAAO,CAAC,KACV;YACNC,WAAW,IAAI,CAAC9C,KAAK,CAAC6B,MAAM;YAC5B9B,SAAS,IAAI,CAACA,OAAO;YACrBgD,aAAa,AAAC,CAAA,AAAC,IAAI,CAAChD,OAAO,GAAG,IAAI,CAACF,cAAc,GAAI,GAAE,EAAGgD,OAAO,CAAC;QACpE;IACF;AACF;AAKA,IAAA,AAAMG,iBAAN,MAAMA,uBAAuBtD;IAC3B,YAAYuD,SAAS,CAAC,CAAC,CAAE;QACvB,KAAK;QAEL,IAAI,CAACA,MAAM,GAAG;YACZC,cAAcD,OAAOC,YAAY,IAAI;YACrCC,eAAeF,OAAOE,aAAa,IAAI;YACvCC,aAAaH,OAAOG,WAAW,IAAI;YACnC,GAAGH,MAAM;QACX;QAEA,IAAI,CAACI,OAAO,GAAG,IAAInD;QACnB,IAAI,CAACoD,MAAM,GAAG,IAAIpD;QAClB,IAAI,CAACC,OAAO,GAAG;YACboD,kBAAkB;YAClBC,gBAAgB;YAChBC,cAAc;YACdnD,mBAAmB;QACrB;QAEA,IAAI,CAACoD,mBAAmB;IAC1B;IAEA,MAAMC,WAAWC,QAAQ,EAAEnC,IAAI,EAAEoC,SAAS,EAAE;QAC1C,IAAI,CAAC,IAAI,CAACR,OAAO,CAACS,GAAG,CAACF,WAAW;YAC/B,IAAI,CAACP,OAAO,CAACU,GAAG,CAACH,UAAU;gBACzBI,OAAO,EAAE;gBACTH;gBACAI,WAAWjD,KAAKC,GAAG;YACrB;YAGA,MAAMiD,QAAQhC,WAAW;gBACvB,IAAI,CAACiC,aAAa,CAACP;YACrB,GAAG,IAAI,CAACX,MAAM,CAACG,WAAW;YAE1B,IAAI,CAACE,MAAM,CAACS,GAAG,CAACH,UAAUM;QAC5B;QAEA,MAAME,QAAQ,IAAI,CAACf,OAAO,CAACgB,GAAG,CAACT;QAC/BQ,MAAMJ,KAAK,CAACtC,IAAI,CAACD;QAGjB,IAAI2C,MAAMJ,KAAK,CAACnC,MAAM,IAAI,IAAI,CAACoB,MAAM,CAACC,YAAY,EAAE;YAClD,OAAO,IAAI,CAACiB,aAAa,CAACP;QAC5B;QAEA,OAAO,IAAIjD,QAAQ,CAACC,SAASC;YAC3BY,KAAK6C,QAAQ,GAAG1D;YAChBa,KAAK8C,OAAO,GAAG1D;QACjB;IACF;IAEA,MAAMsD,cAAcP,QAAQ,EAAE;QAC5B,MAAMQ,QAAQ,IAAI,CAACf,OAAO,CAACgB,GAAG,CAACT;QAC/B,IAAI,CAACQ,SAASA,MAAMJ,KAAK,CAACnC,MAAM,KAAK,GAAG;QAGxC,MAAMqC,QAAQ,IAAI,CAACZ,MAAM,CAACe,GAAG,CAACT;QAC9B,IAAIM,OAAOM,aAAaN;QAExB,IAAI,CAACZ,MAAM,CAACmB,MAAM,CAACb;QACnB,IAAI,CAACP,OAAO,CAACoB,MAAM,CAACb;QAEpB,MAAM7B,YAAYpC,YAAYsB,GAAG;QAEjC,IAAI;YACF,MAAMhB,UAAU,MAAMmE,MAAMP,SAAS,CAACO,MAAMJ,KAAK;YACjD,MAAM1B,iBAAiB3C,YAAYsB,GAAG,KAAKc;YAG3C,IAAI,CAAC5B,OAAO,CAACoD,gBAAgB;YAC7B,IAAI,CAACpD,OAAO,CAACqD,cAAc,IAAIY,MAAMJ,KAAK,CAACnC,MAAM;YACjD,IAAI,CAAC1B,OAAO,CAACsD,YAAY,GAAG,IAAI,CAACtD,OAAO,CAACqD,cAAc,GAAG,IAAI,CAACrD,OAAO,CAACoD,gBAAgB;YACvF,IAAI,CAACpD,OAAO,CAACG,iBAAiB,GAC5B,AAAC,CAAA,IAAI,CAACH,OAAO,CAACG,iBAAiB,GAAI,CAAA,IAAI,CAACH,OAAO,CAACoD,gBAAgB,GAAG,CAAA,IAAKjB,cAAa,IACrF,IAAI,CAACnC,OAAO,CAACoD,gBAAgB;YAG/Ba,MAAMJ,KAAK,CAACU,OAAO,CAAC,CAACjD,MAAMkD;gBACzB,IAAIlD,KAAK6C,QAAQ,EAAE;oBACjB7C,KAAK6C,QAAQ,CAACrE,OAAO,CAAC0E,MAAM,IAAI1E;gBAClC;YACF;YAEA,IAAI,CAAC2E,IAAI,CAAC,mBAAmB;gBAC3BhB;gBACAiB,WAAWT,MAAMJ,KAAK,CAACnC,MAAM;gBAC7BS;gBACArC;YACF;YAEA,OAAOA;QACT,EAAE,OAAOuC,OAAO;YAEd4B,MAAMJ,KAAK,CAACU,OAAO,CAAC,CAACjD;gBACnB,IAAIA,KAAK8C,OAAO,EAAE;oBAChB9C,KAAK8C,OAAO,CAAC/B;gBACf;YACF;YAEA,IAAI,CAACoC,IAAI,CAAC,eAAe;gBAAEhB;gBAAUpB;gBAAOqC,WAAWT,MAAMJ,KAAK,CAACnC,MAAM;YAAC;YAC1E,MAAMW;QACR;IACF;IAEAkB,sBAAsB;QACpBoB,YAAY;YACV,MAAM7D,MAAMD,KAAKC,GAAG;YAEpB,KAAK,MAAM,CAAC2C,UAAUQ,MAAM,IAAI,IAAI,CAACf,OAAO,CAAC0B,OAAO,GAAI;gBAEtD,IAAI9D,MAAMmD,MAAMH,SAAS,GAAG,IAAI,CAAChB,MAAM,CAACE,aAAa,EAAE;oBACrD,IAAI,CAACgB,aAAa,CAACP;gBACrB;YACF;QACF,GAAG,IAAI,CAACX,MAAM,CAACE,aAAa;IAC9B;IAEAR,aAAa;QACX,OAAO;YACL,GAAG,IAAI,CAACxC,OAAO;YACf6E,gBAAgB,IAAI,CAAC3B,OAAO,CAAC4B,IAAI;YACjCC,cAAcC,MAAMC,IAAI,CAAC,IAAI,CAAC/B,OAAO,CAACgC,MAAM,IAAIC,MAAM,CACpD,CAACC,KAAKnB,QAAUmB,MAAMnB,MAAMJ,KAAK,CAACnC,MAAM,EACxC;QAEJ;IACF;IAEA2D,QAAQ;QAEN,MAAMC,YAAYN,MAAMC,IAAI,CAAC,IAAI,CAAC/B,OAAO,CAACqC,IAAI;QAC9C,OAAO/E,QAAQgF,GAAG,CAACF,UAAUG,GAAG,CAAC,CAACC,MAAQ,IAAI,CAAC1B,aAAa,CAAC0B;IAC/D;AACF;AAKA,OAAO,MAAMC,6BAA6BpG;IACxC,YAAYuD,SAAS,CAAC,CAAC,CAAE;QACvB,KAAK;QAEL,IAAI,CAACA,MAAM,GAAG;YACZ8C,kBAAkB9C,OAAO8C,gBAAgB,KAAK;YAC9CC,uBAAuB/C,OAAO+C,qBAAqB,KAAK;YACxDC,kBAAkBhD,OAAOgD,gBAAgB,KAAK;YAC9CC,uBAAuBjD,OAAOiD,qBAAqB,IAAI;YACvDC,cAAclD,OAAOkD,YAAY,IAAI;YACrCC,iBAAiBnD,OAAOmD,eAAe,IAAI;YAC3C,GAAGnD,MAAM;QACX;QAEA,IAAI,CAACoD,UAAU,GAAG,IAAIzG,oBACpB,IAAI,CAACqD,MAAM,CAACiD,qBAAqB,EACjC,IAAI,CAACjD,MAAM,CAACqD,YAAY,IAAI;QAG9B,IAAI,CAACC,cAAc,GAAG,IAAIvD,eAAe;YACvCE,cAAc,IAAI,CAACD,MAAM,CAACkD,YAAY;YACtChD,eAAe,IAAI,CAACF,MAAM,CAACuD,kBAAkB,IAAI;YACjDpD,aAAa,IAAI,CAACH,MAAM,CAACwD,gBAAgB,IAAI;QAC/C;QAEA,IAAI,CAACtG,OAAO,GAAG;YACbuG,eAAe;gBACbC,iBAAiB;gBACjBC,iBAAiB;gBACjBC,WAAW;gBACXC,kBAAkB,EAAE;YACtB;YACAC,QAAQ;gBACNC,UAAU;gBACVC,aAAa;gBACbC,YAAY;YACd;QACF;QAEA,IAAI,CAACC,KAAK,GAAG,IAAIjH;QACjB,IAAI,CAACkH,mBAAmB,GAAG;QAE3B,IAAI,CAACC,WAAW;IAClB;IAEAA,cAAc;QAEZ,IAAI,IAAI,CAACpE,MAAM,CAACmD,eAAe,GAAG,GAAG;YACnCtB,YAAY,IAAM,IAAI,CAACwC,qBAAqB,IAAI,IAAI,CAACrE,MAAM,CAACmD,eAAe;QAC7E;QAGA,IAAI,IAAI,CAACnD,MAAM,CAACgD,gBAAgB,EAAE;YAChCnB,YAAY,IAAM,IAAI,CAACyC,SAAS,IAAI;QACtC;QAEA,IAAI,CAAC3C,IAAI,CAAC;IACZ;IAKA,MAAM4C,uBAAuB/G,SAAS,EAAEgH,UAAU,CAAC,CAAC,EAAE;QACpD,IAAI,CAAC,IAAI,CAACxE,MAAM,CAAC8C,gBAAgB,EAAE;YACjC,OAAO,MAAMtF;QACf;QAEA,MAAMsB,YAAYpC,YAAYsB,GAAG;QAEjC,IAAI;YACF,MAAMmB,SAAS,MAAM,IAAI,CAACiE,UAAU,CAAC7F,GAAG,CAACC,WAAWgH,QAAQ/G,QAAQ,IAAI;YAExE,MAAMgH,gBAAgB/H,YAAYsB,GAAG,KAAKc;YAC1C,IAAI,CAAC5B,OAAO,CAACuG,aAAa,CAACC,eAAe;YAG1C,IAAI,IAAI,CAACS,mBAAmB,EAAE;gBAC5B,MAAMO,OAAOxG,KAAKyG,GAAG,CAAC,GAAG,IAAI,CAACR,mBAAmB,CAACS,YAAY,GAAGH;gBACjE,IAAI,CAACvH,OAAO,CAACuG,aAAa,CAACI,gBAAgB,CAACpF,IAAI,CAACiG;YACnD;YAEA,OAAOvF;QACT,EAAE,OAAOI,OAAO;YACd,IAAI,CAACoC,IAAI,CAAC,SAAS;gBAAEkD,MAAM;gBAA6BtF;gBAAO/B,WAAWA,UAAUsH,IAAI;YAAC;YACzF,MAAMvF;QACR;IACF;IAKA,MAAMwF,uBAAuBpE,QAAQ,EAAEnC,IAAI,EAAEoC,SAAS,EAAE4D,UAAU,CAAC,CAAC,EAAE;QACpE,IAAI,CAAC,IAAI,CAACxE,MAAM,CAAC+C,qBAAqB,EAAE;YACtC,OAAO,MAAMnC,UAAU;gBAACpC;aAAK;QAC/B;QAEA,IAAI,CAACtB,OAAO,CAACuG,aAAa,CAACE,eAAe;QAE1C,OAAO,MAAM,IAAI,CAACL,cAAc,CAAC5C,UAAU,CAACC,UAAUnC,MAAMoC;IAC9D;IAKA,MAAMoE,kBAAkBpC,GAAG,EAAEpF,SAAS,EAAEyH,MAAM,MAAM,EAAE;QAEpD,MAAMC,SAAS,IAAI,CAAChB,KAAK,CAAC9C,GAAG,CAACwB;QAE9B,IAAIsC,UAAUnH,KAAKC,GAAG,KAAKkH,OAAOC,SAAS,GAAGF,KAAK;YACjD,IAAI,CAAC/H,OAAO,CAACuG,aAAa,CAACG,SAAS;YACpC,OAAOsB,OAAOE,KAAK;QACrB;QAEA,MAAMjG,SAAS,MAAM3B;QAErB,IAAI,CAAC0G,KAAK,CAACpD,GAAG,CAAC8B,KAAK;YAClBwC,OAAOjG;YACPgG,WAAWpH,KAAKC,GAAG;QACrB;QAGA,IAAI,IAAI,CAACkG,KAAK,CAAClC,IAAI,GAAG,MAAM;YAC1B,IAAI,CAACqD,WAAW;QAClB;QAEA,OAAOlG;IACT;IAKA,MAAMmG,wBAAwB9H,SAAS,EAAE+H,cAAc,EAAE;QACvD,MAAMzG,YAAYpC,YAAYsB,GAAG;QAEjC,IAAIwH,aAAa;QACjB,IAAI;YACFA,aAAa,MAAMD,eAAeE,OAAO;YACzC,MAAMtG,SAAS,MAAM3B,UAAUgI;YAE/B,MAAMf,gBAAgB/H,YAAYsB,GAAG,KAAKc;YAG1C,IAAI,CAAC5B,OAAO,CAAC4G,MAAM,CAACG,UAAU,GAC5B,IAAI,CAAC/G,OAAO,CAAC4G,MAAM,CAACG,UAAU,GAAG,MAAM,AAAC,OAAOQ,gBAAiB;YAElE,OAAOtF;QACT,SAAU;YACR,IAAIqG,YAAY;gBACdD,eAAeG,OAAO,CAACF;YACzB;QACF;IACF;IAKA,MAAMG,sBAAsBC,UAAU,EAAEC,aAAa,EAAE;QAErD,MAAMC,SAAS,IAAI,CAACC,wBAAwB,CAACH;QAC7C,MAAM5I,UAAU,EAAE;QAElB,KAAK,MAAMgJ,SAASF,OAAQ;YAC1B,MAAMG,cAAc,MAAM,IAAI,CAAClB,sBAAsB,CAAC,eAAeiB,OAAOH;YAC5E7I,QAAQyB,IAAI,IAAKyD,MAAMgE,OAAO,CAACD,eAAeA,cAAc;gBAACA;aAAY;QAC3E;QAEA,OAAOjJ;IACT;IAKA+I,yBAAyBH,UAAU,EAAE;QACnC,MAAMO,aAAa;YACjBC,KAAK;gBAAC;aAAc;YACpBC,QAAQ;gBAAC;gBAAS;gBAAU;aAAa;YACzCC,MAAM;gBAAC;gBAAc;gBAAW;gBAAa;gBAAa;aAAW;QACvE;QAEA,MAAMR,SAAS,EAAE;QAEjBS,OAAOzE,OAAO,CAACqE,YAAY1E,OAAO,CAAC,CAAC,CAAC+E,OAAOC,MAAM;YAChD,MAAMC,cAAcd,WAAWe,MAAM,CAAC,CAAC9B,OAAS4B,MAAMG,QAAQ,CAAC/B;YAC/D,IAAI6B,YAAY9H,MAAM,GAAG,GAAG;gBAC1BkH,OAAOrH,IAAI,CAACiI;YACd;QACF;QAEA,OAAOZ;IACT;IAKAxB,YAAY;QACV,MAAMuC,eAAe,IAAI,CAACzD,UAAU,CAAC1D,UAAU;QAC/C,MAAMoH,eAAe,IAAI,CAACxD,cAAc,CAAC5D,UAAU;QAGnD,IAAImH,aAAa/G,WAAW,GAAG,MAAM,IAAI,CAACsD,UAAU,CAACxG,cAAc,GAAG,IAAI;YACxE,IAAI,CAACwG,UAAU,CAACxG,cAAc,IAAI;YAClC,IAAI,CAAC+E,IAAI,CAAC,aAAa;gBACrBkD,MAAM;gBACNkC,UAAU,IAAI,CAAC3D,UAAU,CAACxG,cAAc;YAC1C;QACF,OAAO,IAAIiK,aAAa/G,WAAW,GAAG,MAAM,IAAI,CAACsD,UAAU,CAACxG,cAAc,GAAG,GAAG;YAC9E,IAAI,CAACwG,UAAU,CAACxG,cAAc,GAAGsB,KAAKyG,GAAG,CAAC,GAAG,IAAI,CAACvB,UAAU,CAACxG,cAAc,GAAG;YAC9E,IAAI,CAAC+E,IAAI,CAAC,aAAa;gBACrBkD,MAAM;gBACNkC,UAAU,IAAI,CAAC3D,UAAU,CAACxG,cAAc;YAC1C;QACF;QAGA,IAAIkK,aAAatG,YAAY,GAAG,MAAMsG,aAAazJ,iBAAiB,GAAG,MAAM;YAC3E,IAAI,CAACiG,cAAc,CAACtD,MAAM,CAACC,YAAY,GAAG/B,KAAKyG,GAAG,CAChD,IACA,IAAI,CAACrB,cAAc,CAACtD,MAAM,CAACC,YAAY,GAAG;YAE5C,IAAI,CAAC0B,IAAI,CAAC,aAAa;gBACrBkD,MAAM;gBACNkC,UAAU,IAAI,CAACzD,cAAc,CAACtD,MAAM,CAACC,YAAY;YACnD;QACF;IACF;IAKAoF,cAAc;QACZ,MAAMrH,MAAMD,KAAKC,GAAG;QACpB,MAAM8D,UAAUI,MAAMC,IAAI,CAAC,IAAI,CAAC+B,KAAK,CAACpC,OAAO;QAG7CA,QAAQkF,IAAI,CAAC,CAACC,GAAGC,IAAMD,CAAC,CAAC,EAAE,CAAC9B,SAAS,GAAG+B,CAAC,CAAC,EAAE,CAAC/B,SAAS;QACtD,MAAMgC,WAAWjJ,KAAKkJ,KAAK,CAACtF,QAAQlD,MAAM,GAAG;QAE7C,IAAK,IAAIyI,IAAI,GAAGA,IAAIF,UAAUE,IAAK;YACjC,IAAI,CAACnD,KAAK,CAAC1C,MAAM,CAACM,OAAO,CAACuF,EAAE,CAAC,EAAE;QACjC;IACF;IAKAhD,wBAAwB;QAEtB,MAAMiD,OAAOC,QAAQvD,WAAW;QAChC,IAAI,CAAC9G,OAAO,CAAC4G,MAAM,CAACE,WAAW,GAAG,AAACsD,CAAAA,KAAKE,QAAQ,GAAG,OAAO,IAAG,EAAG5H,OAAO,CAAC;QAGxE,MAAMiH,eAAe,IAAI,CAACzD,UAAU,CAAC1D,UAAU;QAC/C,IAAI,CAACxC,OAAO,CAAC4G,MAAM,CAACG,UAAU,GAC5B4C,aAAa1J,SAAS,GAAG,IACrB,AAAC0J,CAAAA,aAAa1J,SAAS,GAAI0J,CAAAA,aAAaxJ,iBAAiB,GAAG,IAAG,CAAC,EAAGuC,OAAO,CAAC,KAC3E;IACR;IAKA6H,sBAAsB;QACpB,OAAO;YACLC,WAAW,IAAI,CAACxK,OAAO;YACvBkG,YAAY,IAAI,CAACA,UAAU,CAAC1D,UAAU;YACtC4D,gBAAgB,IAAI,CAACA,cAAc,CAAC5D,UAAU;YAC9CwE,OAAO;gBACLlC,MAAM,IAAI,CAACkC,KAAK,CAAClC,IAAI;gBACrB2F,SACE,IAAI,CAACzK,OAAO,CAACuG,aAAa,CAACG,SAAS,GAAG,IACnC,AACE,CAAA,AAAC,IAAI,CAAC1G,OAAO,CAACuG,aAAa,CAACG,SAAS,GAClC,CAAA,IAAI,CAAC1G,OAAO,CAACuG,aAAa,CAACC,eAAe,GACzC,IAAI,CAACxG,OAAO,CAACuG,aAAa,CAACG,SAAS,AAAD,IACvC,GAAE,EACFhE,OAAO,CAAC,KACV;YACR;QACF;IACF;IAKAgI,4BAA4B;QAC1B,MAAMC,QAAQ,IAAI,CAACJ,mBAAmB;QACtC,MAAMK,kBAAkB,EAAE;QAG1B,IAAID,MAAMzE,UAAU,CAACtD,WAAW,GAAG,IAAI;YACrCgI,gBAAgBrJ,IAAI,CAAC;gBACnBoG,MAAM;gBACNpH,UAAU;gBACVsK,SAAS;gBACTC,cAAc,IAAI,CAAC5E,UAAU,CAACxG,cAAc;gBAC5CqL,gBAAgB,IAAI,CAAC7E,UAAU,CAACxG,cAAc,GAAG;YACnD;QACF;QAEA,IAAIiL,MAAM3D,KAAK,CAACyD,OAAO,GAAG,IAAI;YAC5BG,gBAAgBrJ,IAAI,CAAC;gBACnBoG,MAAM;gBACNpH,UAAU;gBACVsK,SAAS;gBACTG,gBAAgBL,MAAM3D,KAAK,CAACyD,OAAO;YACrC;QACF;QAEA,IAAIE,MAAMvE,cAAc,CAAC9C,YAAY,GAAG,IAAI;YAC1CsH,gBAAgBrJ,IAAI,CAAC;gBACnBoG,MAAM;gBACNpH,UAAU;gBACVsK,SAAS;gBACTvH,cAAcqH,MAAMvE,cAAc,CAAC9C,YAAY;YACjD;QACF;QAEA,OAAO;YACL2E,WAAW,IAAIpH,OAAOoK,WAAW;YACjCzL,aAAamL;YACbC;YACAM,SAAS;gBACPC,eAAe,IAAI,CAACC,uBAAuB,CAACT;gBAC5CU,YAAY;oBACVtE,YAAY4D,MAAMH,SAAS,CAAC5D,MAAM,CAACG,UAAU;oBAC7CuE,YAAYX,MAAMzE,UAAU,CAACzD,WAAW;oBACxCG,aAAa+H,MAAMzE,UAAU,CAACtD,WAAW;gBAC3C;YACF;QACF;IACF;IAKAwI,wBAAwBT,KAAK,EAAE;QAC7B,MAAMY,UAAU;YACdvK,KAAKwK,GAAG,CAAC,KAAKC,WAAWd,MAAMzE,UAAU,CAACzD,WAAW;YACrDzB,KAAKwK,GAAG,CAAC,KAAK,MAAMC,WAAWd,MAAMzE,UAAU,CAACtD,WAAW;YAC3D5B,KAAKwK,GAAG,CAAC,KAAKC,WAAWd,MAAM3D,KAAK,CAACyD,OAAO;YAC5CzJ,KAAKwK,GAAG,CAAC,KAAK,AAACb,MAAMvE,cAAc,CAAC9C,YAAY,GAAG,IAAI,CAACR,MAAM,CAACkD,YAAY,GAAI;SAChF;QAED,MAAM0F,WAAWH,QAAQpG,MAAM,CAAC,CAACC,KAAKuG,QAAUvG,MAAMuG,OAAO,KAAKJ,QAAQ7J,MAAM;QAEhF,IAAIgK,YAAY,IAAI,OAAO;QAC3B,IAAIA,YAAY,IAAI,OAAO;QAC3B,IAAIA,YAAY,IAAI,OAAO;QAC3B,OAAO;IACT;IAKA,MAAMrG,QAAQ;QACZ,MAAM,IAAI,CAACe,cAAc,CAACf,KAAK;QAC/B,IAAI,CAAC2B,KAAK,CAAC4E,KAAK;QAChB,IAAI,CAACnH,IAAI,CAAC;IACZ;AACF;AAEA,eAAekB,qBAAqB"}