{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/memory.js"],"sourcesContent":["/**\n * Collective Memory System for Hive Mind\n * Shared knowledge base and learning system\n */\n\nimport EventEmitter from 'events';\nimport Database from 'better-sqlite3';\nimport path from 'path';\nimport { performance } from 'perf_hooks';\nimport { Worker } from 'worker_threads';\n\n/**\n * Memory types and their characteristics\n */\nconst MEMORY_TYPES = {\n  knowledge: { priority: 1, ttl: null, compress: false },\n  context: { priority: 2, ttl: 3600000, compress: false }, // 1 hour\n  task: { priority: 3, ttl: 1800000, compress: true }, // 30 minutes\n  result: { priority: 2, ttl: null, compress: true },\n  error: { priority: 1, ttl: 86400000, compress: false }, // 24 hours\n  metric: { priority: 3, ttl: 3600000, compress: true }, // 1 hour\n  consensus: { priority: 1, ttl: null, compress: false },\n  system: { priority: 1, ttl: null, compress: false },\n};\n\n/**\n * Memory Pool for object reuse\n */\nclass MemoryPool {\n  constructor(createFn, resetFn, maxSize = 1000) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.maxSize = maxSize;\n    this.pool = [];\n    this.allocated = 0;\n    this.reused = 0;\n  }\n\n  acquire() {\n    if (this.pool.length > 0) {\n      this.reused++;\n      return this.pool.pop();\n    }\n    this.allocated++;\n    return this.createFn();\n  }\n\n  release(obj) {\n    if (this.pool.length < this.maxSize) {\n      this.resetFn(obj);\n      this.pool.push(obj);\n    }\n  }\n\n  getStats() {\n    return {\n      poolSize: this.pool.length,\n      allocated: this.allocated,\n      reused: this.reused,\n      reuseRate: (this.reused / (this.allocated + this.reused)) * 100,\n    };\n  }\n}\n\n/**\n * Optimized LRU Cache with memory pressure handling\n */\nclass OptimizedLRUCache {\n  constructor(maxSize = 1000, maxMemoryMB = 50) {\n    this.maxSize = maxSize;\n    this.maxMemory = maxMemoryMB * 1024 * 1024;\n    this.cache = new Map();\n    this.currentMemory = 0;\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  get(key) {\n    if (this.cache.has(key)) {\n      const value = this.cache.get(key);\n      // Move to end (most recently used)\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      this.hits++;\n      return value.data;\n    }\n    this.misses++;\n    return null;\n  }\n\n  set(key, data) {\n    const size = this._estimateSize(data);\n\n    // Check memory pressure\n    if (this.currentMemory + size > this.maxMemory) {\n      this._evictByMemoryPressure(size);\n    }\n\n    // Check size limit\n    if (this.cache.size >= this.maxSize) {\n      this._evictLRU();\n    }\n\n    const entry = {\n      data,\n      size,\n      timestamp: Date.now(),\n    };\n\n    this.cache.set(key, entry);\n    this.currentMemory += size;\n  }\n\n  _estimateSize(obj) {\n    return JSON.stringify(obj).length * 2; // Rough estimate\n  }\n\n  _evictLRU() {\n    const firstKey = this.cache.keys().next().value;\n    if (firstKey) {\n      const entry = this.cache.get(firstKey);\n      this.cache.delete(firstKey);\n      this.currentMemory -= entry.size;\n      this.evictions++;\n    }\n  }\n\n  _evictByMemoryPressure(neededSize) {\n    while (this.currentMemory + neededSize > this.maxMemory && this.cache.size > 0) {\n      this._evictLRU();\n    }\n  }\n\n  forEach(callback) {\n    this.cache.forEach((entry, key) => {\n      callback(entry, key);\n    });\n  }\n\n  delete(key) {\n    if (this.cache.has(key)) {\n      const entry = this.cache.get(key);\n      this.cache.delete(key);\n      this.currentMemory -= entry.size;\n      return true;\n    }\n    return false;\n  }\n\n  getStats() {\n    return {\n      size: this.cache.size,\n      memoryUsage: this.currentMemory,\n      hitRate: (this.hits / (this.hits + this.misses)) * 100,\n      evictions: this.evictions,\n    };\n  }\n}\n\n/**\n * Optimized CollectiveMemory class with advanced memory management\n */\nexport class CollectiveMemory extends EventEmitter {\n  constructor(config = {}) {\n    super();\n\n    /** @type {import('better-sqlite3').Database | null} */\n    this.db = null;\n\n    this.config = {\n      swarmId: config.swarmId,\n      maxSize: config.maxSize || 100, // MB\n      dbPath: config.dbPath || path.join(process.cwd(), '.hive-mind', 'hive.db'),\n      compressionThreshold: config.compressionThreshold || 1024, // bytes\n      gcInterval: config.gcInterval || 300000, // 5 minutes\n      cacheSize: config.cacheSize || 1000,\n      cacheMemoryMB: config.cacheMemoryMB || 50,\n      enablePooling: config.enablePooling !== false,\n      enableAsyncOperations: config.enableAsyncOperations !== false,\n      ...config,\n    };\n\n    this.state = {\n      totalSize: 0,\n      entryCount: 0,\n      compressionRatio: 1,\n      lastGC: Date.now(),\n      accessPatterns: new Map(),\n      performanceMetrics: {\n        queryTimes: [],\n        avgQueryTime: 0,\n        cacheHitRate: 0,\n        memoryEfficiency: 0,\n      },\n    };\n\n    this.gcTimer = null;\n\n    // Optimized cache with LRU eviction\n    this.cache = new OptimizedLRUCache(this.config.cacheSize, this.config.cacheMemoryMB);\n\n    // Memory pools for frequently created objects\n    this.pools = {\n      queryResults: new MemoryPool(\n        () => ({ results: [], metadata: {} }),\n        (obj) => {\n          obj.results.length = 0;\n          Object.keys(obj.metadata).forEach((k) => delete obj.metadata[k]);\n        },\n      ),\n      memoryEntries: new MemoryPool(\n        () => ({ id: '', key: '', value: '', metadata: {} }),\n        (obj) => {\n          obj.id = obj.key = obj.value = '';\n          Object.keys(obj.metadata).forEach((k) => delete obj.metadata[k]);\n        },\n      ),\n    };\n\n    // Prepared statements for better performance\n    this.statements = new Map();\n\n    // Background worker for heavy operations\n    this.backgroundWorker = null;\n\n    this._initialize();\n  }\n\n  /**\n   * Initialize collective memory with optimizations\n   */\n  _initialize() {\n    try {\n      // Open database connection with optimizations\n      this.db = new Database(this.config.dbPath);\n\n      // Performance optimizations\n      this.db.pragma('journal_mode = WAL');\n      this.db.pragma('synchronous = NORMAL');\n      this.db.pragma('cache_size = -64000'); // 64MB cache\n      this.db.pragma('temp_store = MEMORY');\n      this.db.pragma('mmap_size = 268435456'); // 256MB memory mapping\n      this.db.pragma('optimize');\n\n      // Ensure table exists with optimized schema\n      this.db.exec(`\n        CREATE TABLE IF NOT EXISTS collective_memory (\n          id TEXT PRIMARY KEY,\n          swarm_id TEXT NOT NULL,\n          key TEXT NOT NULL,\n          value BLOB,\n          type TEXT DEFAULT 'knowledge',\n          confidence REAL DEFAULT 1.0,\n          created_by TEXT,\n          created_at INTEGER DEFAULT (strftime('%s','now')),\n          accessed_at INTEGER DEFAULT (strftime('%s','now')),\n          access_count INTEGER DEFAULT 0,\n          compressed INTEGER DEFAULT 0,\n          size INTEGER DEFAULT 0,\n          FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n        );\n        \n        -- Optimized indexes\n        CREATE UNIQUE INDEX IF NOT EXISTS idx_memory_swarm_key \n        ON collective_memory(swarm_id, key);\n        \n        CREATE INDEX IF NOT EXISTS idx_memory_type_accessed \n        ON collective_memory(type, accessed_at DESC);\n        \n        CREATE INDEX IF NOT EXISTS idx_memory_size_compressed \n        ON collective_memory(size, compressed);\n        \n        -- Memory optimization view\n        CREATE VIEW IF NOT EXISTS memory_stats AS\n        SELECT \n          swarm_id,\n          type,\n          COUNT(*) as entry_count,\n          SUM(size) as total_size,\n          AVG(access_count) as avg_access,\n          MAX(accessed_at) as last_access\n        FROM collective_memory\n        GROUP BY swarm_id, type;\n      `);\n\n      // Prepare optimized statements\n      this._prepareStatements();\n\n      // Load initial statistics\n      this._updateStatistics();\n\n      // Start background optimization processes\n      this._startOptimizationTimers();\n\n      // Initialize background worker for heavy operations\n      if (this.config.enableAsyncOperations) {\n        this._initializeBackgroundWorker();\n      }\n\n      this.emit('memory:initialized', {\n        swarmId: this.config.swarmId,\n        optimizations: {\n          pooling: this.config.enablePooling,\n          asyncOps: this.config.enableAsyncOperations,\n          cacheSize: this.config.cacheSize,\n        },\n      });\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Prepare optimized SQL statements\n   */\n  _prepareStatements() {\n    this.statements.set(\n      'insert',\n      this.db.prepare(`\n      INSERT OR REPLACE INTO collective_memory \n      (id, swarm_id, key, value, type, confidence, created_by, compressed, size)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `),\n    );\n\n    this.statements.set(\n      'update',\n      this.db.prepare(`\n      UPDATE collective_memory \n      SET value = ?, accessed_at = strftime('%s','now'), access_count = access_count + 1,\n          compressed = ?, size = ?\n      WHERE swarm_id = ? AND key = ?\n    `),\n    );\n\n    this.statements.set(\n      'select',\n      this.db.prepare(`\n      SELECT value, type, compressed, confidence, access_count\n      FROM collective_memory\n      WHERE swarm_id = ? AND key = ?\n    `),\n    );\n\n    this.statements.set(\n      'updateAccess',\n      this.db.prepare(`\n      UPDATE collective_memory\n      SET accessed_at = strftime('%s','now'), access_count = access_count + 1\n      WHERE swarm_id = ? AND key = ?\n    `),\n    );\n\n    this.statements.set(\n      'searchByPattern',\n      this.db.prepare(`\n      SELECT key, type, confidence, created_at, accessed_at, access_count\n      FROM collective_memory\n      WHERE swarm_id = ? AND key LIKE ? AND confidence >= ?\n      ORDER BY access_count DESC, confidence DESC\n      LIMIT ?\n    `),\n    );\n\n    this.statements.set(\n      'getStats',\n      this.db.prepare(`\n      SELECT \n        COUNT(*) as count,\n        SUM(size) as totalSize,\n        AVG(confidence) as avgConfidence,\n        SUM(compressed) as compressedCount,\n        AVG(access_count) as avgAccess\n      FROM collective_memory\n      WHERE swarm_id = ?\n    `),\n    );\n\n    this.statements.set(\n      'deleteExpired',\n      this.db.prepare(`\n      DELETE FROM collective_memory\n      WHERE swarm_id = ? AND type = ? AND (strftime('%s','now') - accessed_at) > ?\n    `),\n    );\n\n    this.statements.set(\n      'getLRU',\n      this.db.prepare(`\n      SELECT id, size FROM collective_memory\n      WHERE swarm_id = ? AND type NOT IN ('system', 'consensus')\n      ORDER BY accessed_at ASC, access_count ASC\n      LIMIT ?\n    `),\n    );\n  }\n\n  /**\n   * Start optimization timers\n   */\n  _startOptimizationTimers() {\n    // Main garbage collection\n    this.gcTimer = setInterval(() => this._garbageCollect(), this.config.gcInterval);\n\n    // Database optimization\n    this.optimizeTimer = setInterval(() => this._optimizeDatabase(), 1800000); // 30 minutes\n\n    // Cache cleanup\n    this.cacheTimer = setInterval(() => this._optimizeCache(), 60000); // 1 minute\n\n    // Performance monitoring\n    this.metricsTimer = setInterval(() => this._updatePerformanceMetrics(), 30000); // 30 seconds\n  }\n\n  /**\n   * Initialize background worker for heavy operations\n   */\n  _initializeBackgroundWorker() {\n    // Note: In production, this would initialize a proper Worker\n    // For now, we'll use async operations\n    this.backgroundQueue = [];\n    this.backgroundProcessing = false;\n  }\n\n  /**\n   * Store data in collective memory\n   */\n  async store(key, value, type = 'knowledge', metadata = {}) {\n    try {\n      const serialized = JSON.stringify(value);\n      const size = Buffer.byteLength(serialized);\n      const shouldCompress =\n        size > this.config.compressionThreshold && MEMORY_TYPES[type]?.compress;\n\n      let storedValue = serialized;\n      let compressed = 0;\n\n      if (shouldCompress) {\n        // In production, use proper compression like zlib\n        // For now, we'll just mark it as compressed\n        compressed = 1;\n      }\n\n      const id = `${this.config.swarmId}-${key}-${Date.now()}`;\n\n      // Check if key already exists\n      const existing = this.db\n        .prepare(\n          `\n        SELECT id FROM collective_memory \n        WHERE swarm_id = ? AND key = ?\n      `,\n        )\n        .get(this.config.swarmId, key);\n\n      if (existing) {\n        // Update existing entry\n        this.db\n          .prepare(\n            `\n          UPDATE collective_memory \n          SET value = ?, type = ?, confidence = ?, \n              accessed_at = CURRENT_TIMESTAMP, access_count = access_count + 1,\n              compressed = ?, size = ?\n          WHERE swarm_id = ? AND key = ?\n        `,\n          )\n          .run(\n            storedValue,\n            type,\n            metadata.confidence || 1.0,\n            compressed,\n            size,\n            this.config.swarmId,\n            key,\n          );\n      } else {\n        // Insert new entry\n        this.db\n          .prepare(\n            `\n          INSERT INTO collective_memory \n          (id, swarm_id, key, value, type, confidence, created_by, compressed, size)\n          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n          )\n          .run(\n            id,\n            this.config.swarmId,\n            key,\n            storedValue,\n            type,\n            metadata.confidence || 1.0,\n            metadata.createdBy || 'system',\n            compressed,\n            size,\n          );\n      }\n\n      // Update cache\n      this.cache.set(key, {\n        value,\n        type,\n        timestamp: Date.now(),\n        size,\n      });\n\n      // Check memory limits\n      this._checkMemoryLimits();\n\n      // Track access pattern\n      this._trackAccess(key, 'write');\n\n      this.emit('memory:stored', { key, type, size });\n\n      return { success: true, id, size };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from collective memory\n   */\n  async retrieve(key) {\n    try {\n      // Check cache first\n      if (this.cache.has(key)) {\n        const cached = this.cache.get(key);\n        this._trackAccess(key, 'cache_hit');\n        return cached.value;\n      }\n\n      // Query database\n      const result = this.db\n        .prepare(\n          `\n        SELECT value, type, compressed, confidence\n        FROM collective_memory\n        WHERE swarm_id = ? AND key = ?\n      `,\n        )\n        .get(this.config.swarmId, key);\n\n      if (!result) {\n        this._trackAccess(key, 'miss');\n        return null;\n      }\n\n      // Update access statistics\n      this.db\n        .prepare(\n          `\n        UPDATE collective_memory\n        SET accessed_at = CURRENT_TIMESTAMP,\n            access_count = access_count + 1\n        WHERE swarm_id = ? AND key = ?\n      `,\n        )\n        .run(this.config.swarmId, key);\n\n      // Decompress if needed\n      let value = result.value;\n      if (result.compressed) {\n        // In production, decompress here\n      }\n\n      // Parse JSON\n      const parsed = JSON.parse(value);\n\n      // Add to cache\n      this.cache.set(key, {\n        value: parsed,\n        type: result.type,\n        timestamp: Date.now(),\n        confidence: result.confidence,\n      });\n\n      this._trackAccess(key, 'read');\n\n      return parsed;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search collective memory\n   */\n  async search(pattern, options = {}) {\n    try {\n      const limit = options.limit || 50;\n      const type = options.type || null;\n      const minConfidence = options.minConfidence || 0;\n\n      let query = `\n        SELECT key, type, confidence, created_at, accessed_at, access_count\n        FROM collective_memory\n        WHERE swarm_id = ? \n        AND key LIKE ?\n        AND confidence >= ?\n      `;\n\n      const params = [this.config.swarmId, `%${pattern}%`, minConfidence];\n\n      if (type) {\n        query += ' AND type = ?';\n        params.push(type);\n      }\n\n      query += ' ORDER BY access_count DESC, confidence DESC LIMIT ?';\n      params.push(limit);\n\n      const results = this.db.prepare(query).all(...params);\n\n      this._trackAccess(`search:${pattern}`, 'search');\n\n      return results;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get related memories using association\n   */\n  async getRelated(key, limit = 10) {\n    try {\n      // Get the original memory\n      const original = await this.retrieve(key);\n      if (!original) return [];\n\n      // Simple association: find memories accessed around the same time\n      const result = this.db\n        .prepare(\n          `\n        SELECT m1.key, m1.type, m1.confidence, m1.access_count\n        FROM collective_memory m1\n        JOIN collective_memory m2 ON m1.swarm_id = m2.swarm_id\n        WHERE m2.key = ? \n        AND m1.key != ?\n        AND m1.swarm_id = ?\n        AND ABS(julianday(m1.accessed_at) - julianday(m2.accessed_at)) < 0.01\n        ORDER BY m1.confidence DESC, m1.access_count DESC\n        LIMIT ?\n      `,\n        )\n        .all(key, key, this.config.swarmId, limit);\n\n      return result;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Build associations between memories\n   */\n  async associate(key1, key2, strength = 1.0) {\n    try {\n      // Store bidirectional association\n      await this.store(\n        `assoc:${key1}:${key2}`,\n        {\n          from: key1,\n          to: key2,\n          strength,\n          created: Date.now(),\n        },\n        'system',\n      );\n\n      await this.store(\n        `assoc:${key2}:${key1}`,\n        {\n          from: key2,\n          to: key1,\n          strength,\n          created: Date.now(),\n        },\n        'system',\n      );\n\n      this.emit('memory:associated', { key1, key2, strength });\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Consolidate similar memories\n   */\n  async consolidate() {\n    try {\n      // Find similar memories\n      const memories = this.db\n        .prepare(\n          `\n        SELECT key, value, type, confidence, access_count\n        FROM collective_memory\n        WHERE swarm_id = ?\n        AND type IN ('knowledge', 'result')\n        ORDER BY created_at DESC\n        LIMIT 1000\n      `,\n        )\n        .all(this.config.swarmId);\n\n      const consolidated = new Map();\n\n      // Group by similarity (simple implementation)\n      memories.forEach((memory) => {\n        const value = JSON.parse(memory.value);\n        const category = this._categorizeMemory(value);\n\n        if (!consolidated.has(category)) {\n          consolidated.set(category, []);\n        }\n\n        consolidated.get(category).push({\n          ...memory,\n          value,\n        });\n      });\n\n      // Merge similar memories\n      let mergeCount = 0;\n      consolidated.forEach((group, category) => {\n        if (group.length > 1) {\n          const merged = this._mergeMemories(group);\n\n          // Store merged memory\n          this.store(`consolidated:${category}`, merged, 'knowledge', {\n            confidence: merged.confidence,\n            createdBy: 'consolidation',\n          });\n\n          mergeCount++;\n        }\n      });\n\n      this.emit('memory:consolidated', { categories: consolidated.size, merged: mergeCount });\n\n      return { categories: consolidated.size, merged: mergeCount };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Categorize memory for consolidation\n   */\n  _categorizeMemory(value) {\n    // Simple categorization based on content\n    if (typeof value === 'string') {\n      return 'text';\n    }\n\n    if (typeof value === 'object') {\n      const keys = Object.keys(value).sort().join(':');\n      return `object:${keys.substring(0, 50)}`;\n    }\n\n    return 'other';\n  }\n\n  /**\n   * Merge similar memories\n   */\n  _mergeMemories(memories) {\n    // Calculate weighted average confidence\n    let totalWeight = 0;\n    let weightedConfidence = 0;\n    const mergedValue = {};\n\n    memories.forEach((memory) => {\n      const weight = memory.access_count + 1;\n      totalWeight += weight;\n      weightedConfidence += memory.confidence * weight;\n\n      // Merge values (simple implementation)\n      if (typeof memory.value === 'object') {\n        Object.assign(mergedValue, memory.value);\n      }\n    });\n\n    return {\n      value: mergedValue,\n      confidence: weightedConfidence / totalWeight,\n      sourceCount: memories.length,\n    };\n  }\n\n  /**\n   * Garbage collection\n   */\n  _garbageCollect() {\n    try {\n      const now = Date.now();\n      let deletedCount = 0;\n\n      // Delete expired memories based on TTL\n      Object.entries(MEMORY_TYPES).forEach(([type, config]) => {\n        if (config.ttl) {\n          const result = this.db\n            .prepare(\n              `\n            DELETE FROM collective_memory\n            WHERE swarm_id = ?\n            AND type = ?\n            AND (julianday('now') - julianday(accessed_at)) * 86400000 > ?\n          `,\n            )\n            .run(this.config.swarmId, type, config.ttl);\n\n          deletedCount += result.changes;\n        }\n      });\n\n      // Clear old cache entries\n      const cacheTimeout = 300000; // 5 minutes\n      this.cache.forEach((value, key) => {\n        if (now - value.timestamp > cacheTimeout) {\n          this.cache.delete(key);\n        }\n      });\n\n      // Update statistics\n      this._updateStatistics();\n\n      this.state.lastGC = now;\n\n      if (deletedCount > 0) {\n        this.emit('memory:gc', { deleted: deletedCount, cacheSize: this.cache.size });\n      }\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Check memory limits and evict if necessary\n   */\n  _checkMemoryLimits() {\n    if (this.state.totalSize > this.config.maxSize * 1024 * 1024) {\n      // Evict least recently used memories\n      const toEvict = this.db\n        .prepare(\n          `\n        SELECT id, size FROM collective_memory\n        WHERE swarm_id = ?\n        AND type NOT IN ('system', 'consensus')\n        ORDER BY accessed_at ASC, access_count ASC\n        LIMIT 100\n      `,\n        )\n        .all(this.config.swarmId);\n\n      let freedSize = 0;\n      toEvict.forEach((memory) => {\n        this.db.prepare('DELETE FROM collective_memory WHERE id = ?').run(memory.id);\n        freedSize += memory.size;\n      });\n\n      this.emit('memory:evicted', { count: toEvict.length, freedSize });\n    }\n  }\n\n  /**\n   * Optimize database performance\n   */\n  _optimizeDatabase() {\n    try {\n      // Run database optimization\n      this.db.pragma('optimize');\n      this.db.pragma('analysis_limit=1000');\n      this.db.exec('ANALYZE');\n\n      // Update database statistics\n      this._updateStatistics();\n\n      this.emit('database:optimized');\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Optimize cache performance\n   */\n  _optimizeCache() {\n    try {\n      const now = Date.now();\n      const cacheTimeout = 300000; // 5 minutes\n\n      // Clear expired cache entries\n      if (this.cache.cache) {\n        this.cache.cache.forEach((value, key) => {\n          if (now - value.timestamp > cacheTimeout) {\n            this.cache.cache.delete(key);\n          }\n        });\n      }\n\n      this.emit('cache:optimized', {\n        size: this.cache.cache ? this.cache.cache.size : 0,\n      });\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Update performance metrics\n   */\n  _updatePerformanceMetrics() {\n    try {\n      // Calculate cache hit rate\n      const cacheStats = this.cache.getStats();\n      this.state.performanceMetrics.cacheHitRate = cacheStats.hitRate || 0;\n\n      // Calculate memory efficiency\n      this.state.performanceMetrics.memoryEfficiency =\n        (this.state.totalSize / (this.config.maxSize * 1024 * 1024)) * 100;\n\n      // Update average query time if we have recent measurements\n      if (this.state.performanceMetrics.queryTimes.length > 0) {\n        this.state.performanceMetrics.avgQueryTime =\n          this.state.performanceMetrics.queryTimes.reduce((sum, time) => sum + time, 0) /\n          this.state.performanceMetrics.queryTimes.length;\n\n        // Keep only recent query times (last 100)\n        if (this.state.performanceMetrics.queryTimes.length > 100) {\n          this.state.performanceMetrics.queryTimes =\n            this.state.performanceMetrics.queryTimes.slice(-100);\n        }\n      }\n\n      this.emit('metrics:updated', this.state.performanceMetrics);\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Update memory statistics\n   */\n  _updateStatistics() {\n    const stats = this.db\n      .prepare(\n        `\n      SELECT \n        COUNT(*) as count,\n        SUM(size) as totalSize,\n        AVG(confidence) as avgConfidence,\n        SUM(compressed) as compressedCount\n      FROM collective_memory\n      WHERE swarm_id = ?\n    `,\n      )\n      .get(this.config.swarmId);\n\n    this.state.entryCount = stats.count || 0;\n    this.state.totalSize = stats.totalSize || 0;\n    this.state.avgConfidence = stats.avgConfidence || 1.0;\n\n    if (stats.compressedCount > 0) {\n      // Estimate compression ratio\n      this.state.compressionRatio = 0.6; // Assume 40% compression\n    }\n  }\n\n  /**\n   * Track access patterns\n   */\n  _trackAccess(key, operation) {\n    const pattern = this.state.accessPatterns.get(key) || {\n      reads: 0,\n      writes: 0,\n      searches: 0,\n      cacheHits: 0,\n      misses: 0,\n      lastAccess: Date.now(),\n    };\n\n    switch (operation) {\n      case 'read':\n        pattern.reads++;\n        break;\n      case 'write':\n        pattern.writes++;\n        break;\n      case 'search':\n        pattern.searches++;\n        break;\n      case 'cache_hit':\n        pattern.cacheHits++;\n        break;\n      case 'miss':\n        pattern.misses++;\n        break;\n    }\n\n    pattern.lastAccess = Date.now();\n    this.state.accessPatterns.set(key, pattern);\n\n    // Keep access patterns size limited\n    if (this.state.accessPatterns.size > 1000) {\n      // Remove oldest entries\n      const sorted = Array.from(this.state.accessPatterns.entries()).sort(\n        (a, b) => a[1].lastAccess - b[1].lastAccess,\n      );\n\n      sorted.slice(0, 100).forEach(([key]) => {\n        this.state.accessPatterns.delete(key);\n      });\n    }\n  }\n\n  /**\n   * Get enhanced memory statistics\n   */\n  getStatistics() {\n    return {\n      swarmId: this.config.swarmId,\n      entryCount: this.state.entryCount,\n      totalSize: this.state.totalSize,\n      maxSize: this.config.maxSize * 1024 * 1024,\n      utilizationPercent: (this.state.totalSize / (this.config.maxSize * 1024 * 1024)) * 100,\n      avgConfidence: this.state.avgConfidence,\n      compressionRatio: this.state.compressionRatio,\n      cacheSize: this.cache.cache ? this.cache.cache.size : 0,\n      lastGC: new Date(this.state.lastGC).toISOString(),\n      accessPatterns: this.state.accessPatterns.size,\n      optimization: {\n        cacheOptimized: true,\n        poolingEnabled: this.config.enablePooling,\n        asyncOperations: this.config.enableAsyncOperations,\n        compressionRatio: this.state.compressionRatio,\n        performanceMetrics: this.state.performanceMetrics,\n      },\n    };\n  }\n\n  /**\n   * Export memory snapshot\n   */\n  async exportSnapshot(filepath) {\n    try {\n      const memories = this.db\n        .prepare(\n          `\n        SELECT * FROM collective_memory\n        WHERE swarm_id = ?\n        ORDER BY created_at DESC\n      `,\n        )\n        .all(this.config.swarmId);\n\n      const snapshot = {\n        swarmId: this.config.swarmId,\n        timestamp: new Date().toISOString(),\n        statistics: this.getStatistics(),\n        memories: memories.map((m) => ({\n          ...m,\n          value: JSON.parse(m.value),\n        })),\n      };\n\n      // In production, write to file\n      // For now, return the snapshot\n      this.emit('memory:exported', { count: memories.length });\n\n      return snapshot;\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import memory snapshot\n   */\n  async importSnapshot(snapshot) {\n    try {\n      let imported = 0;\n\n      for (const memory of snapshot.memories) {\n        await this.store(memory.key, memory.value, memory.type, {\n          confidence: memory.confidence,\n          createdBy: memory.created_by,\n        });\n        imported++;\n      }\n\n      this.emit('memory:imported', { count: imported });\n\n      return { imported };\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Enhanced shutdown with cleanup\n   */\n  close() {\n    // Clear all timers\n    if (this.gcTimer) clearInterval(this.gcTimer);\n    if (this.optimizeTimer) clearInterval(this.optimizeTimer);\n    if (this.cacheTimer) clearInterval(this.cacheTimer);\n    if (this.metricsTimer) clearInterval(this.metricsTimer);\n\n    // Final optimization before closing\n    try {\n      this.db.pragma('optimize');\n    } catch (error) {\n      // Ignore errors during shutdown\n    }\n\n    // Close database\n    if (this.db) {\n      this.db.close();\n    }\n\n    // Clear memory pools\n    if (this.config.enablePooling) {\n      Object.values(this.pools).forEach((pool) => {\n        pool.pool.length = 0;\n      });\n    }\n\n    const finalStats = {\n      cacheStats: this.cache.getStats ? this.cache.getStats() : {},\n      poolStats: this.config.enablePooling\n        ? {\n            queryResults: this.pools.queryResults.getStats(),\n            memoryEntries: this.pools.memoryEntries.getStats(),\n          }\n        : null,\n      performanceMetrics: this.state.performanceMetrics,\n    };\n\n    this.emit('memory:closed', finalStats);\n  }\n\n  /**\n   * Get comprehensive memory analytics\n   */\n  getAnalytics() {\n    return {\n      basic: this.getStatistics(),\n      performance: this.state.performanceMetrics,\n      cache: this.cache.getStats ? this.cache.getStats() : {},\n      pools: this.config.enablePooling\n        ? {\n            queryResults: this.pools.queryResults.getStats(),\n            memoryEntries: this.pools.memoryEntries.getStats(),\n          }\n        : null,\n      database: {\n        fragmentation: this.db.pragma('freelist_count'),\n        pageSize: this.db.pragma('page_size'),\n        cacheSize: this.db.pragma('cache_size'),\n      },\n    };\n  }\n\n  /**\n   * Memory health check\n   */\n  async healthCheck() {\n    const analytics = this.getAnalytics();\n    const health = {\n      status: 'healthy',\n      issues: [],\n      recommendations: [],\n    };\n\n    // Check cache hit rate\n    if (analytics.cache.hitRate < 50) {\n      health.issues.push('Low cache hit rate');\n      health.recommendations.push('Consider increasing cache size');\n    }\n\n    // Check memory usage\n    if (analytics.basic.utilizationPercent > 90) {\n      health.status = 'warning';\n      health.issues.push('High memory utilization');\n      health.recommendations.push('Consider increasing max memory or running garbage collection');\n    }\n\n    // Check query performance\n    if (analytics.performance.avgQueryTime > 100) {\n      health.issues.push('Slow query performance');\n      health.recommendations.push('Consider database optimization or indexing');\n    }\n\n    return health;\n  }\n}\n\n/**\n * Memory optimization utilities\n */\nexport class MemoryOptimizer {\n  static async optimizeCollectiveMemory(memory) {\n    const startTime = performance.now();\n\n    // Run comprehensive optimization\n    await memory._optimizeDatabase();\n    memory._optimizeCache();\n    memory._garbageCollect();\n\n    const duration = performance.now() - startTime;\n\n    return {\n      duration,\n      analytics: memory.getAnalytics(),\n      health: await memory.healthCheck(),\n    };\n  }\n\n  static calculateOptimalCacheSize(memoryStats, accessPatterns) {\n    const avgEntrySize = memoryStats.totalSize / memoryStats.entryCount;\n    const hotKeys = Array.from(accessPatterns.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, Math.min(1000, memoryStats.entryCount * 0.2));\n\n    const optimalCacheEntries = hotKeys.length * 1.2; // 20% buffer\n    const optimalCacheMemoryMB = (optimalCacheEntries * avgEntrySize) / (1024 * 1024);\n\n    return {\n      entries: Math.ceil(optimalCacheEntries),\n      memoryMB: Math.ceil(optimalCacheMemoryMB),\n      efficiency: (hotKeys.length / memoryStats.entryCount) * 100,\n    };\n  }\n\n  static generateOptimizationReport(analytics) {\n    const report = {\n      timestamp: new Date().toISOString(),\n      summary: {},\n      recommendations: [],\n      metrics: analytics,\n    };\n\n    // Performance summary\n    report.summary.avgQueryTime = analytics.performance.avgQueryTime;\n    report.summary.cacheHitRate = analytics.cache.hitRate || 0;\n    report.summary.memoryEfficiency = analytics.cache.memoryUsage / (1024 * 1024);\n\n    // Generate recommendations\n    if ((analytics.cache.hitRate || 0) < 70) {\n      report.recommendations.push({\n        type: 'cache',\n        priority: 'high',\n        description: 'Increase cache size to improve hit rate',\n        impact: 'Reduce database queries by up to 30%',\n      });\n    }\n\n    if (analytics.performance.avgQueryTime > 50) {\n      report.recommendations.push({\n        type: 'database',\n        priority: 'medium',\n        description: 'Optimize database indexes and run ANALYZE',\n        impact: 'Improve query performance by 20-40%',\n      });\n    }\n\n    if (analytics.pools?.queryResults?.reuseRate < 50) {\n      report.recommendations.push({\n        type: 'pooling',\n        priority: 'low',\n        description: 'Increase object pool sizes for better reuse',\n        impact: 'Reduce garbage collection pressure',\n      });\n    }\n\n    return report;\n  }\n}\n"],"names":["EventEmitter","Database","path","performance","MEMORY_TYPES","knowledge","priority","ttl","compress","context","task","result","error","metric","consensus","system","MemoryPool","createFn","resetFn","maxSize","pool","allocated","reused","acquire","length","pop","release","obj","push","getStats","poolSize","reuseRate","OptimizedLRUCache","maxMemoryMB","maxMemory","cache","Map","currentMemory","hits","misses","evictions","get","key","has","value","delete","set","data","size","_estimateSize","_evictByMemoryPressure","_evictLRU","entry","timestamp","Date","now","JSON","stringify","firstKey","keys","next","neededSize","forEach","callback","memoryUsage","hitRate","CollectiveMemory","config","db","swarmId","dbPath","join","process","cwd","compressionThreshold","gcInterval","cacheSize","cacheMemoryMB","enablePooling","enableAsyncOperations","state","totalSize","entryCount","compressionRatio","lastGC","accessPatterns","performanceMetrics","queryTimes","avgQueryTime","cacheHitRate","memoryEfficiency","gcTimer","pools","queryResults","results","metadata","Object","k","memoryEntries","id","statements","backgroundWorker","_initialize","pragma","exec","_prepareStatements","_updateStatistics","_startOptimizationTimers","_initializeBackgroundWorker","emit","optimizations","pooling","asyncOps","prepare","setInterval","_garbageCollect","optimizeTimer","_optimizeDatabase","cacheTimer","_optimizeCache","metricsTimer","_updatePerformanceMetrics","backgroundQueue","backgroundProcessing","store","type","serialized","Buffer","byteLength","shouldCompress","storedValue","compressed","existing","run","confidence","createdBy","_checkMemoryLimits","_trackAccess","success","retrieve","cached","parsed","parse","search","pattern","options","limit","minConfidence","query","params","all","getRelated","original","associate","key1","key2","strength","from","to","created","consolidate","memories","consolidated","memory","category","_categorizeMemory","mergeCount","group","merged","_mergeMemories","categories","sort","substring","totalWeight","weightedConfidence","mergedValue","weight","access_count","assign","sourceCount","deletedCount","entries","changes","cacheTimeout","deleted","toEvict","freedSize","count","cacheStats","reduce","sum","time","slice","stats","avgConfidence","compressedCount","operation","reads","writes","searches","cacheHits","lastAccess","sorted","Array","a","b","getStatistics","utilizationPercent","toISOString","optimization","cacheOptimized","poolingEnabled","asyncOperations","exportSnapshot","filepath","snapshot","statistics","map","m","importSnapshot","imported","created_by","close","clearInterval","values","finalStats","poolStats","getAnalytics","basic","database","fragmentation","pageSize","healthCheck","analytics","health","status","issues","recommendations","MemoryOptimizer","optimizeCollectiveMemory","startTime","duration","calculateOptimalCacheSize","memoryStats","avgEntrySize","hotKeys","Math","min","optimalCacheEntries","optimalCacheMemoryMB","ceil","memoryMB","efficiency","generateOptimizationReport","report","summary","metrics","description","impact"],"mappings":"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"}