{"version":3,"sources":["../../../../../src/cli/simple-commands/hive-mind/db-optimizer.js"],"sourcesContent":["/**\n * Hive Mind Database Optimizer\n *\n * Safe, backward-compatible database optimization for existing deployments\n * Adds indexes, performance improvements, and new features without breaking changes\n */\n\nimport Database from 'better-sqlite3';\nimport { existsSync, mkdirSync } from 'fs';\nimport { writeFile, readFile } from 'fs/promises';\nimport path from 'path';\nimport chalk from 'chalk';\nimport ora from 'ora';\n\n/**\n * Optimize existing hive mind database with backward compatibility\n */\nexport async function optimizeHiveMindDatabase(dbPath, options = {}) {\n  const spinner = ora('Optimizing Hive Mind database...').start();\n\n  try {\n    // Open database with write-ahead logging for better performance\n    const db = new Database(dbPath, {\n      verbose: options.verbose ? console.log : null,\n    });\n\n    // Enable WAL mode for better concurrency\n    db.pragma('journal_mode = WAL');\n    db.pragma('synchronous = NORMAL');\n\n    // Get current schema version\n    const schemaVersion = getSchemaVersion(db);\n    spinner.text = `Current schema version: ${schemaVersion}`;\n\n    // Apply optimizations based on version\n    let optimizationsApplied = [];\n\n    // Version 1.0 -> 1.1: Add basic indexes\n    if (schemaVersion < 1.1) {\n      spinner.text = 'Applying performance indexes...';\n      applyBasicIndexes(db);\n      optimizationsApplied.push('Basic performance indexes');\n    }\n\n    // Version 1.1 -> 1.2: Add advanced indexes and analyze\n    if (schemaVersion < 1.2) {\n      spinner.text = 'Applying advanced indexes...';\n      applyAdvancedIndexes(db);\n      optimizationsApplied.push('Advanced query optimization');\n    }\n\n    // Version 1.2 -> 1.3: Add performance tracking tables\n    if (schemaVersion < 1.3) {\n      spinner.text = 'Adding performance tracking...';\n      addPerformanceTracking(db);\n      optimizationsApplied.push('Performance monitoring tables');\n    }\n\n    // Version 1.3 -> 1.4: Add memory optimization\n    if (schemaVersion < 1.4) {\n      spinner.text = 'Optimizing memory management...';\n      addMemoryOptimization(db);\n      optimizationsApplied.push('Memory optimization features');\n    }\n\n    // Version 1.4 -> 1.5: Add behavioral tracking\n    if (schemaVersion < 1.5) {\n      spinner.text = 'Adding behavioral analysis...';\n      addBehavioralTracking(db);\n      optimizationsApplied.push('Behavioral pattern tracking');\n    }\n\n    // Run ANALYZE to update query planner statistics\n    spinner.text = 'Updating query statistics...';\n    db.exec('ANALYZE');\n\n    // Vacuum if requested (requires exclusive access)\n    if (options.vacuum) {\n      spinner.text = 'Vacuuming database...';\n      db.exec('VACUUM');\n      optimizationsApplied.push('Database vacuumed');\n    }\n\n    // Update schema version\n    updateSchemaVersion(db, 1.5);\n\n    // Close database\n    db.close();\n\n    spinner.succeed('Database optimization complete!');\n\n    if (optimizationsApplied.length > 0) {\n      console.log('\\n' + chalk.green('✓') + ' Optimizations applied:');\n      optimizationsApplied.forEach((opt) => {\n        console.log('  - ' + opt);\n      });\n    } else {\n      console.log('\\n' + chalk.yellow('ℹ') + ' Database already optimized');\n    }\n\n    return { success: true, optimizations: optimizationsApplied };\n  } catch (error) {\n    spinner.fail('Database optimization failed');\n    console.error(chalk.red('Error:'), error.message);\n    return { success: false, error: error.message };\n  }\n}\n\n/**\n * Get current schema version\n */\nfunction getSchemaVersion(db) {\n  try {\n    // Check if schema_version table exists\n    const tableExists = db\n      .prepare(\n        `\n      SELECT name FROM sqlite_master \n      WHERE type='table' AND name='schema_version'\n    `,\n      )\n      .get();\n\n    if (!tableExists) {\n      // Create schema version table\n      db.exec(`\n        CREATE TABLE schema_version (\n          version REAL PRIMARY KEY,\n          applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          description TEXT\n        )\n      `);\n\n      // Insert initial version\n      db.prepare(\n        `\n        INSERT INTO schema_version (version, description) \n        VALUES (1.0, 'Initial schema')\n      `,\n      ).run();\n\n      return 1.0;\n    }\n\n    // Get latest version\n    const result = db\n      .prepare(\n        `\n      SELECT version FROM schema_version \n      ORDER BY version DESC LIMIT 1\n    `,\n      )\n      .get();\n\n    return result ? result.version : 1.0;\n  } catch (error) {\n    // If any error, assume version 1.0\n    return 1.0;\n  }\n}\n\n/**\n * Update schema version\n */\nfunction updateSchemaVersion(db, version, description = '') {\n  db.prepare(\n    `\n    INSERT OR REPLACE INTO schema_version (version, description) \n    VALUES (?, ?)\n  `,\n  ).run(version, description || `Updated to version ${version}`);\n}\n\n/**\n * Apply basic performance indexes\n */\nfunction applyBasicIndexes(db) {\n  // First ensure all required columns exist\n  ensureRequiredColumns(db);\n\n  // Check which tables exist before creating indexes\n  const tables = db\n    .prepare(\n      `\n    SELECT name FROM sqlite_master \n    WHERE type='table' AND name NOT LIKE 'sqlite_%'\n  `,\n    )\n    .all()\n    .map((row) => row.name);\n\n  const tableSet = new Set(tables);\n\n  const indexes = [];\n\n  // Only create indexes for tables that exist\n  if (tableSet.has('swarms')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_swarms_status ON swarms(status)',\n      'CREATE INDEX IF NOT EXISTS idx_swarms_created ON swarms(created_at)',\n    );\n  }\n\n  if (tableSet.has('agents')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_agents_swarm ON agents(swarm_id)',\n      'CREATE INDEX IF NOT EXISTS idx_agents_type ON agents(type)',\n      'CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status)',\n    );\n  }\n\n  if (tableSet.has('tasks')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_tasks_swarm ON tasks(swarm_id)',\n      'CREATE INDEX IF NOT EXISTS idx_tasks_agent ON tasks(agent_id)',\n      'CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)',\n      'CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority DESC)',\n    );\n  }\n\n  if (tableSet.has('collective_memory')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_memory_swarm ON collective_memory(swarm_id)',\n      'CREATE INDEX IF NOT EXISTS idx_memory_key ON collective_memory(key)',\n      'CREATE INDEX IF NOT EXISTS idx_memory_type ON collective_memory(type)',\n    );\n  }\n\n  if (tableSet.has('consensus_decisions')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_consensus_swarm ON consensus_decisions(swarm_id)',\n      'CREATE INDEX IF NOT EXISTS idx_consensus_created ON consensus_decisions(created_at)',\n    );\n  }\n\n  indexes.forEach((sql) => {\n    try {\n      db.exec(sql);\n    } catch (error) {\n      console.warn(`Warning: Could not create index: ${error.message}`);\n    }\n  });\n}\n\n/**\n * Ensure all required columns exist\n */\nfunction ensureRequiredColumns(db) {\n  // First check which tables exist\n  const tables = db\n    .prepare(\n      `\n    SELECT name FROM sqlite_master \n    WHERE type='table' AND name NOT LIKE 'sqlite_%'\n  `,\n    )\n    .all()\n    .map((row) => row.name);\n\n  const tableSet = new Set(tables);\n\n  // Only check columns for tables that exist\n  if (tableSet.has('tasks')) {\n    // Check and add priority column to tasks table\n    const hasPriority = db\n      .prepare(\n        `\n      SELECT COUNT(*) as count FROM pragma_table_info('tasks') \n      WHERE name = 'priority'\n    `,\n      )\n      .get();\n\n    if (!hasPriority || hasPriority.count === 0) {\n      try {\n        db.exec('ALTER TABLE tasks ADD COLUMN priority INTEGER DEFAULT 5');\n        console.log('Added missing priority column to tasks table');\n      } catch (error) {\n        if (\n          !error.message.includes('duplicate column') &&\n          !error.message.includes('no such table')\n        ) {\n          throw error;\n        }\n      }\n    }\n\n    // Check and add completed_at column to tasks table\n    const hasCompletedAt = db\n      .prepare(\n        `\n      SELECT COUNT(*) as count FROM pragma_table_info('tasks') \n      WHERE name = 'completed_at'\n    `,\n      )\n      .get();\n\n    if (!hasCompletedAt || hasCompletedAt.count === 0) {\n      try {\n        db.exec('ALTER TABLE tasks ADD COLUMN completed_at DATETIME');\n        console.log('Added missing completed_at column to tasks table');\n      } catch (error) {\n        if (\n          !error.message.includes('duplicate column') &&\n          !error.message.includes('no such table')\n        ) {\n          throw error;\n        }\n      }\n    }\n\n    // Check and add result column to tasks table\n    const hasResult = db\n      .prepare(\n        `\n      SELECT COUNT(*) as count FROM pragma_table_info('tasks') \n      WHERE name = 'result'\n    `,\n      )\n      .get();\n\n    if (!hasResult || hasResult.count === 0) {\n      try {\n        db.exec('ALTER TABLE tasks ADD COLUMN result TEXT');\n        console.log('Added missing result column to tasks table');\n      } catch (error) {\n        if (\n          !error.message.includes('duplicate column') &&\n          !error.message.includes('no such table')\n        ) {\n          throw error;\n        }\n      }\n    }\n  }\n\n  if (tableSet.has('swarms')) {\n    // Check and add updated_at column to swarms table\n    const hasUpdatedAt = db\n      .prepare(\n        `\n      SELECT COUNT(*) as count FROM pragma_table_info('swarms') \n      WHERE name = 'updated_at'\n    `,\n      )\n      .get();\n\n    if (!hasUpdatedAt || hasUpdatedAt.count === 0) {\n      try {\n        db.exec('ALTER TABLE swarms ADD COLUMN updated_at DATETIME');\n        console.log('Added missing updated_at column to swarms table');\n      } catch (error) {\n        if (\n          !error.message.includes('duplicate column') &&\n          !error.message.includes('no such table')\n        ) {\n          throw error;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Apply advanced performance indexes\n */\nfunction applyAdvancedIndexes(db) {\n  // Check which tables exist\n  const tables = db\n    .prepare(\n      `\n    SELECT name FROM sqlite_master \n    WHERE type='table' AND name NOT LIKE 'sqlite_%'\n  `,\n    )\n    .all()\n    .map((row) => row.name);\n\n  const tableSet = new Set(tables);\n  const indexes = [];\n\n  // Composite indexes for common queries\n  if (tableSet.has('tasks')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_tasks_swarm_status ON tasks(swarm_id, status)',\n      'CREATE INDEX IF NOT EXISTS idx_tasks_full ON tasks(swarm_id, agent_id, status, priority)',\n      \"CREATE INDEX IF NOT EXISTS idx_tasks_pending ON tasks(swarm_id, priority) WHERE status = 'pending'\",\n    );\n  }\n\n  if (tableSet.has('agents')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_agents_swarm_type ON agents(swarm_id, type)',\n      'CREATE INDEX IF NOT EXISTS idx_agents_full ON agents(swarm_id, type, status, role)',\n    );\n  }\n\n  if (tableSet.has('collective_memory')) {\n    indexes.push(\n      'CREATE INDEX IF NOT EXISTS idx_memory_swarm_key ON collective_memory(swarm_id, key)',\n    );\n  }\n\n  if (tableSet.has('swarms')) {\n    indexes.push(\n      \"CREATE INDEX IF NOT EXISTS idx_swarms_active ON swarms(id, name) WHERE status = 'active'\",\n    );\n  }\n\n  indexes.forEach((sql) => {\n    try {\n      db.exec(sql);\n    } catch (error) {\n      console.warn(`Warning: Could not create index: ${error.message}`);\n    }\n  });\n}\n\n/**\n * Add performance tracking tables\n */\nfunction addPerformanceTracking(db) {\n  // Agent performance metrics\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS agent_performance (\n      agent_id TEXT PRIMARY KEY,\n      tasks_completed INTEGER DEFAULT 0,\n      tasks_failed INTEGER DEFAULT 0,\n      avg_completion_time REAL,\n      success_rate REAL,\n      last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,\n      FOREIGN KEY (agent_id) REFERENCES agents(id)\n    )\n  `);\n\n  // Swarm performance metrics\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS swarm_performance (\n      swarm_id TEXT PRIMARY KEY,\n      total_tasks INTEGER DEFAULT 0,\n      completed_tasks INTEGER DEFAULT 0,\n      avg_consensus_time REAL,\n      memory_efficiency REAL,\n      last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,\n      FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n    )\n  `);\n\n  // Create triggers to update performance metrics\n  db.exec(`\n    CREATE TRIGGER IF NOT EXISTS update_agent_performance\n    AFTER UPDATE OF status ON tasks\n    WHEN NEW.status = 'completed' OR NEW.status = 'failed'\n    BEGIN\n      INSERT OR REPLACE INTO agent_performance (agent_id, tasks_completed, tasks_failed)\n      VALUES (\n        NEW.agent_id,\n        COALESCE((SELECT tasks_completed FROM agent_performance WHERE agent_id = NEW.agent_id), 0) + \n          CASE WHEN NEW.status = 'completed' THEN 1 ELSE 0 END,\n        COALESCE((SELECT tasks_failed FROM agent_performance WHERE agent_id = NEW.agent_id), 0) + \n          CASE WHEN NEW.status = 'failed' THEN 1 ELSE 0 END\n      );\n    END\n  `);\n}\n\n/**\n * Add memory optimization features\n */\nfunction addMemoryOptimization(db) {\n  // Check if collective_memory table exists\n  const tables = db\n    .prepare(\n      `\n    SELECT name FROM sqlite_master \n    WHERE type='table' AND name = 'collective_memory'\n  `,\n    )\n    .all();\n\n  if (tables.length === 0) {\n    console.log('collective_memory table does not exist, skipping memory optimization');\n    return;\n  }\n\n  // Check and add access_count column\n  const hasAccessCount = db\n    .prepare(\n      `\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \n    WHERE name = 'access_count'\n  `,\n    )\n    .get();\n\n  if (!hasAccessCount || hasAccessCount.count === 0) {\n    try {\n      db.exec(`\n        ALTER TABLE collective_memory \n        ADD COLUMN access_count INTEGER DEFAULT 0\n      `);\n      console.log('Added access_count column to collective_memory table');\n    } catch (error) {\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\n        throw error;\n      }\n    }\n  }\n\n  // Check and add accessed_at column (not last_accessed)\n  const hasAccessedAt = db\n    .prepare(\n      `\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \n    WHERE name = 'accessed_at'\n  `,\n    )\n    .get();\n\n  if (!hasAccessedAt || hasAccessedAt.count === 0) {\n    try {\n      db.exec(`\n        ALTER TABLE collective_memory \n        ADD COLUMN accessed_at DATETIME\n      `);\n      console.log('Added accessed_at column to collective_memory table');\n    } catch (error) {\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\n        throw error;\n      }\n    }\n  }\n\n  // Add compressed and size columns if missing\n  const hasCompressed = db\n    .prepare(\n      `\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \n    WHERE name = 'compressed'\n  `,\n    )\n    .get();\n\n  if (!hasCompressed || hasCompressed.count === 0) {\n    try {\n      db.exec(`\n        ALTER TABLE collective_memory \n        ADD COLUMN compressed INTEGER DEFAULT 0\n      `);\n    } catch (error) {\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\n        throw error;\n      }\n    }\n  }\n\n  const hasSize = db\n    .prepare(\n      `\n    SELECT COUNT(*) as count FROM pragma_table_info('collective_memory') \n    WHERE name = 'size'\n  `,\n    )\n    .get();\n\n  if (!hasSize || hasSize.count === 0) {\n    try {\n      db.exec(`\n        ALTER TABLE collective_memory \n        ADD COLUMN size INTEGER DEFAULT 0\n      `);\n    } catch (error) {\n      if (!error.message.includes('duplicate column') && !error.message.includes('no such table')) {\n        throw error;\n      }\n    }\n  }\n\n  // Create memory usage summary view\n  db.exec(`\n    CREATE VIEW IF NOT EXISTS memory_usage_summary AS\n    SELECT \n      swarm_id,\n      COUNT(*) as total_entries,\n      SUM(LENGTH(value)) as total_size,\n      AVG(access_count) as avg_access_count,\n      COUNT(CASE WHEN access_count = 0 THEN 1 END) as unused_entries\n    FROM collective_memory\n    GROUP BY swarm_id\n  `);\n\n  // Add memory cleanup tracking\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS memory_cleanup_log (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      swarm_id TEXT,\n      entries_removed INTEGER,\n      space_reclaimed INTEGER,\n      cleanup_type TEXT,\n      performed_at DATETIME DEFAULT CURRENT_TIMESTAMP\n    )\n  `);\n}\n\n/**\n * Add behavioral tracking features\n */\nfunction addBehavioralTracking(db) {\n  // Agent interaction patterns\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS agent_interactions (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      from_agent_id TEXT,\n      to_agent_id TEXT,\n      interaction_type TEXT,\n      swarm_id TEXT,\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      FOREIGN KEY (from_agent_id) REFERENCES agents(id),\n      FOREIGN KEY (to_agent_id) REFERENCES agents(id),\n      FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n    )\n  `);\n\n  // Behavioral patterns\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS behavioral_patterns (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      swarm_id TEXT,\n      pattern_type TEXT,\n      pattern_data TEXT, -- JSON\n      confidence REAL,\n      first_observed DATETIME DEFAULT CURRENT_TIMESTAMP,\n      last_observed DATETIME DEFAULT CURRENT_TIMESTAMP,\n      occurrence_count INTEGER DEFAULT 1,\n      FOREIGN KEY (swarm_id) REFERENCES swarms(id)\n    )\n  `);\n\n  // Create indexes for behavioral analysis\n  db.exec(`\n    CREATE INDEX IF NOT EXISTS idx_interactions_swarm ON agent_interactions(swarm_id);\n    CREATE INDEX IF NOT EXISTS idx_interactions_agents ON agent_interactions(from_agent_id, to_agent_id);\n    CREATE INDEX IF NOT EXISTS idx_patterns_swarm_type ON behavioral_patterns(swarm_id, pattern_type);\n  `);\n}\n\n/**\n * Database maintenance utilities\n */\nexport async function performMaintenance(dbPath, options = {}) {\n  const spinner = ora('Performing database maintenance...').start();\n\n  try {\n    const db = new Database(dbPath);\n\n    // Clean up old memory entries\n    if (options.cleanMemory) {\n      // Check if collective_memory table exists\n      const hasMemoryTable = db\n        .prepare(\n          `\n        SELECT name FROM sqlite_master \n        WHERE type='table' AND name='collective_memory'\n      `,\n        )\n        .get();\n\n      if (hasMemoryTable) {\n        spinner.text = 'Cleaning old memory entries...';\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - (options.memoryRetentionDays || 30));\n\n        try {\n          const result = db\n            .prepare(\n              `\n            DELETE FROM collective_memory \n            WHERE accessed_at < ? AND access_count < 5\n          `,\n            )\n            .run(cutoffDate.toISOString());\n\n          console.log(chalk.green(`✓ Removed ${result.changes} old memory entries`));\n        } catch (error) {\n          console.warn(chalk.yellow(`⚠ Could not clean memory entries: ${error.message}`));\n        }\n      } else {\n        console.log(chalk.yellow('⚠ collective_memory table not found, skipping memory cleanup'));\n      }\n    }\n\n    // Archive completed tasks\n    if (options.archiveTasks) {\n      spinner.text = 'Archiving completed tasks...';\n\n      // Create archive table if not exists\n      db.exec(`\n        CREATE TABLE IF NOT EXISTS tasks_archive AS \n        SELECT * FROM tasks WHERE 1=0\n      `);\n\n      // Check if completed_at column exists\n      const hasCompletedAt = db\n        .prepare(\n          `\n        SELECT COUNT(*) as count FROM pragma_table_info('tasks') \n        WHERE name = 'completed_at'\n      `,\n        )\n        .get();\n\n      let archived = { changes: 0 };\n\n      if (hasCompletedAt && hasCompletedAt.count > 0) {\n        // Move old completed tasks using completed_at\n        const archiveCutoff = new Date();\n        archiveCutoff.setDate(archiveCutoff.getDate() - (options.taskRetentionDays || 7));\n\n        db.exec(`\n          INSERT INTO tasks_archive \n          SELECT * FROM tasks \n          WHERE status = 'completed' AND completed_at < '${archiveCutoff.toISOString()}'\n        `);\n\n        archived = db\n          .prepare(\n            `\n          DELETE FROM tasks \n          WHERE status = 'completed' AND completed_at < ?\n        `,\n          )\n          .run(archiveCutoff.toISOString());\n      } else {\n        // Use created_at as fallback\n        const archiveCutoff = new Date();\n        archiveCutoff.setDate(archiveCutoff.getDate() - (options.taskRetentionDays || 7));\n\n        db.exec(`\n          INSERT INTO tasks_archive \n          SELECT * FROM tasks \n          WHERE status = 'completed' AND created_at < '${archiveCutoff.toISOString()}'\n        `);\n\n        archived = db\n          .prepare(\n            `\n          DELETE FROM tasks \n          WHERE status = 'completed' AND created_at < ?\n        `,\n          )\n          .run(archiveCutoff.toISOString());\n      }\n\n      console.log(chalk.green(`✓ Archived ${archived.changes} completed tasks`));\n    }\n\n    // Update statistics\n    spinner.text = 'Updating database statistics...';\n    db.exec('ANALYZE');\n\n    // Check integrity\n    if (options.checkIntegrity) {\n      spinner.text = 'Checking database integrity...';\n      const integrityCheck = db.prepare('PRAGMA integrity_check').get();\n      if (integrityCheck.integrity_check === 'ok') {\n        console.log(chalk.green('✓ Database integrity check passed'));\n      } else {\n        console.log(chalk.yellow('⚠ Database integrity issues detected'));\n      }\n    }\n\n    db.close();\n    spinner.succeed('Database maintenance complete!');\n  } catch (error) {\n    spinner.fail('Database maintenance failed');\n    console.error(chalk.red('Error:'), error.message);\n  }\n}\n\n/**\n * Generate optimization report\n */\nexport async function generateOptimizationReport(dbPath) {\n  try {\n    const db = new Database(dbPath, { readonly: true });\n\n    const report = {\n      schemaVersion: getSchemaVersion(db),\n      tables: {},\n      indexes: [],\n      performance: {},\n    };\n\n    // Get table statistics\n    const tables = db\n      .prepare(\n        `\n      SELECT name FROM sqlite_master WHERE type='table'\n    `,\n      )\n      .all();\n\n    for (const table of tables) {\n      const count = db.prepare(`SELECT COUNT(*) as count FROM ${table.name}`).get();\n      const size = db\n        .prepare(\n          `\n        SELECT SUM(pgsize) as size FROM dbstat WHERE name=?\n      `,\n        )\n        .get(table.name);\n\n      report.tables[table.name] = {\n        rowCount: count.count,\n        sizeBytes: size?.size || 0,\n      };\n    }\n\n    // Get index information\n    report.indexes = db\n      .prepare(\n        `\n      SELECT name, tbl_name FROM sqlite_master WHERE type='index'\n    `,\n      )\n      .all();\n\n    // Get performance metrics (check if completed_at column exists)\n    let avgTaskTime = { avg_minutes: 0 };\n    try {\n      // First check if completed_at column exists\n      const hasCompletedAt = db\n        .prepare(\n          `\n        SELECT COUNT(*) as count FROM pragma_table_info('tasks') \n        WHERE name = 'completed_at'\n      `,\n        )\n        .get();\n\n      if (hasCompletedAt && hasCompletedAt.count > 0) {\n        avgTaskTime = db\n          .prepare(\n            `\n          SELECT AVG(julianday(completed_at) - julianday(created_at)) * 24 * 60 as avg_minutes\n          FROM tasks WHERE completed_at IS NOT NULL\n        `,\n          )\n          .get();\n      }\n    } catch (error) {\n      // If error, just use default value\n      console.warn('Could not calculate average task time:', error.message);\n    }\n\n    report.performance.avgTaskCompletionMinutes = avgTaskTime?.avg_minutes || 0;\n\n    db.close();\n\n    return report;\n  } catch (error) {\n    console.error('Error generating report:', error);\n    return null;\n  }\n}\n\n// Export for use in CLI\nexport default {\n  optimizeHiveMindDatabase,\n  performMaintenance,\n  generateOptimizationReport,\n};\n"],"names":["Database","chalk","ora","optimizeHiveMindDatabase","dbPath","options","spinner","start","db","verbose","console","log","pragma","schemaVersion","getSchemaVersion","text","optimizationsApplied","applyBasicIndexes","push","applyAdvancedIndexes","addPerformanceTracking","addMemoryOptimization","addBehavioralTracking","exec","vacuum","updateSchemaVersion","close","succeed","length","green","forEach","opt","yellow","success","optimizations","error","fail","red","message","tableExists","prepare","get","run","result","version","description","ensureRequiredColumns","tables","all","map","row","name","tableSet","Set","indexes","has","sql","warn","hasPriority","count","includes","hasCompletedAt","hasResult","hasUpdatedAt","hasAccessCount","hasAccessedAt","hasCompressed","hasSize","performMaintenance","cleanMemory","hasMemoryTable","cutoffDate","Date","setDate","getDate","memoryRetentionDays","toISOString","changes","archiveTasks","archived","archiveCutoff","taskRetentionDays","checkIntegrity","integrityCheck","integrity_check","generateOptimizationReport","readonly","report","performance","table","size","rowCount","sizeBytes","avgTaskTime","avg_minutes","avgTaskCompletionMinutes"],"mappings":"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"}