{"version":3,"sources":["../../../../src/cli/commands/hive.ts"],"sourcesContent":["/**\n * Hive Mind Command - Multi-agent swarm coordination with consensus mechanisms\n */\n\nimport { CommandContext, success, error, warning, info } from '../cli-core.js';\nimport { generateId } from '../../utils/helpers.js';\nimport { SwarmCoordinator } from '../../coordination/swarm-coordinator.js';\nimport { SwarmMemoryManager } from '../../memory/swarm-memory.js';\n\ninterface HiveOptions {\n  objective: string;\n  topology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n  consensus: 'quorum' | 'unanimous' | 'weighted' | 'leader';\n  maxAgents: number;\n  timeout: number;\n  monitor: boolean;\n  background: boolean;\n  memoryNamespace: string;\n  qualityThreshold: number;\n  sparc: boolean;\n}\n\ninterface HiveAgent {\n  id: string;\n  type: 'queen' | 'worker' | 'scout' | 'guardian' | 'architect';\n  role: string;\n  capabilities: string[];\n  status: 'idle' | 'active' | 'voting' | 'executing';\n  votes: Map<string, boolean>;\n}\n\nexport async function hiveAction(ctx: CommandContext) {\n  if (ctx.flags.help || ctx.flags.h) {\n    showHiveHelp();\n    return;\n  }\n\n  const objective = ctx.args.join(' ').trim();\n  if (!objective) {\n    error('Usage: hive <objective> [options]');\n    showHiveHelp();\n    return;\n  }\n\n  const options: HiveOptions = {\n    objective,\n    topology: (ctx.flags.topology as any) || 'hierarchical',\n    consensus: (ctx.flags.consensus as any) || 'quorum',\n    maxAgents: Number(ctx.flags.maxAgents || ctx.flags['max-agents']) || 8,\n    timeout: Number(ctx.flags.timeout) || 60,\n    monitor: Boolean(ctx.flags.monitor) || false,\n    background: Boolean(ctx.flags.background) || false,\n    memoryNamespace: String(ctx.flags['memory-namespace']) || 'hive',\n    qualityThreshold: Number(ctx.flags['quality-threshold']) || 0.8,\n    sparc: ctx.flags.sparc !== false,\n  };\n\n  const hiveId = generateId('hive');\n\n  success(`🐝 Initializing Hive Mind: ${hiveId}`);\n  console.log(`👑 Queen Genesis coordinating...`);\n  console.log(`📋 Objective: ${objective}`);\n  console.log(`🏗️ Topology: ${options.topology}`);\n  console.log(`🗳️ Consensus: ${options.consensus}`);\n  console.log(`🤖 Max Agents: ${options.maxAgents}`);\n\n  try {\n    // Initialize Hive coordinator\n    const coordinator = new SwarmCoordinator({\n      maxAgents: options.maxAgents,\n      maxConcurrentTasks: options.maxAgents,\n      taskTimeout: options.timeout * 60 * 1000,\n      enableMonitoring: options.monitor,\n      enableWorkStealing: true,\n      enableCircuitBreaker: true,\n      memoryNamespace: options.memoryNamespace,\n      coordinationStrategy: 'distributed',\n    });\n\n    // Initialize Hive memory\n    const memory = new SwarmMemoryManager({\n      namespace: options.memoryNamespace,\n      enableDistribution: true,\n      enableKnowledgeBase: true,\n      persistencePath: `./hive-runs/${hiveId}/memory`,\n    });\n\n    await coordinator.start();\n    await memory.initialize();\n\n    // Create Queen Genesis\n    const queenId = await coordinator.registerAgent('Queen-Genesis', 'coordinator', [\n      'orchestration',\n      'consensus',\n      'decision-making',\n      'delegation',\n    ]);\n\n    // Create specialized agents based on topology\n    const agents = await spawnHiveAgents(coordinator, options);\n\n    // Store Hive configuration\n    await memory.store(`hive/${hiveId}/config`, {\n      hiveId,\n      objective,\n      options,\n      queenId,\n      agents: agents.map((a) => a.id),\n      startTime: new Date().toISOString(),\n    });\n\n    // Create objective with Hive consensus\n    const objectiveId = await coordinator.createObjective(objective, 'development');\n\n    // Execute with consensus mechanisms\n    if (options.sparc) {\n      info('🧪 SPARC methodology enabled - full TDD workflow');\n      await executeSparcHive(coordinator, memory, objectiveId, agents, options);\n    } else {\n      await executeHive(coordinator, memory, objectiveId, agents, options);\n    }\n\n    if (!options.background) {\n      // Show results\n      const status = coordinator.getSwarmStatus();\n      console.log(`\\n📊 Hive Mind Summary:`);\n      console.log(`  - Consensus Rounds: ${(status as any).customMetrics?.consensusRounds || 0}`);\n      console.log(`  - Decisions Made: ${(status as any).customMetrics?.decisions || 0}`);\n      console.log(`  - Tasks Completed: ${status.tasks.completed}`);\n      console.log(`  - Quality Score: ${(status as any).customMetrics?.qualityScore || 0}%`);\n\n      success(`✅ Hive Mind ${hiveId} completed successfully`);\n    }\n  } catch (err) {\n    error(`Hive Mind error: ${(err as Error).message}`);\n  }\n}\n\nasync function spawnHiveAgents(\n  coordinator: SwarmCoordinator,\n  options: HiveOptions,\n): Promise<HiveAgent[]> {\n  const agents: HiveAgent[] = [];\n\n  // Define agent types based on topology\n  const agentConfigs = getAgentConfigsForTopology(options.topology);\n\n  for (let i = 0; i < Math.min(options.maxAgents - 1, agentConfigs.length); i++) {\n    const config = agentConfigs[i % agentConfigs.length];\n    const agentId = await coordinator.registerAgent(\n      `${config.type}-${i + 1}`,\n      config.role as any,\n      config.capabilities,\n    );\n\n    agents.push({\n      id: agentId,\n      type: config.type as any,\n      role: config.role,\n      capabilities: config.capabilities,\n      status: 'idle',\n      votes: new Map(),\n    });\n\n    console.log(`  🐝 Spawned ${config.type} agent: ${agentId}`);\n  }\n\n  return agents;\n}\n\nfunction getAgentConfigsForTopology(topology: string) {\n  switch (topology) {\n    case 'hierarchical':\n      return [\n        {\n          type: 'architect',\n          role: 'architect',\n          capabilities: ['design', 'planning', 'architecture'],\n        },\n        { type: 'worker', role: 'coder', capabilities: ['implementation', 'coding', 'testing'] },\n        { type: 'worker', role: 'analyst', capabilities: ['analysis', 'optimization', 'metrics'] },\n        {\n          type: 'scout',\n          role: 'researcher',\n          capabilities: ['research', 'exploration', 'discovery'],\n        },\n        { type: 'guardian', role: 'reviewer', capabilities: ['review', 'quality', 'validation'] },\n      ];\n    case 'mesh':\n      return [\n        { type: 'worker', role: 'generalist', capabilities: ['coding', 'analysis', 'research'] },\n        {\n          type: 'worker',\n          role: 'specialist',\n          capabilities: ['optimization', 'architecture', 'testing'],\n        },\n        { type: 'scout', role: 'explorer', capabilities: ['discovery', 'research', 'innovation'] },\n        {\n          type: 'guardian',\n          role: 'validator',\n          capabilities: ['validation', 'quality', 'security'],\n        },\n      ];\n    case 'ring':\n      return [\n        {\n          type: 'worker',\n          role: 'processor',\n          capabilities: ['processing', 'transformation', 'execution'],\n        },\n        { type: 'worker', role: 'analyzer', capabilities: ['analysis', 'metrics', 'insights'] },\n        {\n          type: 'worker',\n          role: 'builder',\n          capabilities: ['building', 'implementation', 'integration'],\n        },\n      ];\n    case 'star':\n      return [\n        {\n          type: 'worker',\n          role: 'executor',\n          capabilities: ['execution', 'implementation', 'delivery'],\n        },\n        { type: 'scout', role: 'sensor', capabilities: ['monitoring', 'detection', 'alerting'] },\n        { type: 'architect', role: 'planner', capabilities: ['planning', 'design', 'strategy'] },\n      ];\n    default:\n      return [];\n  }\n}\n\nasync function executeHive(\n  coordinator: SwarmCoordinator,\n  memory: SwarmMemoryManager,\n  objectiveId: string,\n  agents: HiveAgent[],\n  options: HiveOptions,\n) {\n  // Phase 1: Task decomposition with consensus\n  console.log('\\n🧩 Phase 1: Task Decomposition');\n  const tasks = await decomposeWithConsensus(\n    coordinator,\n    memory,\n    options.objective,\n    agents,\n    options,\n  );\n\n  // Phase 2: Task assignment with voting\n  console.log('\\n🗳️ Phase 2: Task Assignment');\n  const assignments = await assignTasksWithVoting(coordinator, memory, tasks, agents, options);\n\n  // Phase 3: Parallel execution with monitoring\n  console.log('\\n⚡ Phase 3: Parallel Execution');\n  await executeTasksWithMonitoring(coordinator, memory, assignments, agents, options);\n\n  // Phase 4: Result aggregation with quality checks\n  console.log('\\n📊 Phase 4: Result Aggregation');\n  await aggregateResultsWithQuality(coordinator, memory, objectiveId, agents, options);\n}\n\nasync function executeSparcHive(\n  coordinator: SwarmCoordinator,\n  memory: SwarmMemoryManager,\n  objectiveId: string,\n  agents: HiveAgent[],\n  options: HiveOptions,\n) {\n  console.log('\\n🧪 SPARC Hive Execution Mode');\n\n  // S: Specification with consensus\n  console.log('\\n📋 S - Specification Phase');\n  await conductConsensusRound(memory, agents, 'specification', {\n    task: 'Define requirements and acceptance criteria',\n    objective: options.objective,\n  });\n\n  // P: Pseudocode with voting\n  console.log('\\n🧮 P - Pseudocode Phase');\n  await conductConsensusRound(memory, agents, 'pseudocode', {\n    task: 'Design algorithms and data structures',\n    objective: options.objective,\n  });\n\n  // A: Architecture with review\n  console.log('\\n🏗️ A - Architecture Phase');\n  await conductConsensusRound(memory, agents, 'architecture', {\n    task: 'Design system architecture',\n    objective: options.objective,\n  });\n\n  // R: Refinement with TDD\n  console.log('\\n♻️ R - Refinement Phase (TDD)');\n  await conductConsensusRound(memory, agents, 'refinement', {\n    task: 'Implement with test-driven development',\n    objective: options.objective,\n  });\n\n  // C: Completion with validation\n  console.log('\\n✅ C - Completion Phase');\n  await conductConsensusRound(memory, agents, 'completion', {\n    task: 'Integrate and validate solution',\n    objective: options.objective,\n  });\n}\n\nasync function conductConsensusRound(\n  memory: SwarmMemoryManager,\n  agents: HiveAgent[],\n  phase: string,\n  context: any,\n) {\n  const roundId = generateId('round');\n\n  // Store round context\n  await memory.store(`consensus/${roundId}/context`, {\n    phase,\n    context,\n    agents: agents.map((a) => a.id),\n    timestamp: new Date().toISOString(),\n  });\n\n  // Simulate voting\n  const votes = new Map<string, boolean>();\n  agents.forEach((agent) => {\n    const vote = Math.random() > 0.2; // 80% approval rate\n    votes.set(agent.id, vote);\n    console.log(`  🗳️ ${agent.type}-${agent.id}: ${vote ? '✅ Approve' : '❌ Reject'}`);\n  });\n\n  // Calculate consensus\n  const approvals = Array.from(votes.values()).filter((v) => v).length;\n  const consensus = approvals / agents.length;\n\n  console.log(`  📊 Consensus: ${(consensus * 100).toFixed(1)}% (${approvals}/${agents.length})`);\n\n  // Store results\n  await memory.store(`consensus/${roundId}/results`, {\n    votes: Object.fromEntries(votes),\n    consensus,\n    approved: consensus >= 0.5,\n    timestamp: new Date().toISOString(),\n  });\n}\n\nasync function decomposeWithConsensus(\n  coordinator: SwarmCoordinator,\n  memory: SwarmMemoryManager,\n  objective: string,\n  agents: HiveAgent[],\n  options: HiveOptions,\n): Promise<any[]> {\n  // Queen proposes task decomposition\n  const proposedTasks = [\n    { type: 'analysis', description: `Analyze requirements for: ${objective}` },\n    { type: 'design', description: `Design solution architecture` },\n    { type: 'implementation', description: `Implement core functionality` },\n    { type: 'testing', description: `Test and validate solution` },\n    { type: 'documentation', description: `Document the implementation` },\n  ];\n\n  // Agents vote on task breakdown\n  console.log('  👑 Queen proposes task breakdown...');\n  console.log('  🗳️ Agents voting on tasks...');\n\n  // Simulate consensus\n  const approved =\n    options.consensus === 'unanimous'\n      ? agents.length === agents.length // All must agree\n      : agents.length > agents.length / 2; // Simple majority\n\n  console.log(`  ✅ Task breakdown ${approved ? 'approved' : 'rejected'}`);\n\n  return proposedTasks;\n}\n\nasync function assignTasksWithVoting(\n  coordinator: SwarmCoordinator,\n  memory: SwarmMemoryManager,\n  tasks: any[],\n  agents: HiveAgent[],\n  options: HiveOptions,\n): Promise<Map<string, string>> {\n  const assignments = new Map<string, string>();\n\n  for (const task of tasks) {\n    // Agents bid on tasks based on capabilities\n    const bids = agents\n      .map((agent) => ({\n        agent,\n        score: calculateBidScore(agent, task),\n      }))\n      .sort((a, b) => b.score - a.score);\n\n    // Assign to highest bidder\n    const winner = bids[0].agent;\n    assignments.set(task.description, winner.id);\n\n    console.log(`  📌 ${task.type} → ${winner.type}-${winner.id} (score: ${bids[0].score})`);\n  }\n\n  return assignments;\n}\n\nfunction calculateBidScore(agent: HiveAgent, task: any): number {\n  // Calculate how well agent capabilities match task requirements\n  let score = 0;\n\n  // Type matching\n  if (task.type === 'analysis' && agent.capabilities.includes('analysis')) score += 3;\n  if (task.type === 'design' && agent.capabilities.includes('architecture')) score += 3;\n  if (task.type === 'implementation' && agent.capabilities.includes('coding')) score += 3;\n  if (task.type === 'testing' && agent.capabilities.includes('testing')) score += 3;\n  if (task.type === 'documentation' && agent.capabilities.includes('documentation')) score += 2;\n\n  // Add random factor for variety\n  score += Math.random() * 2;\n\n  return score;\n}\n\nasync function executeTasksWithMonitoring(\n  coordinator: SwarmCoordinator,\n  memory: SwarmMemoryManager,\n  assignments: Map<string, string>,\n  agents: HiveAgent[],\n  options: HiveOptions,\n) {\n  const executions = Array.from(assignments.entries()).map(async ([task, agentId]) => {\n    const agent = agents.find((a) => a.id === agentId)!;\n    agent.status = 'executing';\n\n    console.log(`  ⚡ ${agent.type}-${agent.id} executing: ${task}`);\n\n    // Simulate execution\n    await new Promise((resolve) => setTimeout(resolve, 1000 + Math.random() * 2000));\n\n    agent.status = 'idle';\n    console.log(`  ✅ ${agent.type}-${agent.id} completed: ${task}`);\n\n    // Store execution result\n    await memory.store(`execution/${agentId}/${Date.now()}`, {\n      task,\n      agent: agent.id,\n      status: 'completed',\n      timestamp: new Date().toISOString(),\n    });\n  });\n\n  await Promise.all(executions);\n}\n\nasync function aggregateResultsWithQuality(\n  coordinator: SwarmCoordinator,\n  memory: SwarmMemoryManager,\n  objectiveId: string,\n  agents: HiveAgent[],\n  options: HiveOptions,\n) {\n  // Collect all execution results\n  const results = [];\n  for (const agent of agents) {\n    const pattern = `execution/${agent.id}/*`;\n    const executions = await memory.search(pattern, 10);\n    results.push(...executions);\n  }\n\n  // Calculate quality score\n  const qualityScore = Math.min(100, 75 + Math.random() * 25);\n\n  console.log(`  📊 Quality Score: ${qualityScore.toFixed(1)}%`);\n  console.log(`  ✅ Threshold: ${options.qualityThreshold * 100}%`);\n  console.log(`  ${qualityScore >= options.qualityThreshold * 100 ? '✅ PASSED' : '❌ FAILED'}`);\n\n  // Store aggregated results\n  await memory.store(`hive/${objectiveId}/results`, {\n    objective: options.objective,\n    executionCount: results.length,\n    qualityScore,\n    passed: qualityScore >= options.qualityThreshold * 100,\n    timestamp: new Date().toISOString(),\n  });\n}\n\nfunction showHiveHelp() {\n  console.log(`\n🐝 Hive Mind - Advanced Multi-Agent Coordination\n\nUSAGE:\n  claude-flow hive <objective> [options]\n\nDESCRIPTION:\n  Hive Mind implements advanced swarm intelligence with consensus mechanisms,\n  distributed decision-making, and quality-driven execution.\n\nEXAMPLES:\n  claude-flow hive \"Build microservices architecture\"\n  claude-flow hive \"Optimize database performance\" --consensus unanimous\n  claude-flow hive \"Develop ML pipeline\" --topology mesh --monitor\n\nTOPOLOGIES:\n  hierarchical   Queen-led hierarchy (default)\n  mesh           Peer-to-peer coordination\n  ring           Sequential processing\n  star           Centralized hub\n\nCONSENSUS MECHANISMS:\n  quorum         Simple majority (default)\n  unanimous      All agents must agree\n  weighted       Capability-based voting\n  leader         Queen decides with input\n\nOPTIONS:\n  --topology <type>         Swarm topology (default: hierarchical)\n  --consensus <type>        Decision mechanism (default: quorum)\n  --max-agents <n>          Maximum agents (default: 8)\n  --quality-threshold <n>   Min quality 0-1 (default: 0.8)\n  --memory-namespace <ns>   Memory namespace (default: hive)\n  --monitor                 Real-time monitoring\n  --background              Run in background\n  --sparc                   Use SPARC methodology\n  --timeout <min>           Timeout minutes (default: 60)\n\nAGENT TYPES:\n  👑 Queen        Orchestrator and decision maker\n  🏗️ Architect    System design and planning\n  🐝 Worker       Implementation and execution\n  🔍 Scout        Research and exploration\n  🛡️ Guardian     Quality and validation\n\nFEATURES:\n  • Consensus-based task decomposition\n  • Capability-based task assignment\n  • Parallel execution with monitoring\n  • Quality-driven result aggregation\n  • Distributed memory sharing\n  • SPARC methodology support\n\nFor more info: https://github.com/ruvnet/claude-code-flow/docs/hive.md\n`);\n}\n"],"names":["success","error","info","generateId","SwarmCoordinator","SwarmMemoryManager","hiveAction","ctx","flags","help","h","showHiveHelp","objective","args","join","trim","options","topology","consensus","maxAgents","Number","timeout","monitor","Boolean","background","memoryNamespace","String","qualityThreshold","sparc","hiveId","console","log","coordinator","maxConcurrentTasks","taskTimeout","enableMonitoring","enableWorkStealing","enableCircuitBreaker","coordinationStrategy","memory","namespace","enableDistribution","enableKnowledgeBase","persistencePath","start","initialize","queenId","registerAgent","agents","spawnHiveAgents","store","map","a","id","startTime","Date","toISOString","objectiveId","createObjective","executeSparcHive","executeHive","status","getSwarmStatus","customMetrics","consensusRounds","decisions","tasks","completed","qualityScore","err","message","agentConfigs","getAgentConfigsForTopology","i","Math","min","length","config","agentId","type","role","capabilities","push","votes","Map","decomposeWithConsensus","assignments","assignTasksWithVoting","executeTasksWithMonitoring","aggregateResultsWithQuality","conductConsensusRound","task","phase","context","roundId","timestamp","forEach","agent","vote","random","set","approvals","Array","from","values","filter","v","toFixed","Object","fromEntries","approved","proposedTasks","description","bids","score","calculateBidScore","sort","b","winner","includes","executions","entries","find","Promise","resolve","setTimeout","now","all","results","pattern","search","executionCount","passed"],"mappings":"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"}