{"version":3,"sources":["../../../../src/cli/__tests__/utils.test.js"],"sourcesContent":["/**\n * Tests for utils.js\n */\n\nimport { jest } from '@jest/globals';\nimport {\n  parseFlags,\n  formatBytes,\n  truncateString,\n  printSuccess,\n  printError,\n  printWarning,\n  printInfo,\n  validateArgs,\n  generateId,\n  retry,\n  sleep,\n  chunk,\n  isValidJson,\n  isValidUrl,\n  formatTimestamp,\n} from '../utils.js';\n\n// Mock console for testing output functions\nlet consoleLogSpy;\nlet consoleErrorSpy;\n\nbeforeEach(() => {\n  consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();\n  consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n});\n\nafterEach(() => {\n  consoleLogSpy.mockRestore();\n  consoleErrorSpy.mockRestore();\n});\n\ndescribe('Utils', () => {\n  describe('parseFlags', () => {\n    test('should parse boolean flags', () => {\n      const result = parseFlags(['--verbose', '--force']);\n      expect(result.flags).toEqual({ verbose: true, force: true });\n      expect(result.args).toEqual([]);\n    });\n\n    test('should parse value flags', () => {\n      const result = parseFlags(['--port', '8080', '--name', 'test']);\n      expect(result.flags).toEqual({ port: '8080', name: 'test' });\n      expect(result.args).toEqual([]);\n    });\n\n    test('should parse mixed flags and arguments', () => {\n      const result = parseFlags(['arg1', '--flag', 'value', 'arg2', '--bool']);\n      expect(result.flags).toEqual({ flag: 'value', bool: true });\n      expect(result.args).toEqual(['arg1', 'arg2']);\n    });\n\n    test('should handle short flags', () => {\n      const result = parseFlags(['-vf', '--port', '8080']);\n      expect(result.flags).toEqual({ v: true, f: true, port: '8080' });\n      expect(result.args).toEqual([]);\n    });\n\n    test('should handle empty input', () => {\n      const result = parseFlags([]);\n      expect(result.flags).toEqual({});\n      expect(result.args).toEqual([]);\n    });\n  });\n\n  describe('formatBytes', () => {\n    test('should format bytes to human readable', () => {\n      expect(formatBytes(0)).toBe('0.00 B');\n      expect(formatBytes(1024)).toBe('1.00 KB');\n      expect(formatBytes(1048576)).toBe('1.00 MB');\n      expect(formatBytes(1073741824)).toBe('1.00 GB');\n    });\n\n    test('should handle large numbers', () => {\n      expect(formatBytes(2048)).toBe('2.00 KB');\n      expect(formatBytes(1536)).toBe('1.50 KB');\n    });\n  });\n\n  describe('truncateString', () => {\n    test('should truncate long strings', () => {\n      expect(truncateString('Hello World', 5)).toBe('Hello...');\n      expect(truncateString('Short', 10)).toBe('Short');\n    });\n\n    test('should handle empty string', () => {\n      expect(truncateString('', 5)).toBe('');\n    });\n\n    test('should use default length', () => {\n      const longString = 'a'.repeat(150);\n      const result = truncateString(longString);\n      expect(result).toBe('a'.repeat(100) + '...');\n    });\n  });\n\n  describe('print functions', () => {\n    test('printSuccess should log success message', () => {\n      printSuccess('Test message');\n      expect(consoleLogSpy).toHaveBeenCalledWith('✅ Test message');\n    });\n\n    test('printError should log error message', () => {\n      printError('Error message');\n      expect(consoleLogSpy).toHaveBeenCalledWith('❌ Error message');\n    });\n\n    test('printWarning should log warning message', () => {\n      printWarning('Warning message');\n      expect(consoleLogSpy).toHaveBeenCalledWith('⚠️  Warning message');\n    });\n\n    test('printInfo should log info message', () => {\n      printInfo('Info message');\n      expect(consoleLogSpy).toHaveBeenCalledWith('ℹ️  Info message');\n    });\n  });\n\n  describe('validateArgs', () => {\n    test('should return true for valid arguments', () => {\n      const result = validateArgs(['arg1', 'arg2'], 2, 'command <arg1> <arg2>');\n      expect(result).toBe(true);\n    });\n\n    test('should return false and print error for insufficient arguments', () => {\n      const result = validateArgs(['arg1'], 2, 'command <arg1> <arg2>');\n      expect(result).toBe(false);\n      expect(consoleLogSpy).toHaveBeenCalledWith('❌ Usage: command <arg1> <arg2>');\n    });\n  });\n\n  describe('generateId', () => {\n    test('should generate unique IDs', () => {\n      const id1 = generateId();\n      const id2 = generateId();\n\n      expect(id1).not.toBe(id2);\n      expect(id1.length).toBeGreaterThan(0);\n      expect(typeof id1).toBe('string');\n    });\n\n    test('should generate ID with prefix', () => {\n      const id = generateId('user');\n      expect(id).toMatch(/^user-\\d+-[a-z0-9]+$/);\n    });\n  });\n\n  describe('retry', () => {\n    test('should retry on failure', async () => {\n      let attempts = 0;\n      const fn = jest.fn(async () => {\n        attempts++;\n        if (attempts < 3) throw new Error('Failed');\n        return 'success';\n      });\n\n      const result = await retry(fn, 3, 10);\n\n      expect(result).toBe('success');\n      expect(fn).toHaveBeenCalledTimes(3);\n    });\n\n    test('should fail after max retries', async () => {\n      const fn = jest.fn(async () => {\n        throw new Error('Always fails');\n      });\n\n      await expect(retry(fn, 2, 10)).rejects.toThrow('Always fails');\n      expect(fn).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('sleep', () => {\n    test('should delay execution', async () => {\n      const start = Date.now();\n      await sleep(50);\n      const end = Date.now();\n\n      expect(end - start).toBeGreaterThanOrEqual(45); // Allow some margin\n    });\n  });\n\n  describe('chunk', () => {\n    test('should split array into chunks', () => {\n      const array = [1, 2, 3, 4, 5, 6, 7];\n      const result = chunk(array, 3);\n\n      expect(result).toEqual([[1, 2, 3], [4, 5, 6], [7]]);\n    });\n\n    test('should handle empty array', () => {\n      const result = chunk([], 3);\n      expect(result).toEqual([]);\n    });\n\n    test('should handle chunk size larger than array', () => {\n      const result = chunk([1, 2], 5);\n      expect(result).toEqual([[1, 2]]);\n    });\n  });\n\n  describe('isValidJson', () => {\n    test('should validate correct JSON', () => {\n      expect(isValidJson('{\"key\":\"value\"}')).toBe(true);\n      expect(isValidJson('[1,2,3]')).toBe(true);\n      expect(isValidJson('\"string\"')).toBe(true);\n      expect(isValidJson('123')).toBe(true);\n    });\n\n    test('should reject invalid JSON', () => {\n      expect(isValidJson('{\"key\":}')).toBe(false);\n      expect(isValidJson('invalid')).toBe(false);\n      expect(isValidJson('')).toBe(false);\n    });\n  });\n\n  describe('isValidUrl', () => {\n    test('should validate correct URLs', () => {\n      expect(isValidUrl('https://example.com')).toBe(true);\n      expect(isValidUrl('http://localhost:8080')).toBe(true);\n      expect(isValidUrl('ftp://files.example.com')).toBe(true);\n    });\n\n    test('should reject invalid URLs', () => {\n      expect(isValidUrl('not a url')).toBe(false);\n      expect(isValidUrl('example.com')).toBe(false);\n      expect(isValidUrl('')).toBe(false);\n    });\n  });\n\n  describe('formatTimestamp', () => {\n    test('should format timestamp to readable string', () => {\n      const timestamp = 1234567890000; // Fixed timestamp\n      const result = formatTimestamp(timestamp);\n\n      expect(typeof result).toBe('string');\n      expect(result.length).toBeGreaterThan(0);\n    });\n\n    test('should handle current timestamp', () => {\n      const now = Date.now();\n      const result = formatTimestamp(now);\n\n      expect(typeof result).toBe('string');\n      expect(result).toContain('2025'); // Should contain current year\n    });\n  });\n});\n"],"names":["jest","parseFlags","formatBytes","truncateString","printSuccess","printError","printWarning","printInfo","validateArgs","generateId","retry","sleep","chunk","isValidJson","isValidUrl","formatTimestamp","consoleLogSpy","consoleErrorSpy","beforeEach","spyOn","console","mockImplementation","afterEach","mockRestore","describe","test","result","expect","flags","toEqual","verbose","force","args","port","name","flag","bool","v","f","toBe","longString","repeat","toHaveBeenCalledWith","id1","id2","not","length","toBeGreaterThan","id","toMatch","attempts","fn","Error","toHaveBeenCalledTimes","rejects","toThrow","start","Date","now","end","toBeGreaterThanOrEqual","array","timestamp","toContain"],"mappings":"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"}