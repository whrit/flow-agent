{"version":3,"sources":["../../../src/verification/rollback.ts"],"sourcesContent":["/**\n * Comprehensive Rollback Manager System\n * \n * Provides atomic rollback operations with state management, automated recovery,\n * and git integration for maintaining system integrity.\n * \n * Features:\n * - StateManager: Captures and manages system snapshots\n * - RollbackTrigger: Configurable thresholds and automated monitoring\n * - AutomatedRecovery: Multi-tier recovery strategies\n * - RollbackHistory: Compressed history tracking with TTL\n * - Git Integration: Code rollbacks with atomic commits\n */\n\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { exec, spawn } from 'child_process';\nimport { promisify } from 'util';\nimport { createHash } from 'crypto';\nimport { EventEmitter } from 'events';\nimport { gzip, gunzip } from 'zlib';\n\nconst execAsync = promisify(exec);\nconst gzipAsync = promisify(gzip);\nconst gunzipAsync = promisify(gunzip);\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\nexport interface SystemSnapshot {\n  id: string;\n  timestamp: number;\n  version: string;\n  metadata: {\n    description: string;\n    tags: string[];\n    triggeredBy: string;\n    severity: 'low' | 'medium' | 'high' | 'critical';\n  };\n  state: {\n    config: Record<string, any>;\n    memory: Record<string, any>;\n    processes: ProcessState[];\n    files: FileSnapshot[];\n    git: GitState;\n  };\n  integrity: {\n    checksum: string;\n    compressed: boolean;\n    size: number;\n  };\n}\n\nexport interface ProcessState {\n  pid: number;\n  name: string;\n  status: string;\n  memory: number;\n  cpu: number;\n  env: Record<string, string>;\n}\n\nexport interface FileSnapshot {\n  path: string;\n  content: string | Buffer;\n  stats: {\n    size: number;\n    mtime: number;\n    mode: number;\n  };\n  checksum: string;\n}\n\nexport interface GitState {\n  branch: string;\n  commit: string;\n  status: string;\n  staged: string[];\n  modified: string[];\n  untracked: string[];\n}\n\nexport interface RollbackTriggerConfig {\n  enabled: boolean;\n  thresholds: {\n    errorRate: number;           // Errors per minute\n    memoryUsage: number;         // Percentage\n    cpuUsage: number;            // Percentage\n    responseTime: number;        // Milliseconds\n    diskSpace: number;           // Percentage free\n    consecutiveFailures: number; // Count\n  };\n  monitoring: {\n    interval: number;            // Monitoring check interval (ms)\n    cooldown: number;            // Cooldown period after rollback (ms)\n    gracePeriod: number;         // Grace period before triggering (ms)\n  };\n  notifications: {\n    webhook?: string;\n    email?: string[];\n    slack?: string;\n  };\n}\n\nexport interface RecoveryStrategy {\n  name: string;\n  priority: number;\n  enabled: boolean;\n  timeout: number;\n  retries: number;\n  conditions: (metrics: SystemMetrics) => boolean;\n  execute: (snapshot: SystemSnapshot, context: RecoveryContext) => Promise<boolean>;\n}\n\nexport interface SystemMetrics {\n  timestamp: number;\n  errors: {\n    count: number;\n    rate: number;\n    recent: Error[];\n  };\n  performance: {\n    memory: { used: number; total: number; percentage: number; };\n    cpu: { usage: number; load: number[]; };\n    disk: { used: number; total: number; free: number; };\n    network: { in: number; out: number; };\n  };\n  health: {\n    status: 'healthy' | 'degraded' | 'critical';\n    score: number;\n    checks: HealthCheck[];\n  };\n}\n\nexport interface HealthCheck {\n  name: string;\n  status: 'pass' | 'fail' | 'warn';\n  message: string;\n  duration: number;\n}\n\nexport interface RecoveryContext {\n  triggeredBy: string;\n  reason: string;\n  metrics: SystemMetrics;\n  previousAttempts: RecoveryAttempt[];\n}\n\nexport interface RecoveryAttempt {\n  strategy: string;\n  timestamp: number;\n  success: boolean;\n  error?: string;\n  duration: number;\n}\n\nexport interface RollbackHistoryEntry {\n  id: string;\n  timestamp: number;\n  snapshot: SystemSnapshot;\n  trigger: {\n    type: 'manual' | 'automatic';\n    reason: string;\n    metrics?: SystemMetrics;\n  };\n  recovery: {\n    strategy: string;\n    success: boolean;\n    duration: number;\n    attempts: RecoveryAttempt[];\n  };\n  verification: {\n    passed: boolean;\n    checks: HealthCheck[];\n    rollbackRequired: boolean;\n  };\n}\n\n// ============================================================================\n// StateManager - Captures and manages system snapshots\n// ============================================================================\n\nexport class StateManager extends EventEmitter {\n  private snapshots: Map<string, SystemSnapshot> = new Map();\n  private snapshotDir: string;\n  private maxSnapshots: number;\n  private compressionEnabled: boolean;\n\n  constructor(\n    snapshotDir: string = './snapshots',\n    maxSnapshots: number = 100,\n    compressionEnabled: boolean = true\n  ) {\n    super();\n    this.snapshotDir = snapshotDir;\n    this.maxSnapshots = maxSnapshots;\n    this.compressionEnabled = compressionEnabled;\n    this.initializeStorage();\n  }\n\n  private async initializeStorage(): Promise<void> {\n    try {\n      await fs.mkdir(this.snapshotDir, { recursive: true });\n      await this.loadExistingSnapshots();\n    } catch (error) {\n      this.emit('error', new Error(`Failed to initialize storage: ${error}`));\n    }\n  }\n\n  private async loadExistingSnapshots(): Promise<void> {\n    try {\n      const files = await fs.readdir(this.snapshotDir);\n      const snapshotFiles = files.filter(f => f.endsWith('.snapshot.json'));\n      \n      for (const file of snapshotFiles) {\n        try {\n          const content = await fs.readFile(join(this.snapshotDir, file), 'utf-8');\n          const snapshot: SystemSnapshot = JSON.parse(content);\n          this.snapshots.set(snapshot.id, snapshot);\n        } catch (error) {\n          console.warn(`Failed to load snapshot ${file}:`, error);\n        }\n      }\n      \n      this.emit('snapshots_loaded', this.snapshots.size);\n    } catch (error) {\n      this.emit('error', new Error(`Failed to load snapshots: ${error}`));\n    }\n  }\n\n  /**\n   * Creates a comprehensive system snapshot with atomic operations\n   */\n  public async captureSnapshot(\n    description: string,\n    tags: string[] = [],\n    triggeredBy: string = 'manual'\n  ): Promise<SystemSnapshot> {\n    const id = this.generateSnapshotId();\n    const timestamp = Date.now();\n\n    try {\n      // Capture system state atomically\n      const [config, memory, processes, files, git] = await Promise.all([\n        this.captureConfig(),\n        this.captureMemory(),\n        this.captureProcesses(),\n        this.captureFiles(),\n        this.captureGitState()\n      ]);\n\n      const snapshot: SystemSnapshot = {\n        id,\n        timestamp,\n        version: '1.0.0',\n        metadata: {\n          description,\n          tags,\n          triggeredBy,\n          severity: 'medium'\n        },\n        state: {\n          config,\n          memory,\n          processes,\n          files,\n          git\n        },\n        integrity: {\n          checksum: '',\n          compressed: this.compressionEnabled,\n          size: 0\n        }\n      };\n\n      // Calculate integrity checksum\n      const serialized = JSON.stringify(snapshot.state);\n      snapshot.integrity.checksum = createHash('sha256').update(serialized).digest('hex');\n      snapshot.integrity.size = Buffer.byteLength(serialized, 'utf8');\n\n      // Store snapshot\n      await this.storeSnapshot(snapshot);\n      this.snapshots.set(id, snapshot);\n\n      // Cleanup old snapshots\n      await this.cleanupOldSnapshots();\n\n      this.emit('snapshot_created', snapshot);\n      return snapshot;\n\n    } catch (error) {\n      this.emit('error', new Error(`Failed to capture snapshot: ${error}`));\n      throw error;\n    }\n  }\n\n  private async captureConfig(): Promise<Record<string, any>> {\n    try {\n      // Capture application configuration\n      const configPaths = [\n        './claude-flow.config.json',\n        './package.json',\n        './tsconfig.json',\n        './.env'\n      ];\n\n      const config: Record<string, any> = {};\n      \n      for (const path of configPaths) {\n        try {\n          const content = await fs.readFile(path, 'utf-8');\n          config[path] = JSON.parse(content);\n        } catch {\n          // File might not exist or be invalid JSON\n        }\n      }\n\n      return config;\n    } catch (error) {\n      return {};\n    }\n  }\n\n  private async captureMemory(): Promise<Record<string, any>> {\n    try {\n      // Capture memory-related state\n      const memoryPaths = [\n        './memory/memory-store.json',\n        './memory/claude-flow-data.json',\n        './swarm-memory/state.json'\n      ];\n\n      const memory: Record<string, any> = {};\n      \n      for (const path of memoryPaths) {\n        try {\n          const content = await fs.readFile(path, 'utf-8');\n          memory[path] = JSON.parse(content);\n        } catch {\n          // File might not exist\n        }\n      }\n\n      return memory;\n    } catch (error) {\n      return {};\n    }\n  }\n\n  private async captureProcesses(): Promise<ProcessState[]> {\n    try {\n      // Capture running processes related to claude-flow\n      const { stdout } = await execAsync('ps aux | grep -E \"(claude-flow|node)\" | grep -v grep');\n      const lines = stdout.trim().split('\\n');\n      \n      return lines.map(line => {\n        const parts = line.trim().split(/\\s+/);\n        return {\n          pid: parseInt(parts[1]) || 0,\n          name: parts[10] || 'unknown',\n          status: 'running',\n          memory: parseFloat(parts[5]) || 0,\n          cpu: parseFloat(parts[2]) || 0,\n          env: process.env as Record<string, string>\n        };\n      });\n    } catch {\n      return [];\n    }\n  }\n\n  private async captureFiles(): Promise<FileSnapshot[]> {\n    try {\n      // Capture critical files\n      const criticalPaths = [\n        './src/verification/rollback.ts',\n        './src/core/orchestrator.ts',\n        './src/memory/manager.ts',\n        './src/mcp/server.ts'\n      ];\n\n      const files: FileSnapshot[] = [];\n      \n      for (const path of criticalPaths) {\n        try {\n          const [content, stats] = await Promise.all([\n            fs.readFile(path, 'utf-8'),\n            fs.stat(path)\n          ]);\n          \n          files.push({\n            path,\n            content,\n            stats: {\n              size: stats.size,\n              mtime: stats.mtime.getTime(),\n              mode: stats.mode\n            },\n            checksum: createHash('md5').update(content).digest('hex')\n          });\n        } catch {\n          // File might not exist\n        }\n      }\n\n      return files;\n    } catch {\n      return [];\n    }\n  }\n\n  private async captureGitState(): Promise<GitState> {\n    try {\n      const [branch, commit, status, staged, modified, untracked] = await Promise.all([\n        execAsync('git rev-parse --abbrev-ref HEAD').then(r => r.stdout.trim()).catch(() => 'unknown'),\n        execAsync('git rev-parse HEAD').then(r => r.stdout.trim()).catch(() => 'unknown'),\n        execAsync('git status --porcelain').then(r => r.stdout.trim()).catch(() => ''),\n        execAsync('git diff --cached --name-only').then(r => r.stdout.trim().split('\\n').filter(Boolean)).catch(() => []),\n        execAsync('git diff --name-only').then(r => r.stdout.trim().split('\\n').filter(Boolean)).catch(() => []),\n        execAsync('git ls-files --others --exclude-standard').then(r => r.stdout.trim().split('\\n').filter(Boolean)).catch(() => [])\n      ]);\n\n      return {\n        branch,\n        commit,\n        status,\n        staged,\n        modified,\n        untracked\n      };\n    } catch {\n      return {\n        branch: 'unknown',\n        commit: 'unknown',\n        status: '',\n        staged: [],\n        modified: [],\n        untracked: []\n      };\n    }\n  }\n\n  private async storeSnapshot(snapshot: SystemSnapshot): Promise<void> {\n    const filename = `${snapshot.id}.snapshot.json`;\n    const filepath = join(this.snapshotDir, filename);\n\n    let content = JSON.stringify(snapshot, null, 2);\n    \n    if (this.compressionEnabled) {\n      const compressed = await gzipAsync(Buffer.from(content, 'utf-8'));\n      await fs.writeFile(filepath + '.gz', compressed);\n    } else {\n      await fs.writeFile(filepath, content);\n    }\n  }\n\n  private async cleanupOldSnapshots(): Promise<void> {\n    if (this.snapshots.size <= this.maxSnapshots) return;\n\n    const sorted = Array.from(this.snapshots.values())\n      .sort((a, b) => a.timestamp - b.timestamp);\n    \n    const toDelete = sorted.slice(0, sorted.length - this.maxSnapshots);\n    \n    for (const snapshot of toDelete) {\n      try {\n        const filename = `${snapshot.id}.snapshot.json`;\n        const filepath = join(this.snapshotDir, filename);\n        \n        await fs.unlink(filepath).catch(() => {});\n        await fs.unlink(filepath + '.gz').catch(() => {});\n        \n        this.snapshots.delete(snapshot.id);\n      } catch (error) {\n        console.warn(`Failed to delete snapshot ${snapshot.id}:`, error);\n      }\n    }\n  }\n\n  private generateSnapshotId(): string {\n    return `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  public async getSnapshot(id: string): Promise<SystemSnapshot | null> {\n    return this.snapshots.get(id) || null;\n  }\n\n  public listSnapshots(): SystemSnapshot[] {\n    return Array.from(this.snapshots.values())\n      .sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  public async deleteSnapshot(id: string): Promise<boolean> {\n    try {\n      const filename = `${id}.snapshot.json`;\n      const filepath = join(this.snapshotDir, filename);\n      \n      await fs.unlink(filepath).catch(() => {});\n      await fs.unlink(filepath + '.gz').catch(() => {});\n      \n      this.snapshots.delete(id);\n      this.emit('snapshot_deleted', id);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n// ============================================================================\n// RollbackTrigger - Configurable thresholds and monitoring\n// ============================================================================\n\nexport class RollbackTrigger extends EventEmitter {\n  private config: RollbackTriggerConfig;\n  private monitoring: boolean = false;\n  private metrics: SystemMetrics[] = [];\n  private monitoringInterval?: NodeJS.Timeout;\n  private lastRollback: number = 0;\n\n  constructor(config: Partial<RollbackTriggerConfig> = {}) {\n    super();\n    this.config = this.mergeConfig(config);\n  }\n\n  private mergeConfig(config: Partial<RollbackTriggerConfig>): RollbackTriggerConfig {\n    return {\n      enabled: config.enabled ?? true,\n      thresholds: {\n        errorRate: config.thresholds?.errorRate ?? 10,\n        memoryUsage: config.thresholds?.memoryUsage ?? 90,\n        cpuUsage: config.thresholds?.cpuUsage ?? 95,\n        responseTime: config.thresholds?.responseTime ?? 5000,\n        diskSpace: config.thresholds?.diskSpace ?? 10,\n        consecutiveFailures: config.thresholds?.consecutiveFailures ?? 3\n      },\n      monitoring: {\n        interval: config.monitoring?.interval ?? 30000,\n        cooldown: config.monitoring?.cooldown ?? 300000,\n        gracePeriod: config.monitoring?.gracePeriod ?? 60000\n      },\n      notifications: {\n        webhook: config.notifications?.webhook,\n        email: config.notifications?.email,\n        slack: config.notifications?.slack\n      }\n    };\n  }\n\n  public startMonitoring(): void {\n    if (this.monitoring) return;\n    \n    this.monitoring = true;\n    this.monitoringInterval = setInterval(\n      () => this.checkThresholds(),\n      this.config.monitoring.interval\n    );\n    \n    this.emit('monitoring_started');\n  }\n\n  public stopMonitoring(): void {\n    if (!this.monitoring) return;\n    \n    this.monitoring = false;\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = undefined;\n    }\n    \n    this.emit('monitoring_stopped');\n  }\n\n  private async checkThresholds(): Promise<void> {\n    if (!this.config.enabled) return;\n    \n    // Check cooldown period\n    if (Date.now() - this.lastRollback < this.config.monitoring.cooldown) {\n      return;\n    }\n\n    try {\n      const metrics = await this.collectMetrics();\n      this.metrics.push(metrics);\n      \n      // Keep only recent metrics (last hour)\n      const oneHourAgo = Date.now() - 3600000;\n      this.metrics = this.metrics.filter(m => m.timestamp > oneHourAgo);\n      \n      const violations = this.evaluateThresholds(metrics);\n      \n      if (violations.length > 0) {\n        this.emit('threshold_violated', { metrics, violations });\n        \n        // Check grace period\n        const recentViolations = this.metrics\n          .filter(m => m.timestamp > Date.now() - this.config.monitoring.gracePeriod)\n          .filter(m => this.evaluateThresholds(m).length > 0);\n        \n        if (recentViolations.length >= 2) {\n          this.triggerRollback(metrics, violations);\n        }\n      }\n      \n    } catch (error) {\n      this.emit('monitoring_error', error);\n    }\n  }\n\n  private async collectMetrics(): Promise<SystemMetrics> {\n    const timestamp = Date.now();\n    \n    try {\n      const [memInfo, cpuInfo, diskInfo] = await Promise.all([\n        this.getMemoryInfo(),\n        this.getCpuInfo(),\n        this.getDiskInfo()\n      ]);\n\n      return {\n        timestamp,\n        errors: {\n          count: 0, // Would be tracked by error handler\n          rate: 0,\n          recent: []\n        },\n        performance: {\n          memory: memInfo,\n          cpu: cpuInfo,\n          disk: diskInfo,\n          network: { in: 0, out: 0 }\n        },\n        health: {\n          status: 'healthy',\n          score: 100,\n          checks: []\n        }\n      };\n      \n    } catch (error) {\n      return {\n        timestamp,\n        errors: { count: 1, rate: 1, recent: [error as Error] },\n        performance: {\n          memory: { used: 0, total: 0, percentage: 0 },\n          cpu: { usage: 0, load: [0, 0, 0] },\n          disk: { used: 0, total: 0, free: 0 },\n          network: { in: 0, out: 0 }\n        },\n        health: {\n          status: 'critical',\n          score: 0,\n          checks: [{ name: 'metrics_collection', status: 'fail', message: error?.toString() || 'Unknown error', duration: 0 }]\n        }\n      };\n    }\n  }\n\n  private async getMemoryInfo() {\n    try {\n      const meminfo = await fs.readFile('/proc/meminfo', 'utf-8');\n      const lines = meminfo.split('\\n');\n      \n      const memTotal = parseInt(lines.find(l => l.startsWith('MemTotal:'))?.split(/\\s+/)[1] || '0') * 1024;\n      const memAvailable = parseInt(lines.find(l => l.startsWith('MemAvailable:'))?.split(/\\s+/)[1] || '0') * 1024;\n      const memUsed = memTotal - memAvailable;\n      \n      return {\n        used: memUsed,\n        total: memTotal,\n        percentage: memTotal > 0 ? (memUsed / memTotal) * 100 : 0\n      };\n    } catch {\n      return { used: 0, total: 0, percentage: 0 };\n    }\n  }\n\n  private async getCpuInfo() {\n    try {\n      const loadavg = await fs.readFile('/proc/loadavg', 'utf-8');\n      const loads = loadavg.trim().split(' ').slice(0, 3).map(parseFloat);\n      \n      return {\n        usage: loads[0] * 100, // Approximate CPU usage from 1-min load\n        load: loads\n      };\n    } catch {\n      return { usage: 0, load: [0, 0, 0] };\n    }\n  }\n\n  private async getDiskInfo() {\n    try {\n      const { stdout } = await execAsync('df -h . | tail -1');\n      const parts = stdout.trim().split(/\\s+/);\n      \n      const total = this.parseSize(parts[1]);\n      const used = this.parseSize(parts[2]);\n      const free = this.parseSize(parts[3]);\n      \n      return { used, total, free };\n    } catch {\n      return { used: 0, total: 0, free: 0 };\n    }\n  }\n\n  private parseSize(sizeStr: string): number {\n    const match = sizeStr.match(/^(\\d+(?:\\.\\d+)?)(K|M|G|T)?$/);\n    if (!match) return 0;\n    \n    const value = parseFloat(match[1]);\n    const unit = match[2] || '';\n    \n    const multipliers: Record<string, number> = {\n      '': 1,\n      'K': 1024,\n      'M': 1024 * 1024,\n      'G': 1024 * 1024 * 1024,\n      'T': 1024 * 1024 * 1024 * 1024\n    };\n    \n    return value * (multipliers[unit] || 1);\n  }\n\n  private evaluateThresholds(metrics: SystemMetrics): string[] {\n    const violations: string[] = [];\n    \n    if (metrics.performance.memory.percentage > this.config.thresholds.memoryUsage) {\n      violations.push(`Memory usage: ${metrics.performance.memory.percentage.toFixed(1)}% > ${this.config.thresholds.memoryUsage}%`);\n    }\n    \n    if (metrics.performance.cpu.usage > this.config.thresholds.cpuUsage) {\n      violations.push(`CPU usage: ${metrics.performance.cpu.usage.toFixed(1)}% > ${this.config.thresholds.cpuUsage}%`);\n    }\n    \n    const diskFreePercentage = (metrics.performance.disk.free / metrics.performance.disk.total) * 100;\n    if (diskFreePercentage < this.config.thresholds.diskSpace) {\n      violations.push(`Disk space: ${diskFreePercentage.toFixed(1)}% free < ${this.config.thresholds.diskSpace}%`);\n    }\n    \n    if (metrics.errors.rate > this.config.thresholds.errorRate) {\n      violations.push(`Error rate: ${metrics.errors.rate}/min > ${this.config.thresholds.errorRate}/min`);\n    }\n    \n    return violations;\n  }\n\n  private async triggerRollback(metrics: SystemMetrics, violations: string[]): Promise<void> {\n    this.lastRollback = Date.now();\n    \n    this.emit('rollback_triggered', {\n      reason: 'threshold_violations',\n      violations,\n      metrics\n    });\n    \n    // Send notifications\n    await this.sendNotifications(violations, metrics);\n  }\n\n  private async sendNotifications(violations: string[], metrics: SystemMetrics): Promise<void> {\n    const message = `ðŸš¨ Rollback triggered due to threshold violations:\\n${violations.join('\\n')}`;\n    \n    try {\n      if (this.config.notifications.webhook) {\n        // Send webhook notification\n        // Implementation would depend on the webhook service\n      }\n      \n      if (this.config.notifications.slack) {\n        // Send Slack notification\n        // Implementation would depend on Slack integration\n      }\n      \n      if (this.config.notifications.email) {\n        // Send email notification\n        // Implementation would depend on email service\n      }\n    } catch (error) {\n      this.emit('notification_error', error);\n    }\n  }\n\n  public updateConfig(config: Partial<RollbackTriggerConfig>): void {\n    this.config = this.mergeConfig(config);\n    this.emit('config_updated', this.config);\n  }\n\n  public getCurrentMetrics(): SystemMetrics | null {\n    return this.metrics[this.metrics.length - 1] || null;\n  }\n\n  public getMetricsHistory(): SystemMetrics[] {\n    return [...this.metrics];\n  }\n}\n\n// ============================================================================\n// AutomatedRecovery - Multi-tier recovery strategies\n// ============================================================================\n\nexport class AutomatedRecovery extends EventEmitter {\n  private strategies: Map<string, RecoveryStrategy> = new Map();\n  private recoveryHistory: RecoveryAttempt[] = [];\n  private stateManager: StateManager;\n  private isRecovering: boolean = false;\n\n  constructor(stateManager: StateManager) {\n    super();\n    this.stateManager = stateManager;\n    this.initializeDefaultStrategies();\n  }\n\n  private initializeDefaultStrategies(): void {\n    // Strategy 1: Service Restart\n    this.registerStrategy({\n      name: 'service_restart',\n      priority: 1,\n      enabled: true,\n      timeout: 30000,\n      retries: 2,\n      conditions: (metrics) => metrics.health.status === 'degraded',\n      execute: async (snapshot, context) => {\n        try {\n          this.emit('recovery_step', { strategy: 'service_restart', action: 'restarting_services' });\n          \n          // Restart critical services\n          await execAsync('pkill -f \"claude-flow\" && sleep 2');\n          \n          // Wait for services to restart\n          await new Promise(resolve => setTimeout(resolve, 5000));\n          \n          return true;\n        } catch (error) {\n          this.emit('recovery_error', { strategy: 'service_restart', error });\n          return false;\n        }\n      }\n    });\n\n    // Strategy 2: Memory Cleanup\n    this.registerStrategy({\n      name: 'memory_cleanup',\n      priority: 2,\n      enabled: true,\n      timeout: 15000,\n      retries: 1,\n      conditions: (metrics) => metrics.performance.memory.percentage > 85,\n      execute: async (snapshot, context) => {\n        try {\n          this.emit('recovery_step', { strategy: 'memory_cleanup', action: 'clearing_memory' });\n          \n          // Force garbage collection\n          if (global.gc) {\n            global.gc();\n          }\n          \n          // Clear caches\n          await this.clearApplicationCaches();\n          \n          return true;\n        } catch (error) {\n          this.emit('recovery_error', { strategy: 'memory_cleanup', error });\n          return false;\n        }\n      }\n    });\n\n    // Strategy 3: Configuration Reset\n    this.registerStrategy({\n      name: 'config_reset',\n      priority: 3,\n      enabled: true,\n      timeout: 20000,\n      retries: 1,\n      conditions: (metrics) => metrics.health.status === 'critical',\n      execute: async (snapshot, context) => {\n        try {\n          this.emit('recovery_step', { strategy: 'config_reset', action: 'resetting_config' });\n          \n          // Restore configuration from snapshot\n          await this.restoreConfiguration(snapshot);\n          \n          return true;\n        } catch (error) {\n          this.emit('recovery_error', { strategy: 'config_reset', error });\n          return false;\n        }\n      }\n    });\n\n    // Strategy 4: Full State Rollback\n    this.registerStrategy({\n      name: 'full_rollback',\n      priority: 10,\n      enabled: true,\n      timeout: 60000,\n      retries: 1,\n      conditions: () => true, // Last resort\n      execute: async (snapshot, context) => {\n        try {\n          this.emit('recovery_step', { strategy: 'full_rollback', action: 'rolling_back_state' });\n          \n          // Full system rollback\n          await this.performFullRollback(snapshot);\n          \n          return true;\n        } catch (error) {\n          this.emit('recovery_error', { strategy: 'full_rollback', error });\n          return false;\n        }\n      }\n    });\n  }\n\n  public registerStrategy(strategy: RecoveryStrategy): void {\n    this.strategies.set(strategy.name, strategy);\n    this.emit('strategy_registered', strategy.name);\n  }\n\n  public async executeRecovery(\n    metrics: SystemMetrics,\n    triggerReason: string,\n    preferredSnapshot?: string\n  ): Promise<boolean> {\n    if (this.isRecovering) {\n      this.emit('recovery_blocked', 'Recovery already in progress');\n      return false;\n    }\n\n    this.isRecovering = true;\n    \n    try {\n      this.emit('recovery_started', { reason: triggerReason, metrics });\n      \n      // Get appropriate snapshot\n      const snapshots = this.stateManager.listSnapshots();\n      const snapshot = preferredSnapshot \n        ? await this.stateManager.getSnapshot(preferredSnapshot)\n        : snapshots[0]; // Most recent snapshot\n      \n      if (!snapshot) {\n        throw new Error('No snapshot available for recovery');\n      }\n\n      // Get applicable strategies\n      const applicableStrategies = Array.from(this.strategies.values())\n        .filter(s => s.enabled && s.conditions(metrics))\n        .sort((a, b) => a.priority - b.priority);\n\n      if (applicableStrategies.length === 0) {\n        throw new Error('No applicable recovery strategies found');\n      }\n\n      const context: RecoveryContext = {\n        triggeredBy: triggerReason,\n        reason: triggerReason,\n        metrics,\n        previousAttempts: this.recoveryHistory.slice(-10) // Last 10 attempts\n      };\n\n      // Execute strategies in priority order\n      for (const strategy of applicableStrategies) {\n        const success = await this.executeStrategy(strategy, snapshot, context);\n        \n        if (success) {\n          this.emit('recovery_success', { \n            strategy: strategy.name, \n            snapshot: snapshot.id,\n            duration: Date.now() - metrics.timestamp \n          });\n          return true;\n        }\n      }\n\n      throw new Error('All recovery strategies failed');\n      \n    } catch (error) {\n      this.emit('recovery_failed', { error: error?.toString(), metrics });\n      return false;\n    } finally {\n      this.isRecovering = false;\n    }\n  }\n\n  private async executeStrategy(\n    strategy: RecoveryStrategy,\n    snapshot: SystemSnapshot,\n    context: RecoveryContext\n  ): Promise<boolean> {\n    const startTime = Date.now();\n    \n    for (let attempt = 0; attempt <= strategy.retries; attempt++) {\n      try {\n        this.emit('strategy_attempt', { \n          strategy: strategy.name, \n          attempt: attempt + 1,\n          maxAttempts: strategy.retries + 1\n        });\n        \n        // Execute with timeout\n        const success = await Promise.race([\n          strategy.execute(snapshot, context),\n          new Promise<boolean>((_, reject) => \n            setTimeout(() => reject(new Error('Strategy timeout')), strategy.timeout)\n          )\n        ]);\n\n        const duration = Date.now() - startTime;\n        \n        const recoveryAttempt: RecoveryAttempt = {\n          strategy: strategy.name,\n          timestamp: Date.now(),\n          success,\n          duration\n        };\n        \n        this.recoveryHistory.push(recoveryAttempt);\n        \n        if (success) {\n          this.emit('strategy_success', { strategy: strategy.name, attempt, duration });\n          return true;\n        }\n        \n      } catch (error) {\n        const duration = Date.now() - startTime;\n        \n        const recoveryAttempt: RecoveryAttempt = {\n          strategy: strategy.name,\n          timestamp: Date.now(),\n          success: false,\n          error: error?.toString(),\n          duration\n        };\n        \n        this.recoveryHistory.push(recoveryAttempt);\n        \n        this.emit('strategy_failed', { \n          strategy: strategy.name, \n          attempt, \n          error: error?.toString(),\n          duration \n        });\n        \n        if (attempt === strategy.retries) {\n          return false; // All retries exhausted\n        }\n        \n        // Wait before retry\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n      }\n    }\n    \n    return false;\n  }\n\n  private async clearApplicationCaches(): Promise<void> {\n    try {\n      // Clear memory caches\n      const memoryPaths = [\n        './memory/cache',\n        './swarm-memory/cache',\n        './temp'\n      ];\n      \n      for (const path of memoryPaths) {\n        try {\n          await fs.rm(path, { recursive: true, force: true });\n          await fs.mkdir(path, { recursive: true });\n        } catch {\n          // Path might not exist\n        }\n      }\n    } catch (error) {\n      throw new Error(`Failed to clear caches: ${error}`);\n    }\n  }\n\n  private async restoreConfiguration(snapshot: SystemSnapshot): Promise<void> {\n    try {\n      // Restore configuration files from snapshot\n      for (const [path, content] of Object.entries(snapshot.state.config)) {\n        try {\n          await fs.writeFile(path, JSON.stringify(content, null, 2));\n        } catch (error) {\n          console.warn(`Failed to restore config file ${path}:`, error);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Failed to restore configuration: ${error}`);\n    }\n  }\n\n  private async performFullRollback(snapshot: SystemSnapshot): Promise<void> {\n    try {\n      // 1. Stop services\n      await execAsync('pkill -f \"claude-flow\"').catch(() => {});\n      \n      // 2. Restore files\n      for (const file of snapshot.state.files) {\n        try {\n          await fs.writeFile(file.path, file.content);\n          await fs.chmod(file.path, file.stats.mode);\n        } catch (error) {\n          console.warn(`Failed to restore file ${file.path}:`, error);\n        }\n      }\n      \n      // 3. Restore memory\n      for (const [path, content] of Object.entries(snapshot.state.memory)) {\n        try {\n          await fs.writeFile(path, JSON.stringify(content, null, 2));\n        } catch (error) {\n          console.warn(`Failed to restore memory file ${path}:`, error);\n        }\n      }\n      \n      // 4. Git rollback if needed\n      if (snapshot.state.git.commit !== 'unknown') {\n        try {\n          await execAsync(`git reset --hard ${snapshot.state.git.commit}`);\n        } catch (error) {\n          console.warn('Failed to perform git rollback:', error);\n        }\n      }\n      \n      // 5. Restart services\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n    } catch (error) {\n      throw new Error(`Failed to perform full rollback: ${error}`);\n    }\n  }\n\n  public getStrategyNames(): string[] {\n    return Array.from(this.strategies.keys());\n  }\n\n  public getStrategy(name: string): RecoveryStrategy | undefined {\n    return this.strategies.get(name);\n  }\n\n  public enableStrategy(name: string): boolean {\n    const strategy = this.strategies.get(name);\n    if (strategy) {\n      strategy.enabled = true;\n      this.emit('strategy_enabled', name);\n      return true;\n    }\n    return false;\n  }\n\n  public disableStrategy(name: string): boolean {\n    const strategy = this.strategies.get(name);\n    if (strategy) {\n      strategy.enabled = false;\n      this.emit('strategy_disabled', name);\n      return true;\n    }\n    return false;\n  }\n\n  public getRecoveryHistory(): RecoveryAttempt[] {\n    return [...this.recoveryHistory];\n  }\n}\n\n// ============================================================================\n// RollbackHistory - Compressed history tracking with TTL\n// ============================================================================\n\nexport class RollbackHistory extends EventEmitter {\n  private history: Map<string, RollbackHistoryEntry> = new Map();\n  private historyDir: string;\n  private maxHistorySize: number;\n  private compressionEnabled: boolean;\n  private ttlMs: number;\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(\n    historyDir: string = './rollback-history',\n    maxHistorySize: number = 1000,\n    ttlDays: number = 30,\n    compressionEnabled: boolean = true\n  ) {\n    super();\n    this.historyDir = historyDir;\n    this.maxHistorySize = maxHistorySize;\n    this.ttlMs = ttlDays * 24 * 60 * 60 * 1000; // Convert days to ms\n    this.compressionEnabled = compressionEnabled;\n    \n    this.initializeStorage();\n    this.startCleanupInterval();\n  }\n\n  private async initializeStorage(): Promise<void> {\n    try {\n      await fs.mkdir(this.historyDir, { recursive: true });\n      await this.loadExistingHistory();\n    } catch (error) {\n      this.emit('error', new Error(`Failed to initialize history storage: ${error}`));\n    }\n  }\n\n  private async loadExistingHistory(): Promise<void> {\n    try {\n      const files = await fs.readdir(this.historyDir);\n      const historyFiles = files.filter(f => f.endsWith('.history.json') || f.endsWith('.history.json.gz'));\n      \n      for (const file of historyFiles) {\n        try {\n          const filepath = join(this.historyDir, file);\n          let content: string;\n          \n          if (file.endsWith('.gz')) {\n            const compressed = await fs.readFile(filepath);\n            const decompressed = await gunzipAsync(compressed);\n            content = decompressed.toString('utf-8');\n          } else {\n            content = await fs.readFile(filepath, 'utf-8');\n          }\n          \n          const entry: RollbackHistoryEntry = JSON.parse(content);\n          this.history.set(entry.id, entry);\n        } catch (error) {\n          console.warn(`Failed to load history entry ${file}:`, error);\n        }\n      }\n      \n      this.emit('history_loaded', this.history.size);\n    } catch (error) {\n      this.emit('error', new Error(`Failed to load history: ${error}`));\n    }\n  }\n\n  private startCleanupInterval(): void {\n    // Run cleanup every 6 hours\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpiredEntries();\n    }, 6 * 60 * 60 * 1000);\n  }\n\n  public async addEntry(\n    snapshot: SystemSnapshot,\n    triggerType: 'manual' | 'automatic',\n    triggerReason: string,\n    triggerMetrics: SystemMetrics | undefined,\n    recoveryStrategy: string,\n    recoverySuccess: boolean,\n    recoveryDuration: number,\n    recoveryAttempts: RecoveryAttempt[],\n    verificationChecks: HealthCheck[],\n    verificationPassed: boolean,\n    rollbackRequired: boolean\n  ): Promise<string> {\n    const id = this.generateHistoryId();\n    \n    const entry: RollbackHistoryEntry = {\n      id,\n      timestamp: Date.now(),\n      snapshot,\n      trigger: {\n        type: triggerType,\n        reason: triggerReason,\n        metrics: triggerMetrics\n      },\n      recovery: {\n        strategy: recoveryStrategy,\n        success: recoverySuccess,\n        duration: recoveryDuration,\n        attempts: recoveryAttempts\n      },\n      verification: {\n        passed: verificationPassed,\n        checks: verificationChecks,\n        rollbackRequired\n      }\n    };\n\n    try {\n      await this.storeHistoryEntry(entry);\n      this.history.set(id, entry);\n      \n      // Cleanup if we exceed max size\n      await this.cleanupOldEntries();\n      \n      this.emit('entry_added', entry);\n      return id;\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to add history entry: ${error}`));\n      throw error;\n    }\n  }\n\n  private async storeHistoryEntry(entry: RollbackHistoryEntry): Promise<void> {\n    const filename = `${entry.id}.history.json`;\n    const filepath = join(this.historyDir, filename);\n\n    let content = JSON.stringify(entry, null, 2);\n    \n    if (this.compressionEnabled) {\n      const compressed = await gzipAsync(Buffer.from(content, 'utf-8'));\n      await fs.writeFile(filepath + '.gz', compressed);\n    } else {\n      await fs.writeFile(filepath, content);\n    }\n  }\n\n  private async cleanupExpiredEntries(): Promise<void> {\n    const now = Date.now();\n    const expiredEntries: string[] = [];\n    \n    for (const [id, entry] of this.history.entries()) {\n      if (now - entry.timestamp > this.ttlMs) {\n        expiredEntries.push(id);\n      }\n    }\n    \n    for (const id of expiredEntries) {\n      await this.deleteEntry(id);\n    }\n    \n    if (expiredEntries.length > 0) {\n      this.emit('entries_expired', expiredEntries.length);\n    }\n  }\n\n  private async cleanupOldEntries(): Promise<void> {\n    if (this.history.size <= this.maxHistorySize) return;\n\n    const sorted = Array.from(this.history.values())\n      .sort((a, b) => a.timestamp - b.timestamp);\n    \n    const toDelete = sorted.slice(0, sorted.length - this.maxHistorySize);\n    \n    for (const entry of toDelete) {\n      await this.deleteEntry(entry.id);\n    }\n  }\n\n  private async deleteEntry(id: string): Promise<void> {\n    try {\n      const filename = `${id}.history.json`;\n      const filepath = join(this.historyDir, filename);\n      \n      await fs.unlink(filepath).catch(() => {});\n      await fs.unlink(filepath + '.gz').catch(() => {});\n      \n      this.history.delete(id);\n    } catch (error) {\n      console.warn(`Failed to delete history entry ${id}:`, error);\n    }\n  }\n\n  private generateHistoryId(): string {\n    return `history_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  public getEntry(id: string): RollbackHistoryEntry | null {\n    return this.history.get(id) || null;\n  }\n\n  public getRecentEntries(limit: number = 50): RollbackHistoryEntry[] {\n    return Array.from(this.history.values())\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, limit);\n  }\n\n  public getEntriesByDateRange(startDate: Date, endDate: Date): RollbackHistoryEntry[] {\n    const startTime = startDate.getTime();\n    const endTime = endDate.getTime();\n    \n    return Array.from(this.history.values())\n      .filter(entry => entry.timestamp >= startTime && entry.timestamp <= endTime)\n      .sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  public getSuccessRate(timeframe: number = 24 * 60 * 60 * 1000): number {\n    const cutoff = Date.now() - timeframe;\n    const recentEntries = Array.from(this.history.values())\n      .filter(entry => entry.timestamp > cutoff);\n    \n    if (recentEntries.length === 0) return 100;\n    \n    const successCount = recentEntries.filter(entry => entry.recovery.success).length;\n    return (successCount / recentEntries.length) * 100;\n  }\n\n  public getStatistics(): {\n    totalEntries: number;\n    successRate: number;\n    averageRecoveryTime: number;\n    mostCommonFailureReason: string;\n    rollbacksByTrigger: Record<string, number>;\n  } {\n    const entries = Array.from(this.history.values());\n    \n    if (entries.length === 0) {\n      return {\n        totalEntries: 0,\n        successRate: 100,\n        averageRecoveryTime: 0,\n        mostCommonFailureReason: 'none',\n        rollbacksByTrigger: {}\n      };\n    }\n    \n    const successCount = entries.filter(e => e.recovery.success).length;\n    const successRate = (successCount / entries.length) * 100;\n    \n    const totalRecoveryTime = entries.reduce((sum, e) => sum + e.recovery.duration, 0);\n    const averageRecoveryTime = totalRecoveryTime / entries.length;\n    \n    const failureReasons = entries\n      .filter(e => !e.recovery.success)\n      .map(e => e.trigger.reason);\n    \n    const reasonCounts = failureReasons.reduce((acc, reason) => {\n      acc[reason] = (acc[reason] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const mostCommonFailureReason = Object.entries(reasonCounts)\n      .sort(([,a], [,b]) => b - a)[0]?.[0] || 'none';\n    \n    const rollbacksByTrigger = entries.reduce((acc, entry) => {\n      acc[entry.trigger.type] = (acc[entry.trigger.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    return {\n      totalEntries: entries.length,\n      successRate,\n      averageRecoveryTime,\n      mostCommonFailureReason,\n      rollbacksByTrigger\n    };\n  }\n\n  public destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = undefined;\n    }\n  }\n}\n\n// ============================================================================\n// GitRollbackManager - Git integration for code rollbacks\n// ============================================================================\n\nexport class GitRollbackManager extends EventEmitter {\n  private gitDir: string;\n  private backupBranch: string;\n  private safetyChecks: boolean;\n\n  constructor(\n    gitDir: string = './',\n    backupBranch: string = 'rollback-backup',\n    safetyChecks: boolean = true\n  ) {\n    super();\n    this.gitDir = gitDir;\n    this.backupBranch = backupBranch;\n    this.safetyChecks = safetyChecks;\n  }\n\n  /**\n   * Creates an atomic git commit with rollback marker\n   */\n  public async createRollbackPoint(\n    message: string = 'Automated rollback point',\n    tags: string[] = []\n  ): Promise<string> {\n    try {\n      // Ensure we're in a git repository\n      await this.ensureGitRepo();\n      \n      if (this.safetyChecks) {\n        await this.performSafetyChecks();\n      }\n      \n      // Create backup branch\n      await this.createBackupBranch();\n      \n      // Stage all changes\n      await execAsync('git add -A', { cwd: this.gitDir });\n      \n      // Create commit with rollback metadata\n      const rollbackMessage = this.formatRollbackMessage(message, tags);\n      await execAsync(`git commit -m \"${rollbackMessage}\"`, { cwd: this.gitDir });\n      \n      // Get commit hash\n      const { stdout: commitHash } = await execAsync('git rev-parse HEAD', { cwd: this.gitDir });\n      const hash = commitHash.trim();\n      \n      // Create tag for easy reference\n      const tagName = `rollback-${Date.now()}`;\n      await execAsync(`git tag -a \"${tagName}\" -m \"Rollback point: ${message}\"`, { cwd: this.gitDir });\n      \n      this.emit('rollback_point_created', { hash, tag: tagName, message });\n      return hash;\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to create rollback point: ${error}`));\n      throw error;\n    }\n  }\n\n  /**\n   * Performs atomic rollback to a specific commit\n   */\n  public async rollbackToCommit(\n    commitHash: string,\n    strategy: 'hard' | 'soft' | 'mixed' = 'mixed',\n    preserveUntracked: boolean = true\n  ): Promise<boolean> {\n    try {\n      if (this.safetyChecks) {\n        await this.performSafetyChecks();\n        await this.validateCommit(commitHash);\n      }\n      \n      // Stash any current changes if preserving untracked files\n      let stashRef: string | null = null;\n      if (preserveUntracked) {\n        try {\n          await execAsync('git stash push -u -m \"Pre-rollback stash\"', { cwd: this.gitDir });\n          stashRef = await this.getLastStashRef();\n        } catch {\n          // No changes to stash\n        }\n      }\n      \n      // Perform the rollback\n      await execAsync(`git reset --${strategy} ${commitHash}`, { cwd: this.gitDir });\n      \n      // If hard reset and preserving untracked, restore stashed files\n      if (strategy === 'hard' && stashRef && preserveUntracked) {\n        try {\n          // Only restore untracked files from stash\n          await execAsync(`git stash show -p ${stashRef} | git apply --index`, { cwd: this.gitDir });\n          await execAsync(`git stash drop ${stashRef}`, { cwd: this.gitDir });\n        } catch {\n          // Stash restoration failed, but rollback succeeded\n          this.emit('warning', 'Rollback completed but failed to restore untracked files');\n        }\n      }\n      \n      // Verify rollback success\n      const { stdout: currentHash } = await execAsync('git rev-parse HEAD', { cwd: this.gitDir });\n      const success = currentHash.trim() === commitHash;\n      \n      if (success) {\n        this.emit('rollback_completed', { commitHash, strategy });\n      } else {\n        throw new Error('Rollback verification failed');\n      }\n      \n      return success;\n      \n    } catch (error) {\n      this.emit('error', new Error(`Rollback failed: ${error}`));\n      \n      // Attempt emergency recovery\n      try {\n        await this.emergencyRecovery();\n      } catch (recoveryError) {\n        this.emit('error', new Error(`Emergency recovery failed: ${recoveryError}`));\n      }\n      \n      return false;\n    }\n  }\n\n  /**\n   * Rolls back specific files to their state at a given commit\n   */\n  public async rollbackFiles(\n    files: string[],\n    commitHash: string\n  ): Promise<boolean> {\n    try {\n      if (this.safetyChecks) {\n        await this.validateCommit(commitHash);\n        await this.validateFiles(files);\n      }\n      \n      // Backup current state of files\n      const backupStash = await this.createFileBackup(files);\n      \n      try {\n        // Rollback each file\n        for (const file of files) {\n          await execAsync(`git checkout ${commitHash} -- \"${file}\"`, { cwd: this.gitDir });\n        }\n        \n        this.emit('files_rolled_back', { files, commitHash });\n        return true;\n        \n      } catch (error) {\n        // Restore from backup on failure\n        if (backupStash) {\n          await this.restoreFileBackup(backupStash, files);\n        }\n        throw error;\n      }\n      \n    } catch (error) {\n      this.emit('error', new Error(`File rollback failed: ${error}`));\n      return false;\n    }\n  }\n\n  /**\n   * Creates a branch from current state for safe rollback testing\n   */\n  public async createTestBranch(name?: string): Promise<string> {\n    try {\n      const branchName = name || `rollback-test-${Date.now()}`;\n      \n      await execAsync(`git checkout -b \"${branchName}\"`, { cwd: this.gitDir });\n      \n      this.emit('test_branch_created', branchName);\n      return branchName;\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to create test branch: ${error}`));\n      throw error;\n    }\n  }\n\n  /**\n   * Lists available rollback points (commits with rollback markers)\n   */\n  public async listRollbackPoints(): Promise<Array<{\n    hash: string;\n    date: Date;\n    message: string;\n    tags: string[];\n  }>> {\n    try {\n      // Get commits with rollback markers\n      const { stdout } = await execAsync(\n        'git log --grep=\"\\\\[ROLLBACK\\\\]\" --oneline --format=\"%H|%ai|%s\" -n 50',\n        { cwd: this.gitDir }\n      );\n      \n      const commits = stdout.trim().split('\\n').filter(Boolean).map(line => {\n        const [hash, dateStr, message] = line.split('|');\n        return {\n          hash,\n          date: new Date(dateStr),\n          message: message.replace(/\\[ROLLBACK\\]/, '').trim(),\n          tags: this.extractTagsFromMessage(message)\n        };\n      });\n      \n      // Also get tagged rollback points\n      const { stdout: tagOutput } = await execAsync(\n        'git tag -l \"rollback-*\" --format=\"%(refname:short)|%(creatordate)|%(subject)\"',\n        { cwd: this.gitDir }\n      ).catch(() => ({ stdout: '' }));\n      \n      const taggedCommits = tagOutput.trim().split('\\n').filter(Boolean).map(line => {\n        const [tag, dateStr, message] = line.split('|');\n        return {\n          hash: tag,\n          date: new Date(dateStr),\n          message: message || 'Tagged rollback point',\n          tags: [tag]\n        };\n      });\n      \n      return [...commits, ...taggedCommits].sort((a, b) => b.date.getTime() - a.date.getTime());\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to list rollback points: ${error}`));\n      return [];\n    }\n  }\n\n  private async ensureGitRepo(): Promise<void> {\n    try {\n      await execAsync('git rev-parse --git-dir', { cwd: this.gitDir });\n    } catch {\n      throw new Error('Not a git repository');\n    }\n  }\n\n  private async performSafetyChecks(): Promise<void> {\n    // Check for uncommitted changes\n    const { stdout: status } = await execAsync('git status --porcelain', { cwd: this.gitDir });\n    if (status.trim()) {\n      this.emit('warning', 'Uncommitted changes detected');\n    }\n    \n    // Check if we're on a protected branch\n    const { stdout: branch } = await execAsync('git rev-parse --abbrev-ref HEAD', { cwd: this.gitDir });\n    const currentBranch = branch.trim();\n    \n    const protectedBranches = ['main', 'master', 'production', 'release'];\n    if (protectedBranches.includes(currentBranch)) {\n      this.emit('warning', `Operating on protected branch: ${currentBranch}`);\n    }\n  }\n\n  private async createBackupBranch(): Promise<void> {\n    try {\n      // Delete existing backup branch if it exists\n      await execAsync(`git branch -D \"${this.backupBranch}\"`, { cwd: this.gitDir }).catch(() => {});\n      \n      // Create new backup branch\n      await execAsync(`git checkout -b \"${this.backupBranch}\"`, { cwd: this.gitDir });\n      \n      // Switch back to original branch\n      await execAsync('git checkout -', { cwd: this.gitDir });\n      \n    } catch (error) {\n      this.emit('warning', `Failed to create backup branch: ${error}`);\n    }\n  }\n\n  private formatRollbackMessage(message: string, tags: string[]): string {\n    const tagStr = tags.length > 0 ? ` [${tags.join(', ')}]` : '';\n    return `[ROLLBACK] ${message}${tagStr}`;\n  }\n\n  private extractTagsFromMessage(message: string): string[] {\n    const match = message.match(/\\[([^\\]]+)\\]/g);\n    if (!match) return [];\n    \n    return match.map(tag => tag.slice(1, -1)).filter(tag => tag !== 'ROLLBACK');\n  }\n\n  private async validateCommit(commitHash: string): Promise<void> {\n    try {\n      await execAsync(`git cat-file -e ${commitHash}`, { cwd: this.gitDir });\n    } catch {\n      throw new Error(`Invalid commit hash: ${commitHash}`);\n    }\n  }\n\n  private async validateFiles(files: string[]): Promise<void> {\n    for (const file of files) {\n      try {\n        await fs.access(join(this.gitDir, file));\n      } catch {\n        throw new Error(`File not found: ${file}`);\n      }\n    }\n  }\n\n  private async getLastStashRef(): Promise<string> {\n    const { stdout } = await execAsync('git stash list -1 --format=\"%H\"', { cwd: this.gitDir });\n    return stdout.trim();\n  }\n\n  private async createFileBackup(files: string[]): Promise<string | null> {\n    try {\n      // Create a stash with only the specified files\n      for (const file of files) {\n        await execAsync(`git add \"${file}\"`, { cwd: this.gitDir });\n      }\n      \n      await execAsync('git stash push -m \"File backup before rollback\"', { cwd: this.gitDir });\n      return await this.getLastStashRef();\n      \n    } catch {\n      return null;\n    }\n  }\n\n  private async restoreFileBackup(stashRef: string, files: string[]): Promise<void> {\n    try {\n      // Restore files from stash\n      await execAsync(`git stash show -p ${stashRef} | git apply`, { cwd: this.gitDir });\n      await execAsync(`git stash drop ${stashRef}`, { cwd: this.gitDir });\n    } catch (error) {\n      this.emit('error', new Error(`Failed to restore file backup: ${error}`));\n    }\n  }\n\n  private async emergencyRecovery(): Promise<void> {\n    try {\n      // Try to recover using backup branch\n      if (this.backupBranch) {\n        await execAsync(`git checkout \"${this.backupBranch}\"`, { cwd: this.gitDir });\n        await execAsync('git checkout -b \"emergency-recovery\"', { cwd: this.gitDir });\n        this.emit('emergency_recovery_completed', 'emergency-recovery');\n      }\n    } catch (error) {\n      throw new Error(`Emergency recovery failed: ${error}`);\n    }\n  }\n}\n\n// ============================================================================\n// Main RollbackManager - Orchestrates all rollback components\n// ============================================================================\n\nexport class RollbackManager extends EventEmitter {\n  private stateManager: StateManager;\n  private rollbackTrigger: RollbackTrigger;\n  private automatedRecovery: AutomatedRecovery;\n  private rollbackHistory: RollbackHistory;\n  private gitRollbackManager: GitRollbackManager;\n  private isInitialized: boolean = false;\n\n  constructor(config: {\n    snapshotDir?: string;\n    historyDir?: string;\n    gitDir?: string;\n    maxSnapshots?: number;\n    maxHistorySize?: number;\n    historyTtlDays?: number;\n    compressionEnabled?: boolean;\n    triggerConfig?: Partial<RollbackTriggerConfig>;\n  } = {}) {\n    super();\n    \n    // Initialize components\n    this.stateManager = new StateManager(\n      config.snapshotDir,\n      config.maxSnapshots,\n      config.compressionEnabled\n    );\n    \n    this.rollbackTrigger = new RollbackTrigger(config.triggerConfig);\n    this.automatedRecovery = new AutomatedRecovery(this.stateManager);\n    \n    this.rollbackHistory = new RollbackHistory(\n      config.historyDir,\n      config.maxHistorySize,\n      config.historyTtlDays,\n      config.compressionEnabled\n    );\n    \n    this.gitRollbackManager = new GitRollbackManager(config.gitDir);\n    \n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    // Connect rollback trigger to automated recovery\n    this.rollbackTrigger.on('rollback_triggered', async (event) => {\n      await this.handleAutomaticRollback(event.metrics, event.reason);\n    });\n    \n    // Forward important events\n    this.stateManager.on('error', (error) => this.emit('error', error));\n    this.rollbackTrigger.on('error', (error) => this.emit('error', error));\n    this.automatedRecovery.on('error', (error) => this.emit('error', error));\n    this.rollbackHistory.on('error', (error) => this.emit('error', error));\n    this.gitRollbackManager.on('error', (error) => this.emit('error', error));\n    \n    // Aggregate events\n    this.stateManager.on('snapshot_created', (snapshot) => \n      this.emit('snapshot_created', snapshot));\n    this.automatedRecovery.on('recovery_success', (event) => \n      this.emit('recovery_success', event));\n    this.gitRollbackManager.on('rollback_completed', (event) => \n      this.emit('git_rollback_completed', event));\n  }\n\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    \n    try {\n      // Start monitoring\n      this.rollbackTrigger.startMonitoring();\n      \n      this.isInitialized = true;\n      this.emit('initialized');\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to initialize RollbackManager: ${error}`));\n      throw error;\n    }\n  }\n\n  public async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n    \n    try {\n      this.rollbackTrigger.stopMonitoring();\n      this.rollbackHistory.destroy();\n      \n      this.isInitialized = false;\n      this.emit('shutdown');\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to shutdown RollbackManager: ${error}`));\n    }\n  }\n\n  /**\n   * Creates a comprehensive system checkpoint\n   */\n  public async createCheckpoint(\n    description: string,\n    tags: string[] = []\n  ): Promise<string> {\n    try {\n      // Create system snapshot\n      const snapshot = await this.stateManager.captureSnapshot(\n        description,\n        tags,\n        'manual_checkpoint'\n      );\n      \n      // Create git rollback point\n      await this.gitRollbackManager.createRollbackPoint(\n        description,\n        tags\n      );\n      \n      this.emit('checkpoint_created', { snapshot: snapshot.id, description, tags });\n      return snapshot.id;\n      \n    } catch (error) {\n      this.emit('error', new Error(`Failed to create checkpoint: ${error}`));\n      throw error;\n    }\n  }\n\n  /**\n   * Performs a manual rollback to a specific checkpoint\n   */\n  public async rollbackToCheckpoint(\n    snapshotId: string,\n    strategy: 'graceful' | 'immediate' = 'graceful'\n  ): Promise<boolean> {\n    try {\n      const snapshot = await this.stateManager.getSnapshot(snapshotId);\n      if (!snapshot) {\n        throw new Error(`Snapshot not found: ${snapshotId}`);\n      }\n      \n      const startTime = Date.now();\n      \n      // Execute rollback based on strategy\n      let success: boolean;\n      if (strategy === 'graceful') {\n        success = await this.performGracefulRollback(snapshot);\n      } else {\n        success = await this.performImmediateRollback(snapshot);\n      }\n      \n      const duration = Date.now() - startTime;\n      \n      // Record in history\n      await this.rollbackHistory.addEntry(\n        snapshot,\n        'manual',\n        `Manual rollback to checkpoint ${snapshotId}`,\n        undefined, // No trigger metrics for manual rollback\n        strategy,\n        success,\n        duration,\n        [], // No recovery attempts for manual rollback\n        [], // Would need to run verification\n        success,\n        !success\n      );\n      \n      if (success) {\n        this.emit('manual_rollback_success', { snapshotId, strategy, duration });\n      } else {\n        this.emit('manual_rollback_failed', { snapshotId, strategy, duration });\n      }\n      \n      return success;\n      \n    } catch (error) {\n      this.emit('error', new Error(`Manual rollback failed: ${error}`));\n      return false;\n    }\n  }\n\n  private async handleAutomaticRollback(\n    metrics: SystemMetrics,\n    reason: string\n  ): Promise<void> {\n    try {\n      const success = await this.automatedRecovery.executeRecovery(metrics, reason);\n      \n      if (success) {\n        this.emit('automatic_rollback_success', { reason, metrics });\n      } else {\n        this.emit('automatic_rollback_failed', { reason, metrics });\n      }\n      \n    } catch (error) {\n      this.emit('error', new Error(`Automatic rollback failed: ${error}`));\n    }\n  }\n\n  private async performGracefulRollback(snapshot: SystemSnapshot): Promise<boolean> {\n    try {\n      // 1. Create backup of current state\n      await this.stateManager.captureSnapshot(\n        'Pre-rollback backup',\n        ['auto-backup'],\n        'rollback_backup'\n      );\n      \n      // 2. Gradually restore components\n      const restoreSteps = [\n        () => this.restoreConfiguration(snapshot),\n        () => this.restoreMemoryState(snapshot),\n        () => this.restoreFileSystem(snapshot),\n        () => this.performGitRollback(snapshot)\n      ];\n      \n      for (const step of restoreSteps) {\n        await step();\n        // Small delay between steps\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      return true;\n      \n    } catch (error) {\n      this.emit('graceful_rollback_error', error);\n      return false;\n    }\n  }\n\n  private async performImmediateRollback(snapshot: SystemSnapshot): Promise<boolean> {\n    try {\n      // Perform all restoration steps in parallel for speed\n      await Promise.all([\n        this.restoreConfiguration(snapshot),\n        this.restoreMemoryState(snapshot),\n        this.restoreFileSystem(snapshot),\n        this.performGitRollback(snapshot)\n      ]);\n      \n      return true;\n      \n    } catch (error) {\n      this.emit('immediate_rollback_error', error);\n      return false;\n    }\n  }\n\n  private async restoreConfiguration(snapshot: SystemSnapshot): Promise<void> {\n    for (const [path, content] of Object.entries(snapshot.state.config)) {\n      try {\n        await fs.writeFile(path, JSON.stringify(content, null, 2));\n      } catch (error) {\n        console.warn(`Failed to restore config ${path}:`, error);\n      }\n    }\n  }\n\n  private async restoreMemoryState(snapshot: SystemSnapshot): Promise<void> {\n    for (const [path, content] of Object.entries(snapshot.state.memory)) {\n      try {\n        await fs.writeFile(path, JSON.stringify(content, null, 2));\n      } catch (error) {\n        console.warn(`Failed to restore memory ${path}:`, error);\n      }\n    }\n  }\n\n  private async restoreFileSystem(snapshot: SystemSnapshot): Promise<void> {\n    for (const file of snapshot.state.files) {\n      try {\n        await fs.writeFile(file.path, file.content);\n        await fs.chmod(file.path, file.stats.mode);\n      } catch (error) {\n        console.warn(`Failed to restore file ${file.path}:`, error);\n      }\n    }\n  }\n\n  private async performGitRollback(snapshot: SystemSnapshot): Promise<void> {\n    if (snapshot.state.git.commit !== 'unknown') {\n      try {\n        await this.gitRollbackManager.rollbackToCommit(snapshot.state.git.commit);\n      } catch (error) {\n        console.warn('Git rollback failed:', error);\n      }\n    }\n  }\n\n  // Public API methods\n  public getStateManager(): StateManager { return this.stateManager; }\n  public getRollbackTrigger(): RollbackTrigger { return this.rollbackTrigger; }\n  public getAutomatedRecovery(): AutomatedRecovery { return this.automatedRecovery; }\n  public getRollbackHistory(): RollbackHistory { return this.rollbackHistory; }\n  public getGitRollbackManager(): GitRollbackManager { return this.gitRollbackManager; }\n\n  public async getSystemStatus(): Promise<{\n    isMonitoring: boolean;\n    snapshotCount: number;\n    historyEntries: number;\n    lastCheckpoint: string | null;\n    healthScore: number;\n  }> {\n    const snapshots = this.stateManager.listSnapshots();\n    const recentEntries = this.rollbackHistory.getRecentEntries(10);\n    const successRate = this.rollbackHistory.getSuccessRate();\n    \n    return {\n      isMonitoring: this.rollbackTrigger.getCurrentMetrics() !== null,\n      snapshotCount: snapshots.length,\n      historyEntries: recentEntries.length,\n      lastCheckpoint: snapshots[0]?.id || null,\n      healthScore: successRate\n    };\n  }\n}\n\n// Export the main class and interfaces\nexport default RollbackManager;"],"names":["promises","fs","join","exec","promisify","createHash","EventEmitter","gzip","gunzip","execAsync","gzipAsync","gunzipAsync","StateManager","snapshots","Map","snapshotDir","maxSnapshots","compressionEnabled","initializeStorage","mkdir","recursive","loadExistingSnapshots","error","emit","Error","files","readdir","snapshotFiles","filter","f","endsWith","file","content","readFile","snapshot","JSON","parse","set","id","console","warn","size","captureSnapshot","description","tags","triggeredBy","generateSnapshotId","timestamp","Date","now","config","memory","processes","git","Promise","all","captureConfig","captureMemory","captureProcesses","captureFiles","captureGitState","version","metadata","severity","state","integrity","checksum","compressed","serialized","stringify","update","digest","Buffer","byteLength","storeSnapshot","cleanupOldSnapshots","configPaths","path","memoryPaths","stdout","lines","trim","split","map","line","parts","pid","parseInt","name","status","parseFloat","cpu","env","process","criticalPaths","stats","stat","push","mtime","getTime","mode","branch","commit","staged","modified","untracked","then","r","catch","Boolean","filename","filepath","from","writeFile","sorted","Array","values","sort","a","b","toDelete","slice","length","unlink","delete","Math","random","toString","substr","getSnapshot","get","listSnapshots","deleteSnapshot","RollbackTrigger","monitoring","metrics","monitoringInterval","lastRollback","mergeConfig","enabled","thresholds","errorRate","memoryUsage","cpuUsage","responseTime","diskSpace","consecutiveFailures","interval","cooldown","gracePeriod","notifications","webhook","email","slack","startMonitoring","setInterval","checkThresholds","stopMonitoring","clearInterval","undefined","collectMetrics","oneHourAgo","m","violations","evaluateThresholds","recentViolations","triggerRollback","memInfo","cpuInfo","diskInfo","getMemoryInfo","getCpuInfo","getDiskInfo","errors","count","rate","recent","performance","disk","network","in","out","health","score","checks","used","total","percentage","usage","load","free","message","duration","meminfo","memTotal","find","l","startsWith","memAvailable","memUsed","loadavg","loads","parseSize","sizeStr","match","value","unit","multipliers","toFixed","diskFreePercentage","reason","sendNotifications","updateConfig","getCurrentMetrics","getMetricsHistory","AutomatedRecovery","strategies","recoveryHistory","stateManager","isRecovering","initializeDefaultStrategies","registerStrategy","priority","timeout","retries","conditions","execute","context","strategy","action","resolve","setTimeout","global","gc","clearApplicationCaches","restoreConfiguration","performFullRollback","executeRecovery","triggerReason","preferredSnapshot","applicableStrategies","s","previousAttempts","success","executeStrategy","startTime","attempt","maxAttempts","race","_","reject","recoveryAttempt","rm","force","Object","entries","chmod","getStrategyNames","keys","getStrategy","enableStrategy","disableStrategy","getRecoveryHistory","RollbackHistory","history","historyDir","maxHistorySize","ttlMs","cleanupInterval","ttlDays","startCleanupInterval","loadExistingHistory","historyFiles","decompressed","entry","cleanupExpiredEntries","addEntry","triggerType","triggerMetrics","recoveryStrategy","recoverySuccess","recoveryDuration","recoveryAttempts","verificationChecks","verificationPassed","rollbackRequired","generateHistoryId","trigger","type","recovery","attempts","verification","passed","storeHistoryEntry","cleanupOldEntries","expiredEntries","deleteEntry","getEntry","getRecentEntries","limit","getEntriesByDateRange","startDate","endDate","endTime","getSuccessRate","timeframe","cutoff","recentEntries","successCount","getStatistics","totalEntries","successRate","averageRecoveryTime","mostCommonFailureReason","rollbacksByTrigger","e","totalRecoveryTime","reduce","sum","failureReasons","reasonCounts","acc","destroy","GitRollbackManager","gitDir","backupBranch","safetyChecks","createRollbackPoint","ensureGitRepo","performSafetyChecks","createBackupBranch","cwd","rollbackMessage","formatRollbackMessage","commitHash","hash","tagName","tag","rollbackToCommit","preserveUntracked","validateCommit","stashRef","getLastStashRef","currentHash","emergencyRecovery","recoveryError","rollbackFiles","validateFiles","backupStash","createFileBackup","restoreFileBackup","createTestBranch","branchName","listRollbackPoints","commits","dateStr","date","replace","extractTagsFromMessage","tagOutput","taggedCommits","currentBranch","protectedBranches","includes","tagStr","access","RollbackManager","rollbackTrigger","automatedRecovery","rollbackHistory","gitRollbackManager","isInitialized","triggerConfig","historyTtlDays","setupEventHandlers","on","event","handleAutomaticRollback","initialize","shutdown","createCheckpoint","rollbackToCheckpoint","snapshotId","performGracefulRollback","performImmediateRollback","restoreSteps","restoreMemoryState","restoreFileSystem","performGitRollback","step","getStateManager","getRollbackTrigger","getAutomatedRecovery","getRollbackHistory","getGitRollbackManager","getSystemStatus","isMonitoring","snapshotCount","historyEntries","lastCheckpoint","healthScore"],"mappings":"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"}