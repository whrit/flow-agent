{"version":3,"sources":["../../../src/verification/alert-manager.ts"],"sourcesContent":["/**\n * Truth Alert Manager - Advanced alerting and notification system\n * \n * Provides comprehensive threshold monitoring, intelligent alert routing,\n * escalation management, and automated remediation capabilities.\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  TruthMetric,\n  TruthAlert,\n  AlertThreshold,\n  AlertAction,\n  EscalationLevel,\n  TruthAlertType,\n  TruthTelemetryConfig,\n} from './telemetry.js';\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  description: string;\n  enabled: boolean;\n  \n  // Condition definition\n  metric: string;\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte' | 'ne' | 'change' | 'rate';\n  threshold: number;\n  duration: number; // How long condition must persist (ms)\n  \n  // Alert configuration\n  severity: 'info' | 'warning' | 'critical' | 'emergency';\n  category: TruthAlertType;\n  priority: number; // 1-10, higher is more urgent\n  \n  // Context and filtering\n  filters: Record<string, any>;\n  conditions: AlertCondition[];\n  \n  // Actions and escalation\n  actions: AlertAction[];\n  escalationPath: EscalationLevel[];\n  suppressions: AlertSuppression[];\n  \n  // Metadata\n  tags: Record<string, string>;\n  createdBy: string;\n  createdAt: Date;\n  lastModified: Date;\n}\n\nexport interface AlertCondition {\n  field: string;\n  operator: string;\n  value: any;\n  logicalOperator?: 'AND' | 'OR';\n}\n\nexport interface AlertSuppression {\n  id: string;\n  condition: string;\n  startTime: Date;\n  endTime: Date;\n  reason: string;\n  createdBy: string;\n}\n\nexport interface AlertChannel {\n  id: string;\n  name: string;\n  type: 'email' | 'slack' | 'webhook' | 'sms' | 'teams' | 'discord' | 'pagerduty';\n  config: Record<string, any>;\n  enabled: boolean;\n  filters: AlertFilter[];\n  rateLimits: RateLimit[];\n}\n\nexport interface AlertFilter {\n  field: string;\n  operator: string;\n  values: string[];\n  action: 'include' | 'exclude';\n}\n\nexport interface RateLimit {\n  window: number; // time window in milliseconds\n  maxAlerts: number;\n  resetTime?: Date;\n  currentCount: number;\n}\n\nexport interface AlertHistory {\n  alertId: string;\n  timestamp: Date;\n  action: 'created' | 'acknowledged' | 'resolved' | 'escalated' | 'suppressed';\n  actor: string;\n  details: Record<string, any>;\n}\n\nexport interface AlertStatistics {\n  totalAlerts: number;\n  activeAlerts: number;\n  resolvedAlerts: number;\n  averageResolutionTime: number;\n  alertsByType: Record<string, number>;\n  alertsBySeverity: Record<string, number>;\n  topAlertSources: Array<{ source: string; count: number }>;\n  escalationRate: number;\n  falsePositiveRate: number;\n}\n\nexport interface ThresholdGroup {\n  name: string;\n  thresholds: AlertThreshold[];\n  enabled: boolean;\n  scope: 'system' | 'agent' | 'task' | 'custom';\n}\n\nexport class TruthAlertManager {\n  private config: TruthTelemetryConfig;\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  \n  // Alert management state\n  private alertRules = new Map<string, AlertRule>();\n  private activeAlerts = new Map<string, TruthAlert>();\n  private alertHistory: AlertHistory[] = [];\n  private alertChannels = new Map<string, AlertChannel>();\n  private suppressions = new Map<string, AlertSuppression>();\n  \n  // Threshold monitoring\n  private thresholdGroups = new Map<string, ThresholdGroup>();\n  private metricStates = new Map<string, MetricState>();\n  \n  // Processing state\n  private processingInterval?: NodeJS.Timeout;\n  private escalationInterval?: NodeJS.Timeout;\n  private cleanupInterval?: NodeJS.Timeout;\n  \n  // Statistics\n  private statistics: AlertStatistics;\n  \n  constructor(\n    config: TruthTelemetryConfig,\n    logger: ILogger,\n    eventBus: IEventBus\n  ) {\n    this.config = config;\n    this.logger = logger;\n    this.eventBus = eventBus;\n    \n    this.statistics = this.initializeStatistics();\n    this.initializeDefaultRules();\n    this.initializeDefaultChannels();\n  }\n  \n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Truth Alert Manager', {\n      alertEnabled: this.config.alertEnabled,\n      thresholds: this.config.alertThresholds,\n    });\n    \n    // Start processing loops\n    this.startAlertProcessing();\n    this.startEscalationProcessing();\n    this.startCleanupProcessing();\n    \n    // Load configuration\n    await this.loadAlertConfiguration();\n    \n    this.logger.info('Truth Alert Manager initialized successfully', {\n      rules: this.alertRules.size,\n      channels: this.alertChannels.size,\n    });\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Truth Alert Manager');\n    \n    // Stop processing intervals\n    if (this.processingInterval) clearInterval(this.processingInterval);\n    if (this.escalationInterval) clearInterval(this.escalationInterval);\n    if (this.cleanupInterval) clearInterval(this.cleanupInterval);\n    \n    // Save state\n    await this.saveAlertConfiguration();\n    \n    this.logger.info('Truth Alert Manager shutdown complete');\n  }\n  \n  // ========================================================================================\n  // Alert Processing\n  // ========================================================================================\n  \n  async checkThresholds(metric: TruthMetric): Promise<void> {\n    if (!this.config.alertEnabled) return;\n    \n    try {\n      // Update metric state\n      await this.updateMetricState(metric);\n      \n      // Check all applicable rules\n      const applicableRules = this.getApplicableRules(metric);\n      \n      for (const rule of applicableRules) {\n        await this.evaluateRule(rule, metric);\n      }\n      \n    } catch (error) {\n      this.logger.error('Error checking thresholds', { metricId: metric.id, error });\n    }\n  }\n  \n  private async updateMetricState(metric: TruthMetric): Promise<void> {\n    const key = `${metric.agentId}:${metric.metricType}`;\n    \n    let state = this.metricStates.get(key);\n    if (!state) {\n      state = {\n        key,\n        currentValue: metric.value,\n        previousValue: metric.value,\n        lastUpdate: metric.timestamp,\n        changeRate: 0,\n        samples: [metric.value],\n        thresholdViolations: new Map(),\n      };\n      this.metricStates.set(key, state);\n    } else {\n      // Update state\n      state.previousValue = state.currentValue;\n      state.currentValue = metric.value;\n      state.lastUpdate = metric.timestamp;\n      \n      // Calculate change rate (per hour)\n      const timeDiff = metric.timestamp.getTime() - state.lastUpdate.getTime();\n      if (timeDiff > 0) {\n        const valueDiff = metric.value - state.previousValue;\n        state.changeRate = (valueDiff / timeDiff) * (60 * 60 * 1000); // per hour\n      }\n      \n      // Update samples (keep last 100)\n      state.samples.push(metric.value);\n      if (state.samples.length > 100) {\n        state.samples = state.samples.slice(-100);\n      }\n    }\n  }\n  \n  private getApplicableRules(metric: TruthMetric): AlertRule[] {\n    return Array.from(this.alertRules.values()).filter(rule => {\n      if (!rule.enabled) return false;\n      \n      // Check if rule applies to this metric\n      if (rule.metric !== metric.metricType && rule.metric !== '*') return false;\n      \n      // Check filters\n      if (!this.matchesFilters(metric, rule.filters)) return false;\n      \n      // Check conditions\n      if (!this.matchesConditions(metric, rule.conditions)) return false;\n      \n      return true;\n    });\n  }\n  \n  private async evaluateRule(rule: AlertRule, metric: TruthMetric): Promise<void> {\n    const key = `${metric.agentId}:${metric.metricType}`;\n    const state = this.metricStates.get(key);\n    \n    if (!state) return;\n    \n    // Evaluate threshold condition\n    const conditionMet = this.evaluateCondition(rule, metric, state);\n    \n    if (conditionMet) {\n      await this.handleThresholdViolation(rule, metric, state);\n    } else {\n      await this.handleThresholdClearance(rule, metric, state);\n    }\n  }\n  \n  private evaluateCondition(rule: AlertRule, metric: TruthMetric, state: MetricState): boolean {\n    const value = metric.value;\n    const threshold = rule.threshold;\n    \n    switch (rule.operator) {\n      case 'gt': return value > threshold;\n      case 'gte': return value >= threshold;\n      case 'lt': return value < threshold;\n      case 'lte': return value <= threshold;\n      case 'eq': return value === threshold;\n      case 'ne': return value !== threshold;\n      case 'change': return Math.abs(value - state.previousValue) > threshold;\n      case 'rate': return Math.abs(state.changeRate) > threshold;\n      default: return false;\n    }\n  }\n  \n  private async handleThresholdViolation(\n    rule: AlertRule,\n    metric: TruthMetric,\n    state: MetricState\n  ): Promise<void> {\n    const violationKey = `${rule.id}:${state.key}`;\n    let violation = state.thresholdViolations.get(violationKey);\n    \n    if (!violation) {\n      // New violation\n      violation = {\n        ruleId: rule.id,\n        startTime: metric.timestamp,\n        lastSeen: metric.timestamp,\n        count: 1,\n        alertId: null,\n      };\n      state.thresholdViolations.set(violationKey, violation);\n    } else {\n      // Existing violation\n      violation.lastSeen = metric.timestamp;\n      violation.count++;\n    }\n    \n    // Check if violation has persisted long enough\n    const duration = metric.timestamp.getTime() - violation.startTime.getTime();\n    \n    if (duration >= rule.duration && !violation.alertId) {\n      // Create alert\n      const alertId = await this.createAlert(rule, metric, violation);\n      violation.alertId = alertId;\n    }\n  }\n  \n  private async handleThresholdClearance(\n    rule: AlertRule,\n    metric: TruthMetric,\n    state: MetricState\n  ): Promise<void> {\n    const violationKey = `${rule.id}:${state.key}`;\n    const violation = state.thresholdViolations.get(violationKey);\n    \n    if (violation && violation.alertId) {\n      // Resolve the alert\n      await this.resolveAlert(violation.alertId, 'threshold_cleared');\n    }\n    \n    // Clear violation\n    state.thresholdViolations.delete(violationKey);\n  }\n  \n  private async createAlert(\n    rule: AlertRule,\n    metric: TruthMetric,\n    violation: ThresholdViolation\n  ): Promise<string> {\n    const alertId = `alert-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    \n    const alert: TruthAlert = {\n      id: alertId,\n      timestamp: new Date(),\n      severity: rule.severity,\n      type: rule.category,\n      message: this.generateAlertMessage(rule, metric),\n      source: `agent:${metric.agentId}`,\n      context: {\n        ruleId: rule.id,\n        ruleName: rule.name,\n        metricType: metric.metricType,\n        metricValue: metric.value,\n        threshold: rule.threshold,\n        operator: rule.operator,\n        duration: violation.lastSeen.getTime() - violation.startTime.getTime(),\n        violationCount: violation.count,\n        agentId: metric.agentId,\n        taskId: metric.taskId,\n        ...metric.context,\n      },\n      thresholds: [\n        {\n          metric: rule.metric,\n          operator: rule.operator,\n          value: rule.threshold,\n          duration: rule.duration,\n          severity: rule.severity,\n        },\n      ],\n      actions: [...rule.actions],\n      escalationPath: [...rule.escalationPath],\n      resolved: false,\n    };\n    \n    this.activeAlerts.set(alertId, alert);\n    \n    // Update statistics\n    this.statistics.totalAlerts++;\n    this.statistics.activeAlerts++;\n    this.statistics.alertsByType[alert.type] = (this.statistics.alertsByType[alert.type] || 0) + 1;\n    this.statistics.alertsBySeverity[alert.severity] = (this.statistics.alertsBySeverity[alert.severity] || 0) + 1;\n    \n    // Log alert creation\n    this.logger.warn('Truth alert created', {\n      alertId,\n      rule: rule.name,\n      metric: metric.metricType,\n      value: metric.value,\n      threshold: rule.threshold,\n      agent: metric.agentId,\n    });\n    \n    // Add to history\n    this.addToHistory(alertId, 'created', 'system', { rule: rule.name });\n    \n    // Emit event\n    this.eventBus.emit('truth-alert:created', { alert, rule, metric });\n    \n    // Execute alert actions\n    await this.executeAlertActions(alert);\n    \n    return alertId;\n  }\n  \n  async executeAlertActions(alert: TruthAlert): Promise<void> {\n    for (const action of alert.actions) {\n      if (!action.enabled) continue;\n      \n      try {\n        await this.executeAction(alert, action);\n      } catch (error) {\n        this.logger.error('Failed to execute alert action', {\n          alertId: alert.id,\n          actionType: action.type,\n          error,\n        });\n      }\n    }\n  }\n  \n  private async executeAction(alert: TruthAlert, action: AlertAction): Promise<void> {\n    switch (action.type) {\n      case 'notify':\n        await this.sendNotification(alert, action);\n        break;\n      \n      case 'escalate':\n        await this.escalateAlert(alert, action);\n        break;\n      \n      case 'auto-remediate':\n        await this.autoRemediate(alert, action);\n        break;\n      \n      case 'suspend':\n        await this.suspendAgent(alert, action);\n        break;\n      \n      case 'restart':\n        await this.restartAgent(alert, action);\n        break;\n      \n      default:\n        this.logger.warn('Unknown alert action type', { type: action.type });\n    }\n  }\n  \n  // ========================================================================================\n  // Notification System\n  // ========================================================================================\n  \n  private async sendNotification(alert: TruthAlert, action: AlertAction): Promise<void> {\n    const channelIds = action.config.channels || ['default'];\n    \n    for (const channelId of channelIds) {\n      const channel = this.alertChannels.get(channelId);\n      if (!channel || !channel.enabled) continue;\n      \n      // Check filters\n      if (!this.alertMatchesChannelFilters(alert, channel)) continue;\n      \n      // Check rate limits\n      if (!this.checkRateLimit(channel, alert)) continue;\n      \n      await this.sendToChannel(alert, channel);\n    }\n  }\n  \n  private async sendToChannel(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    try {\n      switch (channel.type) {\n        case 'email':\n          await this.sendEmailNotification(alert, channel);\n          break;\n        \n        case 'slack':\n          await this.sendSlackNotification(alert, channel);\n          break;\n        \n        case 'webhook':\n          await this.sendWebhookNotification(alert, channel);\n          break;\n        \n        case 'teams':\n          await this.sendTeamsNotification(alert, channel);\n          break;\n        \n        case 'discord':\n          await this.sendDiscordNotification(alert, channel);\n          break;\n        \n        case 'pagerduty':\n          await this.sendPagerDutyNotification(alert, channel);\n          break;\n        \n        default:\n          this.logger.warn('Unknown channel type', { type: channel.type });\n      }\n      \n      this.logger.info('Alert notification sent', {\n        alertId: alert.id,\n        channel: channel.name,\n        type: channel.type,\n      });\n      \n    } catch (error) {\n      this.logger.error('Failed to send notification', {\n        alertId: alert.id,\n        channel: channel.name,\n        error,\n      });\n    }\n  }\n  \n  // ========================================================================================\n  // Escalation Management\n  // ========================================================================================\n  \n  private async escalateAlert(alert: TruthAlert, action: AlertAction): Promise<void> {\n    const escalationLevel = action.config.level || 1;\n    \n    if (escalationLevel <= alert.escalationLevel) return; // Already escalated\n    \n    alert.escalationLevel = escalationLevel;\n    \n    // Find escalation configuration\n    const escalation = alert.escalationPath.find(e => e.level === escalationLevel);\n    if (!escalation) return;\n    \n    // Check escalation conditions\n    if (!this.checkEscalationConditions(alert, escalation)) return;\n    \n    // Update alert severity if needed\n    if (escalationLevel > 1) {\n      alert.severity = this.getEscalatedSeverity(alert.severity);\n    }\n    \n    // Send escalation notifications\n    await this.sendEscalationNotifications(alert, escalation);\n    \n    // Add to history\n    this.addToHistory(alert.id, 'escalated', 'system', {\n      level: escalationLevel,\n      targets: escalation.targets,\n    });\n    \n    // Update statistics\n    this.statistics.escalationRate = this.calculateEscalationRate();\n    \n    this.logger.warn('Alert escalated', {\n      alertId: alert.id,\n      level: escalationLevel,\n      severity: alert.severity,\n    });\n    \n    this.eventBus.emit('truth-alert:escalated', { alert, escalationLevel });\n  }\n  \n  private async sendEscalationNotifications(\n    alert: TruthAlert,\n    escalation: EscalationLevel\n  ): Promise<void> {\n    for (const target of escalation.targets) {\n      const channel = this.alertChannels.get(target);\n      if (channel && channel.enabled) {\n        await this.sendToChannel(alert, channel);\n      }\n    }\n  }\n  \n  // ========================================================================================\n  // Auto-Remediation\n  // ========================================================================================\n  \n  private async autoRemediate(alert: TruthAlert, action: AlertAction): Promise<void> {\n    const remediationType = action.config.type;\n    \n    try {\n      switch (remediationType) {\n        case 'restart_agent':\n          await this.restartAgent(alert, action);\n          break;\n        \n        case 'scale_resources':\n          await this.scaleResources(alert, action);\n          break;\n        \n        case 'adjust_thresholds':\n          await this.adjustThresholds(alert, action);\n          break;\n        \n        case 'redistribute_load':\n          await this.redistributeLoad(alert, action);\n          break;\n        \n        case 'failover':\n          await this.initiateFailover(alert, action);\n          break;\n        \n        default:\n          this.logger.warn('Unknown remediation type', { type: remediationType });\n      }\n      \n      this.logger.info('Auto-remediation executed', {\n        alertId: alert.id,\n        type: remediationType,\n      });\n      \n    } catch (error) {\n      this.logger.error('Auto-remediation failed', {\n        alertId: alert.id,\n        type: remediationType,\n        error,\n      });\n    }\n  }\n  \n  private async restartAgent(alert: TruthAlert, action: AlertAction): Promise<void> {\n    const agentId = alert.context.agentId;\n    if (!agentId) return;\n    \n    this.eventBus.emit('agent:restart-requested', {\n      agentId,\n      reason: 'automated_remediation',\n      alertId: alert.id,\n    });\n  }\n  \n  private async suspendAgent(alert: TruthAlert, action: AlertAction): Promise<void> {\n    const agentId = alert.context.agentId;\n    if (!agentId) return;\n    \n    this.eventBus.emit('agent:suspend-requested', {\n      agentId,\n      duration: action.config.duration || 300000, // 5 minutes default\n      reason: 'automated_remediation',\n      alertId: alert.id,\n    });\n  }\n  \n  private async scaleResources(alert: TruthAlert, action: AlertAction): Promise<void> {\n    this.eventBus.emit('system:scale-requested', {\n      direction: action.config.direction || 'up',\n      factor: action.config.factor || 1.5,\n      reason: 'automated_remediation',\n      alertId: alert.id,\n    });\n  }\n  \n  private async adjustThresholds(alert: TruthAlert, action: AlertAction): Promise<void> {\n    const ruleId = alert.context.ruleId;\n    const rule = this.alertRules.get(ruleId);\n    \n    if (rule) {\n      const adjustment = action.config.adjustment || 0.1;\n      rule.threshold = rule.threshold + (rule.threshold * adjustment);\n      \n      this.logger.info('Alert threshold adjusted', {\n        ruleId,\n        oldThreshold: rule.threshold - (rule.threshold * adjustment),\n        newThreshold: rule.threshold,\n      });\n    }\n  }\n  \n  private async redistributeLoad(alert: TruthAlert, action: AlertAction): Promise<void> {\n    this.eventBus.emit('load-balancer:redistribute', {\n      reason: 'automated_remediation',\n      alertId: alert.id,\n      excludeAgents: [alert.context.agentId],\n    });\n  }\n  \n  private async initiateFailover(alert: TruthAlert, action: AlertAction): Promise<void> {\n    this.eventBus.emit('system:failover-requested', {\n      primaryAgent: alert.context.agentId,\n      reason: 'automated_remediation',\n      alertId: alert.id,\n    });\n  }\n  \n  // ========================================================================================\n  // Alert Resolution\n  // ========================================================================================\n  \n  async resolveAlert(alertId: string, reason: string, resolvedBy?: string): Promise<boolean> {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert || alert.resolved) return false;\n    \n    alert.resolved = true;\n    alert.resolvedAt = new Date();\n    alert.resolvedBy = resolvedBy || 'system';\n    alert.context.resolutionReason = reason;\n    \n    // Update statistics\n    this.statistics.activeAlerts--;\n    this.statistics.resolvedAlerts++;\n    \n    // Calculate resolution time\n    const resolutionTime = alert.resolvedAt.getTime() - alert.timestamp.getTime();\n    this.updateAverageResolutionTime(resolutionTime);\n    \n    // Add to history\n    this.addToHistory(alertId, 'resolved', resolvedBy || 'system', { reason });\n    \n    this.logger.info('Alert resolved', {\n      alertId,\n      reason,\n      resolvedBy: resolvedBy || 'system',\n      duration: resolutionTime,\n    });\n    \n    this.eventBus.emit('truth-alert:resolved', { alert, reason, resolvedBy });\n    \n    return true;\n  }\n  \n  async acknowledgeAlert(alertId: string, acknowledgedBy: string, comment?: string): Promise<boolean> {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert || alert.resolved) return false;\n    \n    alert.acknowledged = true;\n    alert.acknowledgedAt = new Date();\n    alert.acknowledgedBy = acknowledgedBy;\n    \n    if (comment) {\n      alert.context.acknowledgmentComment = comment;\n    }\n    \n    // Add to history\n    this.addToHistory(alertId, 'acknowledged', acknowledgedBy, { comment });\n    \n    this.logger.info('Alert acknowledged', {\n      alertId,\n      acknowledgedBy,\n      comment,\n    });\n    \n    this.eventBus.emit('truth-alert:acknowledged', { alert, acknowledgedBy, comment });\n    \n    return true;\n  }\n  \n  // ========================================================================================\n  // Rule Management\n  // ========================================================================================\n  \n  createAlertRule(rule: Omit<AlertRule, 'id' | 'createdAt' | 'lastModified'>): string {\n    const ruleId = `rule-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    \n    const fullRule: AlertRule = {\n      ...rule,\n      id: ruleId,\n      createdAt: new Date(),\n      lastModified: new Date(),\n    };\n    \n    this.alertRules.set(ruleId, fullRule);\n    \n    this.logger.info('Alert rule created', {\n      ruleId,\n      name: rule.name,\n      metric: rule.metric,\n      threshold: rule.threshold,\n    });\n    \n    return ruleId;\n  }\n  \n  updateAlertRule(ruleId: string, updates: Partial<AlertRule>): boolean {\n    const rule = this.alertRules.get(ruleId);\n    if (!rule) return false;\n    \n    const updatedRule = {\n      ...rule,\n      ...updates,\n      id: ruleId, // Prevent ID changes\n      lastModified: new Date(),\n    };\n    \n    this.alertRules.set(ruleId, updatedRule);\n    \n    this.logger.info('Alert rule updated', { ruleId, updates });\n    \n    return true;\n  }\n  \n  deleteAlertRule(ruleId: string): boolean {\n    const deleted = this.alertRules.delete(ruleId);\n    \n    if (deleted) {\n      this.logger.info('Alert rule deleted', { ruleId });\n    }\n    \n    return deleted;\n  }\n  \n  // ========================================================================================\n  // Processing Loops\n  // ========================================================================================\n  \n  private startAlertProcessing(): void {\n    this.processingInterval = setInterval(() => {\n      this.processActiveAlerts();\n    }, 30000); // Every 30 seconds\n    \n    this.logger.info('Started alert processing');\n  }\n  \n  private startEscalationProcessing(): void {\n    this.escalationInterval = setInterval(() => {\n      this.processEscalations();\n    }, 60000); // Every minute\n    \n    this.logger.info('Started escalation processing');\n  }\n  \n  private startCleanupProcessing(): void {\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupResolvedAlerts();\n      this.cleanupOldHistory();\n      this.resetRateLimits();\n    }, 300000); // Every 5 minutes\n    \n    this.logger.info('Started cleanup processing');\n  }\n  \n  async processAlert(alert: TruthAlert): Promise<void> {\n    // Check for auto-resolution conditions\n    await this.checkAutoResolution(alert);\n    \n    // Check for escalation conditions\n    await this.checkEscalation(alert);\n    \n    // Update alert statistics\n    this.updateAlertStatistics(alert);\n  }\n  \n  private async processActiveAlerts(): Promise<void> {\n    for (const alert of this.activeAlerts.values()) {\n      if (!alert.resolved) {\n        await this.processAlert(alert);\n      }\n    }\n  }\n  \n  private async processEscalations(): Promise<void> {\n    for (const alert of this.activeAlerts.values()) {\n      if (!alert.resolved && !alert.acknowledged) {\n        await this.checkEscalation(alert);\n      }\n    }\n  }\n  \n  private async checkAutoResolution(alert: TruthAlert): Promise<void> {\n    // Check if the underlying condition has been resolved\n    const currentValue = await this.getCurrentMetricValue(alert);\n    if (currentValue === null) return;\n    \n    const rule = this.alertRules.get(alert.context.ruleId);\n    if (!rule) return;\n    \n    // Check if condition is no longer met\n    const conditionMet = this.evaluateConditionValue(rule, currentValue);\n    \n    if (!conditionMet) {\n      await this.resolveAlert(alert.id, 'condition_resolved');\n    }\n  }\n  \n  private async checkEscalation(alert: TruthAlert): Promise<void> {\n    const now = Date.now();\n    const alertAge = now - alert.timestamp.getTime();\n    \n    // Find next escalation level\n    const nextEscalation = alert.escalationPath.find(\n      e => e.level > alert.escalationLevel\n    );\n    \n    if (nextEscalation && alertAge >= nextEscalation.delay) {\n      await this.escalateAlert(alert, {\n        type: 'escalate',\n        target: 'escalation',\n        config: { level: nextEscalation.level },\n        enabled: true,\n      });\n    }\n  }\n  \n  // ========================================================================================\n  // Utility Methods\n  // ========================================================================================\n  \n  private generateAlertMessage(rule: AlertRule, metric: TruthMetric): string {\n    return `${rule.name}: ${metric.metricType} ${rule.operator} ${rule.threshold} ` +\n           `(current: ${metric.value.toFixed(3)}) for agent ${metric.agentId}`;\n  }\n  \n  private matchesFilters(metric: TruthMetric, filters: Record<string, any>): boolean {\n    for (const [key, value] of Object.entries(filters)) {\n      const metricValue = this.getMetricProperty(metric, key);\n      if (metricValue !== value) return false;\n    }\n    return true;\n  }\n  \n  private matchesConditions(metric: TruthMetric, conditions: AlertCondition[]): boolean {\n    if (conditions.length === 0) return true;\n    \n    // Simple AND/OR logic evaluation\n    let result = true;\n    let currentOperator = 'AND';\n    \n    for (const condition of conditions) {\n      const metricValue = this.getMetricProperty(metric, condition.field);\n      const conditionResult = this.evaluateConditionValue(condition, metricValue);\n      \n      if (currentOperator === 'AND') {\n        result = result && conditionResult;\n      } else {\n        result = result || conditionResult;\n      }\n      \n      currentOperator = condition.logicalOperator || 'AND';\n    }\n    \n    return result;\n  }\n  \n  private getMetricProperty(metric: TruthMetric, path: string): any {\n    const parts = path.split('.');\n    let value: any = metric;\n    \n    for (const part of parts) {\n      value = value?.[part];\n    }\n    \n    return value;\n  }\n  \n  private evaluateConditionValue(condition: any, value: any): boolean {\n    switch (condition.operator) {\n      case 'gt': return value > condition.value;\n      case 'gte': return value >= condition.value;\n      case 'lt': return value < condition.value;\n      case 'lte': return value <= condition.value;\n      case 'eq': return value === condition.value;\n      case 'ne': return value !== condition.value;\n      case 'contains': return String(value).includes(condition.value);\n      case 'startsWith': return String(value).startsWith(condition.value);\n      case 'endsWith': return String(value).endsWith(condition.value);\n      default: return false;\n    }\n  }\n  \n  private alertMatchesChannelFilters(alert: TruthAlert, channel: AlertChannel): boolean {\n    for (const filter of channel.filters) {\n      const alertValue = this.getMetricProperty(alert, filter.field);\n      const matches = filter.values.includes(String(alertValue));\n      \n      if (filter.action === 'include' && !matches) return false;\n      if (filter.action === 'exclude' && matches) return false;\n    }\n    return true;\n  }\n  \n  private checkRateLimit(channel: AlertChannel, alert: TruthAlert): boolean {\n    for (const rateLimit of channel.rateLimits) {\n      const now = Date.now();\n      \n      // Reset if window has passed\n      if (rateLimit.resetTime && now > rateLimit.resetTime.getTime()) {\n        rateLimit.currentCount = 0;\n        rateLimit.resetTime = new Date(now + rateLimit.window);\n      }\n      \n      // Initialize if needed\n      if (!rateLimit.resetTime) {\n        rateLimit.resetTime = new Date(now + rateLimit.window);\n        rateLimit.currentCount = 0;\n      }\n      \n      // Check limit\n      if (rateLimit.currentCount >= rateLimit.maxAlerts) {\n        return false;\n      }\n      \n      // Increment counter\n      rateLimit.currentCount++;\n    }\n    \n    return true;\n  }\n  \n  private checkEscalationConditions(alert: TruthAlert, escalation: EscalationLevel): boolean {\n    // Simple condition evaluation\n    for (const condition of escalation.conditions) {\n      // This would typically parse and evaluate complex conditions\n      // For now, using simple checks\n      if (condition.includes('unacknowledged') && alert.acknowledged) return false;\n      if (condition.includes('duration') && !this.checkDurationCondition(alert, condition)) return false;\n    }\n    return true;\n  }\n  \n  private checkDurationCondition(alert: TruthAlert, condition: string): boolean {\n    // Parse condition like \"duration > 30m\"\n    const match = condition.match(/duration\\s*([><=]+)\\s*(\\d+)([mhs])/);\n    if (!match) return true;\n    \n    const operator = match[1];\n    const value = parseInt(match[2]);\n    const unit = match[3];\n    \n    const multiplier = unit === 's' ? 1000 : unit === 'm' ? 60000 : 3600000; // hours\n    const thresholdMs = value * multiplier;\n    const durationMs = Date.now() - alert.timestamp.getTime();\n    \n    switch (operator) {\n      case '>': return durationMs > thresholdMs;\n      case '>=': return durationMs >= thresholdMs;\n      case '<': return durationMs < thresholdMs;\n      case '<=': return durationMs <= thresholdMs;\n      case '=': return Math.abs(durationMs - thresholdMs) < 1000;\n      default: return true;\n    }\n  }\n  \n  private getEscalatedSeverity(currentSeverity: string): 'info' | 'warning' | 'critical' | 'emergency' {\n    switch (currentSeverity) {\n      case 'info': return 'warning';\n      case 'warning': return 'critical';\n      case 'critical': return 'emergency';\n      default: return 'emergency';\n    }\n  }\n  \n  private async getCurrentMetricValue(alert: TruthAlert): Promise<number | null> {\n    // This would typically query the current metric value\n    // For now, returning null to indicate unavailable\n    return null;\n  }\n  \n  private addToHistory(alertId: string, action: string, actor: string, details: Record<string, any>): void {\n    this.alertHistory.push({\n      alertId,\n      timestamp: new Date(),\n      action: action as any,\n      actor,\n      details,\n    });\n    \n    // Keep history size manageable\n    if (this.alertHistory.length > 10000) {\n      this.alertHistory = this.alertHistory.slice(-5000);\n    }\n  }\n  \n  private cleanupResolvedAlerts(): void {\n    const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 hours\n    \n    for (const [alertId, alert] of this.activeAlerts) {\n      if (alert.resolved && alert.resolvedAt && alert.resolvedAt < cutoff) {\n        this.activeAlerts.delete(alertId);\n      }\n    }\n  }\n  \n  private cleanupOldHistory(): void {\n    const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days\n    this.alertHistory = this.alertHistory.filter(h => h.timestamp >= cutoff);\n  }\n  \n  private resetRateLimits(): void {\n    const now = Date.now();\n    \n    for (const channel of this.alertChannels.values()) {\n      for (const rateLimit of channel.rateLimits) {\n        if (rateLimit.resetTime && now > rateLimit.resetTime.getTime()) {\n          rateLimit.currentCount = 0;\n          rateLimit.resetTime = new Date(now + rateLimit.window);\n        }\n      }\n    }\n  }\n  \n  private updateAlertStatistics(alert: TruthAlert): void {\n    // Update top alert sources\n    const source = alert.source;\n    const existing = this.statistics.topAlertSources.find(s => s.source === source);\n    if (existing) {\n      existing.count++;\n    } else {\n      this.statistics.topAlertSources.push({ source, count: 1 });\n    }\n    \n    // Sort and limit\n    this.statistics.topAlertSources.sort((a, b) => b.count - a.count);\n    this.statistics.topAlertSources = this.statistics.topAlertSources.slice(0, 10);\n  }\n  \n  private updateAverageResolutionTime(resolutionTime: number): void {\n    const count = this.statistics.resolvedAlerts;\n    const currentAvg = this.statistics.averageResolutionTime;\n    \n    this.statistics.averageResolutionTime = \n      ((currentAvg * (count - 1)) + resolutionTime) / count;\n  }\n  \n  private calculateEscalationRate(): number {\n    const escalatedAlerts = this.alertHistory.filter(h => h.action === 'escalated').length;\n    return this.statistics.totalAlerts > 0 ? escalatedAlerts / this.statistics.totalAlerts : 0;\n  }\n  \n  // ========================================================================================\n  // Notification Implementations (Placeholders)\n  // ========================================================================================\n  \n  private async sendEmailNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    // Implementation would send actual email\n    this.logger.info('Email notification sent', { alertId: alert.id, to: channel.config.to });\n  }\n  \n  private async sendSlackNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    // Implementation would send to Slack webhook\n    this.logger.info('Slack notification sent', { alertId: alert.id, webhook: channel.config.webhook });\n  }\n  \n  private async sendWebhookNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    // Implementation would POST to webhook URL\n    this.logger.info('Webhook notification sent', { alertId: alert.id, url: channel.config.url });\n  }\n  \n  private async sendTeamsNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    // Implementation would send to Teams webhook\n    this.logger.info('Teams notification sent', { alertId: alert.id, webhook: channel.config.webhook });\n  }\n  \n  private async sendDiscordNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    // Implementation would send to Discord webhook\n    this.logger.info('Discord notification sent', { alertId: alert.id, webhook: channel.config.webhook });\n  }\n  \n  private async sendPagerDutyNotification(alert: TruthAlert, channel: AlertChannel): Promise<void> {\n    // Implementation would create PagerDuty incident\n    this.logger.info('PagerDuty notification sent', { alertId: alert.id, serviceKey: channel.config.serviceKey });\n  }\n  \n  // ========================================================================================\n  // Configuration Management\n  // ========================================================================================\n  \n  private async loadAlertConfiguration(): Promise<void> {\n    // Placeholder for loading configuration from storage\n    this.logger.debug('Loading alert configuration');\n  }\n  \n  private async saveAlertConfiguration(): Promise<void> {\n    // Placeholder for saving configuration to storage\n    this.logger.debug('Saving alert configuration');\n  }\n  \n  private initializeDefaultRules(): void {\n    // Create default alert rules\n    const defaultRules: Omit<AlertRule, 'id' | 'createdAt' | 'lastModified'>[] = [\n      {\n        name: 'Low Truth Accuracy',\n        description: 'Alert when agent accuracy falls below threshold',\n        enabled: true,\n        metric: 'accuracy',\n        operator: 'lt',\n        threshold: this.config.alertThresholds.accuracyThreshold,\n        duration: 300000, // 5 minutes\n        severity: 'critical',\n        category: 'accuracy_degradation',\n        priority: 8,\n        filters: {},\n        conditions: [],\n        actions: [\n          { type: 'notify', target: 'default', config: { channels: ['default'] }, enabled: true },\n        ],\n        escalationPath: [\n          { level: 1, delay: 900000, targets: ['critical'], conditions: ['unacknowledged'] }, // 15 minutes\n        ],\n        suppressions: [],\n        tags: { category: 'accuracy', auto_created: 'true' },\n        createdBy: 'system',\n      },\n      {\n        name: 'High Human Intervention Rate',\n        description: 'Alert when human intervention rate exceeds threshold',\n        enabled: true,\n        metric: '*',\n        operator: 'gt',\n        threshold: this.config.alertThresholds.interventionRateThreshold,\n        duration: 600000, // 10 minutes\n        severity: 'warning',\n        category: 'high_intervention_rate',\n        priority: 6,\n        filters: { 'context.verificationMethod': 'human' },\n        conditions: [],\n        actions: [\n          { type: 'notify', target: 'default', config: { channels: ['default'] }, enabled: true },\n        ],\n        escalationPath: [],\n        suppressions: [],\n        tags: { category: 'efficiency', auto_created: 'true' },\n        createdBy: 'system',\n      },\n    ];\n    \n    defaultRules.forEach(rule => this.createAlertRule(rule));\n  }\n  \n  private initializeDefaultChannels(): void {\n    // Create default notification channels\n    const defaultChannels: Omit<AlertChannel, 'id'>[] = [\n      {\n        name: 'Default Log Channel',\n        type: 'email',\n        config: { to: 'admin@example.com' },\n        enabled: true,\n        filters: [],\n        rateLimits: [\n          { window: 300000, maxAlerts: 10, currentCount: 0 }, // 10 alerts per 5 minutes\n        ],\n      },\n      {\n        name: 'Critical Alerts',\n        type: 'slack',\n        config: { webhook: 'https://hooks.slack.com/services/...' },\n        enabled: false, // Disabled until configured\n        filters: [\n          { field: 'severity', operator: 'eq', values: ['critical', 'emergency'], action: 'include' },\n        ],\n        rateLimits: [\n          { window: 60000, maxAlerts: 5, currentCount: 0 }, // 5 alerts per minute\n        ],\n      },\n    ];\n    \n    defaultChannels.forEach(channel => {\n      const channelId = `channel-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      this.alertChannels.set(channelId, { ...channel, id: channelId });\n    });\n  }\n  \n  private initializeStatistics(): AlertStatistics {\n    return {\n      totalAlerts: 0,\n      activeAlerts: 0,\n      resolvedAlerts: 0,\n      averageResolutionTime: 0,\n      alertsByType: {},\n      alertsBySeverity: {},\n      topAlertSources: [],\n      escalationRate: 0,\n      falsePositiveRate: 0,\n    };\n  }\n  \n  // ========================================================================================\n  // Public API\n  // ========================================================================================\n  \n  getActiveAlerts(): TruthAlert[] {\n    return Array.from(this.activeAlerts.values()).filter(a => !a.resolved);\n  }\n  \n  getAlert(alertId: string): TruthAlert | undefined {\n    return this.activeAlerts.get(alertId);\n  }\n  \n  getAlertHistory(alertId?: string, limit: number = 100): AlertHistory[] {\n    let history = this.alertHistory;\n    \n    if (alertId) {\n      history = history.filter(h => h.alertId === alertId);\n    }\n    \n    return history.slice(-limit);\n  }\n  \n  getAlertRules(): AlertRule[] {\n    return Array.from(this.alertRules.values());\n  }\n  \n  getAlertChannels(): AlertChannel[] {\n    return Array.from(this.alertChannels.values());\n  }\n  \n  getStatistics(): AlertStatistics {\n    return { ...this.statistics };\n  }\n  \n  createSuppression(alertId: string, suppression: Omit<AlertSuppression, 'id'>): string {\n    const suppressionId = `suppression-${Date.now()}`;\n    this.suppressions.set(suppressionId, { ...suppression, id: suppressionId });\n    return suppressionId;\n  }\n  \n  removeSuppression(suppressionId: string): boolean {\n    return this.suppressions.delete(suppressionId);\n  }\n}\n\n// ========================================================================================\n// Supporting Interfaces\n// ========================================================================================\n\ninterface MetricState {\n  key: string;\n  currentValue: number;\n  previousValue: number;\n  lastUpdate: Date;\n  changeRate: number;\n  samples: number[];\n  thresholdViolations: Map<string, ThresholdViolation>;\n}\n\ninterface ThresholdViolation {\n  ruleId: string;\n  startTime: Date;\n  lastSeen: Date;\n  count: number;\n  alertId: string | null;\n}"],"names":["TruthAlertManager","config","logger","eventBus","alertRules","Map","activeAlerts","alertHistory","alertChannels","suppressions","thresholdGroups","metricStates","processingInterval","escalationInterval","cleanupInterval","statistics","initializeStatistics","initializeDefaultRules","initializeDefaultChannels","initialize","info","alertEnabled","thresholds","alertThresholds","startAlertProcessing","startEscalationProcessing","startCleanupProcessing","loadAlertConfiguration","rules","size","channels","shutdown","clearInterval","saveAlertConfiguration","checkThresholds","metric","updateMetricState","applicableRules","getApplicableRules","rule","evaluateRule","error","metricId","id","key","agentId","metricType","state","get","currentValue","value","previousValue","lastUpdate","timestamp","changeRate","samples","thresholdViolations","set","timeDiff","getTime","valueDiff","push","length","slice","Array","from","values","filter","enabled","matchesFilters","filters","matchesConditions","conditions","conditionMet","evaluateCondition","handleThresholdViolation","handleThresholdClearance","threshold","operator","Math","abs","violationKey","violation","ruleId","startTime","lastSeen","count","alertId","duration","createAlert","resolveAlert","delete","Date","now","random","toString","alert","severity","type","category","message","generateAlertMessage","source","context","ruleName","name","metricValue","violationCount","taskId","actions","escalationPath","resolved","totalAlerts","alertsByType","alertsBySeverity","warn","agent","addToHistory","emit","executeAlertActions","action","executeAction","actionType","sendNotification","escalateAlert","autoRemediate","suspendAgent","restartAgent","channelIds","channelId","channel","alertMatchesChannelFilters","checkRateLimit","sendToChannel","sendEmailNotification","sendSlackNotification","sendWebhookNotification","sendTeamsNotification","sendDiscordNotification","sendPagerDutyNotification","escalationLevel","level","escalation","find","e","checkEscalationConditions","getEscalatedSeverity","sendEscalationNotifications","targets","escalationRate","calculateEscalationRate","target","remediationType","scaleResources","adjustThresholds","redistributeLoad","initiateFailover","reason","direction","factor","adjustment","oldThreshold","newThreshold","excludeAgents","primaryAgent","resolvedBy","resolvedAt","resolutionReason","resolvedAlerts","resolutionTime","updateAverageResolutionTime","acknowledgeAlert","acknowledgedBy","comment","acknowledged","acknowledgedAt","acknowledgmentComment","createAlertRule","fullRule","createdAt","lastModified","updateAlertRule","updates","updatedRule","deleteAlertRule","deleted","setInterval","processActiveAlerts","processEscalations","cleanupResolvedAlerts","cleanupOldHistory","resetRateLimits","processAlert","checkAutoResolution","checkEscalation","updateAlertStatistics","getCurrentMetricValue","evaluateConditionValue","alertAge","nextEscalation","delay","toFixed","Object","entries","getMetricProperty","result","currentOperator","condition","field","conditionResult","logicalOperator","path","parts","split","part","String","includes","startsWith","endsWith","alertValue","matches","rateLimit","rateLimits","resetTime","currentCount","window","maxAlerts","checkDurationCondition","match","parseInt","unit","multiplier","thresholdMs","durationMs","currentSeverity","actor","details","cutoff","h","existing","topAlertSources","s","sort","a","b","currentAvg","averageResolutionTime","escalatedAlerts","to","webhook","url","serviceKey","debug","defaultRules","description","accuracyThreshold","priority","tags","auto_created","createdBy","interventionRateThreshold","forEach","defaultChannels","falsePositiveRate","getActiveAlerts","getAlert","getAlertHistory","limit","history","getAlertRules","getAlertChannels","getStatistics","createSuppression","suppression","suppressionId","removeSuppression"],"mappings":"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"}