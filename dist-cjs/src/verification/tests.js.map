{"version":3,"sources":["../../../src/verification/tests.ts"],"sourcesContent":["/**\n * Security Testing Framework\n * \n * Comprehensive testing utilities for security enforcement system\n * including penetration testing, load testing, and security validation.\n */\n\nimport { EventEmitter } from 'events';\nimport { SecurityEnforcementSystem, VerificationRequest, VerificationResult } from './security';\nimport { SecurityMiddlewareManager, ThreatIntelligenceMiddleware } from './middleware';\nimport { SecurityAlert, AttackPattern, ThreatLevel } from './types';\n\n// ======================== TEST UTILITIES ========================\n\nexport class SecurityTestUtils {\n  // Generate mock verification request\n  static createMockVerificationRequest(overrides: Partial<VerificationRequest> = {}): VerificationRequest {\n    const crypto = require('crypto');\n    \n    return {\n      requestId: crypto.randomBytes(16).toString('hex'),\n      agentId: 'test-agent-1',\n      truthClaim: { statement: 'Test truth claim', confidence: 0.9 },\n      timestamp: new Date(),\n      nonce: crypto.randomBytes(32).toString('hex'),\n      signature: 'mock-signature',\n      ...overrides\n    };\n  }\n\n  // Generate multiple mock requests\n  static createMockVerificationRequests(count: number, baseRequest?: Partial<VerificationRequest>): VerificationRequest[] {\n    return Array.from({ length: count }, (_, i) => \n      this.createMockVerificationRequest({\n        ...baseRequest,\n        requestId: `test-request-${i}`,\n        agentId: `test-agent-${i % 5}`, // Cycle through 5 agents\n      })\n    );\n  }\n\n  // Create malicious request patterns\n  static createMaliciousRequests(): {\n    byzantineRequests: VerificationRequest[];\n    spamRequests: VerificationRequest[];\n    replayAttacks: VerificationRequest[];\n    oversizedRequests: VerificationRequest[];\n  } {\n    const baseTime = new Date();\n    \n    return {\n      // Byzantine attack - contradictory claims from same agent\n      byzantineRequests: [\n        this.createMockVerificationRequest({\n          agentId: 'byzantine-agent',\n          truthClaim: { statement: 'The sky is blue', confidence: 1.0 },\n          timestamp: baseTime\n        }),\n        this.createMockVerificationRequest({\n          agentId: 'byzantine-agent',\n          truthClaim: { statement: 'The sky is red', confidence: 1.0 },\n          timestamp: new Date(baseTime.getTime() + 1000)\n        })\n      ],\n      \n      // Spam attack - rapid requests\n      spamRequests: Array.from({ length: 100 }, (_, i) =>\n        this.createMockVerificationRequest({\n          agentId: 'spam-agent',\n          timestamp: new Date(baseTime.getTime() + i * 10) // 10ms apart\n        })\n      ),\n      \n      // Replay attack - same request multiple times\n      replayAttacks: (() => {\n        const originalRequest = this.createMockVerificationRequest({\n          agentId: 'replay-attacker',\n          timestamp: baseTime\n        });\n        return Array.from({ length: 5 }, () => ({ ...originalRequest }));\n      })(),\n      \n      // Oversized payload attack\n      oversizedRequests: [\n        this.createMockVerificationRequest({\n          agentId: 'oversized-agent',\n          truthClaim: {\n            statement: 'A'.repeat(50000), // Very large payload\n            confidence: 0.5\n          }\n        })\n      ]\n    };\n  }\n\n  // Measure performance metrics\n  static async measurePerformance<T>(\n    operation: () => Promise<T>,\n    iterations: number = 100\n  ): Promise<{\n    averageTime: number;\n    minTime: number;\n    maxTime: number;\n    totalTime: number;\n    successCount: number;\n    errorCount: number;\n    throughput: number;\n  }> {\n    const times: number[] = [];\n    let successCount = 0;\n    let errorCount = 0;\n    const startTime = Date.now();\n\n    for (let i = 0; i < iterations; i++) {\n      const operationStart = Date.now();\n      \n      try {\n        await operation();\n        const operationTime = Date.now() - operationStart;\n        times.push(operationTime);\n        successCount++;\n      } catch (error) {\n        errorCount++;\n      }\n    }\n\n    const totalTime = Date.now() - startTime;\n    const averageTime = times.length > 0 ? times.reduce((sum, time) => sum + time, 0) / times.length : 0;\n    const minTime = times.length > 0 ? Math.min(...times) : 0;\n    const maxTime = times.length > 0 ? Math.max(...times) : 0;\n    const throughput = iterations / (totalTime / 1000); // requests per second\n\n    return {\n      averageTime,\n      minTime,\n      maxTime,\n      totalTime,\n      successCount,\n      errorCount,\n      throughput\n    };\n  }\n}\n\n// ======================== PENETRATION TESTING FRAMEWORK ========================\n\nexport class PenetrationTestingSuite {\n  private security: SecurityEnforcementSystem;\n  private testResults: Map<string, any> = new Map();\n  private vulnerabilities: string[] = [];\n\n  constructor(security: SecurityEnforcementSystem) {\n    this.security = security;\n  }\n\n  // Run comprehensive penetration test\n  async runFullPenetrationTest(): Promise<{\n    testResults: Map<string, any>;\n    vulnerabilities: string[];\n    securityScore: number;\n    recommendations: string[];\n  }> {\n    console.log('Starting comprehensive penetration test...');\n\n    // Authentication bypass tests\n    await this.testAuthenticationBypass();\n    \n    // Rate limiting bypass tests\n    await this.testRateLimitBypass();\n    \n    // Byzantine attack tests\n    await this.testByzantineAttacks();\n    \n    // Cryptographic security tests\n    await this.testCryptographicSecurity();\n    \n    // Audit trail tampering tests\n    await this.testAuditTrailSecurity();\n    \n    // DoS attack tests\n    await this.testDoSResistance();\n\n    // Calculate security score\n    const securityScore = this.calculateSecurityScore();\n    const recommendations = this.generateRecommendations();\n\n    return {\n      testResults: this.testResults,\n      vulnerabilities: this.vulnerabilities,\n      securityScore,\n      recommendations\n    };\n  }\n\n  // Test authentication bypass attempts\n  private async testAuthenticationBypass(): Promise<void> {\n    console.log('Testing authentication bypass...');\n    \n    const tests = [\n      {\n        name: 'Invalid Agent ID',\n        test: () => this.security.processVerificationRequest(\n          SecurityTestUtils.createMockVerificationRequest({ agentId: 'non-existent-agent' })\n        )\n      },\n      {\n        name: 'Missing Signature',\n        test: () => this.security.processVerificationRequest(\n          SecurityTestUtils.createMockVerificationRequest({ signature: undefined })\n        )\n      },\n      {\n        name: 'Invalid Signature',\n        test: () => this.security.processVerificationRequest(\n          SecurityTestUtils.createMockVerificationRequest({ signature: 'invalid-signature' })\n        )\n      },\n      {\n        name: 'Expired Timestamp',\n        test: () => this.security.processVerificationRequest(\n          SecurityTestUtils.createMockVerificationRequest({ \n            timestamp: new Date(Date.now() - 10 * 60 * 1000) // 10 minutes ago\n          })\n        )\n      }\n    ];\n\n    const results = [];\n    for (const test of tests) {\n      try {\n        await test.test();\n        this.vulnerabilities.push(`Authentication bypass possible: ${test.name}`);\n        results.push({ name: test.name, passed: false, error: 'No error thrown' });\n      } catch (error) {\n        results.push({ name: test.name, passed: true, error: error.message });\n      }\n    }\n\n    this.testResults.set('authenticationBypass', results);\n  }\n\n  // Test rate limiting bypass\n  private async testRateLimitBypass(): Promise<void> {\n    console.log('Testing rate limiting bypass...');\n    \n    // Register test agent first\n    try {\n      await this.security.registerAgent('rate-limit-test-agent', ['verify'], 'MEDIUM');\n    } catch (error) {\n      // Agent might already exist\n    }\n\n    // Test rapid requests\n    const rapidRequests = SecurityTestUtils.createMockVerificationRequests(50, {\n      agentId: 'rate-limit-test-agent'\n    });\n\n    let successCount = 0;\n    let rateLimitedCount = 0;\n\n    for (const request of rapidRequests) {\n      try {\n        await this.security.processVerificationRequest(request);\n        successCount++;\n      } catch (error) {\n        if (error.message.includes('rate limit') || error.message.includes('Rate limit')) {\n          rateLimitedCount++;\n        }\n      }\n    }\n\n    const rateLimitEffective = rateLimitedCount > 0;\n    if (!rateLimitEffective) {\n      this.vulnerabilities.push('Rate limiting appears ineffective');\n    }\n\n    this.testResults.set('rateLimitBypass', {\n      totalRequests: rapidRequests.length,\n      successCount,\n      rateLimitedCount,\n      effective: rateLimitEffective\n    });\n  }\n\n  // Test Byzantine attack detection\n  private async testByzantineAttacks(): Promise<void> {\n    console.log('Testing Byzantine attack detection...');\n    \n    const maliciousRequests = SecurityTestUtils.createMaliciousRequests();\n    const results: any = {};\n\n    // Test Byzantine behavior detection\n    try {\n      await this.security.registerAgent('byzantine-test-agent', ['verify'], 'MEDIUM');\n    } catch (error) {\n      // Agent might already exist\n    }\n\n    let byzantineDetected = false;\n    for (const request of maliciousRequests.byzantineRequests) {\n      try {\n        await this.security.processVerificationRequest(request);\n      } catch (error) {\n        if (error.message.includes('Byzantine') || error.message.includes('byzantine')) {\n          byzantineDetected = true;\n        }\n      }\n    }\n\n    results.byzantineDetection = {\n      detected: byzantineDetected,\n      requestCount: maliciousRequests.byzantineRequests.length\n    };\n\n    if (!byzantineDetected) {\n      this.vulnerabilities.push('Byzantine behavior not detected');\n    }\n\n    this.testResults.set('byzantineAttacks', results);\n  }\n\n  // Test cryptographic security\n  private async testCryptographicSecurity(): Promise<void> {\n    console.log('Testing cryptographic security...');\n    \n    // Test signature verification with tampered data\n    const originalRequest = SecurityTestUtils.createMockVerificationRequest();\n    const tamperedRequest = {\n      ...originalRequest,\n      truthClaim: { statement: 'Tampered claim', confidence: 0.1 }\n    };\n\n    let signatureVerificationWorking = false;\n    try {\n      await this.security.processVerificationRequest(tamperedRequest);\n    } catch (error) {\n      if (error.message.includes('signature') || error.message.includes('Invalid')) {\n        signatureVerificationWorking = true;\n      }\n    }\n\n    if (!signatureVerificationWorking) {\n      this.vulnerabilities.push('Signature verification may be compromised');\n    }\n\n    this.testResults.set('cryptographicSecurity', {\n      signatureVerification: signatureVerificationWorking\n    });\n  }\n\n  // Test audit trail security\n  private async testAuditTrailSecurity(): Promise<void> {\n    console.log('Testing audit trail security...');\n    \n    // This would test audit trail tampering resistance\n    // For now, we'll check if audit trails are being created\n    const securityStatus = this.security.getSecurityStatus();\n    const auditTrailWorking = securityStatus.auditSummary.integrityValid;\n\n    if (!auditTrailWorking) {\n      this.vulnerabilities.push('Audit trail integrity compromised');\n    }\n\n    this.testResults.set('auditTrailSecurity', {\n      integrityValid: auditTrailWorking,\n      totalEntries: securityStatus.auditSummary.totalEntries\n    });\n  }\n\n  // Test DoS resistance\n  private async testDoSResistance(): Promise<void> {\n    console.log('Testing DoS resistance...');\n    \n    const maliciousRequests = SecurityTestUtils.createMaliciousRequests();\n    \n    // Test with oversized requests\n    let dosResistant = false;\n    for (const request of maliciousRequests.oversizedRequests) {\n      try {\n        await this.security.processVerificationRequest(request);\n      } catch (error) {\n        if (error.message.includes('size') || error.message.includes('large') || error.message.includes('Invalid')) {\n          dosResistant = true;\n        }\n      }\n    }\n\n    this.testResults.set('dosResistance', {\n      resistant: dosResistant,\n      oversizedRequestsBlocked: dosResistant\n    });\n  }\n\n  // Calculate overall security score\n  private calculateSecurityScore(): number {\n    const totalTests = this.testResults.size;\n    let passedTests = 0;\n\n    for (const [testName, result] of this.testResults) {\n      switch (testName) {\n        case 'authenticationBypass':\n          if (result.every((test: any) => test.passed)) passedTests++;\n          break;\n        case 'rateLimitBypass':\n          if (result.effective) passedTests++;\n          break;\n        case 'byzantineAttacks':\n          if (result.byzantineDetection.detected) passedTests++;\n          break;\n        case 'cryptographicSecurity':\n          if (result.signatureVerification) passedTests++;\n          break;\n        case 'auditTrailSecurity':\n          if (result.integrityValid) passedTests++;\n          break;\n        case 'dosResistance':\n          if (result.resistant) passedTests++;\n          break;\n      }\n    }\n\n    return Math.round((passedTests / totalTests) * 100);\n  }\n\n  // Generate security recommendations\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n\n    if (this.vulnerabilities.length === 0) {\n      recommendations.push('Security system appears robust');\n      recommendations.push('Continue regular security assessments');\n    } else {\n      recommendations.push('Address identified vulnerabilities immediately');\n      recommendations.push('Implement additional security layers');\n      recommendations.push('Increase monitoring and alerting');\n      recommendations.push('Consider external security audit');\n    }\n\n    return recommendations;\n  }\n}\n\n// ======================== LOAD TESTING FRAMEWORK ========================\n\nexport class LoadTestingSuite {\n  private security: SecurityEnforcementSystem;\n\n  constructor(security: SecurityEnforcementSystem) {\n    this.security = security;\n  }\n\n  // Run concurrent load test\n  async runConcurrentLoadTest(\n    concurrentUsers: number,\n    requestsPerUser: number,\n    durationSeconds: number\n  ): Promise<{\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n    averageResponseTime: number;\n    throughput: number;\n    errorDistribution: Map<string, number>;\n  }> {\n    console.log(`Starting load test: ${concurrentUsers} users, ${requestsPerUser} requests each, ${durationSeconds}s duration`);\n\n    const startTime = Date.now();\n    const endTime = startTime + (durationSeconds * 1000);\n    const results: any[] = [];\n    const errorDistribution = new Map<string, number>();\n\n    // Register test agents\n    const testAgents = Array.from({ length: concurrentUsers }, (_, i) => `load-test-agent-${i}`);\n    for (const agentId of testAgents) {\n      try {\n        await this.security.registerAgent(agentId, ['verify'], 'MEDIUM');\n      } catch (error) {\n        // Agent might already exist\n      }\n    }\n\n    // Create concurrent user simulations\n    const userPromises = testAgents.map(async (agentId, userIndex) => {\n      const userResults: any[] = [];\n      let requestCount = 0;\n\n      while (Date.now() < endTime && requestCount < requestsPerUser) {\n        const requestStart = Date.now();\n        \n        try {\n          const request = SecurityTestUtils.createMockVerificationRequest({ agentId });\n          await this.security.processVerificationRequest(request);\n          \n          const responseTime = Date.now() - requestStart;\n          userResults.push({\n            success: true,\n            responseTime,\n            timestamp: new Date()\n          });\n        } catch (error) {\n          const responseTime = Date.now() - requestStart;\n          userResults.push({\n            success: false,\n            responseTime,\n            error: error.message,\n            timestamp: new Date()\n          });\n\n          // Track error distribution\n          const errorType = error.message.split(':')[0] || 'Unknown';\n          errorDistribution.set(errorType, (errorDistribution.get(errorType) || 0) + 1);\n        }\n        \n        requestCount++;\n        \n        // Small delay between requests\n        await new Promise(resolve => setTimeout(resolve, 10));\n      }\n\n      return userResults;\n    });\n\n    // Wait for all users to complete\n    const allUserResults = await Promise.all(userPromises);\n    \n    // Aggregate results\n    const allResults = allUserResults.flat();\n    const totalRequests = allResults.length;\n    const successfulRequests = allResults.filter(r => r.success).length;\n    const failedRequests = totalRequests - successfulRequests;\n    \n    const responseTimes = allResults.map(r => r.responseTime);\n    const averageResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;\n    \n    const actualDuration = (Date.now() - startTime) / 1000;\n    const throughput = totalRequests / actualDuration;\n\n    return {\n      totalRequests,\n      successfulRequests,\n      failedRequests,\n      averageResponseTime,\n      throughput,\n      errorDistribution\n    };\n  }\n\n  // Run stress test with gradually increasing load\n  async runStressTest(\n    maxConcurrentUsers: number,\n    rampUpDurationSeconds: number,\n    sustainDurationSeconds: number\n  ): Promise<{\n    breakingPoint: number;\n    maxThroughput: number;\n    degradationPattern: Array<{ users: number; throughput: number; errorRate: number }>;\n  }> {\n    console.log(`Starting stress test: ramp up to ${maxConcurrentUsers} users over ${rampUpDurationSeconds}s`);\n\n    const degradationPattern: Array<{ users: number; throughput: number; errorRate: number }> = [];\n    let breakingPoint = maxConcurrentUsers;\n    let maxThroughput = 0;\n\n    const step = Math.max(1, Math.floor(maxConcurrentUsers / 10));\n    \n    for (let users = step; users <= maxConcurrentUsers; users += step) {\n      console.log(`Testing with ${users} concurrent users...`);\n      \n      const result = await this.runConcurrentLoadTest(\n        users,\n        10, // 10 requests per user\n        Math.max(10, sustainDurationSeconds) // At least 10 seconds\n      );\n\n      const errorRate = result.failedRequests / result.totalRequests;\n      \n      degradationPattern.push({\n        users,\n        throughput: result.throughput,\n        errorRate\n      });\n\n      maxThroughput = Math.max(maxThroughput, result.throughput);\n\n      // Consider breaking point when error rate > 10% or throughput drops significantly\n      if (errorRate > 0.1 || (degradationPattern.length > 1 && \n          result.throughput < degradationPattern[degradationPattern.length - 2].throughput * 0.8)) {\n        breakingPoint = users;\n        console.log(`Breaking point detected at ${users} users`);\n        break;\n      }\n\n      // Brief pause between test phases\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n\n    return {\n      breakingPoint,\n      maxThroughput,\n      degradationPattern\n    };\n  }\n}\n\n// ======================== SECURITY VALIDATION SUITE ========================\n\nexport class SecurityValidationSuite {\n  private security: SecurityEnforcementSystem;\n\n  constructor(security: SecurityEnforcementSystem) {\n    this.security = security;\n  }\n\n  // Validate all security components\n  async validateSecuritySystem(): Promise<{\n    componentStatus: Map<string, boolean>;\n    overallHealth: boolean;\n    issues: string[];\n    recommendations: string[];\n  }> {\n    const componentStatus = new Map<string, boolean>();\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n\n    // Test authentication system\n    componentStatus.set('authentication', await this.validateAuthentication());\n    \n    // Test rate limiting\n    componentStatus.set('rateLimiting', await this.validateRateLimiting());\n    \n    // Test Byzantine detection\n    componentStatus.set('byzantineDetection', await this.validateByzantineDetection());\n    \n    // Test cryptographic components\n    componentStatus.set('cryptography', await this.validateCryptography());\n    \n    // Test audit trail\n    componentStatus.set('auditTrail', await this.validateAuditTrail());\n\n    // Calculate overall health\n    const overallHealth = Array.from(componentStatus.values()).every(status => status);\n\n    // Generate issues and recommendations\n    for (const [component, status] of componentStatus) {\n      if (!status) {\n        issues.push(`${component} validation failed`);\n        recommendations.push(`Review and fix ${component} implementation`);\n      }\n    }\n\n    if (overallHealth) {\n      recommendations.push('Security system is functioning correctly');\n      recommendations.push('Continue regular monitoring and updates');\n    }\n\n    return {\n      componentStatus,\n      overallHealth,\n      issues,\n      recommendations\n    };\n  }\n\n  private async validateAuthentication(): Promise<boolean> {\n    try {\n      // Test agent registration\n      const agentId = 'validation-test-agent';\n      await this.security.registerAgent(agentId, ['verify'], 'HIGH');\n      \n      // Test valid request\n      const validRequest = SecurityTestUtils.createMockVerificationRequest({ agentId });\n      await this.security.processVerificationRequest(validRequest);\n      \n      return true;\n    } catch (error) {\n      console.error('Authentication validation failed:', error);\n      return false;\n    }\n  }\n\n  private async validateRateLimiting(): Promise<boolean> {\n    try {\n      const agentId = 'rate-limit-validation-agent';\n      await this.security.registerAgent(agentId, ['verify'], 'MEDIUM');\n      \n      // Send multiple rapid requests\n      const requests = SecurityTestUtils.createMockVerificationRequests(20, { agentId });\n      let rateLimitHit = false;\n      \n      for (const request of requests) {\n        try {\n          await this.security.processVerificationRequest(request);\n        } catch (error) {\n          if (error.message.includes('rate limit')) {\n            rateLimitHit = true;\n            break;\n          }\n        }\n      }\n      \n      return rateLimitHit;\n    } catch (error) {\n      console.error('Rate limiting validation failed:', error);\n      return false;\n    }\n  }\n\n  private async validateByzantineDetection(): Promise<boolean> {\n    try {\n      // This would test Byzantine detection logic\n      // For now, return true as placeholder\n      return true;\n    } catch (error) {\n      console.error('Byzantine detection validation failed:', error);\n      return false;\n    }\n  }\n\n  private async validateCryptography(): Promise<boolean> {\n    try {\n      // Test cryptographic operations\n      const status = this.security.getSecurityStatus();\n      return status.metrics.totalRequests >= 0; // Basic check\n    } catch (error) {\n      console.error('Cryptography validation failed:', error);\n      return false;\n    }\n  }\n\n  private async validateAuditTrail(): Promise<boolean> {\n    try {\n      const status = this.security.getSecurityStatus();\n      return status.auditSummary.integrityValid;\n    } catch (error) {\n      console.error('Audit trail validation failed:', error);\n      return false;\n    }\n  }\n}\n\n// Export all testing components\nexport {\n  SecurityTestUtils,\n  PenetrationTestingSuite,\n  LoadTestingSuite,\n  SecurityValidationSuite\n};"],"names":["SecurityTestUtils","createMockVerificationRequest","overrides","crypto","require","requestId","randomBytes","toString","agentId","truthClaim","statement","confidence","timestamp","Date","nonce","signature","createMockVerificationRequests","count","baseRequest","Array","from","length","_","i","createMaliciousRequests","baseTime","byzantineRequests","getTime","spamRequests","replayAttacks","originalRequest","oversizedRequests","repeat","measurePerformance","operation","iterations","times","successCount","errorCount","startTime","now","operationStart","operationTime","push","error","totalTime","averageTime","reduce","sum","time","minTime","Math","min","maxTime","max","throughput","PenetrationTestingSuite","security","testResults","Map","vulnerabilities","runFullPenetrationTest","console","log","testAuthenticationBypass","testRateLimitBypass","testByzantineAttacks","testCryptographicSecurity","testAuditTrailSecurity","testDoSResistance","securityScore","calculateSecurityScore","recommendations","generateRecommendations","tests","name","test","processVerificationRequest","undefined","results","passed","message","set","registerAgent","rapidRequests","rateLimitedCount","request","includes","rateLimitEffective","totalRequests","effective","maliciousRequests","byzantineDetected","byzantineDetection","detected","requestCount","tamperedRequest","signatureVerificationWorking","signatureVerification","securityStatus","getSecurityStatus","auditTrailWorking","auditSummary","integrityValid","totalEntries","dosResistant","resistant","oversizedRequestsBlocked","totalTests","size","passedTests","testName","result","every","round","LoadTestingSuite","runConcurrentLoadTest","concurrentUsers","requestsPerUser","durationSeconds","endTime","errorDistribution","testAgents","userPromises","map","userIndex","userResults","requestStart","responseTime","success","errorType","split","get","Promise","resolve","setTimeout","allUserResults","all","allResults","flat","successfulRequests","filter","r","failedRequests","responseTimes","averageResponseTime","actualDuration","runStressTest","maxConcurrentUsers","rampUpDurationSeconds","sustainDurationSeconds","degradationPattern","breakingPoint","maxThroughput","step","floor","users","errorRate","SecurityValidationSuite","validateSecuritySystem","componentStatus","issues","validateAuthentication","validateRateLimiting","validateByzantineDetection","validateCryptography","validateAuditTrail","overallHealth","values","status","component","validRequest","requests","rateLimitHit","metrics"],"mappings":"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"}