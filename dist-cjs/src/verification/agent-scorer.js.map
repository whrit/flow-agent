{"version":3,"sources":["../../../src/verification/agent-scorer.ts"],"sourcesContent":["/**\n * Agent Truth Scorer - Advanced performance evaluation and scoring system\n * \n * Provides comprehensive agent performance analysis including accuracy,\n * reliability, consistency, efficiency, and adaptability metrics.\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport type {\n  TruthMetric,\n  AgentTruthScore,\n  PerformanceWindow,\n  ScoreTrend,\n  BenchmarkComparison,\n  RiskAssessment,\n  RiskFactor,\n  TruthTelemetryConfig,\n} from './telemetry.js';\n\nexport interface AgentScoringConfig {\n  windowSizes: {\n    recent: number; // minutes\n    short: number; // hours\n    medium: number; // days\n    long: number; // weeks\n  };\n  weights: {\n    accuracy: number;\n    reliability: number;\n    consistency: number;\n    efficiency: number;\n    adaptability: number;\n  };\n  benchmarks: {\n    minAccuracy: number;\n    minReliability: number;\n    minConsistency: number;\n    minEfficiency: number;\n    targetTasksPerHour: number;\n  };\n  riskThresholds: {\n    low: number;\n    medium: number;\n    high: number;\n  };\n}\n\nexport interface AgentPerformanceData {\n  agentId: string;\n  metrics: TruthMetric[];\n  recentMetrics: TruthMetric[];\n  taskHistory: TaskPerformance[];\n  errorHistory: ErrorAnalysis[];\n}\n\nexport interface TaskPerformance {\n  taskId: string;\n  timestamp: Date;\n  taskType: string;\n  complexity: string;\n  duration: number;\n  accuracy: number;\n  success: boolean;\n  interventionRequired: boolean;\n  errorCount: number;\n}\n\nexport interface ErrorAnalysis {\n  timestamp: Date;\n  errorType: string;\n  severity: string;\n  frequency: number;\n  impact: number;\n  resolved: boolean;\n  pattern: string;\n}\n\nexport interface TrendAnalysis {\n  metric: string;\n  timeframe: string;\n  direction: 'improving' | 'declining' | 'stable';\n  rate: number;\n  confidence: number;\n  significance: number;\n  seasonality?: {\n    detected: boolean;\n    period: number;\n    strength: number;\n  };\n}\n\nexport class AgentTruthScorer {\n  private config: AgentScoringConfig;\n  private logger: ILogger;\n  private telemetryConfig: TruthTelemetryConfig;\n  \n  // Agent data storage\n  private agentData = new Map<string, AgentPerformanceData>();\n  private agentScores = new Map<string, AgentTruthScore>();\n  \n  // Benchmark data\n  private benchmarkScores = new Map<string, number>();\n  private industryBenchmarks: Map<string, BenchmarkComparison[]> = new Map();\n  \n  constructor(telemetryConfig: TruthTelemetryConfig, logger: ILogger) {\n    this.telemetryConfig = telemetryConfig;\n    this.logger = logger;\n    \n    this.config = {\n      windowSizes: {\n        recent: 15, // 15 minutes\n        short: 4, // 4 hours\n        medium: 7, // 7 days\n        long: 4, // 4 weeks\n      },\n      weights: {\n        accuracy: 0.30,\n        reliability: 0.25,\n        consistency: 0.20,\n        efficiency: 0.15,\n        adaptability: 0.10,\n      },\n      benchmarks: {\n        minAccuracy: 0.90,\n        minReliability: 0.85,\n        minConsistency: 0.80,\n        minEfficiency: 0.75,\n        targetTasksPerHour: 10,\n      },\n      riskThresholds: {\n        low: 0.85,\n        medium: 0.70,\n        high: 0.50,\n      },\n    };\n    \n    this.initializeBenchmarks();\n  }\n  \n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Agent Truth Scorer', {\n      weights: this.config.weights,\n      benchmarks: this.config.benchmarks,\n    });\n    \n    await this.loadHistoricalData();\n    \n    this.logger.info('Agent Truth Scorer initialized successfully');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Agent Truth Scorer');\n    \n    await this.persistScoringData();\n    \n    this.logger.info('Agent Truth Scorer shutdown complete');\n  }\n  \n  async updateAgentMetric(metric: TruthMetric): Promise<void> {\n    const agentId = metric.agentId;\n    \n    // Get or create agent data\n    let agentData = this.agentData.get(agentId);\n    if (!agentData) {\n      agentData = {\n        agentId,\n        metrics: [],\n        recentMetrics: [],\n        taskHistory: [],\n        errorHistory: [],\n      };\n      this.agentData.set(agentId, agentData);\n    }\n    \n    // Add metric to agent data\n    agentData.metrics.push(metric);\n    \n    // Update recent metrics (last 15 minutes)\n    const recentCutoff = new Date(Date.now() - this.config.windowSizes.recent * 60 * 1000);\n    agentData.recentMetrics = agentData.metrics.filter(m => m.timestamp >= recentCutoff);\n    \n    // Update task history\n    await this.updateTaskHistory(agentData, metric);\n    \n    // Update error history\n    await this.updateErrorHistory(agentData, metric);\n    \n    // Trigger score recalculation for significant updates\n    if (this.shouldRecalculateScore(metric)) {\n      await this.calculateAgentScore(agentId);\n    }\n  }\n  \n  async calculateAgentScore(agentId: string): Promise<AgentTruthScore | null> {\n    const agentData = this.agentData.get(agentId);\n    if (!agentData || agentData.metrics.length === 0) {\n      return null;\n    }\n    \n    try {\n      // Calculate component scores\n      const components = await this.calculateComponentScores(agentData);\n      \n      // Calculate overall score using weighted average\n      const overallScore = this.calculateWeightedScore(components);\n      \n      // Generate performance windows\n      const recentPerformance = await this.generatePerformanceWindows(agentData);\n      \n      // Analyze trends\n      const trends = await this.analyzeTrends(agentData);\n      \n      // Generate benchmark comparisons\n      const benchmarks = await this.generateBenchmarkComparisons(agentId, components);\n      \n      // Assess risk\n      const riskAssessment = await this.assessRisk(agentData, components);\n      \n      const score: AgentTruthScore = {\n        agentId,\n        timestamp: new Date(),\n        overallScore,\n        components,\n        recentPerformance,\n        trends,\n        benchmarks,\n        riskAssessment,\n      };\n      \n      this.agentScores.set(agentId, score);\n      \n      this.logger.debug('Calculated agent score', {\n        agentId,\n        overallScore: overallScore.toFixed(3),\n        components,\n      });\n      \n      return score;\n      \n    } catch (error) {\n      this.logger.error('Error calculating agent score', { agentId, error });\n      return null;\n    }\n  }\n  \n  private async calculateComponentScores(agentData: AgentPerformanceData): Promise<{\n    accuracy: number;\n    reliability: number;\n    consistency: number;\n    efficiency: number;\n    adaptability: number;\n  }> {\n    const shortTermMetrics = this.getMetricsInWindow(\n      agentData.metrics,\n      this.config.windowSizes.short * 60 * 60 * 1000 // hours to ms\n    );\n    \n    return {\n      accuracy: await this.calculateAccuracyScore(shortTermMetrics),\n      reliability: await this.calculateReliabilityScore(shortTermMetrics),\n      consistency: await this.calculateConsistencyScore(shortTermMetrics),\n      efficiency: await this.calculateEfficiencyScore(agentData),\n      adaptability: await this.calculateAdaptabilityScore(agentData),\n    };\n  }\n  \n  private async calculateAccuracyScore(metrics: TruthMetric[]): Promise<number> {\n    if (metrics.length === 0) return 0;\n    \n    const accuracyMetrics = metrics.filter(m => m.metricType === 'accuracy');\n    if (accuracyMetrics.length === 0) return 0.8; // Default for new agents\n    \n    // Weighted average with more recent metrics having higher weight\n    let totalWeight = 0;\n    let weightedSum = 0;\n    \n    accuracyMetrics.forEach((metric, index) => {\n      const age = Date.now() - metric.timestamp.getTime();\n      const weight = Math.exp(-age / (24 * 60 * 60 * 1000)); // Exponential decay over 24 hours\n      \n      totalWeight += weight * metric.confidence;\n      weightedSum += metric.value * weight * metric.confidence;\n    });\n    \n    return totalWeight > 0 ? Math.min(1, weightedSum / totalWeight) : 0;\n  }\n  \n  private async calculateReliabilityScore(metrics: TruthMetric[]): Promise<number> {\n    if (metrics.length === 0) return 0;\n    \n    const reliabilityMetrics = metrics.filter(m => m.metricType === 'reliability');\n    const validationScores = metrics.map(m => m.validation.score);\n    \n    // Calculate task success rate\n    const successRate = validationScores.filter(score => score >= 0.8).length / validationScores.length;\n    \n    // Calculate consistency of performance\n    const variance = this.calculateVariance(validationScores);\n    const consistencyScore = Math.max(0, 1 - variance);\n    \n    // Combine factors\n    return (successRate * 0.7) + (consistencyScore * 0.3);\n  }\n  \n  private async calculateConsistencyScore(metrics: TruthMetric[]): Promise<number> {\n    if (metrics.length < 3) return 0.8; // Default for insufficient data\n    \n    const values = metrics.map(m => m.value);\n    const confidences = metrics.map(m => m.confidence);\n    \n    // Calculate coefficient of variation for values and confidence\n    const valueCV = this.calculateCoefficientOfVariation(values);\n    const confidenceCV = this.calculateCoefficientOfVariation(confidences);\n    \n    // Lower CV means higher consistency\n    const valueConsistency = Math.max(0, 1 - valueCV);\n    const confidenceConsistency = Math.max(0, 1 - confidenceCV);\n    \n    return (valueConsistency * 0.6) + (confidenceConsistency * 0.4);\n  }\n  \n  private async calculateEfficiencyScore(agentData: AgentPerformanceData): Promise<number> {\n    const recentTasks = agentData.taskHistory.filter(\n      task => task.timestamp > new Date(Date.now() - this.config.windowSizes.short * 60 * 60 * 1000)\n    );\n    \n    if (recentTasks.length === 0) return 0.8; // Default\n    \n    // Calculate tasks per hour\n    const hoursSpanned = this.config.windowSizes.short;\n    const tasksPerHour = recentTasks.length / hoursSpanned;\n    const throughputScore = Math.min(1, tasksPerHour / this.config.benchmarks.targetTasksPerHour);\n    \n    // Calculate average task duration relative to complexity\n    const durationEfficiency = this.calculateDurationEfficiency(recentTasks);\n    \n    // Calculate human intervention rate (lower is better)\n    const interventionRate = recentTasks.filter(t => t.interventionRequired).length / recentTasks.length;\n    const interventionScore = Math.max(0, 1 - (interventionRate * 2)); // Penalty for interventions\n    \n    return (throughputScore * 0.4) + (durationEfficiency * 0.4) + (interventionScore * 0.2);\n  }\n  \n  private async calculateAdaptabilityScore(agentData: AgentPerformanceData): Promise<number> {\n    const recentTasks = agentData.taskHistory.filter(\n      task => task.timestamp > new Date(Date.now() - this.config.windowSizes.medium * 24 * 60 * 60 * 1000)\n    );\n    \n    if (recentTasks.length < 5) return 0.7; // Default for new agents\n    \n    // Analyze performance across different task types\n    const taskTypes = new Set(recentTasks.map(t => t.taskType));\n    const performanceByType = new Map<string, number[]>();\n    \n    recentTasks.forEach(task => {\n      if (!performanceByType.has(task.taskType)) {\n        performanceByType.set(task.taskType, []);\n      }\n      performanceByType.get(task.taskType)!.push(task.accuracy);\n    });\n    \n    // Calculate adaptability as consistency across different task types\n    let adaptabilitySum = 0;\n    let typeCount = 0;\n    \n    for (const [taskType, accuracies] of performanceByType) {\n      if (accuracies.length >= 2) {\n        const avgAccuracy = accuracies.reduce((sum, acc) => sum + acc, 0) / accuracies.length;\n        adaptabilitySum += avgAccuracy;\n        typeCount++;\n      }\n    }\n    \n    const adaptabilityScore = typeCount > 0 ? adaptabilitySum / typeCount : 0.7;\n    \n    // Bonus for handling multiple task types\n    const diversityBonus = Math.min(0.1, taskTypes.size * 0.02);\n    \n    return Math.min(1, adaptabilityScore + diversityBonus);\n  }\n  \n  private calculateWeightedScore(components: {\n    accuracy: number;\n    reliability: number;\n    consistency: number;\n    efficiency: number;\n    adaptability: number;\n  }): number {\n    const weights = this.config.weights;\n    \n    return (\n      components.accuracy * weights.accuracy +\n      components.reliability * weights.reliability +\n      components.consistency * weights.consistency +\n      components.efficiency * weights.efficiency +\n      components.adaptability * weights.adaptability\n    );\n  }\n  \n  private async generatePerformanceWindows(agentData: AgentPerformanceData): Promise<PerformanceWindow[]> {\n    const windows: PerformanceWindow[] = [];\n    const now = new Date();\n    \n    // Recent window (last 15 minutes)\n    const recentStart = new Date(now.getTime() - this.config.windowSizes.recent * 60 * 1000);\n    windows.push(await this.createPerformanceWindow('recent', recentStart, now, agentData));\n    \n    // Short window (last 4 hours)\n    const shortStart = new Date(now.getTime() - this.config.windowSizes.short * 60 * 60 * 1000);\n    windows.push(await this.createPerformanceWindow('short', shortStart, now, agentData));\n    \n    // Medium window (last 7 days)\n    const mediumStart = new Date(now.getTime() - this.config.windowSizes.medium * 24 * 60 * 60 * 1000);\n    windows.push(await this.createPerformanceWindow('medium', mediumStart, now, agentData));\n    \n    // Long window (last 4 weeks)\n    const longStart = new Date(now.getTime() - this.config.windowSizes.long * 7 * 24 * 60 * 60 * 1000);\n    windows.push(await this.createPerformanceWindow('long', longStart, now, agentData));\n    \n    return windows;\n  }\n  \n  private async createPerformanceWindow(\n    period: string,\n    startTime: Date,\n    endTime: Date,\n    agentData: AgentPerformanceData\n  ): Promise<PerformanceWindow> {\n    const windowMetrics = agentData.metrics.filter(\n      m => m.timestamp >= startTime && m.timestamp <= endTime\n    );\n    \n    const windowTasks = agentData.taskHistory.filter(\n      t => t.timestamp >= startTime && t.timestamp <= endTime\n    );\n    \n    const successfulTasks = windowTasks.filter(t => t.success).length;\n    const accuracyValues = windowMetrics\n      .filter(m => m.metricType === 'accuracy')\n      .map(m => m.value);\n    const confidenceValues = windowMetrics.map(m => m.confidence);\n    const interventions = windowTasks.filter(t => t.interventionRequired).length;\n    const criticalErrors = agentData.errorHistory.filter(\n      e => e.timestamp >= startTime && e.timestamp <= endTime && e.severity === 'critical'\n    ).length;\n    \n    return {\n      period,\n      startTime,\n      endTime,\n      metrics: {\n        totalTasks: windowTasks.length,\n        successfulTasks,\n        averageAccuracy: accuracyValues.length > 0 ? \n          accuracyValues.reduce((sum, val) => sum + val, 0) / accuracyValues.length : 0,\n        averageConfidence: confidenceValues.length > 0 ?\n          confidenceValues.reduce((sum, val) => sum + val, 0) / confidenceValues.length : 0,\n        humanInterventions: interventions,\n        criticalErrors,\n      },\n    };\n  }\n  \n  private async analyzeTrends(agentData: AgentPerformanceData): Promise<ScoreTrend[]> {\n    const trends: ScoreTrend[] = [];\n    \n    const metricTypes = ['accuracy', 'reliability', 'consistency', 'efficiency'];\n    \n    for (const metricType of metricTypes) {\n      const trend = await this.analyzeTrendForMetric(agentData, metricType);\n      if (trend) {\n        trends.push(trend);\n      }\n    }\n    \n    return trends;\n  }\n  \n  private async analyzeTrendForMetric(\n    agentData: AgentPerformanceData,\n    metricType: string\n  ): Promise<ScoreTrend | null> {\n    const relevantMetrics = agentData.metrics\n      .filter(m => m.metricType === metricType)\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n    \n    if (relevantMetrics.length < 5) return null; // Need minimum data points\n    \n    // Calculate linear trend\n    const values = relevantMetrics.map(m => m.value);\n    const times = relevantMetrics.map(m => m.timestamp.getTime());\n    \n    const { slope, correlation } = this.calculateLinearTrend(times, values);\n    \n    // Determine trend direction and significance\n    let direction: 'improving' | 'declining' | 'stable';\n    if (Math.abs(slope) < 0.001) {\n      direction = 'stable';\n    } else {\n      direction = slope > 0 ? 'improving' : 'declining';\n    }\n    \n    const confidence = Math.abs(correlation);\n    const rate = Math.abs(slope);\n    \n    return {\n      metric: metricType,\n      direction,\n      rate,\n      confidence,\n      timespan: 'medium',\n    };\n  }\n  \n  private async generateBenchmarkComparisons(\n    agentId: string,\n    components: any\n  ): Promise<BenchmarkComparison[]> {\n    const comparisons: BenchmarkComparison[] = [];\n    \n    // Compare against configured benchmarks\n    const benchmarks = this.config.benchmarks;\n    \n    comparisons.push({\n      category: 'accuracy',\n      agentScore: components.accuracy,\n      benchmarkScore: benchmarks.minAccuracy,\n      percentile: this.calculatePercentile(components.accuracy, 'accuracy'),\n      comparison: components.accuracy >= benchmarks.minAccuracy ? 'above' : 'below',\n    });\n    \n    comparisons.push({\n      category: 'reliability',\n      agentScore: components.reliability,\n      benchmarkScore: benchmarks.minReliability,\n      percentile: this.calculatePercentile(components.reliability, 'reliability'),\n      comparison: components.reliability >= benchmarks.minReliability ? 'above' : 'below',\n    });\n    \n    comparisons.push({\n      category: 'consistency',\n      agentScore: components.consistency,\n      benchmarkScore: benchmarks.minConsistency,\n      percentile: this.calculatePercentile(components.consistency, 'consistency'),\n      comparison: components.consistency >= benchmarks.minConsistency ? 'above' : 'below',\n    });\n    \n    comparisons.push({\n      category: 'efficiency',\n      agentScore: components.efficiency,\n      benchmarkScore: benchmarks.minEfficiency,\n      percentile: this.calculatePercentile(components.efficiency, 'efficiency'),\n      comparison: components.efficiency >= benchmarks.minEfficiency ? 'above' : 'below',\n    });\n    \n    return comparisons;\n  }\n  \n  private async assessRisk(\n    agentData: AgentPerformanceData,\n    components: any\n  ): Promise<RiskAssessment> {\n    const riskFactors: RiskFactor[] = [];\n    \n    // Accuracy risk\n    if (components.accuracy < this.config.riskThresholds.medium) {\n      riskFactors.push({\n        name: 'Low Accuracy',\n        severity: components.accuracy < this.config.riskThresholds.high ? 0.8 : 0.5,\n        probability: 0.9,\n        impact: 'High risk of incorrect outputs',\n        trend: this.getTrendDirection(agentData, 'accuracy'),\n      });\n    }\n    \n    // Reliability risk\n    if (components.reliability < this.config.riskThresholds.medium) {\n      riskFactors.push({\n        name: 'Low Reliability',\n        severity: components.reliability < this.config.riskThresholds.high ? 0.7 : 0.4,\n        probability: 0.8,\n        impact: 'Frequent task failures',\n        trend: this.getTrendDirection(agentData, 'reliability'),\n      });\n    }\n    \n    // Efficiency risk\n    if (components.efficiency < this.config.riskThresholds.medium) {\n      riskFactors.push({\n        name: 'Low Efficiency',\n        severity: 0.4,\n        probability: 0.7,\n        impact: 'Reduced throughput and increased costs',\n        trend: this.getTrendDirection(agentData, 'efficiency'),\n      });\n    }\n    \n    // Error pattern risk\n    const recentErrors = agentData.errorHistory.filter(\n      e => e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours\n    );\n    \n    if (recentErrors.length > 5) {\n      riskFactors.push({\n        name: 'High Error Rate',\n        severity: 0.6,\n        probability: 0.8,\n        impact: 'Increased human intervention required',\n        trend: 'increasing',\n      });\n    }\n    \n    // Determine overall risk level\n    const maxSeverity = riskFactors.length > 0 ? \n      Math.max(...riskFactors.map(f => f.severity)) : 0;\n    \n    let level: 'low' | 'medium' | 'high' | 'critical';\n    if (maxSeverity >= 0.8) level = 'critical';\n    else if (maxSeverity >= 0.6) level = 'high';\n    else if (maxSeverity >= 0.3) level = 'medium';\n    else level = 'low';\n    \n    return {\n      level,\n      factors: riskFactors,\n      recommendations: this.generateRecommendations(riskFactors),\n      mitigationStrategies: this.generateMitigationStrategies(riskFactors),\n    };\n  }\n  \n  // ========================================================================================\n  // Utility Methods\n  // ========================================================================================\n  \n  private getMetricsInWindow(metrics: TruthMetric[], windowMs: number): TruthMetric[] {\n    const cutoff = new Date(Date.now() - windowMs);\n    return metrics.filter(m => m.timestamp >= cutoff);\n  }\n  \n  private calculateVariance(values: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));\n    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;\n  }\n  \n  private calculateCoefficientOfVariation(values: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    if (mean === 0) return 0;\n    \n    const variance = this.calculateVariance(values);\n    const stdDev = Math.sqrt(variance);\n    \n    return stdDev / mean;\n  }\n  \n  private calculateDurationEfficiency(tasks: TaskPerformance[]): number {\n    if (tasks.length === 0) return 0.8;\n    \n    // Group tasks by complexity and calculate average duration\n    const complexityGroups = new Map<string, number[]>();\n    \n    tasks.forEach(task => {\n      if (!complexityGroups.has(task.complexity)) {\n        complexityGroups.set(task.complexity, []);\n      }\n      complexityGroups.get(task.complexity)!.push(task.duration);\n    });\n    \n    // Expected durations by complexity (in minutes)\n    const expectedDurations: Record<string, number> = {\n      low: 5,\n      medium: 15,\n      high: 45,\n      critical: 120,\n    };\n    \n    let totalEfficiency = 0;\n    let groupCount = 0;\n    \n    for (const [complexity, durations] of complexityGroups) {\n      const avgDuration = durations.reduce((sum, d) => sum + d, 0) / durations.length;\n      const expected = expectedDurations[complexity] || 15;\n      \n      // Efficiency is better when duration is less than expected\n      const efficiency = Math.min(1, expected / avgDuration);\n      totalEfficiency += efficiency;\n      groupCount++;\n    }\n    \n    return groupCount > 0 ? totalEfficiency / groupCount : 0.8;\n  }\n  \n  private calculateLinearTrend(x: number[], y: number[]): { slope: number; correlation: number } {\n    const n = x.length;\n    if (n < 2) return { slope: 0, correlation: 0 };\n    \n    const sumX = x.reduce((sum, val) => sum + val, 0);\n    const sumY = y.reduce((sum, val) => sum + val, 0);\n    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);\n    const sumX2 = x.reduce((sum, val) => sum + val * val, 0);\n    const sumY2 = y.reduce((sum, val) => sum + val * val, 0);\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    \n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n    const correlation = denominator !== 0 ? numerator / denominator : 0;\n    \n    return { slope, correlation };\n  }\n  \n  private calculatePercentile(score: number, category: string): number {\n    // This would typically compare against a database of historical scores\n    // For now, using a simplified calculation\n    const allScores = Array.from(this.agentScores.values())\n      .map(s => s.components[category as keyof typeof s.components])\n      .filter(s => s !== undefined)\n      .sort((a, b) => a - b);\n    \n    if (allScores.length === 0) return 50;\n    \n    const index = allScores.findIndex(s => s >= score);\n    return index === -1 ? 100 : (index / allScores.length) * 100;\n  }\n  \n  private getTrendDirection(agentData: AgentPerformanceData, metricType: string): 'increasing' | 'stable' | 'decreasing' {\n    const recentMetrics = agentData.metrics\n      .filter(m => m.metricType === metricType)\n      .slice(-10); // Last 10 metrics\n    \n    if (recentMetrics.length < 3) return 'stable';\n    \n    const values = recentMetrics.map(m => m.value);\n    const firstHalf = values.slice(0, Math.floor(values.length / 2));\n    const secondHalf = values.slice(Math.floor(values.length / 2));\n    \n    const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;\n    \n    const diff = secondAvg - firstAvg;\n    if (Math.abs(diff) < 0.01) return 'stable';\n    return diff > 0 ? 'increasing' : 'decreasing';\n  }\n  \n  private generateRecommendations(riskFactors: RiskFactor[]): string[] {\n    const recommendations: string[] = [];\n    \n    riskFactors.forEach(factor => {\n      switch (factor.name) {\n        case 'Low Accuracy':\n          recommendations.push('Implement additional validation steps');\n          recommendations.push('Review training data quality');\n          recommendations.push('Consider accuracy-focused training sessions');\n          break;\n        case 'Low Reliability':\n          recommendations.push('Increase redundancy in critical tasks');\n          recommendations.push('Implement circuit breaker patterns');\n          recommendations.push('Add health check monitoring');\n          break;\n        case 'Low Efficiency':\n          recommendations.push('Optimize task distribution algorithms');\n          recommendations.push('Review resource allocation');\n          recommendations.push('Consider task batching strategies');\n          break;\n        case 'High Error Rate':\n          recommendations.push('Implement better error handling');\n          recommendations.push('Add preventive validation checks');\n          recommendations.push('Review error patterns for systemic issues');\n          break;\n      }\n    });\n    \n    return Array.from(new Set(recommendations)); // Remove duplicates\n  }\n  \n  private generateMitigationStrategies(riskFactors: RiskFactor[]): string[] {\n    const strategies: string[] = [];\n    \n    const hasAccuracyRisk = riskFactors.some(f => f.name.includes('Accuracy'));\n    const hasReliabilityRisk = riskFactors.some(f => f.name.includes('Reliability'));\n    const hasEfficiencyRisk = riskFactors.some(f => f.name.includes('Efficiency'));\n    \n    if (hasAccuracyRisk) {\n      strategies.push('Increase human oversight for critical tasks');\n      strategies.push('Implement staged rollback procedures');\n      strategies.push('Add confidence-based task routing');\n    }\n    \n    if (hasReliabilityRisk) {\n      strategies.push('Implement automatic failover mechanisms');\n      strategies.push('Add task retry logic with exponential backoff');\n      strategies.push('Create backup processing pipelines');\n    }\n    \n    if (hasEfficiencyRisk) {\n      strategies.push('Implement dynamic load balancing');\n      strategies.push('Add performance-based task assignment');\n      strategies.push('Create efficiency monitoring dashboards');\n    }\n    \n    return strategies;\n  }\n  \n  private shouldRecalculateScore(metric: TruthMetric): boolean {\n    // Recalculate for significant changes\n    return (\n      metric.value < 0.7 || // Low performance\n      metric.confidence < 0.5 || // Low confidence\n      metric.validation.errors.some(e => e.severity === 'critical') || // Critical errors\n      metric.metricType === 'accuracy' // Always recalculate for accuracy metrics\n    );\n  }\n  \n  private async updateTaskHistory(agentData: AgentPerformanceData, metric: TruthMetric): Promise<void> {\n    // Convert metric to task performance record\n    const taskPerformance: TaskPerformance = {\n      taskId: metric.taskId,\n      timestamp: metric.timestamp,\n      taskType: metric.context.taskType,\n      complexity: metric.context.complexity,\n      duration: 0, // Would be calculated from task start/end times\n      accuracy: metric.value,\n      success: metric.validation.isValid,\n      interventionRequired: metric.context.verificationMethod === 'human',\n      errorCount: metric.validation.errors.length,\n    };\n    \n    agentData.taskHistory.push(taskPerformance);\n    \n    // Keep only recent history (last 1000 tasks)\n    if (agentData.taskHistory.length > 1000) {\n      agentData.taskHistory = agentData.taskHistory.slice(-1000);\n    }\n  }\n  \n  private async updateErrorHistory(agentData: AgentPerformanceData, metric: TruthMetric): Promise<void> {\n    // Process validation errors\n    metric.validation.errors.forEach(error => {\n      const errorAnalysis: ErrorAnalysis = {\n        timestamp: metric.timestamp,\n        errorType: error.type,\n        severity: error.severity,\n        frequency: 1,\n        impact: error.impact,\n        resolved: false,\n        pattern: this.identifyErrorPattern(error, agentData.errorHistory),\n      };\n      \n      agentData.errorHistory.push(errorAnalysis);\n    });\n    \n    // Keep only recent history (last 500 errors)\n    if (agentData.errorHistory.length > 500) {\n      agentData.errorHistory = agentData.errorHistory.slice(-500);\n    }\n  }\n  \n  private identifyErrorPattern(error: any, errorHistory: ErrorAnalysis[]): string {\n    // Simple pattern identification based on error type frequency\n    const recentSimilar = errorHistory.filter(\n      e => e.errorType === error.type && \n           e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours\n    );\n    \n    if (recentSimilar.length >= 3) return 'recurring';\n    if (recentSimilar.length >= 2) return 'intermittent';\n    return 'isolated';\n  }\n  \n  private initializeBenchmarks(): void {\n    // Initialize industry benchmarks (would typically load from external source)\n    this.benchmarkScores.set('accuracy', 0.92);\n    this.benchmarkScores.set('reliability', 0.88);\n    this.benchmarkScores.set('consistency', 0.85);\n    this.benchmarkScores.set('efficiency', 0.80);\n    this.benchmarkScores.set('adaptability', 0.75);\n  }\n  \n  private async loadHistoricalData(): Promise<void> {\n    // Placeholder for loading historical scoring data\n    this.logger.debug('Loading historical agent scoring data');\n  }\n  \n  private async persistScoringData(): Promise<void> {\n    // Placeholder for persisting scoring data\n    this.logger.debug('Persisting agent scoring data');\n  }\n  \n  // ========================================================================================\n  // Public API\n  // ========================================================================================\n  \n  getAgentScore(agentId: string): AgentTruthScore | undefined {\n    return this.agentScores.get(agentId);\n  }\n  \n  getAllAgentScores(): AgentTruthScore[] {\n    return Array.from(this.agentScores.values());\n  }\n  \n  getTopPerformers(limit: number = 10): AgentTruthScore[] {\n    return Array.from(this.agentScores.values())\n      .sort((a, b) => b.overallScore - a.overallScore)\n      .slice(0, limit);\n  }\n  \n  getAgentsByRiskLevel(riskLevel: 'low' | 'medium' | 'high' | 'critical'): AgentTruthScore[] {\n    return Array.from(this.agentScores.values())\n      .filter(score => score.riskAssessment.level === riskLevel);\n  }\n  \n  getPerformanceStatistics(): {\n    totalAgents: number;\n    averageScore: number;\n    highPerformers: number;\n    atRiskAgents: number;\n    improvingAgents: number;\n    decliningAgents: number;\n  } {\n    const scores = Array.from(this.agentScores.values());\n    \n    return {\n      totalAgents: scores.length,\n      averageScore: scores.length > 0 ? \n        scores.reduce((sum, s) => sum + s.overallScore, 0) / scores.length : 0,\n      highPerformers: scores.filter(s => s.overallScore >= 0.9).length,\n      atRiskAgents: scores.filter(s => s.riskAssessment.level === 'high' || s.riskAssessment.level === 'critical').length,\n      improvingAgents: scores.filter(s => \n        s.trends.some(t => t.direction === 'improving' && t.confidence > 0.7)\n      ).length,\n      decliningAgents: scores.filter(s => \n        s.trends.some(t => t.direction === 'declining' && t.confidence > 0.7)\n      ).length,\n    };\n  }\n}"],"names":["AgentTruthScorer","config","logger","telemetryConfig","agentData","Map","agentScores","benchmarkScores","industryBenchmarks","windowSizes","recent","short","medium","long","weights","accuracy","reliability","consistency","efficiency","adaptability","benchmarks","minAccuracy","minReliability","minConsistency","minEfficiency","targetTasksPerHour","riskThresholds","low","high","initializeBenchmarks","initialize","info","loadHistoricalData","shutdown","persistScoringData","updateAgentMetric","metric","agentId","get","metrics","recentMetrics","taskHistory","errorHistory","set","push","recentCutoff","Date","now","filter","m","timestamp","updateTaskHistory","updateErrorHistory","shouldRecalculateScore","calculateAgentScore","length","components","calculateComponentScores","overallScore","calculateWeightedScore","recentPerformance","generatePerformanceWindows","trends","analyzeTrends","generateBenchmarkComparisons","riskAssessment","assessRisk","score","debug","toFixed","error","shortTermMetrics","getMetricsInWindow","calculateAccuracyScore","calculateReliabilityScore","calculateConsistencyScore","calculateEfficiencyScore","calculateAdaptabilityScore","accuracyMetrics","metricType","totalWeight","weightedSum","forEach","index","age","getTime","weight","Math","exp","confidence","value","min","reliabilityMetrics","validationScores","map","validation","successRate","variance","calculateVariance","consistencyScore","max","values","confidences","valueCV","calculateCoefficientOfVariation","confidenceCV","valueConsistency","confidenceConsistency","recentTasks","task","hoursSpanned","tasksPerHour","throughputScore","durationEfficiency","calculateDurationEfficiency","interventionRate","t","interventionRequired","interventionScore","taskTypes","Set","taskType","performanceByType","has","adaptabilitySum","typeCount","accuracies","avgAccuracy","reduce","sum","acc","adaptabilityScore","diversityBonus","size","windows","recentStart","createPerformanceWindow","shortStart","mediumStart","longStart","period","startTime","endTime","windowMetrics","windowTasks","successfulTasks","success","accuracyValues","confidenceValues","interventions","criticalErrors","e","severity","totalTasks","averageAccuracy","val","averageConfidence","humanInterventions","metricTypes","trend","analyzeTrendForMetric","relevantMetrics","sort","a","b","times","slope","correlation","calculateLinearTrend","direction","abs","rate","timespan","comparisons","category","agentScore","benchmarkScore","percentile","calculatePercentile","comparison","riskFactors","name","probability","impact","getTrendDirection","recentErrors","maxSeverity","f","level","factors","recommendations","generateRecommendations","mitigationStrategies","generateMitigationStrategies","windowMs","cutoff","mean","squaredDiffs","pow","diff","stdDev","sqrt","tasks","complexityGroups","complexity","duration","expectedDurations","critical","totalEfficiency","groupCount","durations","avgDuration","d","expected","x","y","n","sumX","sumY","sumXY","i","sumX2","sumY2","numerator","denominator","allScores","Array","from","s","undefined","findIndex","slice","firstHalf","floor","secondHalf","firstAvg","secondAvg","factor","strategies","hasAccuracyRisk","some","includes","hasReliabilityRisk","hasEfficiencyRisk","errors","taskPerformance","taskId","context","isValid","verificationMethod","errorCount","errorAnalysis","errorType","type","frequency","resolved","pattern","identifyErrorPattern","recentSimilar","getAgentScore","getAllAgentScores","getTopPerformers","limit","getAgentsByRiskLevel","riskLevel","getPerformanceStatistics","scores","totalAgents","averageScore","highPerformers","atRiskAgents","improvingAgents","decliningAgents"],"mappings":"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"}