{"version":3,"sources":["../../../src/verification/hooks.ts"],"sourcesContent":["/**\n * Verification Hooks Module\n * \n * Comprehensive verification and validation system for claude-flow operations.\n * Provides pre-task verification, post-task validation, integration testing,\n * truth telemetry, and rollback capabilities.\n */\n\nimport { Logger } from '../core/logger.js';\nimport { agenticHookManager } from '../services/agentic-flow-hooks/index.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  HookRegistration,\n  WorkflowHookPayload,\n  PerformanceHookPayload,\n  MemoryHookPayload,\n} from '../services/agentic-flow-hooks/types.js';\n\nconst logger = new Logger({\n  level: 'info',\n  format: 'text',\n  destination: 'console'\n}, { prefix: 'VerificationHooks' });\n\n// ===== Types & Interfaces =====\n\nexport interface VerificationConfig {\n  preTask: {\n    enabled: boolean;\n    checkers: PreTaskChecker[];\n    failureStrategy: 'abort' | 'warn' | 'continue';\n  };\n  postTask: {\n    enabled: boolean;\n    validators: PostTaskValidator[];\n    accuracyThreshold: number;\n  };\n  integration: {\n    enabled: boolean;\n    testSuites: IntegrationTestSuite[];\n    parallel: boolean;\n  };\n  telemetry: {\n    enabled: boolean;\n    truthValidators: TruthValidator[];\n    reportingInterval: number;\n  };\n  rollback: {\n    enabled: boolean;\n    triggers: RollbackTrigger[];\n    snapshotStrategy: 'automatic' | 'manual' | 'selective';\n  };\n}\n\nexport interface PreTaskChecker {\n  id: string;\n  name: string;\n  description: string;\n  priority: number;\n  check: (context: VerificationContext) => Promise<VerificationResult>;\n}\n\nexport interface PostTaskValidator {\n  id: string;\n  name: string;\n  description: string;\n  priority: number;\n  validate: (context: VerificationContext, result: any) => Promise<ValidationResult>;\n}\n\nexport interface IntegrationTestSuite {\n  id: string;\n  name: string;\n  description: string;\n  tests: IntegrationTest[];\n  requirements: string[];\n}\n\nexport interface IntegrationTest {\n  id: string;\n  name: string;\n  description: string;\n  execute: (context: VerificationContext) => Promise<TestResult>;\n  cleanup?: (context: VerificationContext) => Promise<void>;\n}\n\nexport interface TruthValidator {\n  id: string;\n  name: string;\n  description: string;\n  validate: (data: any, expected: any) => Promise<TruthResult>;\n}\n\nexport interface RollbackTrigger {\n  id: string;\n  name: string;\n  description: string;\n  condition: (context: VerificationContext, error?: Error) => boolean;\n  action: RollbackAction;\n}\n\nexport interface VerificationContext {\n  taskId: string;\n  sessionId: string;\n  timestamp: number;\n  metadata: Record<string, any>;\n  state: VerificationState;\n  snapshots: StateSnapshot[];\n  metrics: VerificationMetrics;\n}\n\nexport interface VerificationState {\n  phase: 'pre-task' | 'execution' | 'post-task' | 'validation' | 'complete' | 'failed';\n  checksPassed: string[];\n  checksFailed: string[];\n  validationResults: ValidationResult[];\n  testResults: TestResult[];\n  truthResults: TruthResult[];\n  errors: VerificationError[];\n}\n\nexport interface StateSnapshot {\n  id: string;\n  timestamp: number;\n  phase: string;\n  state: any;\n  metadata: Record<string, any>;\n}\n\nexport interface VerificationMetrics {\n  totalChecks: number;\n  passedChecks: number;\n  failedChecks: number;\n  executionTime: number;\n  accuracyScore: number;\n  confidenceScore: number;\n}\n\nexport interface VerificationResult {\n  passed: boolean;\n  score: number;\n  message: string;\n  details?: any;\n  recommendations?: string[];\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  accuracy: number;\n  confidence: number;\n  message: string;\n  details?: any;\n  evidence?: any[];\n}\n\nexport interface TestResult {\n  passed: boolean;\n  duration: number;\n  message: string;\n  details?: any;\n  logs?: string[];\n}\n\nexport interface TruthResult {\n  truthful: boolean;\n  accuracy: number;\n  confidence: number;\n  discrepancies: string[];\n  evidence: any[];\n}\n\nexport interface VerificationError {\n  type: 'check' | 'validation' | 'test' | 'truth' | 'system';\n  phase: string;\n  message: string;\n  details?: any;\n  recoverable: boolean;\n}\n\nexport type RollbackAction = \n  | 'restore-snapshot' \n  | 'revert-changes' \n  | 'reset-state' \n  | 'abort-task'\n  | 'retry-with-fallback';\n\n// ===== Default Configuration =====\n\nexport const DEFAULT_VERIFICATION_CONFIG: VerificationConfig = {\n  preTask: {\n    enabled: true,\n    checkers: [],\n    failureStrategy: 'abort',\n  },\n  postTask: {\n    enabled: true,\n    validators: [],\n    accuracyThreshold: 0.8,\n  },\n  integration: {\n    enabled: true,\n    testSuites: [],\n    parallel: true,\n  },\n  telemetry: {\n    enabled: true,\n    truthValidators: [],\n    reportingInterval: 30000, // 30 seconds\n  },\n  rollback: {\n    enabled: true,\n    triggers: [],\n    snapshotStrategy: 'automatic',\n  },\n};\n\n// ===== Verification Hook Manager =====\n\nexport class VerificationHookManager {\n  private config: VerificationConfig;\n  private contexts: Map<string, VerificationContext> = new Map();\n  private snapshots: Map<string, StateSnapshot[]> = new Map();\n\n  constructor(config: Partial<VerificationConfig> = {}) {\n    this.config = { ...DEFAULT_VERIFICATION_CONFIG, ...config };\n    this.registerHooks();\n    this.startTelemetryReporting();\n  }\n\n  /**\n   * Register all verification hooks with the agentic hook manager\n   */\n  private registerHooks(): void {\n    // Pre-task verification hook\n    this.registerPreTaskHook();\n    \n    // Post-task validation hook\n    this.registerPostTaskHook();\n    \n    // Integration test hook\n    this.registerIntegrationTestHook();\n    \n    // Truth telemetry hook\n    this.registerTruthTelemetryHook();\n    \n    // Rollback trigger hook\n    this.registerRollbackTriggerHook();\n\n    logger.info('Verification hooks registered successfully');\n  }\n\n  // ===== 1. Pre-Task Verification Hook =====\n\n  private registerPreTaskHook(): void {\n    const preTaskHook: HookRegistration = {\n      id: 'verification-pre-task',\n      type: 'workflow-start',\n      priority: 100, // High priority to run early\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.preTask.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.createVerificationContext(payload, context);\n        \n        try {\n          await this.executePreTaskChecks(verificationContext);\n          \n          const state = verificationContext.state;\n          if (state.checksFailed.length > 0) {\n            const strategy = this.config.preTask.failureStrategy;\n            \n            if (strategy === 'abort') {\n              return {\n                continue: false,\n                metadata: {\n                  verificationFailed: true,\n                  failedChecks: state.checksFailed,\n                  error: 'Pre-task verification failed'\n                }\n              };\n            } else if (strategy === 'warn') {\n              logger.warn('Pre-task verification warnings:', state.checksFailed);\n            }\n          }\n\n          // Create initial snapshot\n          await this.createSnapshot(verificationContext, 'pre-task-complete');\n\n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              verificationContext: verificationContext.taskId\n            },\n            metadata: {\n              verificationPassed: true,\n              checksExecuted: state.checksPassed.length,\n              warnings: state.checksFailed.length\n            }\n          };\n        } catch (error) {\n          logger.error('Pre-task verification error:', error);\n          \n          return {\n            continue: this.config.preTask.failureStrategy !== 'abort',\n            metadata: {\n              verificationError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 30000, // 30 second timeout\n        async: false,\n      }\n    };\n\n    agenticHookManager.register(preTaskHook);\n  }\n\n  private async executePreTaskChecks(context: VerificationContext): Promise<void> {\n    const checkers = this.config.preTask.checkers.sort((a, b) => b.priority - a.priority);\n    \n    for (const checker of checkers) {\n      try {\n        const result = await checker.check(context);\n        \n        if (result.passed) {\n          context.state.checksPassed.push(checker.id);\n        } else {\n          context.state.checksFailed.push(checker.id);\n          context.state.errors.push({\n            type: 'check',\n            phase: 'pre-task',\n            message: result.message,\n            details: result.details,\n            recoverable: true\n          });\n        }\n\n        // Update metrics\n        context.metrics.totalChecks++;\n        if (result.passed) {\n          context.metrics.passedChecks++;\n        } else {\n          context.metrics.failedChecks++;\n        }\n      } catch (error) {\n        logger.error(`Pre-task checker '${checker.id}' failed:`, error);\n        context.state.checksFailed.push(checker.id);\n        context.state.errors.push({\n          type: 'check',\n          phase: 'pre-task',\n          message: `Checker '${checker.id}' threw an error: ${(error as Error).message}`,\n          details: error,\n          recoverable: false\n        });\n      }\n    }\n  }\n\n  // ===== 2. Post-Task Validation Hook =====\n\n  private registerPostTaskHook(): void {\n    const postTaskHook: HookRegistration = {\n      id: 'verification-post-task',\n      type: 'workflow-complete',\n      priority: 90,\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.postTask.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getVerificationContext(payload.workflowId) || \n                                   this.createVerificationContext(payload, context);\n        \n        try {\n          await this.executePostTaskValidation(verificationContext, payload);\n          \n          const accuracy = this.calculateAccuracy(verificationContext);\n          const meetsThreshold = accuracy >= this.config.postTask.accuracyThreshold;\n\n          // Create completion snapshot\n          await this.createSnapshot(verificationContext, 'post-task-complete');\n\n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              validationResults: verificationContext.state.validationResults,\n              accuracy,\n              meetsThreshold\n            },\n            metadata: {\n              validationComplete: true,\n              accuracy,\n              meetsThreshold,\n              validationCount: verificationContext.state.validationResults.length\n            },\n            sideEffects: [{\n              type: 'metric',\n              action: 'update',\n              data: {\n                name: 'verification.accuracy',\n                value: accuracy\n              }\n            }]\n          };\n        } catch (error) {\n          logger.error('Post-task validation error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              validationError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 60000, // 60 second timeout\n        async: true,\n      }\n    };\n\n    agenticHookManager.register(postTaskHook);\n  }\n\n  private async executePostTaskValidation(\n    context: VerificationContext, \n    payload: WorkflowHookPayload\n  ): Promise<void> {\n    const validators = this.config.postTask.validators.sort((a, b) => b.priority - a.priority);\n    \n    for (const validator of validators) {\n      try {\n        const result = await validator.validate(context, payload.state);\n        context.state.validationResults.push(result);\n        \n        // Update metrics\n        if (result.valid) {\n          context.metrics.accuracyScore += result.accuracy;\n          context.metrics.confidenceScore += result.confidence;\n        }\n      } catch (error) {\n        logger.error(`Post-task validator '${validator.id}' failed:`, error);\n        context.state.errors.push({\n          type: 'validation',\n          phase: 'post-task',\n          message: `Validator '${validator.id}' threw an error: ${(error as Error).message}`,\n          details: error,\n          recoverable: false\n        });\n      }\n    }\n  }\n\n  // ===== 3. Integration Test Hook =====\n\n  private registerIntegrationTestHook(): void {\n    const integrationTestHook: HookRegistration = {\n      id: 'verification-integration-test',\n      type: 'workflow-step',\n      priority: 80,\n      filter: {\n        patterns: [/integration.*test/i, /test.*integration/i]\n      },\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.integration.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getVerificationContext(payload.workflowId) || \n                                   this.createVerificationContext(payload, context);\n        \n        try {\n          await this.executeIntegrationTests(verificationContext);\n          \n          const allTestsPassed = verificationContext.state.testResults.every(r => r.passed);\n          const testCount = verificationContext.state.testResults.length;\n          const passedCount = verificationContext.state.testResults.filter(r => r.passed).length;\n\n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              testResults: verificationContext.state.testResults,\n              allTestsPassed,\n              testSummary: {\n                total: testCount,\n                passed: passedCount,\n                failed: testCount - passedCount\n              }\n            },\n            metadata: {\n              integrationTestsComplete: true,\n              allTestsPassed,\n              testCount,\n              passedCount\n            },\n            sideEffects: [{\n              type: 'metric',\n              action: 'update',\n              data: {\n                name: 'verification.integration.success_rate',\n                value: passedCount / testCount\n              }\n            }]\n          };\n        } catch (error) {\n          logger.error('Integration test execution error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              integrationTestError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 120000, // 2 minute timeout for tests\n        async: true,\n      }\n    };\n\n    agenticHookManager.register(integrationTestHook);\n  }\n\n  private async executeIntegrationTests(context: VerificationContext): Promise<void> {\n    const testSuites = this.config.integration.testSuites;\n    \n    for (const suite of testSuites) {\n      // Check if requirements are met\n      const requirementsMet = await this.checkTestRequirements(suite.requirements, context);\n      if (!requirementsMet) {\n        logger.warn(`Skipping test suite '${suite.id}' - requirements not met`);\n        continue;\n      }\n\n      if (this.config.integration.parallel) {\n        // Execute tests in parallel\n        const testPromises = suite.tests.map(test => this.executeIntegrationTest(test, context));\n        const results = await Promise.allSettled(testPromises);\n        \n        results.forEach((result, index) => {\n          if (result.status === 'fulfilled') {\n            context.state.testResults.push(result.value);\n          } else {\n            context.state.testResults.push({\n              passed: false,\n              duration: 0,\n              message: `Test '${suite.tests[index].id}' failed: ${result.reason}`,\n              details: result.reason\n            });\n          }\n        });\n      } else {\n        // Execute tests sequentially\n        for (const test of suite.tests) {\n          try {\n            const result = await this.executeIntegrationTest(test, context);\n            context.state.testResults.push(result);\n          } catch (error) {\n            context.state.testResults.push({\n              passed: false,\n              duration: 0,\n              message: `Test '${test.id}' failed: ${(error as Error).message}`,\n              details: error\n            });\n          }\n        }\n      }\n    }\n  }\n\n  private async executeIntegrationTest(\n    test: IntegrationTest, \n    context: VerificationContext\n  ): Promise<TestResult> {\n    const startTime = Date.now();\n    \n    try {\n      const result = await test.execute(context);\n      result.duration = Date.now() - startTime;\n      \n      // Cleanup if provided\n      if (test.cleanup) {\n        try {\n          await test.cleanup(context);\n        } catch (cleanupError) {\n          logger.warn(`Test cleanup failed for '${test.id}':`, cleanupError);\n        }\n      }\n      \n      return result;\n    } catch (error) {\n      return {\n        passed: false,\n        duration: Date.now() - startTime,\n        message: `Test execution failed: ${(error as Error).message}`,\n        details: error\n      };\n    }\n  }\n\n  private async checkTestRequirements(\n    requirements: string[], \n    context: VerificationContext\n  ): Promise<boolean> {\n    // Simple requirement checking - can be extended\n    for (const requirement of requirements) {\n      if (requirement.startsWith('env:')) {\n        const envVar = requirement.substring(4);\n        if (!process.env[envVar]) {\n          return false;\n        }\n      } else if (requirement.startsWith('check:')) {\n        const checkId = requirement.substring(6);\n        if (!context.state.checksPassed.includes(checkId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // ===== 4. Truth Telemetry Hook =====\n\n  private registerTruthTelemetryHook(): void {\n    const truthTelemetryHook: HookRegistration = {\n      id: 'verification-truth-telemetry',\n      type: 'performance-metric',\n      priority: 70,\n      handler: async (payload: PerformanceHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.telemetry.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getOrCreateVerificationContext(payload, context);\n        \n        try {\n          await this.executeTruthValidation(verificationContext, payload);\n          \n          const truthfulness = this.calculateTruthfulness(verificationContext);\n          \n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              truthResults: verificationContext.state.truthResults,\n              truthfulness\n            },\n            metadata: {\n              truthValidationComplete: true,\n              truthfulness,\n              validatorCount: this.config.telemetry.truthValidators.length\n            },\n            sideEffects: [\n              {\n                type: 'metric',\n                action: 'update',\n                data: {\n                  name: 'verification.truthfulness',\n                  value: truthfulness\n                }\n              },\n              {\n                type: 'memory',\n                action: 'store',\n                data: {\n                  key: `truth_telemetry_${Date.now()}`,\n                  value: {\n                    timestamp: Date.now(),\n                    truthfulness,\n                    results: verificationContext.state.truthResults\n                  }\n                }\n              }\n            ]\n          };\n        } catch (error) {\n          logger.error('Truth telemetry execution error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              truthTelemetryError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 45000, // 45 second timeout\n        async: true,\n      }\n    };\n\n    agenticHookManager.register(truthTelemetryHook);\n  }\n\n  private async executeTruthValidation(\n    context: VerificationContext, \n    payload: PerformanceHookPayload\n  ): Promise<void> {\n    const validators = this.config.telemetry.truthValidators;\n    \n    for (const validator of validators) {\n      try {\n        // Extract data and expected values from payload\n        const data = payload.context.metrics || payload.value;\n        const expected = payload.threshold; // Use threshold as expected value\n        \n        const result = await validator.validate(data, expected);\n        context.state.truthResults.push(result);\n      } catch (error) {\n        logger.error(`Truth validator '${validator.id}' failed:`, error);\n        context.state.errors.push({\n          type: 'truth',\n          phase: 'telemetry',\n          message: `Truth validator '${validator.id}' threw an error: ${(error as Error).message}`,\n          details: error,\n          recoverable: false\n        });\n      }\n    }\n  }\n\n  private calculateTruthfulness(context: VerificationContext): number {\n    const truthResults = context.state.truthResults;\n    if (truthResults.length === 0) return 1.0;\n    \n    const totalAccuracy = truthResults.reduce((sum, result) => sum + result.accuracy, 0);\n    return totalAccuracy / truthResults.length;\n  }\n\n  // ===== 5. Rollback Trigger Hook =====\n\n  private registerRollbackTriggerHook(): void {\n    const rollbackTriggerHook: HookRegistration = {\n      id: 'verification-rollback-trigger',\n      type: 'workflow-error',\n      priority: 95, // Very high priority for error handling\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.rollback.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getVerificationContext(payload.workflowId);\n        if (!verificationContext) {\n          logger.warn('No verification context found for rollback evaluation');\n          return { continue: true };\n        }\n\n        try {\n          const shouldRollback = await this.evaluateRollbackTriggers(verificationContext, payload.error);\n          \n          if (shouldRollback) {\n            const rollbackResult = await this.executeRollback(verificationContext);\n            \n            return {\n              continue: rollbackResult.success,\n              modified: true,\n              payload: {\n                ...payload,\n                rollbackExecuted: true,\n                rollbackResult\n              },\n              metadata: {\n                rollbackTriggered: true,\n                rollbackSuccess: rollbackResult.success,\n                rollbackAction: rollbackResult.action\n              },\n              sideEffects: [\n                {\n                  type: 'log',\n                  action: 'warn',\n                  data: {\n                    level: 'warn',\n                    message: 'Rollback triggered due to verification failure',\n                    data: rollbackResult\n                  }\n                },\n                {\n                  type: 'metric',\n                  action: 'increment',\n                  data: {\n                    name: 'verification.rollbacks.triggered'\n                  }\n                }\n              ]\n            };\n          }\n\n          return { continue: true };\n        } catch (error) {\n          logger.error('Rollback trigger evaluation error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              rollbackError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 30000, // 30 second timeout\n        async: false, // Critical for error handling\n      }\n    };\n\n    agenticHookManager.register(rollbackTriggerHook);\n  }\n\n  private async evaluateRollbackTriggers(\n    context: VerificationContext, \n    error?: Error\n  ): Promise<boolean> {\n    const triggers = this.config.rollback.triggers;\n    \n    for (const trigger of triggers) {\n      try {\n        if (trigger.condition(context, error)) {\n          logger.info(`Rollback trigger '${trigger.id}' activated`);\n          return true;\n        }\n      } catch (triggerError) {\n        logger.error(`Rollback trigger '${trigger.id}' evaluation failed:`, triggerError);\n      }\n    }\n    \n    return false;\n  }\n\n  private async executeRollback(context: VerificationContext): Promise<{\n    success: boolean;\n    action: string;\n    details?: any;\n  }> {\n    try {\n      const snapshots = this.snapshots.get(context.taskId) || [];\n      const latestSnapshot = snapshots[snapshots.length - 1];\n      \n      if (!latestSnapshot) {\n        throw new Error('No snapshots available for rollback');\n      }\n\n      // Execute rollback based on strategy\n      switch (this.config.rollback.snapshotStrategy) {\n        case 'automatic':\n          await this.restoreSnapshot(context, latestSnapshot);\n          break;\n          \n        case 'selective':\n          // Find the best snapshot to restore to\n          const bestSnapshot = this.findBestRollbackSnapshot(snapshots);\n          await this.restoreSnapshot(context, bestSnapshot);\n          break;\n          \n        default:\n          await this.restoreSnapshot(context, latestSnapshot);\n      }\n\n      return {\n        success: true,\n        action: 'snapshot-restored',\n        details: {\n          snapshotId: latestSnapshot.id,\n          timestamp: latestSnapshot.timestamp\n        }\n      };\n    } catch (error) {\n      logger.error('Rollback execution failed:', error);\n      \n      return {\n        success: false,\n        action: 'rollback-failed',\n        details: (error as Error).message\n      };\n    }\n  }\n\n  // ===== Helper Methods =====\n\n  private createVerificationContext(\n    payload: WorkflowHookPayload, \n    context: AgenticHookContext\n  ): VerificationContext {\n    const verificationContext: VerificationContext = {\n      taskId: payload.workflowId,\n      sessionId: context.sessionId,\n      timestamp: Date.now(),\n      metadata: { ...payload.state, ...context.metadata },\n      state: {\n        phase: 'pre-task',\n        checksPassed: [],\n        checksFailed: [],\n        validationResults: [],\n        testResults: [],\n        truthResults: [],\n        errors: []\n      },\n      snapshots: [],\n      metrics: {\n        totalChecks: 0,\n        passedChecks: 0,\n        failedChecks: 0,\n        executionTime: 0,\n        accuracyScore: 0,\n        confidenceScore: 0\n      }\n    };\n\n    this.contexts.set(verificationContext.taskId, verificationContext);\n    return verificationContext;\n  }\n\n  private getVerificationContext(taskId: string): VerificationContext | undefined {\n    return this.contexts.get(taskId);\n  }\n\n  private getOrCreateVerificationContext(\n    payload: any, \n    context: AgenticHookContext\n  ): VerificationContext {\n    const taskId = payload.workflowId || payload.context?.taskId || context.correlationId;\n    \n    let verificationContext = this.contexts.get(taskId);\n    if (!verificationContext) {\n      verificationContext = this.createVerificationContext(\n        { workflowId: taskId, state: payload.context || {} } as WorkflowHookPayload,\n        context\n      );\n    }\n    \n    return verificationContext;\n  }\n\n  private async createSnapshot(\n    context: VerificationContext, \n    phase: string\n  ): Promise<void> {\n    const snapshot: StateSnapshot = {\n      id: `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n      phase,\n      state: JSON.parse(JSON.stringify(context.state)),\n      metadata: JSON.parse(JSON.stringify(context.metadata))\n    };\n\n    if (!this.snapshots.has(context.taskId)) {\n      this.snapshots.set(context.taskId, []);\n    }\n\n    this.snapshots.get(context.taskId)!.push(snapshot);\n    context.snapshots.push(snapshot);\n\n    logger.debug(`Created snapshot '${snapshot.id}' for task '${context.taskId}' in phase '${phase}'`);\n  }\n\n  private async restoreSnapshot(\n    context: VerificationContext, \n    snapshot: StateSnapshot\n  ): Promise<void> {\n    context.state = JSON.parse(JSON.stringify(snapshot.state));\n    context.metadata = JSON.parse(JSON.stringify(snapshot.metadata));\n    \n    logger.info(`Restored snapshot '${snapshot.id}' for task '${context.taskId}'`);\n  }\n\n  private findBestRollbackSnapshot(snapshots: StateSnapshot[]): StateSnapshot {\n    // Find the latest snapshot with successful state\n    const successfulSnapshots = snapshots.filter(s => \n      s.phase.includes('complete') && !s.phase.includes('error')\n    );\n    \n    return successfulSnapshots.length > 0 \n      ? successfulSnapshots[successfulSnapshots.length - 1]\n      : snapshots[snapshots.length - 1];\n  }\n\n  private calculateAccuracy(context: VerificationContext): number {\n    const validationResults = context.state.validationResults;\n    if (validationResults.length === 0) return 1.0;\n    \n    const totalAccuracy = validationResults.reduce((sum, result) => sum + result.accuracy, 0);\n    return totalAccuracy / validationResults.length;\n  }\n\n  private startTelemetryReporting(): void {\n    if (!this.config.telemetry.enabled) return;\n\n    setInterval(() => {\n      this.generateTelemetryReport();\n    }, this.config.telemetry.reportingInterval);\n  }\n\n  private generateTelemetryReport(): void {\n    const report = {\n      timestamp: Date.now(),\n      activeContexts: this.contexts.size,\n      totalSnapshots: Array.from(this.snapshots.values()).reduce((sum, arr) => sum + arr.length, 0),\n      metrics: this.aggregateMetrics()\n    };\n\n    logger.info('Verification telemetry report:', report);\n    \n    // Emit telemetry event for external systems\n    agenticHookManager.emit('verification:telemetry', report);\n  }\n\n  private aggregateMetrics(): any {\n    const allContexts = Array.from(this.contexts.values());\n    \n    return {\n      totalChecks: allContexts.reduce((sum, ctx) => sum + ctx.metrics.totalChecks, 0),\n      totalPassed: allContexts.reduce((sum, ctx) => sum + ctx.metrics.passedChecks, 0),\n      totalFailed: allContexts.reduce((sum, ctx) => sum + ctx.metrics.failedChecks, 0),\n      averageAccuracy: allContexts.length > 0 \n        ? allContexts.reduce((sum, ctx) => sum + ctx.metrics.accuracyScore, 0) / allContexts.length\n        : 0,\n      averageConfidence: allContexts.length > 0\n        ? allContexts.reduce((sum, ctx) => sum + ctx.metrics.confidenceScore, 0) / allContexts.length\n        : 0\n    };\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Add a pre-task checker\n   */\n  public addPreTaskChecker(checker: PreTaskChecker): void {\n    this.config.preTask.checkers.push(checker);\n    logger.info(`Added pre-task checker: ${checker.name}`);\n  }\n\n  /**\n   * Add a post-task validator\n   */\n  public addPostTaskValidator(validator: PostTaskValidator): void {\n    this.config.postTask.validators.push(validator);\n    logger.info(`Added post-task validator: ${validator.name}`);\n  }\n\n  /**\n   * Add an integration test suite\n   */\n  public addIntegrationTestSuite(testSuite: IntegrationTestSuite): void {\n    this.config.integration.testSuites.push(testSuite);\n    logger.info(`Added integration test suite: ${testSuite.name}`);\n  }\n\n  /**\n   * Add a truth validator\n   */\n  public addTruthValidator(validator: TruthValidator): void {\n    this.config.telemetry.truthValidators.push(validator);\n    logger.info(`Added truth validator: ${validator.name}`);\n  }\n\n  /**\n   * Add a rollback trigger\n   */\n  public addRollbackTrigger(trigger: RollbackTrigger): void {\n    this.config.rollback.triggers.push(trigger);\n    logger.info(`Added rollback trigger: ${trigger.name}`);\n  }\n\n  /**\n   * Get verification status for a task\n   */\n  public getVerificationStatus(taskId: string): VerificationContext | undefined {\n    return this.contexts.get(taskId);\n  }\n\n  /**\n   * Get verification metrics\n   */\n  public getMetrics(): any {\n    return this.aggregateMetrics();\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<VerificationConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    logger.info('Verification configuration updated');\n  }\n\n  /**\n   * Cleanup old contexts and snapshots\n   */\n  public cleanup(maxAge: number = 24 * 60 * 60 * 1000): void {\n    const cutoff = Date.now() - maxAge;\n    \n    // Cleanup contexts\n    for (const [taskId, context] of this.contexts.entries()) {\n      if (context.timestamp < cutoff) {\n        this.contexts.delete(taskId);\n        this.snapshots.delete(taskId);\n      }\n    }\n    \n    logger.info(`Cleaned up verification data older than ${maxAge}ms`);\n  }\n}\n\n// ===== Default Verification Components =====\n\nexport const DEFAULT_PRE_TASK_CHECKERS: PreTaskChecker[] = [\n  {\n    id: 'environment-check',\n    name: 'Environment Validation',\n    description: 'Validates that required environment variables and dependencies are available',\n    priority: 100,\n    check: async (context: VerificationContext): Promise<VerificationResult> => {\n      // Basic environment validation\n      const requiredEnvVars = ['NODE_ENV'];\n      const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);\n      \n      return {\n        passed: missing.length === 0,\n        score: missing.length === 0 ? 1.0 : 0.5,\n        message: missing.length === 0 \n          ? 'Environment validation passed' \n          : `Missing environment variables: ${missing.join(', ')}`,\n        details: { missing, available: requiredEnvVars.filter(envVar => process.env[envVar]) },\n        recommendations: missing.length > 0 \n          ? [`Set missing environment variables: ${missing.join(', ')}`]\n          : undefined\n      };\n    }\n  },\n  {\n    id: 'resource-check',\n    name: 'Resource Availability',\n    description: 'Checks system resources and capacity',\n    priority: 90,\n    check: async (context: VerificationContext): Promise<VerificationResult> => {\n      // Simple memory check\n      const memUsage = process.memoryUsage();\n      const heapUsedMB = memUsage.heapUsed / 1024 / 1024;\n      const heapTotalMB = memUsage.heapTotal / 1024 / 1024;\n      const usageRatio = heapUsedMB / heapTotalMB;\n      \n      return {\n        passed: usageRatio < 0.9, // Less than 90% memory usage\n        score: Math.max(0, 1 - usageRatio),\n        message: `Memory usage: ${heapUsedMB.toFixed(2)}MB / ${heapTotalMB.toFixed(2)}MB (${(usageRatio * 100).toFixed(1)}%)`,\n        details: { memUsage, usageRatio },\n        recommendations: usageRatio > 0.8 \n          ? ['Consider freeing memory before proceeding']\n          : undefined\n      };\n    }\n  }\n];\n\nexport const DEFAULT_POST_TASK_VALIDATORS: PostTaskValidator[] = [\n  {\n    id: 'completion-validator',\n    name: 'Task Completion Validation',\n    description: 'Validates that the task completed successfully',\n    priority: 100,\n    validate: async (context: VerificationContext, result: any): Promise<ValidationResult> => {\n      const hasErrors = context.state.errors.length > 0;\n      const hasFailedChecks = context.state.checksFailed.length > 0;\n      \n      return {\n        valid: !hasErrors && !hasFailedChecks,\n        accuracy: hasErrors || hasFailedChecks ? 0.5 : 1.0,\n        confidence: 0.9,\n        message: hasErrors || hasFailedChecks \n          ? 'Task completed with errors or failed checks'\n          : 'Task completed successfully',\n        details: {\n          errorCount: context.state.errors.length,\n          failedCheckCount: context.state.checksFailed.length\n        }\n      };\n    }\n  }\n];\n\nexport const DEFAULT_TRUTH_VALIDATORS: TruthValidator[] = [\n  {\n    id: 'data-consistency-validator',\n    name: 'Data Consistency Validation',\n    description: 'Validates data consistency and integrity',\n    validate: async (data: any, expected: any): Promise<TruthResult> => {\n      // Simple JSON comparison for data consistency\n      const dataStr = JSON.stringify(data);\n      const expectedStr = JSON.stringify(expected);\n      const isEqual = dataStr === expectedStr;\n      \n      return {\n        truthful: isEqual,\n        accuracy: isEqual ? 1.0 : 0.0,\n        confidence: 0.95,\n        discrepancies: isEqual ? [] : ['Data does not match expected structure'],\n        evidence: [{ data, expected, match: isEqual }]\n      };\n    }\n  }\n];\n\nexport const DEFAULT_ROLLBACK_TRIGGERS: RollbackTrigger[] = [\n  {\n    id: 'error-threshold-trigger',\n    name: 'Error Threshold Trigger',\n    description: 'Triggers rollback when error count exceeds threshold',\n    condition: (context: VerificationContext, error?: Error): boolean => {\n      return context.state.errors.filter(e => !e.recoverable).length > 3;\n    },\n    action: 'restore-snapshot'\n  },\n  {\n    id: 'accuracy-threshold-trigger',\n    name: 'Accuracy Threshold Trigger',\n    description: 'Triggers rollback when accuracy falls below threshold',\n    condition: (context: VerificationContext, error?: Error): boolean => {\n      return context.metrics.accuracyScore < 0.5 && context.state.validationResults.length > 0;\n    },\n    action: 'restore-snapshot'\n  }\n];\n\n// ===== Export Singleton Instance =====\n\nexport const verificationHookManager = new VerificationHookManager({\n  preTask: {\n    enabled: true,\n    checkers: DEFAULT_PRE_TASK_CHECKERS,\n    failureStrategy: 'abort'\n  },\n  postTask: {\n    enabled: true,\n    validators: DEFAULT_POST_TASK_VALIDATORS,\n    accuracyThreshold: 0.8\n  },\n  integration: {\n    enabled: true,\n    testSuites: [],\n    parallel: true\n  },\n  telemetry: {\n    enabled: true,\n    truthValidators: DEFAULT_TRUTH_VALIDATORS,\n    reportingInterval: 30000\n  },\n  rollback: {\n    enabled: true,\n    triggers: DEFAULT_ROLLBACK_TRIGGERS,\n    snapshotStrategy: 'automatic'\n  }\n});\n\n// Initialize default components\nlogger.info('Verification hooks module initialized with default configuration');"],"names":["Logger","agenticHookManager","logger","level","format","destination","prefix","DEFAULT_VERIFICATION_CONFIG","preTask","enabled","checkers","failureStrategy","postTask","validators","accuracyThreshold","integration","testSuites","parallel","telemetry","truthValidators","reportingInterval","rollback","triggers","snapshotStrategy","VerificationHookManager","config","contexts","Map","snapshots","registerHooks","startTelemetryReporting","registerPreTaskHook","registerPostTaskHook","registerIntegrationTestHook","registerTruthTelemetryHook","registerRollbackTriggerHook","info","preTaskHook","id","type","priority","handler","payload","context","continue","verificationContext","createVerificationContext","executePreTaskChecks","state","checksFailed","length","strategy","metadata","verificationFailed","failedChecks","error","warn","createSnapshot","modified","taskId","verificationPassed","checksExecuted","checksPassed","warnings","verificationError","message","options","timeout","async","register","sort","a","b","checker","result","check","passed","push","errors","phase","details","recoverable","metrics","totalChecks","passedChecks","postTaskHook","getVerificationContext","workflowId","executePostTaskValidation","accuracy","calculateAccuracy","meetsThreshold","validationResults","validationComplete","validationCount","sideEffects","action","data","name","value","validationError","validator","validate","valid","accuracyScore","confidenceScore","confidence","integrationTestHook","filter","patterns","executeIntegrationTests","allTestsPassed","testResults","every","r","testCount","passedCount","testSummary","total","failed","integrationTestsComplete","integrationTestError","suite","requirementsMet","checkTestRequirements","requirements","testPromises","tests","map","test","executeIntegrationTest","results","Promise","allSettled","forEach","index","status","duration","reason","startTime","Date","now","execute","cleanup","cleanupError","requirement","startsWith","envVar","substring","process","env","checkId","includes","truthTelemetryHook","getOrCreateVerificationContext","executeTruthValidation","truthfulness","calculateTruthfulness","truthResults","truthValidationComplete","validatorCount","key","timestamp","truthTelemetryError","expected","threshold","totalAccuracy","reduce","sum","rollbackTriggerHook","shouldRollback","evaluateRollbackTriggers","rollbackResult","executeRollback","success","rollbackExecuted","rollbackTriggered","rollbackSuccess","rollbackAction","rollbackError","trigger","condition","triggerError","get","latestSnapshot","Error","restoreSnapshot","bestSnapshot","findBestRollbackSnapshot","snapshotId","sessionId","executionTime","set","correlationId","snapshot","Math","random","toString","substr","JSON","parse","stringify","has","debug","successfulSnapshots","s","setInterval","generateTelemetryReport","report","activeContexts","size","totalSnapshots","Array","from","values","arr","aggregateMetrics","emit","allContexts","ctx","totalPassed","totalFailed","averageAccuracy","averageConfidence","addPreTaskChecker","addPostTaskValidator","addIntegrationTestSuite","testSuite","addTruthValidator","addRollbackTrigger","getVerificationStatus","getMetrics","updateConfig","newConfig","maxAge","cutoff","entries","delete","DEFAULT_PRE_TASK_CHECKERS","description","requiredEnvVars","missing","score","join","available","recommendations","undefined","memUsage","memoryUsage","heapUsedMB","heapUsed","heapTotalMB","heapTotal","usageRatio","max","toFixed","DEFAULT_POST_TASK_VALIDATORS","hasErrors","hasFailedChecks","errorCount","failedCheckCount","DEFAULT_TRUTH_VALIDATORS","dataStr","expectedStr","isEqual","truthful","discrepancies","evidence","match","DEFAULT_ROLLBACK_TRIGGERS","e","verificationHookManager"],"mappings":"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"}