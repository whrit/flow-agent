{"version":3,"sources":["../../../src/verification/checkpoint-manager.ts"],"sourcesContent":["/**\n * Checkpoint Manager\n * Manages system state snapshots and verification checkpoints\n */\n\nimport { \n  Checkpoint, \n  StateSnapshot, \n  CheckpointScope, \n  CheckpointFilter,\n  Validation,\n  AgentState,\n  SystemState,\n  TaskState,\n  MemoryState,\n  FileSystemState,\n  DatabaseState,\n  StateScope,\n  SnapshotMetadata\n} from './interfaces.js';\nimport { createHash } from 'crypto';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\n\nexport class CheckpointManager {\n  private checkpointStore: Map<string, Checkpoint> = new Map();\n  private snapshotStore: Map<string, StateSnapshot> = new Map();\n  private storagePath: string;\n\n  constructor(storagePath: string = '.claude-flow/checkpoints') {\n    this.storagePath = storagePath;\n    this.ensureStorageDirectory();\n  }\n\n  /**\n   * Create a new checkpoint with state snapshot\n   */\n  async createCheckpoint(\n    description: string, \n    scope: CheckpointScope,\n    agentId?: string,\n    taskId?: string,\n    validations: Validation[] = []\n  ): Promise<string> {\n    const checkpointId = this.generateCheckpointId();\n    const timestamp = Date.now();\n    \n    // Capture current system state\n    const stateSnapshot = await this.captureSystemState(scope, agentId, taskId);\n    \n    const checkpoint: Checkpoint = {\n      id: checkpointId,\n      type: 'during', // Default type, can be overridden\n      agent_id: agentId || 'system',\n      task_id: taskId || 'system',\n      timestamp,\n      required: true,\n      validations,\n      state_snapshot: stateSnapshot,\n      description,\n      scope\n    };\n\n    // Store checkpoint\n    await this.storeCheckpoint(checkpoint);\n    \n    console.log(`‚úÖ Checkpoint created: ${checkpointId} (${description})`);\n    return checkpointId;\n  }\n\n  /**\n   * Create a pre-execution checkpoint\n   */\n  async createPreExecutionCheckpoint(\n    agentId: string,\n    taskId: string,\n    description: string\n  ): Promise<string> {\n    const validations: Validation[] = [\n      {\n        name: 'agent_capabilities',\n        type: 'test',\n        command: 'validate-agent-capabilities',\n        expected_result: true,\n        passed: false,\n        weight: 0.3,\n        execution_time_ms: 0\n      },\n      {\n        name: 'resource_availability',\n        type: 'test',\n        command: 'check-resource-availability',\n        expected_result: true,\n        passed: false,\n        weight: 0.3,\n        execution_time_ms: 0\n      },\n      {\n        name: 'dependency_verification',\n        type: 'test',\n        command: 'verify-dependencies',\n        expected_result: true,\n        passed: false,\n        weight: 0.4,\n        execution_time_ms: 0\n      }\n    ];\n\n    const checkpointId = await this.createCheckpoint(\n      `Pre-execution: ${description}`,\n      'task',\n      agentId,\n      taskId,\n      validations\n    );\n\n    // Execute validations\n    await this.executeValidations(checkpointId, validations);\n\n    return checkpointId;\n  }\n\n  /**\n   * Create a post-execution checkpoint\n   */\n  async createPostExecutionCheckpoint(\n    agentId: string,\n    taskId: string,\n    description: string,\n    truthScore: number\n  ): Promise<string> {\n    const validations: Validation[] = [\n      {\n        name: 'result_verification',\n        type: 'test',\n        command: 'verify-task-results',\n        expected_result: true,\n        passed: false,\n        weight: 0.4,\n        execution_time_ms: 0\n      },\n      {\n        name: 'system_integrity',\n        type: 'test',\n        command: 'check-system-integrity',\n        expected_result: true,\n        passed: false,\n        weight: 0.3,\n        execution_time_ms: 0\n      },\n      {\n        name: 'truth_score_validation',\n        type: 'test',\n        command: 'validate-truth-score',\n        expected_result: truthScore >= 0.95,\n        passed: truthScore >= 0.95,\n        weight: 0.3,\n        execution_time_ms: 0\n      }\n    ];\n\n    const checkpointId = await this.createCheckpoint(\n      `Post-execution: ${description}`,\n      'task',\n      agentId,\n      taskId,\n      validations\n    );\n\n    // Execute validations\n    await this.executeValidations(checkpointId, validations);\n\n    return checkpointId;\n  }\n\n  /**\n   * List checkpoints with optional filtering\n   */\n  async listCheckpoints(filter?: CheckpointFilter): Promise<Checkpoint[]> {\n    let checkpoints = Array.from(this.checkpointStore.values());\n\n    if (filter) {\n      checkpoints = checkpoints.filter(checkpoint => {\n        if (filter.agent_id && checkpoint.agent_id !== filter.agent_id) return false;\n        if (filter.task_id && checkpoint.task_id !== filter.task_id) return false;\n        if (filter.type && checkpoint.type !== filter.type) return false;\n        if (filter.scope && checkpoint.scope !== filter.scope) return false;\n        if (filter.from_timestamp && checkpoint.timestamp < filter.from_timestamp) return false;\n        if (filter.to_timestamp && checkpoint.timestamp > filter.to_timestamp) return false;\n        return true;\n      });\n    }\n\n    return checkpoints.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Get a specific checkpoint\n   */\n  async getCheckpoint(checkpointId: string): Promise<Checkpoint | null> {\n    return this.checkpointStore.get(checkpointId) || null;\n  }\n\n  /**\n   * Delete a checkpoint\n   */\n  async deleteCheckpoint(checkpointId: string): Promise<void> {\n    const checkpoint = this.checkpointStore.get(checkpointId);\n    if (!checkpoint) {\n      throw new Error(`Checkpoint ${checkpointId} not found`);\n    }\n\n    // Remove from memory\n    this.checkpointStore.delete(checkpointId);\n    this.snapshotStore.delete(checkpoint.state_snapshot.id);\n\n    // Remove from disk\n    const checkpointFile = path.join(this.storagePath, `${checkpointId}.json`);\n    const snapshotFile = path.join(this.storagePath, 'snapshots', `${checkpoint.state_snapshot.id}.json`);\n\n    try {\n      await fs.unlink(checkpointFile);\n      await fs.unlink(snapshotFile);\n      console.log(`üóëÔ∏è Checkpoint deleted: ${checkpointId}`);\n    } catch (error) {\n      console.warn(`Warning: Failed to delete checkpoint files: ${error}`);\n    }\n  }\n\n  /**\n   * Capture current system state\n   */\n  private async captureSystemState(\n    scope: CheckpointScope,\n    agentId?: string,\n    taskId?: string\n  ): Promise<StateSnapshot> {\n    const snapshotId = this.generateSnapshotId();\n    const timestamp = Date.now();\n\n    const stateScope: StateScope = {\n      include_agents: scope !== 'local',\n      include_tasks: scope !== 'local',\n      include_memory: true,\n      include_filesystem: scope === 'system' || scope === 'global',\n      include_database: scope === 'system' || scope === 'global',\n      agent_filter: agentId ? [agentId] : undefined,\n      task_filter: taskId ? [taskId] : undefined\n    };\n\n    // Capture different state components based on scope\n    const agentStates = stateScope.include_agents ? await this.captureAgentStates(stateScope.agent_filter) : new Map();\n    const systemState = stateScope.include_agents ? await this.captureSystemState_Component() : {} as SystemState;\n    const taskStates = stateScope.include_tasks ? await this.captureTaskStates(stateScope.task_filter) : new Map();\n    const memoryState = stateScope.include_memory ? await this.captureMemoryState() : {} as MemoryState;\n    const fileSystemState = stateScope.include_filesystem ? await this.captureFileSystemState() : {} as FileSystemState;\n    const databaseState = stateScope.include_database ? await this.captureDatabaseState() : {} as DatabaseState;\n\n    // Calculate checksum for integrity verification\n    const checksum = this.calculateStateChecksum({\n      agentStates,\n      systemState,\n      taskStates,\n      memoryState,\n      fileSystemState,\n      databaseState\n    });\n\n    const metadata: SnapshotMetadata = {\n      version: '2.0',\n      created_by: agentId || 'system',\n      description: `State snapshot for ${scope} scope`,\n      tags: [scope, timestamp.toString()],\n      size_bytes: 0, // Will be calculated after serialization\n      compression_ratio: 1.0\n    };\n\n    const snapshot: StateSnapshot = {\n      id: snapshotId,\n      timestamp,\n      agent_states: agentStates,\n      system_state: systemState,\n      task_states: taskStates,\n      memory_state: memoryState,\n      file_system_state: fileSystemState,\n      database_state: databaseState,\n      checksum,\n      metadata\n    };\n\n    // Store snapshot\n    await this.storeSnapshot(snapshot);\n\n    return snapshot;\n  }\n\n  /**\n   * Capture agent states\n   */\n  private async captureAgentStates(agentFilter?: string[]): Promise<Map<string, AgentState>> {\n    const agentStates = new Map<string, AgentState>();\n    \n    // This would integrate with the actual agent manager\n    // For now, we'll simulate capturing agent states\n    const mockAgents = ['coordinator', 'coder', 'tester', 'researcher'];\n    \n    for (const agentId of mockAgents) {\n      if (agentFilter && !agentFilter.includes(agentId)) continue;\n      \n      const agentState: AgentState = {\n        id: agentId,\n        status: 'idle',\n        current_task: null,\n        capabilities: ['code', 'test', 'analyze'],\n        memory: {\n          working_memory: {},\n          long_term_memory: {},\n          shared_memory_keys: [],\n          memory_usage_mb: 10\n        },\n        configuration: {\n          model: 'claude-3-sonnet',\n          temperature: 0.7,\n          max_tokens: 4096,\n          timeout_ms: 30000,\n          retry_attempts: 3,\n          custom_parameters: {}\n        },\n        performance_metrics: {\n          response_time_p95_ms: 500,\n          throughput_requests_per_second: 10,\n          error_rate_percentage: 0.1,\n          cpu_usage_percentage: 5,\n          memory_usage_mb: 50\n        },\n        last_heartbeat: Date.now()\n      };\n      \n      agentStates.set(agentId, agentState);\n    }\n    \n    return agentStates;\n  }\n\n  /**\n   * Capture system state component\n   */\n  private async captureSystemState_Component(): Promise<SystemState> {\n    return {\n      version: '2.0.0-alpha.88',\n      uptime_ms: process.uptime() * 1000,\n      active_agents: 4,\n      active_tasks: 2,\n      memory_usage: {\n        cpu_usage_percentage: 15,\n        memory_usage_mb: 256,\n        disk_usage_mb: 1024,\n        network_io_mbps: 1.5,\n        file_descriptors_used: 50\n      },\n      configuration: {\n        max_agents: 10,\n        max_concurrent_tasks: 5,\n        truth_threshold: 0.95,\n        verification_enabled: true,\n        rollback_enabled: true\n      }\n    };\n  }\n\n  /**\n   * Capture task states\n   */\n  private async captureTaskStates(taskFilter?: string[]): Promise<Map<string, TaskState>> {\n    const taskStates = new Map<string, TaskState>();\n    \n    // Mock task states\n    const mockTasks = ['task_001', 'task_002'];\n    \n    for (const taskId of mockTasks) {\n      if (taskFilter && !taskFilter.includes(taskId)) continue;\n      \n      const taskState: TaskState = {\n        id: taskId,\n        status: 'running',\n        assigned_agent: 'coder',\n        dependencies: [],\n        start_time: Date.now() - 60000,\n        progress_percentage: 50,\n        result: null\n      };\n      \n      taskStates.set(taskId, taskState);\n    }\n    \n    return taskStates;\n  }\n\n  /**\n   * Capture memory state\n   */\n  private async captureMemoryState(): Promise<MemoryState> {\n    return {\n      total_size_mb: 512,\n      used_size_mb: 128,\n      fragmentation_percentage: 10,\n      cache_hit_rate: 0.85,\n      active_sessions: 3\n    };\n  }\n\n  /**\n   * Capture file system state\n   */\n  private async captureFileSystemState(): Promise<FileSystemState> {\n    return {\n      total_files: 1250,\n      total_size_mb: 45,\n      last_modified: Date.now(),\n      checksums: {\n        'package.json': 'abc123',\n        'src/index.ts': 'def456'\n      },\n      permissions_valid: true\n    };\n  }\n\n  /**\n   * Capture database state\n   */\n  private async captureDatabaseState(): Promise<DatabaseState> {\n    return {\n      connection_status: 'connected',\n      transaction_count: 0,\n      pending_migrations: 0,\n      data_integrity_check: true,\n      backup_status: 'current'\n    };\n  }\n\n  /**\n   * Calculate state checksum for integrity verification\n   */\n  private calculateStateChecksum(stateData: any): string {\n    const stateString = JSON.stringify(stateData, null, 0);\n    return createHash('sha256').update(stateString).digest('hex');\n  }\n\n  /**\n   * Execute validations for a checkpoint\n   */\n  private async executeValidations(checkpointId: string, validations: Validation[]): Promise<void> {\n    const checkpoint = this.checkpointStore.get(checkpointId);\n    if (!checkpoint) return;\n\n    for (const validation of validations) {\n      const startTime = Date.now();\n      \n      try {\n        // Execute validation command\n        const result = await this.executeValidationCommand(validation.command, validation.expected_result);\n        \n        validation.actual_result = result;\n        validation.passed = this.compareResults(validation.expected_result, result);\n        validation.execution_time_ms = Date.now() - startTime;\n        \n      } catch (error: any) {\n        validation.passed = false;\n        validation.error_message = error.message;\n        validation.execution_time_ms = Date.now() - startTime;\n      }\n    }\n\n    // Update checkpoint with validation results\n    checkpoint.validations = validations;\n    await this.storeCheckpoint(checkpoint);\n  }\n\n  /**\n   * Execute a validation command\n   */\n  private async executeValidationCommand(command: string, expectedResult: any): Promise<any> {\n    // This would integrate with actual validation systems\n    switch (command) {\n      case 'validate-agent-capabilities':\n        return true; // Mock validation\n      case 'check-resource-availability':\n        return true; // Mock validation\n      case 'verify-dependencies':\n        return true; // Mock validation\n      case 'verify-task-results':\n        return true; // Mock validation\n      case 'check-system-integrity':\n        return true; // Mock validation\n      case 'validate-truth-score':\n        return expectedResult; // Pass through for truth score validation\n      default:\n        throw new Error(`Unknown validation command: ${command}`);\n    }\n  }\n\n  /**\n   * Compare validation results\n   */\n  private compareResults(expected: any, actual: any): boolean {\n    if (typeof expected === 'boolean' && typeof actual === 'boolean') {\n      return expected === actual;\n    }\n    \n    if (typeof expected === 'number' && typeof actual === 'number') {\n      return Math.abs(expected - actual) < 0.001; // Allow small floating point differences\n    }\n    \n    return JSON.stringify(expected) === JSON.stringify(actual);\n  }\n\n  /**\n   * Store checkpoint to persistent storage\n   */\n  private async storeCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    // Store in memory\n    this.checkpointStore.set(checkpoint.id, checkpoint);\n    \n    // Store to disk\n    const checkpointFile = path.join(this.storagePath, `${checkpoint.id}.json`);\n    await this.writeJsonFile(checkpointFile, checkpoint);\n  }\n\n  /**\n   * Store snapshot to persistent storage\n   */\n  private async storeSnapshot(snapshot: StateSnapshot): Promise<void> {\n    // Store in memory\n    this.snapshotStore.set(snapshot.id, snapshot);\n    \n    // Store to disk\n    const snapshotDir = path.join(this.storagePath, 'snapshots');\n    await this.ensureDirectory(snapshotDir);\n    \n    const snapshotFile = path.join(snapshotDir, `${snapshot.id}.json`);\n    await this.writeJsonFile(snapshotFile, snapshot);\n    \n    // Update metadata with actual file size\n    const stats = await fs.stat(snapshotFile);\n    snapshot.metadata.size_bytes = stats.size;\n  }\n\n  /**\n   * Ensure storage directory exists\n   */\n  private async ensureStorageDirectory(): Promise<void> {\n    await this.ensureDirectory(this.storagePath);\n    await this.ensureDirectory(path.join(this.storagePath, 'snapshots'));\n  }\n\n  /**\n   * Ensure directory exists\n   */\n  private async ensureDirectory(dirPath: string): Promise<void> {\n    try {\n      await fs.access(dirPath);\n    } catch {\n      await fs.mkdir(dirPath, { recursive: true });\n    }\n  }\n\n  /**\n   * Write JSON file safely\n   */\n  private async writeJsonFile(filePath: string, data: any): Promise<void> {\n    const jsonData = JSON.stringify(data, null, 2);\n    await fs.writeFile(filePath, jsonData, 'utf8');\n  }\n\n  /**\n   * Generate unique checkpoint ID\n   */\n  private generateCheckpointId(): string {\n    return `checkpoint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Generate unique snapshot ID\n   */\n  private generateSnapshotId(): string {\n    return `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Load checkpoints from disk on startup\n   */\n  async loadCheckpointsFromDisk(): Promise<void> {\n    try {\n      const files = await fs.readdir(this.storagePath);\n      const checkpointFiles = files.filter(f => f.startsWith('checkpoint_') && f.endsWith('.json'));\n      \n      for (const file of checkpointFiles) {\n        const filePath = path.join(this.storagePath, file);\n        const data = await fs.readFile(filePath, 'utf8');\n        const checkpoint: Checkpoint = JSON.parse(data);\n        this.checkpointStore.set(checkpoint.id, checkpoint);\n      }\n      \n      console.log(`üìÅ Loaded ${checkpointFiles.length} checkpoints from disk`);\n    } catch (error) {\n      console.warn('Warning: Failed to load checkpoints from disk:', error);\n    }\n  }\n\n  /**\n   * Load snapshots from disk on startup\n   */\n  async loadSnapshotsFromDisk(): Promise<void> {\n    try {\n      const snapshotDir = path.join(this.storagePath, 'snapshots');\n      const files = await fs.readdir(snapshotDir);\n      const snapshotFiles = files.filter(f => f.startsWith('snapshot_') && f.endsWith('.json'));\n      \n      for (const file of snapshotFiles) {\n        const filePath = path.join(snapshotDir, file);\n        const data = await fs.readFile(filePath, 'utf8');\n        const snapshot: StateSnapshot = JSON.parse(data);\n        this.snapshotStore.set(snapshot.id, snapshot);\n      }\n      \n      console.log(`üìÅ Loaded ${snapshotFiles.length} snapshots from disk`);\n    } catch (error) {\n      console.warn('Warning: Failed to load snapshots from disk:', error);\n    }\n  }\n\n  /**\n   * Cleanup old checkpoints and snapshots\n   */\n  async cleanup(retentionDays: number = 7): Promise<void> {\n    const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\n    let deletedCount = 0;\n\n    // Cleanup checkpoints\n    for (const [id, checkpoint] of this.checkpointStore.entries()) {\n      if (checkpoint.timestamp < cutoffTime) {\n        await this.deleteCheckpoint(id);\n        deletedCount++;\n      }\n    }\n\n    console.log(`üßπ Cleaned up ${deletedCount} old checkpoints (retention: ${retentionDays} days)`);\n  }\n}"],"names":["createHash","promises","fs","path","CheckpointManager","checkpointStore","Map","snapshotStore","storagePath","ensureStorageDirectory","createCheckpoint","description","scope","agentId","taskId","validations","checkpointId","generateCheckpointId","timestamp","Date","now","stateSnapshot","captureSystemState","checkpoint","id","type","agent_id","task_id","required","state_snapshot","storeCheckpoint","console","log","createPreExecutionCheckpoint","name","command","expected_result","passed","weight","execution_time_ms","executeValidations","createPostExecutionCheckpoint","truthScore","listCheckpoints","filter","checkpoints","Array","from","values","from_timestamp","to_timestamp","sort","a","b","getCheckpoint","get","deleteCheckpoint","Error","delete","checkpointFile","join","snapshotFile","unlink","error","warn","snapshotId","generateSnapshotId","stateScope","include_agents","include_tasks","include_memory","include_filesystem","include_database","agent_filter","undefined","task_filter","agentStates","captureAgentStates","systemState","captureSystemState_Component","taskStates","captureTaskStates","memoryState","captureMemoryState","fileSystemState","captureFileSystemState","databaseState","captureDatabaseState","checksum","calculateStateChecksum","metadata","version","created_by","tags","toString","size_bytes","compression_ratio","snapshot","agent_states","system_state","task_states","memory_state","file_system_state","database_state","storeSnapshot","agentFilter","mockAgents","includes","agentState","status","current_task","capabilities","memory","working_memory","long_term_memory","shared_memory_keys","memory_usage_mb","configuration","model","temperature","max_tokens","timeout_ms","retry_attempts","custom_parameters","performance_metrics","response_time_p95_ms","throughput_requests_per_second","error_rate_percentage","cpu_usage_percentage","last_heartbeat","set","uptime_ms","process","uptime","active_agents","active_tasks","memory_usage","disk_usage_mb","network_io_mbps","file_descriptors_used","max_agents","max_concurrent_tasks","truth_threshold","verification_enabled","rollback_enabled","taskFilter","mockTasks","taskState","assigned_agent","dependencies","start_time","progress_percentage","result","total_size_mb","used_size_mb","fragmentation_percentage","cache_hit_rate","active_sessions","total_files","last_modified","checksums","permissions_valid","connection_status","transaction_count","pending_migrations","data_integrity_check","backup_status","stateData","stateString","JSON","stringify","update","digest","validation","startTime","executeValidationCommand","actual_result","compareResults","error_message","message","expectedResult","expected","actual","Math","abs","writeJsonFile","snapshotDir","ensureDirectory","stats","stat","size","dirPath","access","mkdir","recursive","filePath","data","jsonData","writeFile","random","substr","loadCheckpointsFromDisk","files","readdir","checkpointFiles","f","startsWith","endsWith","file","readFile","parse","length","loadSnapshotsFromDisk","snapshotFiles","cleanup","retentionDays","cutoffTime","deletedCount","entries"],"mappings":"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"}