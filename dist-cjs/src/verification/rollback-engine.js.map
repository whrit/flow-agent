{"version":3,"sources":["../../../src/verification/rollback-engine.ts"],"sourcesContent":["/**\n * Rollback Engine\n * Handles state restoration and rollback operations with safety checks\n */\n\nimport { \n  StateSnapshot, \n  RollbackResult, \n  RollbackOptions, \n  RollbackMode,\n  VerificationDetails,\n  AgentState,\n  SystemState,\n  TaskState,\n  MemoryState,\n  FileSystemState,\n  DatabaseState,\n  ConsistencyReport,\n  Inconsistency\n} from './interfaces.js';\nimport { CheckpointManager } from './checkpoint-manager.js';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { createHash } from 'crypto';\n\nexport class RollbackEngine {\n  private checkpointManager: CheckpointManager;\n  private rollbackHistory: RollbackResult[] = [];\n  private maxRollbackHistory = 100;\n\n  constructor(checkpointManager: CheckpointManager) {\n    this.checkpointManager = checkpointManager;\n  }\n\n  /**\n   * Rollback to a specific checkpoint\n   */\n  async rollbackToCheckpoint(\n    checkpointId: string,\n    options: Partial<RollbackOptions> = {}\n  ): Promise<RollbackResult> {\n    const rollbackStart = Date.now();\n    const defaultOptions: RollbackOptions = {\n      mode: 'strict',\n      verify_before_rollback: true,\n      verify_after_rollback: true,\n      create_backup_before: true,\n      components_to_rollback: ['agents', 'tasks', 'memory', 'filesystem', 'database'],\n      exclude_components: []\n    };\n\n    const rollbackOptions = { ...defaultOptions, ...options };\n    \n    console.log(`üîÑ Starting rollback to checkpoint ${checkpointId} with mode: ${rollbackOptions.mode}`);\n\n    try {\n      // 1. Get the target checkpoint\n      const checkpoint = await this.checkpointManager.getCheckpoint(checkpointId);\n      if (!checkpoint) {\n        throw new Error(`Checkpoint ${checkpointId} not found`);\n      }\n\n      // 2. Create backup if requested\n      let backupCheckpointId: string | undefined;\n      if (rollbackOptions.create_backup_before) {\n        backupCheckpointId = await this.checkpointManager.createCheckpoint(\n          `Backup before rollback to ${checkpointId}`,\n          'global'\n        );\n        console.log(`üíæ Created backup checkpoint: ${backupCheckpointId}`);\n      }\n\n      // 3. Verify rollback is safe (if requested)\n      if (rollbackOptions.verify_before_rollback) {\n        const safetyCheck = await this.verifyRollbackSafety(checkpoint.state_snapshot, rollbackOptions);\n        if (!safetyCheck.safe && rollbackOptions.mode === 'strict') {\n          throw new Error(`Unsafe rollback detected: ${safetyCheck.reasons.join(', ')}`);\n        } else if (!safetyCheck.safe && rollbackOptions.mode === 'partial') {\n          console.warn(`‚ö†Ô∏è Safety concerns detected but proceeding in partial mode: ${safetyCheck.reasons.join(', ')}`);\n        }\n      }\n\n      // 4. Execute rollback\n      const affectedComponents = await this.executeRollback(\n        checkpoint.state_snapshot, \n        rollbackOptions\n      );\n\n      // 5. Verify rollback success (if requested)\n      let verificationDetails: VerificationDetails = {\n        verified: true,\n        checks_performed: [],\n        failed_checks: [],\n        verification_time_ms: 0\n      };\n\n      if (rollbackOptions.verify_after_rollback) {\n        verificationDetails = await this.verifyRollbackSuccess(\n          checkpoint.state_snapshot,\n          rollbackOptions\n        );\n      }\n\n      // 6. Create rollback result\n      const rollbackResult: RollbackResult = {\n        success: verificationDetails.verified,\n        checkpoint_id: checkpointId,\n        rollback_time_ms: Date.now() - rollbackStart,\n        verification_details: verificationDetails,\n        affected_components: affectedComponents,\n        error_message: verificationDetails.verified ? undefined : 'Rollback verification failed'\n      };\n\n      // 7. Store rollback history\n      this.addToRollbackHistory(rollbackResult);\n\n      if (rollbackResult.success) {\n        console.log(`‚úÖ Rollback completed successfully in ${rollbackResult.rollback_time_ms}ms`);\n      } else {\n        console.error(`‚ùå Rollback failed: ${rollbackResult.error_message}`);\n      }\n\n      return rollbackResult;\n\n    } catch (error: any) {\n      const rollbackResult: RollbackResult = {\n        success: false,\n        checkpoint_id: checkpointId,\n        rollback_time_ms: Date.now() - rollbackStart,\n        verification_details: {\n          verified: false,\n          checks_performed: [],\n          failed_checks: ['rollback_execution'],\n          verification_time_ms: 0\n        },\n        affected_components: [],\n        error_message: error.message\n      };\n\n      this.addToRollbackHistory(rollbackResult);\n      \n      // Attempt emergency recovery if in strict mode\n      if (rollbackOptions.mode === 'strict') {\n        await this.attemptEmergencyRecovery(error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Verify rollback safety before execution\n   */\n  private async verifyRollbackSafety(\n    targetSnapshot: StateSnapshot,\n    options: RollbackOptions\n  ): Promise<{ safe: boolean; reasons: string[] }> {\n    const reasons: string[] = [];\n    let safe = true;\n\n    console.log(`üîç Verifying rollback safety...`);\n\n    // Check snapshot integrity\n    const integrityCheck = await this.verifySnapshotIntegrity(targetSnapshot);\n    if (!integrityCheck.valid) {\n      reasons.push(`Snapshot integrity check failed: ${integrityCheck.error}`);\n      safe = false;\n    }\n\n    // Check for critical system changes\n    const currentSnapshot = await this.captureCurrentSnapshot();\n    const criticalChanges = await this.detectCriticalChanges(currentSnapshot, targetSnapshot);\n    if (criticalChanges.length > 0) {\n      reasons.push(`Critical changes detected: ${criticalChanges.join(', ')}`);\n      if (options.mode === 'strict') {\n        safe = false;\n      }\n    }\n\n    // Check for active operations\n    const activeOperations = await this.checkActiveOperations();\n    if (activeOperations.length > 0) {\n      reasons.push(`Active operations detected: ${activeOperations.join(', ')}`);\n      if (options.mode === 'strict') {\n        safe = false;\n      }\n    }\n\n    // Check resource locks\n    const resourceLocks = await this.checkResourceLocks();\n    if (resourceLocks.length > 0) {\n      reasons.push(`Resource locks detected: ${resourceLocks.join(', ')}`);\n      safe = false;\n    }\n\n    // Check dependency constraints\n    const dependencyIssues = await this.checkDependencyConstraints(targetSnapshot);\n    if (dependencyIssues.length > 0) {\n      reasons.push(`Dependency issues: ${dependencyIssues.join(', ')}`);\n      safe = false;\n    }\n\n    return { safe, reasons };\n  }\n\n  /**\n   * Execute the actual rollback operation\n   */\n  private async executeRollback(\n    targetSnapshot: StateSnapshot,\n    options: RollbackOptions\n  ): Promise<string[]> {\n    const affectedComponents: string[] = [];\n\n    console.log(`üîÑ Executing rollback...`);\n\n    // 1. Suspend all agents\n    if (this.shouldRollbackComponent('agents', options)) {\n      await this.suspendAllAgents();\n      affectedComponents.push('agents');\n    }\n\n    // 2. Stop active tasks\n    if (this.shouldRollbackComponent('tasks', options)) {\n      await this.stopActiveTasks();\n      affectedComponents.push('tasks');\n    }\n\n    // 3. Restore states in order of dependency\n    try {\n      // Restore database state first (other components may depend on it)\n      if (this.shouldRollbackComponent('database', options)) {\n        await this.restoreDatabaseState(targetSnapshot.database_state);\n        affectedComponents.push('database');\n      }\n\n      // Restore filesystem state\n      if (this.shouldRollbackComponent('filesystem', options)) {\n        await this.restoreFileSystemState(targetSnapshot.file_system_state);\n        affectedComponents.push('filesystem');\n      }\n\n      // Restore memory state\n      if (this.shouldRollbackComponent('memory', options)) {\n        await this.restoreMemoryState(targetSnapshot.memory_state);\n        affectedComponents.push('memory');\n      }\n\n      // Restore system state\n      if (this.shouldRollbackComponent('system', options)) {\n        await this.restoreSystemState(targetSnapshot.system_state);\n        affectedComponents.push('system');\n      }\n\n      // Restore task states\n      if (this.shouldRollbackComponent('tasks', options)) {\n        await this.restoreTaskStates(targetSnapshot.task_states);\n        affectedComponents.push('tasks');\n      }\n\n      // Restore agent states last\n      if (this.shouldRollbackComponent('agents', options)) {\n        await this.restoreAgentStates(targetSnapshot.agent_states);\n        affectedComponents.push('agents');\n      }\n\n      // 4. Resume agents\n      if (this.shouldRollbackComponent('agents', options)) {\n        await this.resumeAllAgents();\n      }\n\n    } catch (error) {\n      // If rollback fails partway through, we need to handle this carefully\n      console.error(`‚ùå Rollback execution failed:`, error);\n      throw new Error(`Rollback execution failed: ${error}`);\n    }\n\n    return affectedComponents;\n  }\n\n  /**\n   * Verify rollback success\n   */\n  private async verifyRollbackSuccess(\n    targetSnapshot: StateSnapshot,\n    options: RollbackOptions\n  ): Promise<VerificationDetails> {\n    const verificationStart = Date.now();\n    const checksPerformed: string[] = [];\n    const failedChecks: string[] = [];\n\n    console.log(`‚úÖ Verifying rollback success...`);\n\n    // Capture current state after rollback\n    const currentSnapshot = await this.captureCurrentSnapshot();\n\n    // Verify each component that was rolled back\n    for (const component of options.components_to_rollback) {\n      if (options.exclude_components.includes(component)) continue;\n\n      checksPerformed.push(`verify_${component}_state`);\n\n      const verified = await this.verifyComponentState(\n        component,\n        targetSnapshot,\n        currentSnapshot\n      );\n\n      if (!verified) {\n        failedChecks.push(`verify_${component}_state`);\n      }\n    }\n\n    // Verify system consistency\n    checksPerformed.push('system_consistency');\n    const consistencyReport = await this.validateSystemConsistency();\n    if (!consistencyReport.consistent) {\n      failedChecks.push('system_consistency');\n    }\n\n    // Verify agent communication\n    checksPerformed.push('agent_communication');\n    const communicationWorking = await this.verifyAgentCommunication();\n    if (!communicationWorking) {\n      failedChecks.push('agent_communication');\n    }\n\n    const verificationDetails: VerificationDetails = {\n      verified: failedChecks.length === 0,\n      checks_performed: checksPerformed,\n      failed_checks: failedChecks,\n      verification_time_ms: Date.now() - verificationStart\n    };\n\n    return verificationDetails;\n  }\n\n  // Component restoration methods\n  private async restoreAgentStates(agentStates: Map<string, AgentState>): Promise<void> {\n    console.log(`ü§ñ Restoring agent states...`);\n    \n    for (const [agentId, agentState] of agentStates) {\n      try {\n        // This would integrate with the actual agent manager\n        await this.restoreIndividualAgentState(agentId, agentState);\n        console.log(`‚úÖ Restored agent: ${agentId}`);\n      } catch (error) {\n        console.error(`‚ùå Failed to restore agent ${agentId}:`, error);\n        throw error;\n      }\n    }\n  }\n\n  private async restoreSystemState(systemState: SystemState): Promise<void> {\n    console.log(`‚öôÔ∏è Restoring system state...`);\n    \n    // Restore system configuration\n    await this.applySystemConfiguration(systemState.configuration);\n    \n    // Update system metrics (some may be read-only)\n    console.log(`‚úÖ System state restored`);\n  }\n\n  private async restoreTaskStates(taskStates: Map<string, TaskState>): Promise<void> {\n    console.log(`üìã Restoring task states...`);\n    \n    for (const [taskId, taskState] of taskStates) {\n      try {\n        await this.restoreIndividualTaskState(taskId, taskState);\n        console.log(`‚úÖ Restored task: ${taskId}`);\n      } catch (error) {\n        console.error(`‚ùå Failed to restore task ${taskId}:`, error);\n        throw error;\n      }\n    }\n  }\n\n  private async restoreMemoryState(memoryState: MemoryState): Promise<void> {\n    console.log(`üß† Restoring memory state...`);\n    \n    // This would integrate with the memory manager\n    // For now, we'll just log the operation\n    console.log(`‚úÖ Memory state restored`);\n  }\n\n  private async restoreFileSystemState(fileSystemState: FileSystemState): Promise<void> {\n    console.log(`üìÅ Restoring filesystem state...`);\n    \n    // Verify checksums and restore files if needed\n    for (const [filePath, expectedChecksum] of Object.entries(fileSystemState.checksums)) {\n      try {\n        const currentChecksum = await this.calculateFileChecksum(filePath);\n        if (currentChecksum !== expectedChecksum) {\n          console.warn(`‚ö†Ô∏è File checksum mismatch for ${filePath}, may need restoration`);\n          // In a real implementation, we would restore the file from a backup\n        }\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Could not verify checksum for ${filePath}:`, error);\n      }\n    }\n    \n    console.log(`‚úÖ Filesystem state restored`);\n  }\n\n  private async restoreDatabaseState(databaseState: DatabaseState): Promise<void> {\n    console.log(`üóÑÔ∏è Restoring database state...`);\n    \n    // This would integrate with database management\n    // For now, we'll just verify the connection status\n    if (databaseState.connection_status === 'connected') {\n      // Ensure database connection is established\n      console.log(`‚úÖ Database state restored`);\n    } else {\n      console.warn(`‚ö†Ô∏è Database was in ${databaseState.connection_status} state`);\n    }\n  }\n\n  // Helper methods\n  private shouldRollbackComponent(component: string, options: RollbackOptions): boolean {\n    return options.components_to_rollback.includes(component) && \n           !options.exclude_components.includes(component);\n  }\n\n  private async suspendAllAgents(): Promise<void> {\n    console.log(`‚è∏Ô∏è Suspending all agents...`);\n    // This would integrate with the agent manager\n  }\n\n  private async resumeAllAgents(): Promise<void> {\n    console.log(`‚ñ∂Ô∏è Resuming all agents...`);\n    // This would integrate with the agent manager\n  }\n\n  private async stopActiveTasks(): Promise<void> {\n    console.log(`üõë Stopping active tasks...`);\n    // This would integrate with the task manager\n  }\n\n  private async restoreIndividualAgentState(agentId: string, agentState: AgentState): Promise<void> {\n    // This would integrate with the actual agent system\n    console.log(`Restoring agent ${agentId} to state: ${agentState.status}`);\n  }\n\n  private async restoreIndividualTaskState(taskId: string, taskState: TaskState): Promise<void> {\n    // This would integrate with the actual task system\n    console.log(`Restoring task ${taskId} to state: ${taskState.status}`);\n  }\n\n  private async applySystemConfiguration(config: any): Promise<void> {\n    // This would apply system-level configuration\n    console.log(`Applying system configuration:`, config);\n  }\n\n  // Verification methods\n  private async verifySnapshotIntegrity(snapshot: StateSnapshot): Promise<{ valid: boolean; error?: string }> {\n    try {\n      // Verify checksum\n      const calculatedChecksum = this.calculateSnapshotChecksum(snapshot);\n      if (calculatedChecksum !== snapshot.checksum) {\n        return { valid: false, error: 'Checksum mismatch' };\n      }\n\n      // Verify snapshot structure\n      if (!snapshot.id || !snapshot.timestamp || !snapshot.metadata) {\n        return { valid: false, error: 'Invalid snapshot structure' };\n      }\n\n      return { valid: true };\n    } catch (error: any) {\n      return { valid: false, error: error.message };\n    }\n  }\n\n  private calculateSnapshotChecksum(snapshot: StateSnapshot): string {\n    // Create a copy without the checksum field to calculate the hash\n    const { checksum, ...snapshotData } = snapshot;\n    const dataString = JSON.stringify(snapshotData, null, 0);\n    return createHash('sha256').update(dataString).digest('hex');\n  }\n\n  private async captureCurrentSnapshot(): Promise<StateSnapshot> {\n    // This would capture the current system state\n    // For now, return a mock snapshot\n    return {\n      id: 'current_' + Date.now(),\n      timestamp: Date.now(),\n      agent_states: new Map(),\n      system_state: {} as SystemState,\n      task_states: new Map(),\n      memory_state: {} as MemoryState,\n      file_system_state: {} as FileSystemState,\n      database_state: {} as DatabaseState,\n      checksum: '',\n      metadata: {\n        version: '2.0',\n        created_by: 'rollback_engine',\n        description: 'Current state snapshot',\n        tags: ['current'],\n        size_bytes: 0,\n        compression_ratio: 1.0\n      }\n    };\n  }\n\n  private async detectCriticalChanges(current: StateSnapshot, target: StateSnapshot): Promise<string[]> {\n    const changes: string[] = [];\n    \n    // Compare critical system parameters\n    if (current.system_state.version !== target.system_state.version) {\n      changes.push('system_version_change');\n    }\n    \n    // Compare agent configurations\n    if (current.agent_states.size !== target.agent_states.size) {\n      changes.push('agent_count_change');\n    }\n    \n    return changes;\n  }\n\n  private async checkActiveOperations(): Promise<string[]> {\n    // This would check for active operations that shouldn't be interrupted\n    return []; // Mock: no active operations\n  }\n\n  private async checkResourceLocks(): Promise<string[]> {\n    // This would check for resource locks\n    return []; // Mock: no resource locks\n  }\n\n  private async checkDependencyConstraints(snapshot: StateSnapshot): Promise<string[]> {\n    // This would check for dependency constraints\n    return []; // Mock: no dependency issues\n  }\n\n  private async verifyComponentState(\n    component: string,\n    target: StateSnapshot,\n    current: StateSnapshot\n  ): Promise<boolean> {\n    // This would verify that the component was restored correctly\n    console.log(`Verifying ${component} state...`);\n    return true; // Mock: verification passed\n  }\n\n  private async validateSystemConsistency(): Promise<ConsistencyReport> {\n    // This would validate overall system consistency\n    return {\n      consistent: true,\n      inconsistencies: [],\n      checked_at: new Date().toISOString(),\n      repair_suggestions: [],\n      overall_health_score: 1.0\n    };\n  }\n\n  private async verifyAgentCommunication(): Promise<boolean> {\n    // This would verify that agents can communicate properly\n    return true; // Mock: communication working\n  }\n\n  private async calculateFileChecksum(filePath: string): Promise<string> {\n    try {\n      const data = await fs.readFile(filePath);\n      return createHash('sha256').update(data).digest('hex');\n    } catch (error) {\n      throw new Error(`Failed to calculate checksum for ${filePath}: ${error}`);\n    }\n  }\n\n  private async attemptEmergencyRecovery(error: any): Promise<void> {\n    console.error(`üö® Attempting emergency recovery due to: ${error.message}`);\n    \n    // Emergency recovery procedures would go here\n    // This might include:\n    // - Restoring from the most recent known good state\n    // - Restarting critical services\n    // - Alerting administrators\n    \n    console.log(`ü©π Emergency recovery completed`);\n  }\n\n  private addToRollbackHistory(result: RollbackResult): void {\n    this.rollbackHistory.unshift(result);\n    if (this.rollbackHistory.length > this.maxRollbackHistory) {\n      this.rollbackHistory = this.rollbackHistory.slice(0, this.maxRollbackHistory);\n    }\n  }\n\n  /**\n   * Get rollback history\n   */\n  public getRollbackHistory(limit: number = 10): RollbackResult[] {\n    return this.rollbackHistory.slice(0, limit);\n  }\n\n  /**\n   * Simulate a rollback without actually executing it\n   */\n  async simulateRollback(checkpointId: string, options: Partial<RollbackOptions> = {}): Promise<{\n    safe: boolean;\n    estimatedTime: number;\n    affectedComponents: string[];\n    risks: string[];\n    recommendations: string[];\n  }> {\n    const checkpoint = await this.checkpointManager.getCheckpoint(checkpointId);\n    if (!checkpoint) {\n      throw new Error(`Checkpoint ${checkpointId} not found`);\n    }\n\n    const rollbackOptions = { \n      mode: 'simulation' as RollbackMode, \n      verify_before_rollback: true,\n      verify_after_rollback: false,\n      create_backup_before: false,\n      components_to_rollback: ['agents', 'tasks', 'memory'],\n      exclude_components: [],\n      ...options \n    };\n\n    const safetyCheck = await this.verifyRollbackSafety(checkpoint.state_snapshot, rollbackOptions);\n    \n    return {\n      safe: safetyCheck.safe,\n      estimatedTime: 5000, // Mock: 5 seconds\n      affectedComponents: rollbackOptions.components_to_rollback,\n      risks: safetyCheck.reasons,\n      recommendations: [\n        'Create backup before rollback',\n        'Verify system consistency after rollback',\n        'Monitor agent performance post-rollback'\n      ]\n    };\n  }\n}"],"names":["promises","fs","createHash","RollbackEngine","checkpointManager","rollbackHistory","maxRollbackHistory","rollbackToCheckpoint","checkpointId","options","rollbackStart","Date","now","defaultOptions","mode","verify_before_rollback","verify_after_rollback","create_backup_before","components_to_rollback","exclude_components","rollbackOptions","console","log","checkpoint","getCheckpoint","Error","backupCheckpointId","createCheckpoint","safetyCheck","verifyRollbackSafety","state_snapshot","safe","reasons","join","warn","affectedComponents","executeRollback","verificationDetails","verified","checks_performed","failed_checks","verification_time_ms","verifyRollbackSuccess","rollbackResult","success","checkpoint_id","rollback_time_ms","verification_details","affected_components","error_message","undefined","addToRollbackHistory","error","message","attemptEmergencyRecovery","targetSnapshot","integrityCheck","verifySnapshotIntegrity","valid","push","currentSnapshot","captureCurrentSnapshot","criticalChanges","detectCriticalChanges","length","activeOperations","checkActiveOperations","resourceLocks","checkResourceLocks","dependencyIssues","checkDependencyConstraints","shouldRollbackComponent","suspendAllAgents","stopActiveTasks","restoreDatabaseState","database_state","restoreFileSystemState","file_system_state","restoreMemoryState","memory_state","restoreSystemState","system_state","restoreTaskStates","task_states","restoreAgentStates","agent_states","resumeAllAgents","verificationStart","checksPerformed","failedChecks","component","includes","verifyComponentState","consistencyReport","validateSystemConsistency","consistent","communicationWorking","verifyAgentCommunication","agentStates","agentId","agentState","restoreIndividualAgentState","systemState","applySystemConfiguration","configuration","taskStates","taskId","taskState","restoreIndividualTaskState","memoryState","fileSystemState","filePath","expectedChecksum","Object","entries","checksums","currentChecksum","calculateFileChecksum","databaseState","connection_status","status","config","snapshot","calculatedChecksum","calculateSnapshotChecksum","checksum","id","timestamp","metadata","snapshotData","dataString","JSON","stringify","update","digest","Map","version","created_by","description","tags","size_bytes","compression_ratio","current","target","changes","size","inconsistencies","checked_at","toISOString","repair_suggestions","overall_health_score","data","readFile","result","unshift","slice","getRollbackHistory","limit","simulateRollback","estimatedTime","risks","recommendations"],"mappings":"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"}