{"version":3,"sources":["../../../src/verification/middleware.ts"],"sourcesContent":["/**\n * Security Middleware System\n * \n * Extensible middleware framework for security enforcement,\n * threat intelligence integration, and dynamic security policies.\n */\n\nimport { EventEmitter } from 'events';\nimport { VerificationRequest, VerificationResult } from './security';\nimport { SecurityMiddleware, SecurityAlert, ThreatLevel, AttackPattern } from './types';\n\n// ======================== MIDDLEWARE MANAGER ========================\n\nexport class SecurityMiddlewareManager {\n  private middlewares: SecurityMiddleware[] = [];\n  private eventBus: EventEmitter;\n\n  constructor() {\n    this.eventBus = new EventEmitter();\n  }\n\n  // Register security middleware\n  registerMiddleware(middleware: SecurityMiddleware): void {\n    this.middlewares.push(middleware);\n    this.middlewares.sort((a, b) => a.priority - b.priority);\n    console.log(`Registered security middleware: ${middleware.name} (priority: ${middleware.priority})`);\n  }\n\n  // Unregister middleware\n  unregisterMiddleware(name: string): boolean {\n    const index = this.middlewares.findIndex(m => m.name === name);\n    if (index >= 0) {\n      this.middlewares.splice(index, 1);\n      console.log(`Unregistered security middleware: ${name}`);\n      return true;\n    }\n    return false;\n  }\n\n  // Execute before-verification middleware\n  async executeBeforeVerification(request: VerificationRequest): Promise<void> {\n    for (const middleware of this.middlewares) {\n      if (middleware.beforeVerification) {\n        try {\n          await middleware.beforeVerification(request);\n        } catch (error) {\n          console.error(`Middleware ${middleware.name} before-verification failed:`, error);\n          throw error;\n        }\n      }\n    }\n  }\n\n  // Execute after-verification middleware\n  async executeAfterVerification(result: VerificationResult): Promise<void> {\n    for (const middleware of this.middlewares) {\n      if (middleware.afterVerification) {\n        try {\n          await middleware.afterVerification(result);\n        } catch (error) {\n          console.error(`Middleware ${middleware.name} after-verification failed:`, error);\n          // Non-critical errors in post-processing shouldn't fail the verification\n        }\n      }\n    }\n  }\n\n  // Execute error handling middleware\n  async executeErrorHandling(error: Error): Promise<void> {\n    for (const middleware of this.middlewares) {\n      if (middleware.onError) {\n        try {\n          await middleware.onError(error);\n        } catch (middlewareError) {\n          console.error(`Middleware ${middleware.name} error handling failed:`, middlewareError);\n        }\n      }\n    }\n  }\n\n  // Get registered middleware info\n  getMiddlewareInfo(): Array<{ name: string; priority: number }> {\n    return this.middlewares.map(m => ({ name: m.name, priority: m.priority }));\n  }\n}\n\n// ======================== THREAT INTELLIGENCE MIDDLEWARE ========================\n\nexport class ThreatIntelligenceMiddleware implements SecurityMiddleware {\n  name = 'ThreatIntelligence';\n  priority = 100;\n\n  private threatIndicators = new Set<string>();\n  private attackPatterns = new Map<string, AttackPattern>();\n  private threatDatabase: Map<string, ThreatLevel> = new Map();\n\n  constructor() {\n    this.initializeDefaultThreats();\n  }\n\n  private initializeDefaultThreats(): void {\n    // Known malicious patterns\n    this.threatIndicators.add('bypass_attempt');\n    this.threatIndicators.add('injection_attack');\n    this.threatIndicators.add('brute_force');\n    this.threatIndicators.add('social_engineering');\n\n    // Attack patterns\n    this.attackPatterns.set('rapid_requests', {\n      patternId: 'rapid_requests',\n      name: 'Rapid Request Pattern',\n      description: 'Multiple requests in very short time span',\n      indicators: ['high_frequency', 'same_agent', 'similar_payload'],\n      severity: 'MEDIUM',\n      mitigation: ['rate_limiting', 'temporary_ban'],\n      frequency: 0\n    });\n\n    this.attackPatterns.set('credential_stuffing', {\n      patternId: 'credential_stuffing',\n      name: 'Credential Stuffing',\n      description: 'Multiple authentication attempts with different credentials',\n      indicators: ['multiple_failed_auth', 'different_credentials', 'same_source'],\n      severity: 'HIGH',\n      mitigation: ['account_lockout', 'ip_blocking', 'captcha'],\n      frequency: 0\n    });\n  }\n\n  async beforeVerification(request: VerificationRequest): Promise<void> {\n    // Check for threat indicators in request\n    await this.analyzeThreatIndicators(request);\n    \n    // Check for known attack patterns\n    await this.checkAttackPatterns(request);\n    \n    // Update threat intelligence\n    await this.updateThreatIntelligence(request);\n  }\n\n  async afterVerification(result: VerificationResult): Promise<void> {\n    // Analyze verification results for threat patterns\n    await this.analyzeVerificationResults(result);\n  }\n\n  async onError(error: Error): Promise<void> {\n    // Log security errors for threat analysis\n    console.log(`Security error logged for threat analysis: ${error.message}`);\n  }\n\n  // Add new threat indicator\n  addThreatIndicator(indicator: string): void {\n    this.threatIndicators.add(indicator.toLowerCase());\n    console.log(`Added threat indicator: ${indicator}`);\n  }\n\n  // Remove threat indicator\n  removeThreatIndicator(indicator: string): void {\n    this.threatIndicators.delete(indicator.toLowerCase());\n    console.log(`Removed threat indicator: ${indicator}`);\n  }\n\n  // Add attack pattern\n  addAttackPattern(pattern: AttackPattern): void {\n    this.attackPatterns.set(pattern.patternId, pattern);\n    console.log(`Added attack pattern: ${pattern.name}`);\n  }\n\n  // Get threat level for agent\n  getThreatLevel(agentId: string): ThreatLevel | null {\n    return this.threatDatabase.get(agentId) || null;\n  }\n\n  private async analyzeThreatIndicators(request: VerificationRequest): Promise<void> {\n    const requestContent = JSON.stringify(request).toLowerCase();\n    \n    for (const indicator of this.threatIndicators) {\n      if (requestContent.includes(indicator)) {\n        console.warn(`Threat indicator detected: ${indicator} in request from ${request.agentId}`);\n        \n        // Update threat level for agent\n        const currentThreat = this.threatDatabase.get(request.agentId) || {\n          level: 'LOW',\n          score: 0,\n          indicators: [],\n          mitigationActions: []\n        };\n\n        currentThreat.indicators.push(indicator);\n        currentThreat.score += 10;\n        \n        if (currentThreat.score >= 50) currentThreat.level = 'HIGH';\n        else if (currentThreat.score >= 25) currentThreat.level = 'MEDIUM';\n\n        this.threatDatabase.set(request.agentId, currentThreat);\n        \n        // Throw error for high-threat indicators\n        if (currentThreat.level === 'HIGH') {\n          throw new Error(`High threat level detected for agent ${request.agentId}: ${indicator}`);\n        }\n      }\n    }\n  }\n\n  private async checkAttackPatterns(request: VerificationRequest): Promise<void> {\n    // Check for rapid request pattern\n    const now = Date.now();\n    const requestKey = `${request.agentId}_requests`;\n    \n    // In a real implementation, this would use persistent storage\n    // For now, we'll simulate pattern detection\n    if (request.timestamp.getTime() > now - 5000) { // Within last 5 seconds\n      const pattern = this.attackPatterns.get('rapid_requests');\n      if (pattern) {\n        pattern.frequency++;\n        console.warn(`Attack pattern detected: ${pattern.name} for agent ${request.agentId}`);\n      }\n    }\n  }\n\n  private async updateThreatIntelligence(request: VerificationRequest): Promise<void> {\n    // Update threat intelligence based on request patterns\n    // This would typically involve external threat intelligence feeds\n    \n    // For demonstration, we'll just log the update\n    console.debug(`Threat intelligence updated for agent: ${request.agentId}`);\n  }\n\n  private async analyzeVerificationResults(result: VerificationResult): Promise<void> {\n    // Analyze verification results for threat patterns\n    if (result.confidence < 0.5) {\n      console.warn(`Low confidence verification result: ${result.confidence} for agent ${result.agentId}`);\n      \n      // Update threat level\n      const currentThreat = this.threatDatabase.get(result.agentId) || {\n        level: 'LOW',\n        score: 0,\n        indicators: [],\n        mitigationActions: []\n      };\n\n      currentThreat.indicators.push('low_confidence_result');\n      currentThreat.score += 5;\n      this.threatDatabase.set(result.agentId, currentThreat);\n    }\n  }\n\n  // Export threat intelligence data\n  exportThreatIntelligence(): {\n    threatIndicators: string[];\n    attackPatterns: AttackPattern[];\n    agentThreatLevels: Array<{ agentId: string; threatLevel: ThreatLevel }>;\n  } {\n    return {\n      threatIndicators: Array.from(this.threatIndicators),\n      attackPatterns: Array.from(this.attackPatterns.values()),\n      agentThreatLevels: Array.from(this.threatDatabase.entries()).map(([agentId, threatLevel]) => ({\n        agentId,\n        threatLevel\n      }))\n    };\n  }\n}\n\n// ======================== IP FILTERING MIDDLEWARE ========================\n\nexport class IPFilterMiddleware implements SecurityMiddleware {\n  name = 'IPFilter';\n  priority = 50;\n\n  private whitelist: Set<string>;\n  private blacklist: Set<string>;\n  private geoBlockList: Set<string>;\n\n  constructor(whitelist: string[] = [], blacklist: string[] = [], geoBlockList: string[] = []) {\n    this.whitelist = new Set(whitelist);\n    this.blacklist = new Set(blacklist);\n    this.geoBlockList = new Set(geoBlockList);\n  }\n\n  async beforeVerification(request: VerificationRequest): Promise<void> {\n    // In a real implementation, we would extract IP from request context\n    // For demonstration, we'll simulate IP checking\n    const simulatedIP = this.extractIPFromRequest(request);\n    \n    if (simulatedIP) {\n      await this.checkIPRestrictions(simulatedIP, request.agentId);\n    }\n  }\n\n  private extractIPFromRequest(request: VerificationRequest): string | null {\n    // Simulate IP extraction - in real implementation, this would come from request headers\n    return `192.168.1.${Math.floor(Math.random() * 255)}`;\n  }\n\n  private async checkIPRestrictions(ip: string, agentId: string): Promise<void> {\n    // Check blacklist first\n    if (this.blacklist.has(ip)) {\n      throw new Error(`IP ${ip} is blacklisted for agent ${agentId}`);\n    }\n\n    // Check whitelist (if not empty, only allow whitelisted IPs)\n    if (this.whitelist.size > 0 && !this.whitelist.has(ip)) {\n      throw new Error(`IP ${ip} is not whitelisted for agent ${agentId}`);\n    }\n\n    // Check geolocation blocking (simplified)\n    const countryCode = await this.getCountryCode(ip);\n    if (countryCode && this.geoBlockList.has(countryCode)) {\n      throw new Error(`Requests from ${countryCode} are blocked for agent ${agentId}`);\n    }\n  }\n\n  private async getCountryCode(ip: string): Promise<string | null> {\n    // Simulate geolocation lookup\n    const countries = ['US', 'CA', 'GB', 'DE', 'FR', 'JP', 'AU', 'CN', 'RU'];\n    return countries[Math.floor(Math.random() * countries.length)];\n  }\n\n  // Add IP to whitelist\n  addToWhitelist(ip: string): void {\n    this.whitelist.add(ip);\n    console.log(`Added ${ip} to IP whitelist`);\n  }\n\n  // Add IP to blacklist\n  addToBlacklist(ip: string): void {\n    this.blacklist.add(ip);\n    console.log(`Added ${ip} to IP blacklist`);\n  }\n\n  // Add country to geo-block list\n  addToGeoBlock(countryCode: string): void {\n    this.geoBlockList.add(countryCode.toUpperCase());\n    console.log(`Added ${countryCode} to geo-block list`);\n  }\n}\n\n// ======================== LOGGING MIDDLEWARE ========================\n\nexport class SecurityLoggingMiddleware implements SecurityMiddleware {\n  name = 'SecurityLogging';\n  priority = 10; // Low priority, runs last\n\n  private logBuffer: Array<{\n    timestamp: Date;\n    type: 'REQUEST' | 'RESULT' | 'ERROR';\n    agentId: string;\n    data: any;\n  }> = [];\n\n  async beforeVerification(request: VerificationRequest): Promise<void> {\n    this.logBuffer.push({\n      timestamp: new Date(),\n      type: 'REQUEST',\n      agentId: request.agentId,\n      data: {\n        requestId: request.requestId,\n        truthClaimType: typeof request.truthClaim,\n        hasSignature: !!request.signature\n      }\n    });\n\n    // Flush log buffer if it gets too large\n    if (this.logBuffer.length > 1000) {\n      await this.flushLogs();\n    }\n  }\n\n  async afterVerification(result: VerificationResult): Promise<void> {\n    this.logBuffer.push({\n      timestamp: new Date(),\n      type: 'RESULT',\n      agentId: result.agentId,\n      data: {\n        resultId: result.resultId,\n        verified: result.verified,\n        confidence: result.confidence,\n        evidenceCount: result.evidence.length\n      }\n    });\n  }\n\n  async onError(error: Error): Promise<void> {\n    this.logBuffer.push({\n      timestamp: new Date(),\n      type: 'ERROR',\n      agentId: 'system',\n      data: {\n        errorMessage: error.message,\n        errorType: error.constructor.name\n      }\n    });\n  }\n\n  // Flush logs to persistent storage\n  private async flushLogs(): Promise<void> {\n    // In a real implementation, this would write to a database or log aggregation service\n    console.log(`Flushing ${this.logBuffer.length} security log entries`);\n    \n    // For demonstration, we'll just clear the buffer\n    this.logBuffer.length = 0;\n  }\n\n  // Export logs for analysis\n  exportLogs(): any[] {\n    return [...this.logBuffer];\n  }\n\n  // Get log statistics\n  getLogStatistics(): {\n    totalEntries: number;\n    requestCount: number;\n    resultCount: number;\n    errorCount: number;\n    timespan: { start: Date | null; end: Date | null };\n  } {\n    const requestCount = this.logBuffer.filter(log => log.type === 'REQUEST').length;\n    const resultCount = this.logBuffer.filter(log => log.type === 'RESULT').length;\n    const errorCount = this.logBuffer.filter(log => log.type === 'ERROR').length;\n    \n    const timestamps = this.logBuffer.map(log => log.timestamp);\n    const start = timestamps.length > 0 ? new Date(Math.min(...timestamps.map(t => t.getTime()))) : null;\n    const end = timestamps.length > 0 ? new Date(Math.max(...timestamps.map(t => t.getTime()))) : null;\n\n    return {\n      totalEntries: this.logBuffer.length,\n      requestCount,\n      resultCount,\n      errorCount,\n      timespan: { start, end }\n    };\n  }\n}\n\n// ======================== PERFORMANCE MONITORING MIDDLEWARE ========================\n\nexport class PerformanceMonitoringMiddleware implements SecurityMiddleware {\n  name = 'PerformanceMonitoring';\n  priority = 20;\n\n  private performanceMetrics = new Map<string, {\n    requestCount: number;\n    totalResponseTime: number;\n    averageResponseTime: number;\n    maxResponseTime: number;\n    minResponseTime: number;\n    errorCount: number;\n  }>();\n\n  private requestStartTimes = new Map<string, number>();\n\n  async beforeVerification(request: VerificationRequest): Promise<void> {\n    this.requestStartTimes.set(request.requestId, Date.now());\n  }\n\n  async afterVerification(result: VerificationResult): Promise<void> {\n    const startTime = this.requestStartTimes.get(result.requestId);\n    if (startTime) {\n      const responseTime = Date.now() - startTime;\n      this.updateMetrics(result.agentId, responseTime, false);\n      this.requestStartTimes.delete(result.requestId);\n    }\n  }\n\n  async onError(error: Error): Promise<void> {\n    // Try to find the associated request for error metrics\n    // In a real implementation, we'd have better error context\n    console.debug('Performance monitoring: Error recorded');\n  }\n\n  private updateMetrics(agentId: string, responseTime: number, isError: boolean): void {\n    let metrics = this.performanceMetrics.get(agentId);\n    \n    if (!metrics) {\n      metrics = {\n        requestCount: 0,\n        totalResponseTime: 0,\n        averageResponseTime: 0,\n        maxResponseTime: 0,\n        minResponseTime: Infinity,\n        errorCount: 0\n      };\n    }\n\n    metrics.requestCount++;\n    \n    if (isError) {\n      metrics.errorCount++;\n    } else {\n      metrics.totalResponseTime += responseTime;\n      metrics.averageResponseTime = metrics.totalResponseTime / (metrics.requestCount - metrics.errorCount);\n      metrics.maxResponseTime = Math.max(metrics.maxResponseTime, responseTime);\n      metrics.minResponseTime = Math.min(metrics.minResponseTime, responseTime);\n    }\n\n    this.performanceMetrics.set(agentId, metrics);\n  }\n\n  // Get performance metrics for specific agent\n  getAgentMetrics(agentId: string): any {\n    return this.performanceMetrics.get(agentId) || null;\n  }\n\n  // Get system-wide performance metrics\n  getSystemMetrics(): {\n    totalRequests: number;\n    totalErrors: number;\n    averageSystemResponseTime: number;\n    agentCount: number;\n    slowestAgent: string | null;\n    fastestAgent: string | null;\n  } {\n    const agents = Array.from(this.performanceMetrics.entries());\n    \n    const totalRequests = agents.reduce((sum, [_, metrics]) => sum + metrics.requestCount, 0);\n    const totalErrors = agents.reduce((sum, [_, metrics]) => sum + metrics.errorCount, 0);\n    \n    const validAgents = agents.filter(([_, metrics]) => metrics.requestCount > metrics.errorCount);\n    const totalResponseTime = validAgents.reduce((sum, [_, metrics]) => sum + metrics.totalResponseTime, 0);\n    const totalSuccessfulRequests = validAgents.reduce((sum, [_, metrics]) => sum + (metrics.requestCount - metrics.errorCount), 0);\n    \n    const averageSystemResponseTime = totalSuccessfulRequests > 0 ? totalResponseTime / totalSuccessfulRequests : 0;\n    \n    let slowestAgent: string | null = null;\n    let fastestAgent: string | null = null;\n    let maxAvgTime = 0;\n    let minAvgTime = Infinity;\n    \n    for (const [agentId, metrics] of validAgents) {\n      if (metrics.averageResponseTime > maxAvgTime) {\n        maxAvgTime = metrics.averageResponseTime;\n        slowestAgent = agentId;\n      }\n      if (metrics.averageResponseTime < minAvgTime) {\n        minAvgTime = metrics.averageResponseTime;\n        fastestAgent = agentId;\n      }\n    }\n\n    return {\n      totalRequests,\n      totalErrors,\n      averageSystemResponseTime,\n      agentCount: agents.length,\n      slowestAgent,\n      fastestAgent\n    };\n  }\n\n  // Reset metrics\n  resetMetrics(): void {\n    this.performanceMetrics.clear();\n    this.requestStartTimes.clear();\n    console.log('Performance metrics reset');\n  }\n}\n\n// ======================== COMPLIANCE MONITORING MIDDLEWARE ========================\n\nexport class ComplianceMonitoringMiddleware implements SecurityMiddleware {\n  name = 'ComplianceMonitoring';\n  priority = 30;\n\n  private complianceEvents: Array<{\n    timestamp: Date;\n    eventType: string;\n    agentId: string;\n    complianceLevel: 'PASS' | 'WARN' | 'FAIL';\n    details: any;\n  }> = [];\n\n  private complianceRules = new Map<string, (request: VerificationRequest) => boolean>();\n\n  constructor() {\n    this.initializeComplianceRules();\n  }\n\n  private initializeComplianceRules(): void {\n    // Example compliance rules\n    this.complianceRules.set('signature_required', (request) => !!request.signature);\n    this.complianceRules.set('timestamp_recent', (request) => {\n      const now = Date.now();\n      const requestTime = request.timestamp.getTime();\n      return (now - requestTime) < 60000; // Within 1 minute\n    });\n    this.complianceRules.set('nonce_present', (request) => !!request.nonce);\n  }\n\n  async beforeVerification(request: VerificationRequest): Promise<void> {\n    await this.checkCompliance(request);\n  }\n\n  async afterVerification(result: VerificationResult): Promise<void> {\n    // Log successful compliance check\n    this.complianceEvents.push({\n      timestamp: new Date(),\n      eventType: 'VERIFICATION_COMPLETED',\n      agentId: result.agentId,\n      complianceLevel: 'PASS',\n      details: { resultId: result.resultId, verified: result.verified }\n    });\n  }\n\n  async onError(error: Error): Promise<void> {\n    // Log compliance failure\n    this.complianceEvents.push({\n      timestamp: new Date(),\n      eventType: 'COMPLIANCE_ERROR',\n      agentId: 'unknown',\n      complianceLevel: 'FAIL',\n      details: { error: error.message }\n    });\n  }\n\n  private async checkCompliance(request: VerificationRequest): Promise<void> {\n    for (const [ruleName, ruleFunc] of this.complianceRules) {\n      const isCompliant = ruleFunc(request);\n      \n      if (!isCompliant) {\n        this.complianceEvents.push({\n          timestamp: new Date(),\n          eventType: 'COMPLIANCE_VIOLATION',\n          agentId: request.agentId,\n          complianceLevel: 'FAIL',\n          details: { rule: ruleName, requestId: request.requestId }\n        });\n        \n        throw new Error(`Compliance violation: ${ruleName} for agent ${request.agentId}`);\n      }\n    }\n\n    // Log successful compliance check\n    this.complianceEvents.push({\n      timestamp: new Date(),\n      eventType: 'COMPLIANCE_CHECK',\n      agentId: request.agentId,\n      complianceLevel: 'PASS',\n      details: { requestId: request.requestId }\n    });\n  }\n\n  // Add custom compliance rule\n  addComplianceRule(name: string, rule: (request: VerificationRequest) => boolean): void {\n    this.complianceRules.set(name, rule);\n    console.log(`Added compliance rule: ${name}`);\n  }\n\n  // Get compliance report\n  getComplianceReport(timeframe?: { start: Date; end: Date }): {\n    totalEvents: number;\n    passCount: number;\n    warnCount: number;\n    failCount: number;\n    complianceRate: number;\n    violations: Array<{ rule: string; agentId: string; timestamp: Date }>;\n  } {\n    let events = this.complianceEvents;\n    \n    if (timeframe) {\n      events = events.filter(event => \n        event.timestamp >= timeframe.start && event.timestamp <= timeframe.end\n      );\n    }\n\n    const passCount = events.filter(e => e.complianceLevel === 'PASS').length;\n    const warnCount = events.filter(e => e.complianceLevel === 'WARN').length;\n    const failCount = events.filter(e => e.complianceLevel === 'FAIL').length;\n    const complianceRate = events.length > 0 ? (passCount / events.length) * 100 : 100;\n\n    const violations = events\n      .filter(e => e.eventType === 'COMPLIANCE_VIOLATION')\n      .map(e => ({\n        rule: e.details.rule,\n        agentId: e.agentId,\n        timestamp: e.timestamp\n      }));\n\n    return {\n      totalEvents: events.length,\n      passCount,\n      warnCount,\n      failCount,\n      complianceRate,\n      violations\n    };\n  }\n}\n\n// Export all middleware classes\nexport {\n  SecurityMiddlewareManager,\n  ThreatIntelligenceMiddleware,\n  IPFilterMiddleware,\n  SecurityLoggingMiddleware,\n  PerformanceMonitoringMiddleware,\n  ComplianceMonitoringMiddleware\n};"],"names":["EventEmitter","SecurityMiddlewareManager","middlewares","eventBus","registerMiddleware","middleware","push","sort","a","b","priority","console","log","name","unregisterMiddleware","index","findIndex","m","splice","executeBeforeVerification","request","beforeVerification","error","executeAfterVerification","result","afterVerification","executeErrorHandling","onError","middlewareError","getMiddlewareInfo","map","ThreatIntelligenceMiddleware","threatIndicators","Set","attackPatterns","Map","threatDatabase","initializeDefaultThreats","add","set","patternId","description","indicators","severity","mitigation","frequency","analyzeThreatIndicators","checkAttackPatterns","updateThreatIntelligence","analyzeVerificationResults","message","addThreatIndicator","indicator","toLowerCase","removeThreatIndicator","delete","addAttackPattern","pattern","getThreatLevel","agentId","get","requestContent","JSON","stringify","includes","warn","currentThreat","level","score","mitigationActions","Error","now","Date","requestKey","timestamp","getTime","debug","confidence","exportThreatIntelligence","Array","from","values","agentThreatLevels","entries","threatLevel","IPFilterMiddleware","whitelist","blacklist","geoBlockList","simulatedIP","extractIPFromRequest","checkIPRestrictions","Math","floor","random","ip","has","size","countryCode","getCountryCode","countries","length","addToWhitelist","addToBlacklist","addToGeoBlock","toUpperCase","SecurityLoggingMiddleware","logBuffer","type","data","requestId","truthClaimType","truthClaim","hasSignature","signature","flushLogs","resultId","verified","evidenceCount","evidence","errorMessage","errorType","exportLogs","getLogStatistics","requestCount","filter","resultCount","errorCount","timestamps","start","min","t","end","max","totalEntries","timespan","PerformanceMonitoringMiddleware","performanceMetrics","requestStartTimes","startTime","responseTime","updateMetrics","isError","metrics","totalResponseTime","averageResponseTime","maxResponseTime","minResponseTime","Infinity","getAgentMetrics","getSystemMetrics","agents","totalRequests","reduce","sum","_","totalErrors","validAgents","totalSuccessfulRequests","averageSystemResponseTime","slowestAgent","fastestAgent","maxAvgTime","minAvgTime","agentCount","resetMetrics","clear","ComplianceMonitoringMiddleware","complianceEvents","complianceRules","initializeComplianceRules","requestTime","nonce","checkCompliance","eventType","complianceLevel","details","ruleName","ruleFunc","isCompliant","rule","addComplianceRule","getComplianceReport","timeframe","events","event","passCount","e","warnCount","failCount","complianceRate","violations","totalEvents"],"mappings":"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"}