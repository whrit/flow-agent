{"version":3,"sources":["../../../src/verification/verification-pipeline.ts"],"sourcesContent":["/**\n * VerificationPipeline - Orchestrates verification with mandatory checkpoints\n * Provides structured verification workflow with rollback capabilities\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport { logger } from '../core/logger.js';\nimport { AppError } from '../utils/error-handler.js';\nimport type { EventEmitter } from 'node:events';\nimport type {\n  VerificationPipelineConfig,\n  VerificationCheckpoint,\n  VerificationResult,\n  CheckpointResult,\n  VerificationStatus,\n  CheckpointValidator,\n  CheckpointCondition,\n  VerificationError,\n  VerificationWarning,\n  ResourceUsage,\n  VerificationEvidence,\n  VerificationCallback,\n  CheckpointCallback,\n} from './types.js';\nimport { VERIFICATION_CONSTANTS } from './types.js';\nimport { TruthScorer } from './truth-scorer.js';\nimport { AgentClaimValidator } from './agent-claim-validator.js';\nimport { IntegrationTestRunner } from './integration-test-runner.js';\nimport { StateSnapshotManager } from './state-snapshot.js';\n\nexport interface PipelineOptions {\n  config: VerificationPipelineConfig;\n  truthScorer?: TruthScorer;\n  claimValidator?: AgentClaimValidator;\n  testRunner?: IntegrationTestRunner;\n  snapshotManager?: StateSnapshotManager;\n  logger?: ILogger;\n  eventEmitter?: EventEmitter;\n}\n\nexport class VerificationPipeline {\n  private readonly config: VerificationPipelineConfig;\n  private readonly logger: ILogger;\n  private readonly truthScorer: TruthScorer;\n  private readonly claimValidator: AgentClaimValidator;\n  private readonly testRunner: IntegrationTestRunner;\n  private readonly snapshotManager: StateSnapshotManager;\n  private readonly eventEmitter?: EventEmitter;\n\n  private currentExecution?: PipelineExecution;\n  private readonly executionHistory: PipelineExecution[] = [];\n  private readonly checkpointCache: Map<string, CheckpointResult> = new Map();\n\n  constructor(options: PipelineOptions) {\n    this.config = options.config;\n    this.logger = options.logger || logger.child({ component: 'VerificationPipeline', pipelineId: options.config.id });\n    this.truthScorer = options.truthScorer || new TruthScorer();\n    this.claimValidator = options.claimValidator || new AgentClaimValidator();\n    this.testRunner = options.testRunner || new IntegrationTestRunner();\n    this.snapshotManager = options.snapshotManager || new StateSnapshotManager();\n    this.eventEmitter = options.eventEmitter;\n\n    this.logger.info('VerificationPipeline initialized', {\n      pipelineId: this.config.id,\n      checkpointCount: this.config.checkpoints.length,\n      level: this.config.level,\n      parallel: this.config.parallel,\n    });\n  }\n\n  /**\n   * Execute the verification pipeline\n   */\n  async execute(\n    context: VerificationContext,\n    callbacks?: PipelineCallbacks\n  ): Promise<VerificationResult> {\n    const startTime = Date.now();\n    const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    this.logger.info('Starting verification pipeline execution', {\n      executionId,\n      pipelineId: this.config.id,\n      context: {\n        targetType: context.target?.type,\n        targetId: context.target?.id,\n        parametersCount: Object.keys(context.parameters || {}).length,\n      },\n    });\n\n    try {\n      // Initialize execution state\n      this.currentExecution = {\n        id: executionId,\n        pipelineId: this.config.id,\n        status: 'running',\n        startTime: new Date(),\n        context,\n        checkpointResults: [],\n        snapshots: [],\n        resourceUsage: this.initializeResourceUsage(),\n        callbacks,\n      };\n\n      // Create initial snapshot if enabled\n      if (this.config.enableRollback) {\n        await this.createSnapshot('initial', 'Pipeline execution start');\n      }\n\n      // Validate pipeline configuration\n      await this.validatePipelineConfig();\n\n      // Sort checkpoints by order\n      const sortedCheckpoints = [...this.config.checkpoints].sort((a, b) => a.order - b.order);\n\n      // Execute checkpoints\n      const checkpointResults = await this.executeCheckpoints(sortedCheckpoints, context, callbacks);\n\n      // Calculate overall result\n      const overallResult = this.calculateOverallResult(checkpointResults);\n\n      // Create final verification result\n      const result: VerificationResult = {\n        id: executionId,\n        pipelineId: this.config.id,\n        timestamp: new Date(),\n        status: overallResult.status,\n        score: overallResult.score,\n        passed: overallResult.passed,\n        checkpointResults,\n        truthScore: overallResult.truthScore,\n        duration: Date.now() - startTime,\n        resourceUsage: this.currentExecution.resourceUsage,\n        evidence: overallResult.evidence,\n        artifacts: overallResult.artifacts,\n        errors: overallResult.errors,\n        warnings: overallResult.warnings,\n        recommendations: overallResult.recommendations,\n        nextSteps: overallResult.nextSteps,\n      };\n\n      // Update execution state\n      this.currentExecution.status = result.status;\n      this.currentExecution.endTime = new Date();\n      this.currentExecution.result = result;\n\n      // Add to history\n      this.executionHistory.push(this.currentExecution);\n      this.currentExecution = undefined;\n\n      // Emit completion event\n      this.eventEmitter?.emit('pipeline:completed', result);\n\n      this.logger.info('Verification pipeline execution completed', {\n        executionId,\n        status: result.status,\n        passed: result.passed,\n        score: result.score,\n        duration: result.duration,\n        checkpointsPassed: checkpointResults.filter(r => r.passed).length,\n        checkpointsTotal: checkpointResults.length,\n      });\n\n      return result;\n    } catch (error) {\n      const errorResult = await this.handleExecutionError(error, executionId, startTime);\n      \n      if (this.currentExecution) {\n        this.currentExecution.status = 'error';\n        this.currentExecution.endTime = new Date();\n        this.currentExecution.result = errorResult;\n        this.executionHistory.push(this.currentExecution);\n        this.currentExecution = undefined;\n      }\n\n      this.eventEmitter?.emit('pipeline:error', errorResult);\n      \n      return errorResult;\n    }\n  }\n\n  /**\n   * Get pipeline execution status\n   */\n  getStatus(): PipelineStatus {\n    return {\n      pipelineId: this.config.id,\n      isRunning: this.currentExecution !== undefined,\n      currentExecution: this.currentExecution ? {\n        id: this.currentExecution.id,\n        status: this.currentExecution.status,\n        progress: this.calculateProgress(),\n        startTime: this.currentExecution.startTime,\n        resourceUsage: this.currentExecution.resourceUsage,\n      } : undefined,\n      history: this.executionHistory.slice(-10).map(exec => ({\n        id: exec.id,\n        status: exec.status,\n        startTime: exec.startTime,\n        endTime: exec.endTime,\n        duration: exec.endTime ? exec.endTime.getTime() - exec.startTime.getTime() : undefined,\n        passed: exec.result?.passed,\n        score: exec.result?.score,\n      })),\n    };\n  }\n\n  /**\n   * Pause pipeline execution\n   */\n  async pause(): Promise<void> {\n    if (!this.currentExecution) {\n      throw new AppError('No active pipeline execution to pause', 'NO_ACTIVE_EXECUTION');\n    }\n\n    this.currentExecution.status = 'paused';\n    this.logger.info('Pipeline execution paused', { executionId: this.currentExecution.id });\n    this.eventEmitter?.emit('pipeline:paused', this.currentExecution.id);\n  }\n\n  /**\n   * Resume pipeline execution\n   */\n  async resume(): Promise<void> {\n    if (!this.currentExecution || this.currentExecution.status !== 'paused') {\n      throw new AppError('No paused pipeline execution to resume', 'NO_PAUSED_EXECUTION');\n    }\n\n    this.currentExecution.status = 'running';\n    this.logger.info('Pipeline execution resumed', { executionId: this.currentExecution.id });\n    this.eventEmitter?.emit('pipeline:resumed', this.currentExecution.id);\n  }\n\n  /**\n   * Cancel pipeline execution\n   */\n  async cancel(): Promise<void> {\n    if (!this.currentExecution) {\n      throw new AppError('No active pipeline execution to cancel', 'NO_ACTIVE_EXECUTION');\n    }\n\n    this.currentExecution.status = 'cancelled';\n    this.currentExecution.endTime = new Date();\n    \n    this.logger.info('Pipeline execution cancelled', { executionId: this.currentExecution.id });\n    this.eventEmitter?.emit('pipeline:cancelled', this.currentExecution.id);\n\n    // Create cancellation result\n    const result: VerificationResult = {\n      id: this.currentExecution.id,\n      pipelineId: this.config.id,\n      timestamp: new Date(),\n      status: 'cancelled',\n      score: 0,\n      passed: false,\n      checkpointResults: this.currentExecution.checkpointResults,\n      truthScore: {\n        score: 0,\n        components: {\n          agentReliability: 0,\n          crossValidation: 0,\n          externalVerification: 0,\n          factualConsistency: 0,\n          logicalCoherence: 0,\n          overall: 0,\n        },\n        confidence: { lower: 0, upper: 0, level: 0 },\n        evidence: [],\n        timestamp: new Date(),\n        metadata: { reason: 'cancelled' },\n      },\n      duration: this.currentExecution.endTime.getTime() - this.currentExecution.startTime.getTime(),\n      resourceUsage: this.currentExecution.resourceUsage,\n      evidence: [],\n      artifacts: {},\n      errors: [{\n        code: 'PIPELINE_CANCELLED',\n        message: 'Pipeline execution was cancelled',\n        severity: 'medium',\n        context: { executionId: this.currentExecution.id },\n        recoverable: true,\n        timestamp: new Date(),\n      }],\n      warnings: [],\n      recommendations: ['Consider reviewing cancellation reason', 'Check for incomplete state'],\n      nextSteps: ['Restart pipeline if needed', 'Clean up any partial state'],\n    };\n\n    this.currentExecution.result = result;\n    this.executionHistory.push(this.currentExecution);\n    this.currentExecution = undefined;\n  }\n\n  /**\n   * Clear execution history\n   */\n  clearHistory(): void {\n    this.executionHistory.length = 0;\n    this.checkpointCache.clear();\n    this.logger.debug('Pipeline execution history cleared');\n  }\n\n  private async validatePipelineConfig(): Promise<void> {\n    const errors: string[] = [];\n\n    if (this.config.checkpoints.length === 0) {\n      errors.push('Pipeline must have at least one checkpoint');\n    }\n\n    // Check for mandatory checkpoints\n    const mandatoryCheckpoints = this.config.checkpoints.filter(cp => cp.mandatory);\n    if (mandatoryCheckpoints.length === 0) {\n      errors.push('Pipeline must have at least one mandatory checkpoint');\n    }\n\n    // Validate checkpoint dependencies\n    for (const checkpoint of this.config.checkpoints) {\n      for (const depId of checkpoint.dependencies) {\n        if (!this.config.checkpoints.find(cp => cp.id === depId)) {\n          errors.push(`Checkpoint ${checkpoint.id} depends on non-existent checkpoint ${depId}`);\n        }\n      }\n    }\n\n    // Check for circular dependencies\n    if (this.hasCircularDependencies()) {\n      errors.push('Circular dependencies detected in checkpoint configuration');\n    }\n\n    if (errors.length > 0) {\n      throw new AppError(`Pipeline configuration validation failed: ${errors.join(', ')}`, 'INVALID_PIPELINE_CONFIG');\n    }\n  }\n\n  private async executeCheckpoints(\n    checkpoints: VerificationCheckpoint[],\n    context: VerificationContext,\n    callbacks?: PipelineCallbacks\n  ): Promise<CheckpointResult[]> {\n    const results: CheckpointResult[] = [];\n    const completed = new Set<string>();\n    const pending = new Set(checkpoints.map(cp => cp.id));\n\n    while (pending.size > 0) {\n      // Find checkpoints that can be executed (dependencies satisfied)\n      const ready = checkpoints.filter(cp => \n        pending.has(cp.id) && \n        cp.dependencies.every(depId => completed.has(depId))\n      );\n\n      if (ready.length === 0) {\n        throw new AppError('Dependency deadlock in checkpoint execution', 'CHECKPOINT_DEADLOCK');\n      }\n\n      // Execute ready checkpoints\n      if (this.config.parallel && ready.length > 1) {\n        const batchResults = await Promise.all(\n          ready.map(checkpoint => this.executeCheckpoint(checkpoint, context, callbacks))\n        );\n        results.push(...batchResults);\n      } else {\n        for (const checkpoint of ready) {\n          const result = await this.executeCheckpoint(checkpoint, context, callbacks);\n          results.push(result);\n          \n          // Check if we should stop on failure\n          if (!result.passed && checkpoint.mandatory) {\n            throw new AppError(\n              `Mandatory checkpoint ${checkpoint.id} failed`,\n              'MANDATORY_CHECKPOINT_FAILED'\n            );\n          }\n        }\n      }\n\n      // Update completion status\n      ready.forEach(cp => {\n        completed.add(cp.id);\n        pending.delete(cp.id);\n      });\n    }\n\n    return results.sort((a, b) => {\n      const aCheckpoint = checkpoints.find(cp => cp.id === a.checkpointId)!;\n      const bCheckpoint = checkpoints.find(cp => cp.id === b.checkpointId)!;\n      return aCheckpoint.order - bCheckpoint.order;\n    });\n  }\n\n  private async executeCheckpoint(\n    checkpoint: VerificationCheckpoint,\n    context: VerificationContext,\n    callbacks?: PipelineCallbacks\n  ): Promise<CheckpointResult> {\n    const startTime = Date.now();\n    \n    this.logger.info('Executing checkpoint', {\n      checkpointId: checkpoint.id,\n      type: checkpoint.type,\n      mandatory: checkpoint.mandatory,\n      validatorCount: checkpoint.validators.length,\n    });\n\n    try {\n      // Check if paused\n      while (this.currentExecution?.status === 'paused') {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n\n      // Check if cancelled\n      if (this.currentExecution?.status === 'cancelled') {\n        throw new AppError('Execution cancelled', 'EXECUTION_CANCELLED');\n      }\n\n      // Create snapshot if required\n      if (checkpoint.createSnapshot && this.config.enableRollback) {\n        await this.createSnapshot(checkpoint.id, `Before checkpoint ${checkpoint.name}`);\n      }\n\n      // Execute validators\n      const validatorResults = await this.executeValidators(checkpoint.validators, context);\n\n      // Evaluate conditions\n      const conditionResults = this.evaluateConditions(checkpoint.conditions, context, validatorResults);\n\n      // Calculate checkpoint result\n      const passed = validatorResults.every(vr => vr.passed) && conditionResults.every(cr => cr.passed);\n      const score = validatorResults.reduce((sum, vr) => sum + vr.score, 0) / validatorResults.length;\n\n      const result: CheckpointResult = {\n        checkpointId: checkpoint.id,\n        status: passed ? 'passed' : 'failed',\n        score,\n        passed,\n        duration: Date.now() - startTime,\n        validatorResults,\n        evidence: validatorResults.flatMap(vr => vr.evidence),\n        errors: validatorResults.flatMap(vr => vr.errors || []),\n        warnings: validatorResults.flatMap(vr => vr.warnings || []),\n      };\n\n      // Handle rollback on failure\n      if (!passed && checkpoint.rollbackOnFailure && this.config.enableRollback) {\n        await this.handleCheckpointRollback(checkpoint);\n      }\n\n      // Update execution state\n      if (this.currentExecution) {\n        this.currentExecution.checkpointResults.push(result);\n      }\n\n      // Cache result\n      this.checkpointCache.set(checkpoint.id, result);\n\n      // Call checkpoint callback\n      if (callbacks?.onCheckpointComplete) {\n        await callbacks.onCheckpointComplete(result);\n      }\n\n      this.eventEmitter?.emit('checkpoint:completed', result);\n\n      this.logger.info('Checkpoint execution completed', {\n        checkpointId: checkpoint.id,\n        passed,\n        score,\n        duration: result.duration,\n      });\n\n      return result;\n    } catch (error) {\n      const errorResult: CheckpointResult = {\n        checkpointId: checkpoint.id,\n        status: 'error',\n        score: 0,\n        passed: false,\n        duration: Date.now() - startTime,\n        validatorResults: [],\n        evidence: [],\n        errors: [{\n          code: 'CHECKPOINT_EXECUTION_ERROR',\n          message: `Checkpoint execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          severity: 'high',\n          context: { checkpointId: checkpoint.id },\n          recoverable: !checkpoint.mandatory,\n          timestamp: new Date(),\n        }],\n        warnings: [],\n      };\n\n      this.logger.error('Checkpoint execution failed', {\n        checkpointId: checkpoint.id,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n\n      return errorResult;\n    }\n  }\n\n  private async executeValidators(\n    validators: CheckpointValidator[],\n    context: VerificationContext\n  ): Promise<ValidatorResult[]> {\n    const results: ValidatorResult[] = [];\n\n    for (const validator of validators) {\n      try {\n        let result: ValidatorResult;\n\n        switch (validator.type) {\n          case 'truth_score':\n            result = await this.executeTruthScoreValidator(validator, context);\n            break;\n          case 'agent_claim':\n            result = await this.executeAgentClaimValidator(validator, context);\n            break;\n          case 'integration_test':\n            result = await this.executeIntegrationTestValidator(validator, context);\n            break;\n          case 'state_validation':\n            result = await this.executeStateValidationValidator(validator, context);\n            break;\n          case 'custom':\n            result = await this.executeCustomValidator(validator, context);\n            break;\n          default:\n            throw new AppError(`Unknown validator type: ${validator.type}`, 'UNKNOWN_VALIDATOR_TYPE');\n        }\n\n        results.push(result);\n      } catch (error) {\n        if (validator.required) {\n          throw error;\n        }\n\n        // Create error result for non-required validators\n        results.push({\n          validatorId: validator.id,\n          status: 'error',\n          score: 0,\n          passed: false,\n          details: { error: error instanceof Error ? error.message : 'Unknown error' },\n          evidence: [],\n          errors: [{\n            code: 'VALIDATOR_EXECUTION_ERROR',\n            message: `Validator execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            severity: 'medium',\n            context: { validatorId: validator.id },\n            recoverable: true,\n            timestamp: new Date(),\n          }],\n        });\n      }\n    }\n\n    return results;\n  }\n\n  private async executeTruthScoreValidator(\n    validator: CheckpointValidator,\n    context: VerificationContext\n  ): Promise<ValidatorResult> {\n    if (!context.claims || context.claims.length === 0) {\n      return {\n        validatorId: validator.id,\n        status: 'failed',\n        score: 0,\n        passed: false,\n        details: { reason: 'No claims to validate' },\n        evidence: [],\n      };\n    }\n\n    const scores = await Promise.all(\n      context.claims.map(claim => this.truthScorer.scoreClaim(claim, context.scoringContext))\n    );\n\n    const averageScore = scores.reduce((sum, score) => sum + score.score, 0) / scores.length;\n    const passed = averageScore >= (validator.config.threshold as number || VERIFICATION_CONSTANTS.DEFAULT_TRUTH_THRESHOLD);\n\n    return {\n      validatorId: validator.id,\n      status: passed ? 'passed' : 'failed',\n      score: averageScore,\n      passed,\n      details: {\n        claimCount: context.claims.length,\n        averageScore,\n        threshold: validator.config.threshold,\n        scores: scores.map(s => s.score),\n      },\n      evidence: scores.flatMap(s => s.evidence),\n    };\n  }\n\n  private async executeAgentClaimValidator(\n    validator: CheckpointValidator,\n    context: VerificationContext\n  ): Promise<ValidatorResult> {\n    if (!context.claims || context.claims.length === 0) {\n      return {\n        validatorId: validator.id,\n        status: 'failed',\n        score: 0,\n        passed: false,\n        details: { reason: 'No claims to validate' },\n        evidence: [],\n      };\n    }\n\n    const validationResults = await Promise.all(\n      context.claims.map(claim => this.claimValidator.validateClaim(claim, validator.config))\n    );\n\n    const passedCount = validationResults.filter(r => r.passed).length;\n    const successRate = passedCount / validationResults.length;\n    const averageScore = validationResults.reduce((sum, r) => sum + r.score, 0) / validationResults.length;\n    const passed = successRate >= (validator.config.minSuccessRate as number || 0.8);\n\n    return {\n      validatorId: validator.id,\n      status: passed ? 'passed' : 'failed',\n      score: averageScore,\n      passed,\n      details: {\n        claimCount: context.claims.length,\n        passedCount,\n        successRate,\n        averageScore,\n        results: validationResults,\n      },\n      evidence: validationResults.flatMap(r => r.evidence),\n    };\n  }\n\n  private async executeIntegrationTestValidator(\n    validator: CheckpointValidator,\n    context: VerificationContext\n  ): Promise<ValidatorResult> {\n    if (!context.testConfig) {\n      return {\n        validatorId: validator.id,\n        status: 'failed',\n        score: 0,\n        passed: false,\n        details: { reason: 'No test configuration provided' },\n        evidence: [],\n      };\n    }\n\n    const testResult = await this.testRunner.runTests(context.testConfig);\n    \n    return {\n      validatorId: validator.id,\n      status: testResult.passed ? 'passed' : 'failed',\n      score: testResult.score,\n      passed: testResult.passed,\n      details: {\n        testId: testResult.testId,\n        scenarioCount: testResult.scenarioResults.length,\n        passedScenarios: testResult.scenarioResults.filter(sr => sr.passed).length,\n        duration: testResult.duration,\n        coverage: testResult.coverage,\n      },\n      evidence: testResult.evidence,\n    };\n  }\n\n  private async executeStateValidationValidator(\n    validator: CheckpointValidator,\n    context: VerificationContext\n  ): Promise<ValidatorResult> {\n    // Validate current system state\n    const validationScore = 0.85; // Simplified - implement actual state validation\n    const passed = validationScore >= (validator.config.threshold as number || 0.8);\n\n    return {\n      validatorId: validator.id,\n      status: passed ? 'passed' : 'failed',\n      score: validationScore,\n      passed,\n      details: {\n        validationType: 'state_validation',\n        validationScore,\n        threshold: validator.config.threshold,\n      },\n      evidence: [{\n        type: 'state_validation',\n        source: 'system_state',\n        timestamp: new Date(),\n        data: { score: validationScore },\n        reliability: 0.9,\n        weight: 1.0,\n      }],\n    };\n  }\n\n  private async executeCustomValidator(\n    validator: CheckpointValidator,\n    context: VerificationContext\n  ): Promise<ValidatorResult> {\n    // Implement custom validator logic based on config\n    const customScore = 0.8; // Simplified - implement actual custom validation\n    const passed = customScore >= (validator.config.threshold as number || 0.8);\n\n    return {\n      validatorId: validator.id,\n      status: passed ? 'passed' : 'failed',\n      score: customScore,\n      passed,\n      details: {\n        validationType: 'custom',\n        config: validator.config,\n        customScore,\n      },\n      evidence: [{\n        type: 'custom',\n        source: 'custom_validator',\n        timestamp: new Date(),\n        data: validator.config,\n        reliability: 0.8,\n        weight: 1.0,\n      }],\n    };\n  }\n\n  private evaluateConditions(\n    conditions: CheckpointCondition[],\n    context: VerificationContext,\n    validatorResults: ValidatorResult[]\n  ): ConditionResult[] {\n    return conditions.map(condition => {\n      try {\n        const value = this.extractConditionValue(condition.field, context, validatorResults);\n        const passed = this.evaluateCondition(condition, value);\n\n        return {\n          condition,\n          passed,\n          value,\n          reason: passed ? 'Condition satisfied' : 'Condition not satisfied',\n        };\n      } catch (error) {\n        return {\n          condition,\n          passed: false,\n          value: undefined,\n          reason: `Condition evaluation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        };\n      }\n    });\n  }\n\n  private extractConditionValue(\n    field: string,\n    context: VerificationContext,\n    validatorResults: ValidatorResult[]\n  ): unknown {\n    // Extract value from context or validator results based on field path\n    if (field.startsWith('validator.')) {\n      const validatorId = field.split('.')[1];\n      const validatorField = field.split('.').slice(2).join('.');\n      const validator = validatorResults.find(vr => vr.validatorId === validatorId);\n      \n      if (validatorField === 'score') return validator?.score;\n      if (validatorField === 'passed') return validator?.passed;\n      \n      return this.getNestedValue(validator?.details, validatorField);\n    }\n\n    if (field.startsWith('context.')) {\n      const contextField = field.split('.').slice(1).join('.');\n      return this.getNestedValue(context, contextField);\n    }\n\n    return undefined;\n  }\n\n  private getNestedValue(obj: any, path: string): unknown {\n    return path.split('.').reduce((current, key) => current?.[key], obj);\n  }\n\n  private evaluateCondition(condition: CheckpointCondition, value: unknown): boolean {\n    switch (condition.operator) {\n      case 'eq':\n        return value === condition.value;\n      case 'ne':\n        return value !== condition.value;\n      case 'gt':\n        return typeof value === 'number' && value > (condition.value as number);\n      case 'gte':\n        return typeof value === 'number' && value >= (condition.value as number);\n      case 'lt':\n        return typeof value === 'number' && value < (condition.value as number);\n      case 'lte':\n        return typeof value === 'number' && value <= (condition.value as number);\n      case 'in':\n        return Array.isArray(condition.value) && condition.value.includes(value);\n      case 'nin':\n        return Array.isArray(condition.value) && !condition.value.includes(value);\n      case 'regex':\n        return typeof value === 'string' && new RegExp(condition.value as string).test(value);\n      default:\n        return false;\n    }\n  }\n\n  private calculateOverallResult(checkpointResults: CheckpointResult[]): OverallResult {\n    const mandatoryResults = checkpointResults.filter(r => {\n      const checkpoint = this.config.checkpoints.find(cp => cp.id === r.checkpointId);\n      return checkpoint?.mandatory;\n    });\n\n    const mandatoryPassed = mandatoryResults.every(r => r.passed);\n    const overallPassed = mandatoryPassed && checkpointResults.every(r => r.passed);\n    \n    const totalScore = checkpointResults.reduce((sum, r) => sum + r.score, 0) / checkpointResults.length;\n    const status: VerificationStatus = overallPassed ? 'passed' : 'failed';\n\n    // Aggregate truth score (simplified)\n    const truthScore = {\n      score: totalScore,\n      components: {\n        agentReliability: totalScore,\n        crossValidation: totalScore,\n        externalVerification: totalScore,\n        factualConsistency: totalScore,\n        logicalCoherence: totalScore,\n        overall: totalScore,\n      },\n      confidence: { lower: totalScore - 0.1, upper: totalScore + 0.1, level: 0.95 },\n      evidence: checkpointResults.flatMap(r => r.evidence),\n      timestamp: new Date(),\n      metadata: { pipelineId: this.config.id },\n    };\n\n    return {\n      status,\n      passed: overallPassed,\n      score: totalScore,\n      truthScore,\n      evidence: checkpointResults.flatMap(r => r.evidence),\n      artifacts: {},\n      errors: checkpointResults.flatMap(r => r.errors),\n      warnings: checkpointResults.flatMap(r => r.warnings),\n      recommendations: [\n        ...(overallPassed ? ['Pipeline verification successful'] : ['Review failed checkpoints']),\n        'Monitor ongoing performance',\n      ],\n      nextSteps: [\n        ...(overallPassed ? ['Proceed with deployment'] : ['Address verification failures']),\n        'Schedule next verification cycle',\n      ],\n    };\n  }\n\n  private async createSnapshot(checkpointId: string, description: string): Promise<void> {\n    if (this.currentExecution) {\n      const snapshot = await this.snapshotManager.createSnapshot({\n        name: `${this.config.id}_${checkpointId}`,\n        description,\n        context: { pipelineId: this.config.id, checkpointId },\n      });\n      \n      this.currentExecution.snapshots.push(snapshot.id);\n      \n      this.logger.debug('Snapshot created', {\n        snapshotId: snapshot.id,\n        checkpointId,\n        description,\n      });\n    }\n  }\n\n  private async handleCheckpointRollback(checkpoint: VerificationCheckpoint): Promise<void> {\n    if (!this.currentExecution || this.currentExecution.snapshots.length === 0) {\n      this.logger.warn('Cannot rollback: no snapshots available', { checkpointId: checkpoint.id });\n      return;\n    }\n\n    const latestSnapshotId = this.currentExecution.snapshots[this.currentExecution.snapshots.length - 1];\n    \n    try {\n      await this.snapshotManager.rollback({\n        snapshotId: latestSnapshotId,\n        reason: `Checkpoint ${checkpoint.id} failed`,\n        scope: { includeAgents: true, includeTasks: true, includeSwarms: true },\n      });\n      \n      this.logger.info('Rollback completed', {\n        checkpointId: checkpoint.id,\n        snapshotId: latestSnapshotId,\n      });\n    } catch (error) {\n      this.logger.error('Rollback failed', {\n        checkpointId: checkpoint.id,\n        snapshotId: latestSnapshotId,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n\n  private async handleExecutionError(error: unknown, executionId: string, startTime: number): Promise<VerificationResult> {\n    this.logger.error('Pipeline execution error', {\n      executionId,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    });\n\n    return {\n      id: executionId,\n      pipelineId: this.config.id,\n      timestamp: new Date(),\n      status: 'error',\n      score: 0,\n      passed: false,\n      checkpointResults: this.currentExecution?.checkpointResults || [],\n      truthScore: {\n        score: 0,\n        components: {\n          agentReliability: 0,\n          crossValidation: 0,\n          externalVerification: 0,\n          factualConsistency: 0,\n          logicalCoherence: 0,\n          overall: 0,\n        },\n        confidence: { lower: 0, upper: 0, level: 0 },\n        evidence: [],\n        timestamp: new Date(),\n        metadata: { error: error instanceof Error ? error.message : 'Unknown error' },\n      },\n      duration: Date.now() - startTime,\n      resourceUsage: this.currentExecution?.resourceUsage || this.initializeResourceUsage(),\n      evidence: [],\n      artifacts: {},\n      errors: [{\n        code: 'PIPELINE_EXECUTION_ERROR',\n        message: `Pipeline execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        severity: 'critical',\n        context: { executionId, pipelineId: this.config.id },\n        recoverable: false,\n        timestamp: new Date(),\n      }],\n      warnings: [],\n      recommendations: ['Review pipeline configuration', 'Check system logs for details'],\n      nextSteps: ['Fix identified issues', 'Restart pipeline execution'],\n    };\n  }\n\n  private calculateProgress(): number {\n    if (!this.currentExecution) return 0;\n    \n    const totalCheckpoints = this.config.checkpoints.length;\n    const completedCheckpoints = this.currentExecution.checkpointResults.length;\n    \n    return totalCheckpoints > 0 ? (completedCheckpoints / totalCheckpoints) * 100 : 0;\n  }\n\n  private hasCircularDependencies(): boolean {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const hasCircle = (checkpointId: string): boolean => {\n      if (recursionStack.has(checkpointId)) return true;\n      if (visited.has(checkpointId)) return false;\n\n      visited.add(checkpointId);\n      recursionStack.add(checkpointId);\n\n      const checkpoint = this.config.checkpoints.find(cp => cp.id === checkpointId);\n      if (checkpoint) {\n        for (const depId of checkpoint.dependencies) {\n          if (hasCircle(depId)) return true;\n        }\n      }\n\n      recursionStack.delete(checkpointId);\n      return false;\n    };\n\n    return this.config.checkpoints.some(cp => hasCircle(cp.id));\n  }\n\n  private initializeResourceUsage(): ResourceUsage {\n    return {\n      cpu: 0,\n      memory: 0,\n      disk: 0,\n      network: 0,\n      tokens: 0,\n      apiCalls: 0,\n    };\n  }\n}\n\n// Supporting interfaces\ninterface PipelineExecution {\n  id: string;\n  pipelineId: string;\n  status: VerificationStatus;\n  startTime: Date;\n  endTime?: Date;\n  context: VerificationContext;\n  checkpointResults: CheckpointResult[];\n  snapshots: string[];\n  resourceUsage: ResourceUsage;\n  result?: VerificationResult;\n  callbacks?: PipelineCallbacks;\n}\n\ninterface VerificationContext {\n  target?: {\n    type: string;\n    id: string;\n    data: Record<string, unknown>;\n  };\n  parameters?: Record<string, unknown>;\n  claims?: any[];\n  testConfig?: any;\n  scoringContext?: any;\n}\n\ninterface PipelineCallbacks {\n  onCheckpointComplete?: CheckpointCallback;\n  onVerificationComplete?: VerificationCallback;\n  onError?: (error: Error) => void | Promise<void>;\n}\n\ninterface ValidatorResult {\n  validatorId: string;\n  status: VerificationStatus;\n  score: number;\n  passed: boolean;\n  details: Record<string, unknown>;\n  evidence: VerificationEvidence[];\n  errors?: VerificationError[];\n  warnings?: VerificationWarning[];\n}\n\ninterface ConditionResult {\n  condition: CheckpointCondition;\n  passed: boolean;\n  value: unknown;\n  reason: string;\n}\n\ninterface OverallResult {\n  status: VerificationStatus;\n  passed: boolean;\n  score: number;\n  truthScore: any;\n  evidence: VerificationEvidence[];\n  artifacts: Record<string, unknown>;\n  errors: VerificationError[];\n  warnings: VerificationWarning[];\n  recommendations: string[];\n  nextSteps: string[];\n}\n\ninterface PipelineStatus {\n  pipelineId: string;\n  isRunning: boolean;\n  currentExecution?: {\n    id: string;\n    status: VerificationStatus;\n    progress: number;\n    startTime: Date;\n    resourceUsage: ResourceUsage;\n  };\n  history: {\n    id: string;\n    status: VerificationStatus;\n    startTime: Date;\n    endTime?: Date;\n    duration?: number;\n    passed?: boolean;\n    score?: number;\n  }[];\n}\n\nexport default VerificationPipeline;"],"names":["logger","AppError","VERIFICATION_CONSTANTS","TruthScorer","AgentClaimValidator","IntegrationTestRunner","StateSnapshotManager","VerificationPipeline","config","truthScorer","claimValidator","testRunner","snapshotManager","eventEmitter","currentExecution","executionHistory","checkpointCache","Map","options","child","component","pipelineId","id","info","checkpointCount","checkpoints","length","level","parallel","execute","context","callbacks","startTime","Date","now","executionId","Math","random","toString","substr","targetType","target","type","targetId","parametersCount","Object","keys","parameters","status","checkpointResults","snapshots","resourceUsage","initializeResourceUsage","enableRollback","createSnapshot","validatePipelineConfig","sortedCheckpoints","sort","a","b","order","executeCheckpoints","overallResult","calculateOverallResult","result","timestamp","score","passed","truthScore","duration","evidence","artifacts","errors","warnings","recommendations","nextSteps","endTime","push","undefined","emit","checkpointsPassed","filter","r","checkpointsTotal","error","errorResult","handleExecutionError","getStatus","isRunning","progress","calculateProgress","history","slice","map","exec","getTime","pause","resume","cancel","components","agentReliability","crossValidation","externalVerification","factualConsistency","logicalCoherence","overall","confidence","lower","upper","metadata","reason","code","message","severity","recoverable","clearHistory","clear","debug","mandatoryCheckpoints","cp","mandatory","checkpoint","depId","dependencies","find","hasCircularDependencies","join","results","completed","Set","pending","size","ready","has","every","batchResults","Promise","all","executeCheckpoint","forEach","add","delete","aCheckpoint","checkpointId","bCheckpoint","validatorCount","validators","resolve","setTimeout","name","validatorResults","executeValidators","conditionResults","evaluateConditions","conditions","vr","cr","reduce","sum","flatMap","rollbackOnFailure","handleCheckpointRollback","set","onCheckpointComplete","Error","validator","executeTruthScoreValidator","executeAgentClaimValidator","executeIntegrationTestValidator","executeStateValidationValidator","executeCustomValidator","required","validatorId","details","claims","scores","claim","scoreClaim","scoringContext","averageScore","threshold","DEFAULT_TRUTH_THRESHOLD","claimCount","s","validationResults","validateClaim","passedCount","successRate","minSuccessRate","testConfig","testResult","runTests","testId","scenarioCount","scenarioResults","passedScenarios","sr","coverage","validationScore","validationType","source","data","reliability","weight","customScore","condition","value","extractConditionValue","field","evaluateCondition","startsWith","split","validatorField","getNestedValue","contextField","obj","path","current","key","operator","Array","isArray","includes","RegExp","test","mandatoryResults","mandatoryPassed","overallPassed","totalScore","description","snapshot","snapshotId","warn","latestSnapshotId","rollback","scope","includeAgents","includeTasks","includeSwarms","totalCheckpoints","completedCheckpoints","visited","recursionStack","hasCircle","some","cpu","memory","disk","network","tokens","apiCalls"],"mappings":"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"}