{"version":3,"sources":["../../../src/verification/telemetry.ts"],"sourcesContent":["/**\n * Agent Truth Telemetry System\n * \n * Comprehensive real-time truth metrics collection and agent performance scoring\n * with system-wide accuracy tracking and automated alerting capabilities.\n * \n * Target Metrics: >95% truth accuracy, <10% human intervention\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { DistributedMemorySystem } from '../memory/distributed-memory.js';\n\n// ========================================================================================\n// Core Truth Telemetry Types\n// ========================================================================================\n\nexport interface TruthMetric {\n  id: string;\n  timestamp: Date;\n  agentId: string;\n  taskId: string;\n  metricType: TruthMetricType;\n  value: number;\n  confidence: number;\n  context: TruthContext;\n  validation: ValidationResult;\n  metadata: Record<string, any>;\n}\n\nexport interface TruthContext {\n  taskType: string;\n  complexity: 'low' | 'medium' | 'high' | 'critical';\n  domain: string;\n  dependencies: string[];\n  inputSources: string[];\n  outputTargets: string[];\n  verificationMethod: 'automated' | 'human' | 'hybrid';\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  validationType: 'syntax' | 'logic' | 'semantic' | 'functional' | 'integration';\n  score: number; // 0-1\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n  suggestions: ValidationSuggestion[];\n  automatedChecks: AutomatedCheck[];\n  humanReview?: HumanReview;\n}\n\nexport interface ValidationError {\n  type: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  message: string;\n  location?: string;\n  suggestedFix?: string;\n  impact: number; // 0-1\n}\n\nexport interface ValidationWarning {\n  type: string;\n  message: string;\n  location?: string;\n  recommendation?: string;\n}\n\nexport interface ValidationSuggestion {\n  type: string;\n  description: string;\n  confidenceScore: number;\n  potentialImpact: number;\n}\n\nexport interface AutomatedCheck {\n  name: string;\n  type: 'static' | 'dynamic' | 'integration' | 'performance';\n  status: 'passed' | 'failed' | 'warning' | 'skipped';\n  details: Record<string, any>;\n  executionTime: number;\n}\n\nexport interface HumanReview {\n  reviewerId: string;\n  timestamp: Date;\n  score: number;\n  feedback: string;\n  timeSpent: number;\n  confidence: number;\n}\n\nexport interface AgentTruthScore {\n  agentId: string;\n  timestamp: Date;\n  overallScore: number; // 0-1\n  components: {\n    accuracy: number;\n    reliability: number;\n    consistency: number;\n    efficiency: number;\n    adaptability: number;\n  };\n  recentPerformance: PerformanceWindow[];\n  trends: ScoreTrend[];\n  benchmarks: BenchmarkComparison[];\n  riskAssessment: RiskAssessment;\n}\n\nexport interface PerformanceWindow {\n  period: string;\n  startTime: Date;\n  endTime: Date;\n  metrics: {\n    totalTasks: number;\n    successfulTasks: number;\n    averageAccuracy: number;\n    averageConfidence: number;\n    humanInterventions: number;\n    criticalErrors: number;\n  };\n}\n\nexport interface ScoreTrend {\n  metric: string;\n  direction: 'improving' | 'declining' | 'stable';\n  rate: number;\n  confidence: number;\n  timespan: string;\n}\n\nexport interface BenchmarkComparison {\n  category: string;\n  agentScore: number;\n  benchmarkScore: number;\n  percentile: number;\n  comparison: 'above' | 'at' | 'below';\n}\n\nexport interface RiskAssessment {\n  level: 'low' | 'medium' | 'high' | 'critical';\n  factors: RiskFactor[];\n  recommendations: string[];\n  mitigationStrategies: string[];\n}\n\nexport interface RiskFactor {\n  name: string;\n  severity: number; // 0-1\n  probability: number; // 0-1\n  impact: string;\n  trend: 'increasing' | 'stable' | 'decreasing';\n}\n\nexport interface SystemTruthMetrics {\n  timestamp: Date;\n  overallAccuracy: number;\n  humanInterventionRate: number;\n  systemReliability: number;\n  agentCount: number;\n  activeAgents: number;\n  totalTasks: number;\n  verifiedTasks: number;\n  criticalFailures: number;\n  recoveryTime: number;\n  efficiency: number;\n  distributionMetrics: DistributionMetrics;\n}\n\nexport interface DistributionMetrics {\n  taskDistribution: Record<string, number>;\n  accuracyDistribution: Record<string, number>;\n  complexityDistribution: Record<string, number>;\n  errorTypeDistribution: Record<string, number>;\n}\n\nexport interface TruthAlert {\n  id: string;\n  timestamp: Date;\n  severity: 'info' | 'warning' | 'critical' | 'emergency';\n  type: TruthAlertType;\n  message: string;\n  source: string;\n  context: Record<string, any>;\n  thresholds: AlertThreshold[];\n  actions: AlertAction[];\n  escalationPath: EscalationLevel[];\n  resolved: boolean;\n  resolvedAt?: Date;\n  resolvedBy?: string;\n}\n\nexport interface AlertThreshold {\n  metric: string;\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte' | 'ne';\n  value: number;\n  duration: number;\n  severity: 'info' | 'warning' | 'critical' | 'emergency';\n}\n\nexport interface AlertAction {\n  type: 'notify' | 'escalate' | 'auto-remediate' | 'suspend' | 'restart';\n  target: string;\n  config: Record<string, any>;\n  enabled: boolean;\n}\n\nexport interface EscalationLevel {\n  level: number;\n  delay: number;\n  targets: string[];\n  conditions: string[];\n}\n\nexport interface DashboardData {\n  timestamp: Date;\n  summary: {\n    overallHealth: number;\n    truthAccuracy: number;\n    humanInterventionRate: number;\n    systemEfficiency: number;\n    alertCount: number;\n  };\n  charts: {\n    accuracyTrend: DataPoint[];\n    interventionTrend: DataPoint[];\n    agentPerformance: AgentPerformanceChart[];\n    errorDistribution: ErrorDistributionChart[];\n    systemLoad: SystemLoadChart[];\n  };\n  tables: {\n    topPerformers: AgentRanking[];\n    recentAlerts: TruthAlert[];\n    criticalIssues: CriticalIssue[];\n  };\n  insights: SystemInsight[];\n}\n\nexport interface DataPoint {\n  timestamp: Date;\n  value: number;\n  label?: string;\n}\n\nexport interface AgentPerformanceChart {\n  agentId: string;\n  score: number;\n  trend: 'up' | 'down' | 'stable';\n  tasks: number;\n  accuracy: number;\n}\n\nexport interface ErrorDistributionChart {\n  category: string;\n  count: number;\n  percentage: number;\n  severity: string;\n}\n\nexport interface SystemLoadChart {\n  timestamp: Date;\n  load: number;\n  capacity: number;\n  utilization: number;\n}\n\nexport interface AgentRanking {\n  rank: number;\n  agentId: string;\n  score: number;\n  tasks: number;\n  accuracy: number;\n  efficiency: number;\n}\n\nexport interface CriticalIssue {\n  id: string;\n  severity: string;\n  description: string;\n  affectedAgents: string[];\n  impact: string;\n  eta: Date;\n}\n\nexport interface SystemInsight {\n  type: 'performance' | 'efficiency' | 'quality' | 'risk';\n  title: string;\n  description: string;\n  impact: 'low' | 'medium' | 'high';\n  actionable: boolean;\n  recommendations: string[];\n}\n\nexport type TruthMetricType = \n  | 'accuracy' \n  | 'confidence' \n  | 'consistency' \n  | 'reliability' \n  | 'efficiency' \n  | 'completeness' \n  | 'correctness' \n  | 'timeliness'\n  | 'innovation'\n  | 'adaptability';\n\nexport type TruthAlertType = \n  | 'accuracy_degradation'\n  | 'high_intervention_rate'\n  | 'system_failure'\n  | 'agent_malfunction'\n  | 'threshold_violation'\n  | 'anomaly_detected'\n  | 'performance_degradation'\n  | 'quality_decline';\n\n// ========================================================================================\n// Truth Telemetry Configuration\n// ========================================================================================\n\nexport interface TruthTelemetryConfig {\n  // Collection settings\n  metricsInterval: number;\n  batchSize: number;\n  bufferSize: number;\n  \n  // Validation settings\n  validationTimeout: number;\n  maxValidationRetries: number;\n  validationThreshold: number;\n  \n  // Scoring settings\n  scoringInterval: number;\n  performanceWindowSize: number;\n  trendAnalysisDepth: number;\n  \n  // Alert settings\n  alertEnabled: boolean;\n  alertThresholds: {\n    accuracyThreshold: number;\n    interventionRateThreshold: number;\n    systemReliabilityThreshold: number;\n    criticalErrorThreshold: number;\n  };\n  \n  // Export settings\n  dashboardEnabled: boolean;\n  exportInterval: number;\n  exportFormat: 'json' | 'csv' | 'prometheus';\n  retentionPeriod: number;\n  \n  // Integration settings\n  mcpIntegration: boolean;\n  persistenceEnabled: boolean;\n  realtimeEnabled: boolean;\n  debugMode: boolean;\n}\n\n// ========================================================================================\n// Core Truth Telemetry Engine\n// ========================================================================================\n\nexport class TruthTelemetryEngine extends EventEmitter {\n  private config: TruthTelemetryConfig;\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private memory: DistributedMemorySystem;\n  \n  // Core components\n  private metricsCollector: TruthMetricsCollector;\n  private agentScorer: AgentTruthScorer;\n  private systemTracker: SystemTruthTracker;\n  private alertManager: TruthAlertManager;\n  private dashboardExporter: DashboardExporter;\n  private automatedValidator: AutomatedValidator;\n  \n  // State management\n  private truthMetrics = new Map<string, TruthMetric>();\n  private agentScores = new Map<string, AgentTruthScore>();\n  private systemMetrics: SystemTruthMetrics;\n  private activeAlerts = new Map<string, TruthAlert>();\n  private metricsBuffer: TruthMetric[] = [];\n  \n  // Intervals and timers\n  private collectionInterval?: NodeJS.Timeout;\n  private scoringInterval?: NodeJS.Timeout;\n  private alertInterval?: NodeJS.Timeout;\n  private exportInterval?: NodeJS.Timeout;\n  \n  constructor(\n    config: Partial<TruthTelemetryConfig>,\n    logger: ILogger,\n    eventBus: IEventBus,\n    memory: DistributedMemorySystem\n  ) {\n    super();\n    \n    this.logger = logger;\n    this.eventBus = eventBus;\n    this.memory = memory;\n    \n    this.config = {\n      metricsInterval: 5000,\n      batchSize: 100,\n      bufferSize: 1000,\n      validationTimeout: 30000,\n      maxValidationRetries: 3,\n      validationThreshold: 0.95,\n      scoringInterval: 60000,\n      performanceWindowSize: 1440, // 24 hours in minutes\n      trendAnalysisDepth: 168, // 1 week in hours\n      alertEnabled: true,\n      alertThresholds: {\n        accuracyThreshold: 0.95,\n        interventionRateThreshold: 0.10,\n        systemReliabilityThreshold: 0.98,\n        criticalErrorThreshold: 0.01,\n      },\n      dashboardEnabled: true,\n      exportInterval: 300000, // 5 minutes\n      exportFormat: 'json',\n      retentionPeriod: 2592000000, // 30 days\n      mcpIntegration: true,\n      persistenceEnabled: true,\n      realtimeEnabled: true,\n      debugMode: false,\n      ...config,\n    };\n    \n    this.initializeComponents();\n    this.initializeSystemMetrics();\n    this.setupEventListeners();\n  }\n  \n  private initializeComponents(): void {\n    this.metricsCollector = new TruthMetricsCollector(this.config, this.logger);\n    this.agentScorer = new AgentTruthScorer(this.config, this.logger);\n    this.systemTracker = new SystemTruthTracker(this.config, this.logger);\n    this.alertManager = new TruthAlertManager(this.config, this.logger, this.eventBus);\n    this.dashboardExporter = new DashboardExporter(this.config, this.logger);\n    this.automatedValidator = new AutomatedValidator(this.config, this.logger);\n  }\n  \n  private initializeSystemMetrics(): void {\n    this.systemMetrics = {\n      timestamp: new Date(),\n      overallAccuracy: 0.95,\n      humanInterventionRate: 0.05,\n      systemReliability: 0.98,\n      agentCount: 0,\n      activeAgents: 0,\n      totalTasks: 0,\n      verifiedTasks: 0,\n      criticalFailures: 0,\n      recoveryTime: 0,\n      efficiency: 0.85,\n      distributionMetrics: {\n        taskDistribution: {},\n        accuracyDistribution: {},\n        complexityDistribution: {},\n        errorTypeDistribution: {},\n      },\n    };\n  }\n  \n  private setupEventListeners(): void {\n    // Agent task events\n    this.eventBus.on('agent:task:started', (data) => {\n      this.handleTaskStarted(data);\n    });\n    \n    this.eventBus.on('agent:task:completed', (data) => {\n      this.handleTaskCompleted(data);\n    });\n    \n    this.eventBus.on('agent:task:failed', (data) => {\n      this.handleTaskFailed(data);\n    });\n    \n    // Validation events\n    this.eventBus.on('validation:completed', (data) => {\n      this.handleValidationCompleted(data);\n    });\n    \n    this.eventBus.on('validation:failed', (data) => {\n      this.handleValidationFailed(data);\n    });\n    \n    // Human intervention events\n    this.eventBus.on('human:intervention', (data) => {\n      this.handleHumanIntervention(data);\n    });\n    \n    // System events\n    this.eventBus.on('system:alert', (data) => {\n      this.handleSystemAlert(data);\n    });\n  }\n  \n  // ========================================================================================\n  // Lifecycle Management\n  // ========================================================================================\n  \n  async initialize(): Promise<void> {\n    this.logger.info('Initializing Truth Telemetry Engine', {\n      config: {\n        metricsInterval: this.config.metricsInterval,\n        alertEnabled: this.config.alertEnabled,\n        dashboardEnabled: this.config.dashboardEnabled,\n        mcpIntegration: this.config.mcpIntegration,\n      },\n    });\n    \n    // Initialize components\n    await this.metricsCollector.initialize();\n    await this.agentScorer.initialize();\n    await this.systemTracker.initialize();\n    await this.alertManager.initialize();\n    await this.dashboardExporter.initialize();\n    await this.automatedValidator.initialize();\n    \n    // Start collection intervals\n    this.startMetricsCollection();\n    this.startAgentScoring();\n    this.startAlertMonitoring();\n    \n    if (this.config.dashboardEnabled) {\n      this.startDashboardExport();\n    }\n    \n    // Load historical data if persistence is enabled\n    if (this.config.persistenceEnabled) {\n      await this.loadHistoricalData();\n    }\n    \n    this.emit('telemetry:initialized');\n    this.logger.info('Truth Telemetry Engine initialized successfully');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Truth Telemetry Engine');\n    \n    // Stop all intervals\n    if (this.collectionInterval) clearInterval(this.collectionInterval);\n    if (this.scoringInterval) clearInterval(this.scoringInterval);\n    if (this.alertInterval) clearInterval(this.alertInterval);\n    if (this.exportInterval) clearInterval(this.exportInterval);\n    \n    // Flush remaining data\n    await this.flushMetricsBuffer();\n    \n    // Persist current state\n    if (this.config.persistenceEnabled) {\n      await this.persistCurrentState();\n    }\n    \n    // Shutdown components\n    await this.metricsCollector.shutdown();\n    await this.agentScorer.shutdown();\n    await this.systemTracker.shutdown();\n    await this.alertManager.shutdown();\n    await this.dashboardExporter.shutdown();\n    await this.automatedValidator.shutdown();\n    \n    this.emit('telemetry:shutdown');\n    this.logger.info('Truth Telemetry Engine shutdown complete');\n  }\n  \n  // ========================================================================================\n  // Metrics Collection\n  // ========================================================================================\n  \n  private startMetricsCollection(): void {\n    this.collectionInterval = setInterval(() => {\n      this.collectMetrics();\n    }, this.config.metricsInterval);\n    \n    this.logger.info('Started metrics collection', {\n      interval: this.config.metricsInterval,\n    });\n  }\n  \n  private async collectMetrics(): Promise<void> {\n    try {\n      // Process metrics buffer\n      await this.processMetricsBuffer();\n      \n      // Update system metrics\n      await this.updateSystemMetrics();\n      \n      // Clean up old metrics\n      this.cleanupOldMetrics();\n      \n    } catch (error) {\n      this.logger.error('Error in metrics collection', error);\n    }\n  }\n  \n  private async processMetricsBuffer(): Promise<void> {\n    if (this.metricsBuffer.length === 0) return;\n    \n    const batch = this.metricsBuffer.splice(0, this.config.batchSize);\n    \n    for (const metric of batch) {\n      await this.processMetric(metric);\n    }\n  }\n  \n  private async processMetric(metric: TruthMetric): Promise<void> {\n    // Store metric\n    this.truthMetrics.set(metric.id, metric);\n    \n    // Update agent scores\n    await this.agentScorer.updateAgentMetric(metric);\n    \n    // Update system tracking\n    await this.systemTracker.updateSystemMetric(metric);\n    \n    // Check for alerts\n    if (this.config.alertEnabled) {\n      await this.alertManager.checkThresholds(metric);\n    }\n    \n    // Emit event for real-time processing\n    if (this.config.realtimeEnabled) {\n      this.emit('metric:processed', { metric });\n    }\n  }\n  \n  // ========================================================================================\n  // Agent Scoring\n  // ========================================================================================\n  \n  private startAgentScoring(): void {\n    this.scoringInterval = setInterval(() => {\n      this.updateAgentScores();\n    }, this.config.scoringInterval);\n    \n    this.logger.info('Started agent scoring', {\n      interval: this.config.scoringInterval,\n    });\n  }\n  \n  private async updateAgentScores(): Promise<void> {\n    try {\n      const agentIds = new Set([\n        ...this.agentScores.keys(),\n        ...Array.from(this.truthMetrics.values()).map(m => m.agentId),\n      ]);\n      \n      for (const agentId of agentIds) {\n        const score = await this.agentScorer.calculateAgentScore(agentId);\n        if (score) {\n          this.agentScores.set(agentId, score);\n          this.emit('agent:score:updated', { agentId, score });\n        }\n      }\n      \n    } catch (error) {\n      this.logger.error('Error updating agent scores', error);\n    }\n  }\n  \n  // ========================================================================================\n  // Alert Monitoring\n  // ========================================================================================\n  \n  private startAlertMonitoring(): void {\n    this.alertInterval = setInterval(() => {\n      this.processAlerts();\n    }, 10000); // Check every 10 seconds\n    \n    this.logger.info('Started alert monitoring');\n  }\n  \n  private async processAlerts(): Promise<void> {\n    try {\n      // Check system-wide thresholds\n      await this.checkSystemThresholds();\n      \n      // Process active alerts\n      await this.processActiveAlerts();\n      \n      // Clean up resolved alerts\n      this.cleanupResolvedAlerts();\n      \n    } catch (error) {\n      this.logger.error('Error processing alerts', error);\n    }\n  }\n  \n  private async checkSystemThresholds(): Promise<void> {\n    const thresholds = this.config.alertThresholds;\n    \n    // Check accuracy threshold\n    if (this.systemMetrics.overallAccuracy < thresholds.accuracyThreshold) {\n      await this.createAlert({\n        type: 'accuracy_degradation',\n        severity: 'critical',\n        message: `System accuracy (${this.systemMetrics.overallAccuracy.toFixed(3)}) below threshold (${thresholds.accuracyThreshold})`,\n        context: { accuracy: this.systemMetrics.overallAccuracy },\n      });\n    }\n    \n    // Check intervention rate threshold\n    if (this.systemMetrics.humanInterventionRate > thresholds.interventionRateThreshold) {\n      await this.createAlert({\n        type: 'high_intervention_rate',\n        severity: 'warning',\n        message: `Human intervention rate (${this.systemMetrics.humanInterventionRate.toFixed(3)}) above threshold (${thresholds.interventionRateThreshold})`,\n        context: { interventionRate: this.systemMetrics.humanInterventionRate },\n      });\n    }\n    \n    // Check system reliability\n    if (this.systemMetrics.systemReliability < thresholds.systemReliabilityThreshold) {\n      await this.createAlert({\n        type: 'system_failure',\n        severity: 'critical',\n        message: `System reliability (${this.systemMetrics.systemReliability.toFixed(3)}) below threshold (${thresholds.systemReliabilityThreshold})`,\n        context: { reliability: this.systemMetrics.systemReliability },\n      });\n    }\n  }\n  \n  private async createAlert(alertData: Partial<TruthAlert>): Promise<string> {\n    const alertId = `alert-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    \n    const alert: TruthAlert = {\n      id: alertId,\n      timestamp: new Date(),\n      severity: alertData.severity || 'warning',\n      type: alertData.type || 'threshold_violation',\n      message: alertData.message || 'Unknown alert',\n      source: 'truth-telemetry',\n      context: alertData.context || {},\n      thresholds: [],\n      actions: [],\n      escalationPath: [],\n      resolved: false,\n      ...alertData,\n    };\n    \n    this.activeAlerts.set(alertId, alert);\n    \n    this.logger.warn('Truth telemetry alert created', {\n      alertId,\n      type: alert.type,\n      severity: alert.severity,\n      message: alert.message,\n    });\n    \n    this.emit('alert:created', { alert });\n    \n    // Execute alert actions\n    await this.alertManager.executeAlertActions(alert);\n    \n    return alertId;\n  }\n  \n  // ========================================================================================\n  // Dashboard Export\n  // ========================================================================================\n  \n  private startDashboardExport(): void {\n    this.exportInterval = setInterval(() => {\n      this.exportDashboardData();\n    }, this.config.exportInterval);\n    \n    this.logger.info('Started dashboard export', {\n      interval: this.config.exportInterval,\n    });\n  }\n  \n  private async exportDashboardData(): Promise<void> {\n    try {\n      const dashboardData = await this.generateDashboardData();\n      \n      // Emit for real-time updates\n      this.emit('dashboard:updated', { data: dashboardData });\n      \n      // Persist if enabled\n      if (this.config.persistenceEnabled) {\n        await this.persistDashboardData(dashboardData);\n      }\n      \n    } catch (error) {\n      this.logger.error('Error exporting dashboard data', error);\n    }\n  }\n  \n  private async generateDashboardData(): Promise<DashboardData> {\n    return this.dashboardExporter.generateDashboard({\n      systemMetrics: this.systemMetrics,\n      agentScores: Array.from(this.agentScores.values()),\n      truthMetrics: Array.from(this.truthMetrics.values()),\n      activeAlerts: Array.from(this.activeAlerts.values()),\n    });\n  }\n  \n  // ========================================================================================\n  // Event Handlers\n  // ========================================================================================\n  \n  private async handleTaskStarted(data: any): Promise<void> {\n    const metric = await this.metricsCollector.createTaskMetric({\n      agentId: data.agentId,\n      taskId: data.taskId,\n      metricType: 'efficiency',\n      context: {\n        taskType: data.taskType,\n        complexity: data.complexity || 'medium',\n        domain: data.domain || 'general',\n        dependencies: data.dependencies || [],\n        inputSources: data.inputSources || [],\n        outputTargets: data.outputTargets || [],\n        verificationMethod: 'automated',\n        riskLevel: data.riskLevel || 'medium',\n      },\n    });\n    \n    this.metricsBuffer.push(metric);\n  }\n  \n  private async handleTaskCompleted(data: any): Promise<void> {\n    // Validate the completed task\n    const validation = await this.automatedValidator.validateTask(data);\n    \n    const metric = await this.metricsCollector.createTaskMetric({\n      agentId: data.agentId,\n      taskId: data.taskId,\n      metricType: 'accuracy',\n      value: validation.score,\n      confidence: data.confidence || 0.8,\n      validation,\n      context: {\n        taskType: data.taskType,\n        complexity: data.complexity || 'medium',\n        domain: data.domain || 'general',\n        dependencies: data.dependencies || [],\n        inputSources: data.inputSources || [],\n        outputTargets: data.outputTargets || [],\n        verificationMethod: validation.humanReview ? 'hybrid' : 'automated',\n        riskLevel: this.assessRiskLevel(validation),\n      },\n    });\n    \n    this.metricsBuffer.push(metric);\n  }\n  \n  private async handleTaskFailed(data: any): Promise<void> {\n    const metric = await this.metricsCollector.createTaskMetric({\n      agentId: data.agentId,\n      taskId: data.taskId,\n      metricType: 'reliability',\n      value: 0,\n      confidence: 1.0,\n      validation: {\n        isValid: false,\n        validationType: 'functional',\n        score: 0,\n        errors: [{\n          type: data.errorType || 'unknown',\n          severity: 'high',\n          message: data.error || 'Task failed',\n          impact: 1.0,\n        }],\n        warnings: [],\n        suggestions: [],\n        automatedChecks: [],\n      },\n      context: {\n        taskType: data.taskType,\n        complexity: data.complexity || 'medium',\n        domain: data.domain || 'general',\n        dependencies: data.dependencies || [],\n        inputSources: data.inputSources || [],\n        outputTargets: data.outputTargets || [],\n        verificationMethod: 'automated',\n        riskLevel: 'high',\n      },\n    });\n    \n    this.metricsBuffer.push(metric);\n  }\n  \n  private async handleValidationCompleted(data: any): Promise<void> {\n    // Update existing metric with validation results\n    const existingMetric = this.truthMetrics.get(data.taskId);\n    if (existingMetric) {\n      existingMetric.validation = data.validation;\n      existingMetric.value = data.validation.score;\n      await this.processMetric(existingMetric);\n    }\n  }\n  \n  private async handleValidationFailed(data: any): Promise<void> {\n    this.logger.warn('Validation failed', { taskId: data.taskId, error: data.error });\n    \n    // Create alert for validation failure\n    await this.createAlert({\n      type: 'threshold_violation',\n      severity: 'warning',\n      message: `Validation failed for task ${data.taskId}: ${data.error}`,\n      context: { taskId: data.taskId, error: data.error },\n    });\n  }\n  \n  private async handleHumanIntervention(data: any): Promise<void> {\n    // Update intervention rate\n    this.systemMetrics.humanInterventionRate = \n      this.calculateHumanInterventionRate();\n    \n    // Create metric for human intervention\n    const metric = await this.metricsCollector.createTaskMetric({\n      agentId: data.agentId,\n      taskId: data.taskId,\n      metricType: 'consistency',\n      value: 0.5, // Human intervention suggests agent uncertainty\n      confidence: 1.0,\n      validation: {\n        isValid: true,\n        validationType: 'semantic',\n        score: data.humanReview?.score || 0.8,\n        errors: [],\n        warnings: [],\n        suggestions: [],\n        automatedChecks: [],\n        humanReview: data.humanReview,\n      },\n      context: {\n        taskType: data.taskType,\n        complexity: 'high', // Usually requires intervention for complex tasks\n        domain: data.domain || 'general',\n        dependencies: data.dependencies || [],\n        inputSources: data.inputSources || [],\n        outputTargets: data.outputTargets || [],\n        verificationMethod: 'human',\n        riskLevel: 'medium',\n      },\n    });\n    \n    this.metricsBuffer.push(metric);\n  }\n  \n  private async handleSystemAlert(data: any): Promise<void> {\n    await this.createAlert({\n      type: data.type || 'system_failure',\n      severity: data.severity || 'warning',\n      message: data.message,\n      context: data.context || {},\n    });\n  }\n  \n  // ========================================================================================\n  // Utility Methods\n  // ========================================================================================\n  \n  private assessRiskLevel(validation: ValidationResult): 'low' | 'medium' | 'high' | 'critical' {\n    const criticalErrors = validation.errors.filter(e => e.severity === 'critical');\n    const highErrors = validation.errors.filter(e => e.severity === 'high');\n    \n    if (criticalErrors.length > 0) return 'critical';\n    if (highErrors.length > 0 || validation.score < 0.7) return 'high';\n    if (validation.score < 0.9) return 'medium';\n    return 'low';\n  }\n  \n  private calculateHumanInterventionRate(): number {\n    const recentMetrics = Array.from(this.truthMetrics.values())\n      .filter(m => m.timestamp > new Date(Date.now() - 3600000)) // Last hour\n      .filter(m => m.context.verificationMethod === 'human' || m.context.verificationMethod === 'hybrid');\n    \n    const totalMetrics = Array.from(this.truthMetrics.values())\n      .filter(m => m.timestamp > new Date(Date.now() - 3600000));\n    \n    return totalMetrics.length > 0 ? recentMetrics.length / totalMetrics.length : 0;\n  }\n  \n  private async updateSystemMetrics(): Promise<void> {\n    const allMetrics = Array.from(this.truthMetrics.values());\n    const recentMetrics = allMetrics.filter(\n      m => m.timestamp > new Date(Date.now() - 3600000) // Last hour\n    );\n    \n    if (recentMetrics.length > 0) {\n      this.systemMetrics = {\n        ...this.systemMetrics,\n        timestamp: new Date(),\n        overallAccuracy: recentMetrics.reduce((sum, m) => sum + m.value, 0) / recentMetrics.length,\n        humanInterventionRate: this.calculateHumanInterventionRate(),\n        totalTasks: allMetrics.length,\n        verifiedTasks: allMetrics.filter(m => m.validation.isValid).length,\n        agentCount: new Set(allMetrics.map(m => m.agentId)).size,\n        activeAgents: new Set(recentMetrics.map(m => m.agentId)).size,\n      };\n    }\n  }\n  \n  private cleanupOldMetrics(): void {\n    const cutoff = new Date(Date.now() - this.config.retentionPeriod);\n    \n    for (const [id, metric] of this.truthMetrics) {\n      if (metric.timestamp < cutoff) {\n        this.truthMetrics.delete(id);\n      }\n    }\n  }\n  \n  private async processActiveAlerts(): Promise<void> {\n    for (const [alertId, alert] of this.activeAlerts) {\n      if (!alert.resolved) {\n        // Check if alert should be escalated\n        await this.alertManager.processAlert(alert);\n      }\n    }\n  }\n  \n  private cleanupResolvedAlerts(): void {\n    const cutoff = new Date(Date.now() - 86400000); // 24 hours\n    \n    for (const [alertId, alert] of this.activeAlerts) {\n      if (alert.resolved && alert.resolvedAt && alert.resolvedAt < cutoff) {\n        this.activeAlerts.delete(alertId);\n      }\n    }\n  }\n  \n  private async flushMetricsBuffer(): Promise<void> {\n    while (this.metricsBuffer.length > 0) {\n      await this.processMetricsBuffer();\n    }\n  }\n  \n  private async persistCurrentState(): Promise<void> {\n    if (!this.config.mcpIntegration) return;\n    \n    try {\n      const state = {\n        timestamp: new Date(),\n        systemMetrics: this.systemMetrics,\n        agentScores: Array.from(this.agentScores.entries()),\n        activeAlerts: Array.from(this.activeAlerts.entries()),\n        config: this.config,\n      };\n      \n      await this.memory.store('truth-telemetry:state', state, {\n        type: 'truth-telemetry-state',\n        partition: 'verification',\n      });\n      \n    } catch (error) {\n      this.logger.error('Failed to persist telemetry state', error);\n    }\n  }\n  \n  private async loadHistoricalData(): Promise<void> {\n    if (!this.config.mcpIntegration) return;\n    \n    try {\n      const state = await this.memory.retrieve('truth-telemetry:state');\n      \n      if (state && state.data) {\n        this.systemMetrics = state.data.systemMetrics || this.systemMetrics;\n        \n        if (state.data.agentScores) {\n          this.agentScores = new Map(state.data.agentScores);\n        }\n        \n        if (state.data.activeAlerts) {\n          this.activeAlerts = new Map(state.data.activeAlerts);\n        }\n        \n        this.logger.info('Loaded historical telemetry data');\n      }\n      \n    } catch (error) {\n      this.logger.warn('Failed to load historical data', error);\n    }\n  }\n  \n  private async persistDashboardData(data: DashboardData): Promise<void> {\n    if (!this.config.mcpIntegration) return;\n    \n    try {\n      await this.memory.store('truth-telemetry:dashboard', data, {\n        type: 'dashboard-data',\n        partition: 'verification',\n      });\n      \n    } catch (error) {\n      this.logger.error('Failed to persist dashboard data', error);\n    }\n  }\n  \n  // ========================================================================================\n  // Public API\n  // ========================================================================================\n  \n  async recordTruthMetric(metric: Omit<TruthMetric, 'id' | 'timestamp'>): Promise<string> {\n    const fullMetric: TruthMetric = {\n      id: `metric-${Date.now()}-${Math.random().toString(36).slice(2)}`,\n      timestamp: new Date(),\n      ...metric,\n    };\n    \n    this.metricsBuffer.push(fullMetric);\n    \n    if (this.config.realtimeEnabled) {\n      this.emit('metric:recorded', { metric: fullMetric });\n    }\n    \n    return fullMetric.id;\n  }\n  \n  getSystemMetrics(): SystemTruthMetrics {\n    return { ...this.systemMetrics };\n  }\n  \n  getAgentScore(agentId: string): AgentTruthScore | undefined {\n    return this.agentScores.get(agentId);\n  }\n  \n  getAllAgentScores(): AgentTruthScore[] {\n    return Array.from(this.agentScores.values());\n  }\n  \n  getActiveAlerts(): TruthAlert[] {\n    return Array.from(this.activeAlerts.values()).filter(a => !a.resolved);\n  }\n  \n  async resolveAlert(alertId: string, resolvedBy: string): Promise<boolean> {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert) return false;\n    \n    alert.resolved = true;\n    alert.resolvedAt = new Date();\n    alert.resolvedBy = resolvedBy;\n    \n    this.emit('alert:resolved', { alert, resolvedBy });\n    \n    return true;\n  }\n  \n  async getDashboardData(): Promise<DashboardData> {\n    return this.generateDashboardData();\n  }\n  \n  getMetrics(filters?: {\n    agentId?: string;\n    taskId?: string;\n    metricType?: TruthMetricType;\n    startTime?: Date;\n    endTime?: Date;\n  }): TruthMetric[] {\n    let metrics = Array.from(this.truthMetrics.values());\n    \n    if (filters) {\n      if (filters.agentId) {\n        metrics = metrics.filter(m => m.agentId === filters.agentId);\n      }\n      if (filters.taskId) {\n        metrics = metrics.filter(m => m.taskId === filters.taskId);\n      }\n      if (filters.metricType) {\n        metrics = metrics.filter(m => m.metricType === filters.metricType);\n      }\n      if (filters.startTime) {\n        metrics = metrics.filter(m => m.timestamp >= filters.startTime!);\n      }\n      if (filters.endTime) {\n        metrics = metrics.filter(m => m.timestamp <= filters.endTime!);\n      }\n    }\n    \n    return metrics;\n  }\n  \n  getTelemetryStatistics(): {\n    totalMetrics: number;\n    activeAlerts: number;\n    agentsTracked: number;\n    systemHealth: number;\n    lastUpdate: Date;\n  } {\n    return {\n      totalMetrics: this.truthMetrics.size,\n      activeAlerts: Array.from(this.activeAlerts.values()).filter(a => !a.resolved).length,\n      agentsTracked: this.agentScores.size,\n      systemHealth: this.systemMetrics.overallAccuracy * this.systemMetrics.systemReliability,\n      lastUpdate: this.systemMetrics.timestamp,\n    };\n  }\n}\n\n// ========================================================================================\n// Supporting Classes (Interfaces for now - implementation in separate files)\n// ========================================================================================\n\nexport class TruthMetricsCollector {\n  constructor(\n    private config: TruthTelemetryConfig,\n    private logger: ILogger\n  ) {}\n  \n  async initialize(): Promise<void> {\n    this.logger.info('TruthMetricsCollector initialized');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('TruthMetricsCollector shutdown');\n  }\n  \n  async createTaskMetric(data: Partial<TruthMetric>): Promise<TruthMetric> {\n    return {\n      id: `metric-${Date.now()}-${Math.random().toString(36).slice(2)}`,\n      timestamp: new Date(),\n      agentId: data.agentId || 'unknown',\n      taskId: data.taskId || 'unknown',\n      metricType: data.metricType || 'accuracy',\n      value: data.value || 0,\n      confidence: data.confidence || 0.5,\n      context: data.context || {\n        taskType: 'unknown',\n        complexity: 'medium',\n        domain: 'general',\n        dependencies: [],\n        inputSources: [],\n        outputTargets: [],\n        verificationMethod: 'automated',\n        riskLevel: 'medium',\n      },\n      validation: data.validation || {\n        isValid: false,\n        validationType: 'functional',\n        score: 0,\n        errors: [],\n        warnings: [],\n        suggestions: [],\n        automatedChecks: [],\n      },\n      metadata: data.metadata || {},\n    };\n  }\n}\n\nexport class AgentTruthScorer {\n  constructor(\n    private config: TruthTelemetryConfig,\n    private logger: ILogger\n  ) {}\n  \n  async initialize(): Promise<void> {\n    this.logger.info('AgentTruthScorer initialized');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('AgentTruthScorer shutdown');\n  }\n  \n  async updateAgentMetric(metric: TruthMetric): Promise<void> {\n    // Implementation would update agent-specific metrics\n  }\n  \n  async calculateAgentScore(agentId: string): Promise<AgentTruthScore | null> {\n    // Implementation would calculate comprehensive agent score\n    return {\n      agentId,\n      timestamp: new Date(),\n      overallScore: 0.85,\n      components: {\n        accuracy: 0.90,\n        reliability: 0.85,\n        consistency: 0.88,\n        efficiency: 0.82,\n        adaptability: 0.80,\n      },\n      recentPerformance: [],\n      trends: [],\n      benchmarks: [],\n      riskAssessment: {\n        level: 'low',\n        factors: [],\n        recommendations: [],\n        mitigationStrategies: [],\n      },\n    };\n  }\n}\n\nexport class SystemTruthTracker {\n  constructor(\n    private config: TruthTelemetryConfig,\n    private logger: ILogger\n  ) {}\n  \n  async initialize(): Promise<void> {\n    this.logger.info('SystemTruthTracker initialized');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('SystemTruthTracker shutdown');\n  }\n  \n  async updateSystemMetric(metric: TruthMetric): Promise<void> {\n    // Implementation would update system-wide metrics\n  }\n}\n\nexport class TruthAlertManager {\n  constructor(\n    private config: TruthTelemetryConfig,\n    private logger: ILogger,\n    private eventBus: IEventBus\n  ) {}\n  \n  async initialize(): Promise<void> {\n    this.logger.info('TruthAlertManager initialized');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('TruthAlertManager shutdown');\n  }\n  \n  async checkThresholds(metric: TruthMetric): Promise<void> {\n    // Implementation would check metric against thresholds\n  }\n  \n  async executeAlertActions(alert: TruthAlert): Promise<void> {\n    // Implementation would execute configured alert actions\n  }\n  \n  async processAlert(alert: TruthAlert): Promise<void> {\n    // Implementation would process escalation and resolution\n  }\n}\n\nexport class DashboardExporter {\n  constructor(\n    private config: TruthTelemetryConfig,\n    private logger: ILogger\n  ) {}\n  \n  async initialize(): Promise<void> {\n    this.logger.info('DashboardExporter initialized');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('DashboardExporter shutdown');\n  }\n  \n  async generateDashboard(data: {\n    systemMetrics: SystemTruthMetrics;\n    agentScores: AgentTruthScore[];\n    truthMetrics: TruthMetric[];\n    activeAlerts: TruthAlert[];\n  }): Promise<DashboardData> {\n    // Implementation would generate comprehensive dashboard\n    return {\n      timestamp: new Date(),\n      summary: {\n        overallHealth: 0.95,\n        truthAccuracy: data.systemMetrics.overallAccuracy,\n        humanInterventionRate: data.systemMetrics.humanInterventionRate,\n        systemEfficiency: data.systemMetrics.efficiency,\n        alertCount: data.activeAlerts.length,\n      },\n      charts: {\n        accuracyTrend: [],\n        interventionTrend: [],\n        agentPerformance: [],\n        errorDistribution: [],\n        systemLoad: [],\n      },\n      tables: {\n        topPerformers: [],\n        recentAlerts: data.activeAlerts.slice(-10),\n        criticalIssues: [],\n      },\n      insights: [],\n    };\n  }\n}\n\nexport class AutomatedValidator {\n  constructor(\n    private config: TruthTelemetryConfig,\n    private logger: ILogger\n  ) {}\n  \n  async initialize(): Promise<void> {\n    this.logger.info('AutomatedValidator initialized');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('AutomatedValidator shutdown');\n  }\n  \n  async validateTask(taskData: any): Promise<ValidationResult> {\n    // Implementation would perform comprehensive validation\n    return {\n      isValid: true,\n      validationType: 'functional',\n      score: 0.9,\n      errors: [],\n      warnings: [],\n      suggestions: [],\n      automatedChecks: [\n        {\n          name: 'syntax_check',\n          type: 'static',\n          status: 'passed',\n          details: {},\n          executionTime: 150,\n        },\n      ],\n    };\n  }\n}\n\nexport default TruthTelemetryEngine;"],"names":["EventEmitter","TruthTelemetryEngine","config","logger","eventBus","memory","metricsCollector","agentScorer","systemTracker","alertManager","dashboardExporter","automatedValidator","truthMetrics","Map","agentScores","systemMetrics","activeAlerts","metricsBuffer","collectionInterval","scoringInterval","alertInterval","exportInterval","metricsInterval","batchSize","bufferSize","validationTimeout","maxValidationRetries","validationThreshold","performanceWindowSize","trendAnalysisDepth","alertEnabled","alertThresholds","accuracyThreshold","interventionRateThreshold","systemReliabilityThreshold","criticalErrorThreshold","dashboardEnabled","exportFormat","retentionPeriod","mcpIntegration","persistenceEnabled","realtimeEnabled","debugMode","initializeComponents","initializeSystemMetrics","setupEventListeners","TruthMetricsCollector","AgentTruthScorer","SystemTruthTracker","TruthAlertManager","DashboardExporter","AutomatedValidator","timestamp","Date","overallAccuracy","humanInterventionRate","systemReliability","agentCount","activeAgents","totalTasks","verifiedTasks","criticalFailures","recoveryTime","efficiency","distributionMetrics","taskDistribution","accuracyDistribution","complexityDistribution","errorTypeDistribution","on","data","handleTaskStarted","handleTaskCompleted","handleTaskFailed","handleValidationCompleted","handleValidationFailed","handleHumanIntervention","handleSystemAlert","initialize","info","startMetricsCollection","startAgentScoring","startAlertMonitoring","startDashboardExport","loadHistoricalData","emit","shutdown","clearInterval","flushMetricsBuffer","persistCurrentState","setInterval","collectMetrics","interval","processMetricsBuffer","updateSystemMetrics","cleanupOldMetrics","error","length","batch","splice","metric","processMetric","set","id","updateAgentMetric","updateSystemMetric","checkThresholds","updateAgentScores","agentIds","Set","keys","Array","from","values","map","m","agentId","score","calculateAgentScore","processAlerts","checkSystemThresholds","processActiveAlerts","cleanupResolvedAlerts","thresholds","createAlert","type","severity","message","toFixed","context","accuracy","interventionRate","reliability","alertData","alertId","now","Math","random","toString","slice","alert","source","actions","escalationPath","resolved","warn","executeAlertActions","exportDashboardData","dashboardData","generateDashboardData","persistDashboardData","generateDashboard","createTaskMetric","taskId","metricType","taskType","complexity","domain","dependencies","inputSources","outputTargets","verificationMethod","riskLevel","push","validation","validateTask","value","confidence","humanReview","assessRiskLevel","isValid","validationType","errors","errorType","impact","warnings","suggestions","automatedChecks","existingMetric","get","calculateHumanInterventionRate","criticalErrors","filter","e","highErrors","recentMetrics","totalMetrics","allMetrics","reduce","sum","size","cutoff","delete","processAlert","resolvedAt","state","entries","store","partition","retrieve","recordTruthMetric","fullMetric","getSystemMetrics","getAgentScore","getAllAgentScores","getActiveAlerts","a","resolveAlert","resolvedBy","getDashboardData","getMetrics","filters","metrics","startTime","endTime","getTelemetryStatistics","agentsTracked","systemHealth","lastUpdate","metadata","overallScore","components","consistency","adaptability","recentPerformance","trends","benchmarks","riskAssessment","level","factors","recommendations","mitigationStrategies","summary","overallHealth","truthAccuracy","systemEfficiency","alertCount","charts","accuracyTrend","interventionTrend","agentPerformance","errorDistribution","systemLoad","tables","topPerformers","recentAlerts","criticalIssues","insights","taskData","name","status","details","executionTime"],"mappings":"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"}