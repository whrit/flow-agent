{"version":3,"sources":["../../../src/verification/system-tracker.ts"],"sourcesContent":["/**\n * System Truth Tracker - System-wide truth accuracy monitoring and analysis\n * \n * Tracks overall system performance, distributional metrics, and system health\n * with real-time monitoring and predictive analytics capabilities.\n */\n\nimport type { ILogger } from '../core/logger.js';\nimport type {\n  TruthMetric,\n  SystemTruthMetrics,\n  DistributionMetrics,\n  TruthTelemetryConfig,\n} from './telemetry.js';\n\nexport interface SystemHealthIndicators {\n  timestamp: Date;\n  overallHealth: number; // 0-1\n  subsystemHealth: {\n    collection: number;\n    validation: number;\n    scoring: number;\n    alerting: number;\n    persistence: number;\n  };\n  performanceIndicators: {\n    latency: number;\n    throughput: number;\n    errorRate: number;\n    availability: number;\n  };\n  capacityMetrics: {\n    currentLoad: number;\n    maxCapacity: number;\n    utilizationRate: number;\n    queueDepth: number;\n  };\n}\n\nexport interface SystemTrend {\n  metric: string;\n  timeframe: string;\n  currentValue: number;\n  previousValue: number;\n  changePercent: number;\n  direction: 'improving' | 'declining' | 'stable';\n  significance: 'low' | 'medium' | 'high';\n  prediction: {\n    nextValue: number;\n    confidence: number;\n    timeToTarget?: Date;\n  };\n}\n\nexport interface DistributionAnalysis {\n  metric: string;\n  distribution: {\n    min: number;\n    max: number;\n    mean: number;\n    median: number;\n    mode: number;\n    stdDev: number;\n    percentiles: Record<string, number>;\n  };\n  outliers: {\n    values: number[];\n    count: number;\n    percentage: number;\n  };\n  normalityTest: {\n    isNormal: boolean;\n    pValue: number;\n    testStatistic: number;\n  };\n}\n\nexport interface SystemPrediction {\n  metric: string;\n  currentValue: number;\n  predictions: {\n    shortTerm: { value: number; confidence: number; timeframe: string };\n    mediumTerm: { value: number; confidence: number; timeframe: string };\n    longTerm: { value: number; confidence: number; timeframe: string };\n  };\n  factors: PredictionFactor[];\n  recommendations: string[];\n}\n\nexport interface PredictionFactor {\n  name: string;\n  impact: number; // -1 to 1\n  confidence: number; // 0 to 1\n  description: string;\n}\n\nexport interface SystemAlert {\n  id: string;\n  timestamp: Date;\n  type: 'performance' | 'quality' | 'capacity' | 'health';\n  severity: 'info' | 'warning' | 'critical' | 'emergency';\n  message: string;\n  metrics: Record<string, number>;\n  threshold: number;\n  currentValue: number;\n  trend: string;\n  impact: string;\n  recommendedActions: string[];\n}\n\nexport class SystemTruthTracker {\n  private config: TruthTelemetryConfig;\n  private logger: ILogger;\n  \n  // System state\n  private systemMetrics: SystemTruthMetrics;\n  private healthIndicators: SystemHealthIndicators;\n  private historicalMetrics: TruthMetric[] = [];\n  private systemTrends = new Map<string, SystemTrend>();\n  private distributionAnalyses = new Map<string, DistributionAnalysis>();\n  private predictions = new Map<string, SystemPrediction>();\n  \n  // Analytics state\n  private metricsBuffer: TruthMetric[] = [];\n  private analysisInterval?: NodeJS.Timeout;\n  private predictionInterval?: NodeJS.Timeout;\n  \n  // Performance tracking\n  private lastAnalysisTime = new Date();\n  private totalMetricsProcessed = 0;\n  private systemStartTime = new Date();\n  \n  constructor(config: TruthTelemetryConfig, logger: ILogger) {\n    this.config = config;\n    this.logger = logger;\n    \n    this.initializeSystemMetrics();\n    this.initializeHealthIndicators();\n  }\n  \n  async initialize(): Promise<void> {\n    this.logger.info('Initializing System Truth Tracker');\n    \n    // Start analysis processes\n    this.startPeriodicAnalysis();\n    this.startPredictiveAnalysis();\n    \n    this.logger.info('System Truth Tracker initialized successfully');\n  }\n  \n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down System Truth Tracker');\n    \n    // Stop intervals\n    if (this.analysisInterval) clearInterval(this.analysisInterval);\n    if (this.predictionInterval) clearInterval(this.predictionInterval);\n    \n    // Final analysis\n    await this.performComprehensiveAnalysis();\n    \n    this.logger.info('System Truth Tracker shutdown complete');\n  }\n  \n  async updateSystemMetric(metric: TruthMetric): Promise<void> {\n    // Add to buffer for batch processing\n    this.metricsBuffer.push(metric);\n    this.totalMetricsProcessed++;\n    \n    // Add to historical data\n    this.historicalMetrics.push(metric);\n    \n    // Keep historical data within limits\n    if (this.historicalMetrics.length > 100000) {\n      this.historicalMetrics = this.historicalMetrics.slice(-50000);\n    }\n    \n    // Real-time updates for critical metrics\n    if (this.isCriticalMetric(metric)) {\n      await this.updateRealTimeMetrics();\n    }\n  }\n  \n  private async updateRealTimeMetrics(): Promise<void> {\n    const recentMetrics = this.getRecentMetrics(60 * 60 * 1000); // Last hour\n    \n    if (recentMetrics.length === 0) return;\n    \n    // Update overall accuracy\n    const accuracyMetrics = recentMetrics.filter(m => m.metricType === 'accuracy');\n    if (accuracyMetrics.length > 0) {\n      this.systemMetrics.overallAccuracy = \n        accuracyMetrics.reduce((sum, m) => sum + m.value, 0) / accuracyMetrics.length;\n    }\n    \n    // Update human intervention rate\n    const totalTasks = recentMetrics.length;\n    const humanInterventions = recentMetrics.filter(\n      m => m.context.verificationMethod === 'human' || m.context.verificationMethod === 'hybrid'\n    ).length;\n    \n    this.systemMetrics.humanInterventionRate = totalTasks > 0 ? humanInterventions / totalTasks : 0;\n    \n    // Update system reliability\n    const validTasks = recentMetrics.filter(m => m.validation.isValid).length;\n    this.systemMetrics.systemReliability = totalTasks > 0 ? validTasks / totalTasks : 1;\n    \n    // Update agent counts\n    const uniqueAgents = new Set(recentMetrics.map(m => m.agentId));\n    this.systemMetrics.activeAgents = uniqueAgents.size;\n    \n    // Update task counts\n    this.systemMetrics.totalTasks = this.historicalMetrics.length;\n    this.systemMetrics.verifiedTasks = this.historicalMetrics.filter(m => m.validation.isValid).length;\n    \n    // Update critical failures\n    const criticalErrors = recentMetrics.filter(\n      m => m.validation.errors.some(e => e.severity === 'critical')\n    ).length;\n    this.systemMetrics.criticalFailures = criticalErrors;\n    \n    // Update efficiency\n    this.systemMetrics.efficiency = this.calculateSystemEfficiency(recentMetrics);\n    \n    // Update timestamp\n    this.systemMetrics.timestamp = new Date();\n  }\n  \n  private startPeriodicAnalysis(): void {\n    this.analysisInterval = setInterval(async () => {\n      await this.performPeriodicAnalysis();\n    }, 5 * 60 * 1000); // Every 5 minutes\n    \n    this.logger.info('Started periodic system analysis');\n  }\n  \n  private startPredictiveAnalysis(): void {\n    this.predictionInterval = setInterval(async () => {\n      await this.performPredictiveAnalysis();\n    }, 15 * 60 * 1000); // Every 15 minutes\n    \n    this.logger.info('Started predictive analysis');\n  }\n  \n  private async performPeriodicAnalysis(): Promise<void> {\n    try {\n      // Process buffered metrics\n      await this.processMetricsBuffer();\n      \n      // Update distribution metrics\n      await this.updateDistributionMetrics();\n      \n      // Analyze trends\n      await this.analyzeTrends();\n      \n      // Update health indicators\n      await this.updateHealthIndicators();\n      \n      // Update timestamp\n      this.lastAnalysisTime = new Date();\n      \n    } catch (error) {\n      this.logger.error('Error in periodic analysis', error);\n    }\n  }\n  \n  private async processMetricsBuffer(): Promise<void> {\n    if (this.metricsBuffer.length === 0) return;\n    \n    const batch = this.metricsBuffer.splice(0);\n    \n    // Update system metrics based on batch\n    await this.updateSystemMetricsFromBatch(batch);\n    \n    // Analyze distribution for each metric type\n    await this.analyzeDistributions(batch);\n  }\n  \n  private async updateSystemMetricsFromBatch(metrics: TruthMetric[]): Promise<void> {\n    if (metrics.length === 0) return;\n    \n    // Group metrics by type\n    const metricsByType = new Map<string, TruthMetric[]>();\n    metrics.forEach(metric => {\n      if (!metricsByType.has(metric.metricType)) {\n        metricsByType.set(metric.metricType, []);\n      }\n      metricsByType.get(metric.metricType)!.push(metric);\n    });\n    \n    // Update accuracy\n    const accuracyMetrics = metricsByType.get('accuracy') || [];\n    if (accuracyMetrics.length > 0) {\n      const weightedSum = accuracyMetrics.reduce(\n        (sum, m) => sum + (m.value * m.confidence), 0\n      );\n      const totalWeight = accuracyMetrics.reduce((sum, m) => sum + m.confidence, 0);\n      \n      if (totalWeight > 0) {\n        this.systemMetrics.overallAccuracy = weightedSum / totalWeight;\n      }\n    }\n    \n    // Update throughput\n    const timeSpan = this.getTimeSpan(metrics);\n    if (timeSpan > 0) {\n      this.systemMetrics.throughput = metrics.length / (timeSpan / (60 * 60 * 1000)); // per hour\n    }\n    \n    // Update latency (average validation time)\n    const validationTimes = metrics\n      .map(m => m.validation.automatedChecks.reduce((sum, c) => sum + c.executionTime, 0))\n      .filter(t => t > 0);\n    \n    if (validationTimes.length > 0) {\n      this.systemMetrics.latency = validationTimes.reduce((sum, t) => sum + t, 0) / validationTimes.length;\n    }\n    \n    // Update error rate\n    const errorCount = metrics.reduce(\n      (sum, m) => sum + m.validation.errors.length, 0\n    );\n    this.systemMetrics.errorRate = metrics.length > 0 ? errorCount / metrics.length : 0;\n    \n    // Update success rate\n    const successCount = metrics.filter(m => m.validation.isValid).length;\n    this.systemMetrics.successRate = metrics.length > 0 ? \n      (successCount / metrics.length) * 100 : 100;\n  }\n  \n  private async updateDistributionMetrics(): Promise<void> {\n    const recentMetrics = this.getRecentMetrics(24 * 60 * 60 * 1000); // Last 24 hours\n    \n    if (recentMetrics.length === 0) return;\n    \n    // Task type distribution\n    const taskTypes = new Map<string, number>();\n    recentMetrics.forEach(metric => {\n      const taskType = metric.context.taskType;\n      taskTypes.set(taskType, (taskTypes.get(taskType) || 0) + 1);\n    });\n    this.systemMetrics.distributionMetrics.taskDistribution = Object.fromEntries(taskTypes);\n    \n    // Accuracy distribution (by ranges)\n    const accuracyRanges = new Map<string, number>();\n    recentMetrics\n      .filter(m => m.metricType === 'accuracy')\n      .forEach(metric => {\n        const range = this.getAccuracyRange(metric.value);\n        accuracyRanges.set(range, (accuracyRanges.get(range) || 0) + 1);\n      });\n    this.systemMetrics.distributionMetrics.accuracyDistribution = Object.fromEntries(accuracyRanges);\n    \n    // Complexity distribution\n    const complexityTypes = new Map<string, number>();\n    recentMetrics.forEach(metric => {\n      const complexity = metric.context.complexity;\n      complexityTypes.set(complexity, (complexityTypes.get(complexity) || 0) + 1);\n    });\n    this.systemMetrics.distributionMetrics.complexityDistribution = Object.fromEntries(complexityTypes);\n    \n    // Error type distribution\n    const errorTypes = new Map<string, number>();\n    recentMetrics.forEach(metric => {\n      metric.validation.errors.forEach(error => {\n        errorTypes.set(error.type, (errorTypes.get(error.type) || 0) + 1);\n      });\n    });\n    this.systemMetrics.distributionMetrics.errorTypeDistribution = Object.fromEntries(errorTypes);\n  }\n  \n  private async analyzeTrends(): Promise<void> {\n    const metrics = ['overallAccuracy', 'humanInterventionRate', 'systemReliability', 'efficiency'];\n    \n    for (const metric of metrics) {\n      const trend = await this.calculateTrend(metric);\n      if (trend) {\n        this.systemTrends.set(metric, trend);\n      }\n    }\n  }\n  \n  private async calculateTrend(metricName: string): Promise<SystemTrend | null> {\n    const historicalValues = await this.getHistoricalValues(metricName, 168); // Last 7 days\n    \n    if (historicalValues.length < 10) return null; // Need sufficient data\n    \n    // Calculate current and previous period averages\n    const midpoint = Math.floor(historicalValues.length / 2);\n    const earlierPeriod = historicalValues.slice(0, midpoint);\n    const laterPeriod = historicalValues.slice(midpoint);\n    \n    const previousValue = earlierPeriod.reduce((sum, v) => sum + v.value, 0) / earlierPeriod.length;\n    const currentValue = laterPeriod.reduce((sum, v) => sum + v.value, 0) / laterPeriod.length;\n    \n    const changePercent = previousValue !== 0 ? \n      ((currentValue - previousValue) / previousValue) * 100 : 0;\n    \n    // Determine direction and significance\n    let direction: 'improving' | 'declining' | 'stable';\n    let significance: 'low' | 'medium' | 'high';\n    \n    if (Math.abs(changePercent) < 1) {\n      direction = 'stable';\n      significance = 'low';\n    } else {\n      direction = changePercent > 0 ? 'improving' : 'declining';\n      \n      if (Math.abs(changePercent) > 10) significance = 'high';\n      else if (Math.abs(changePercent) > 5) significance = 'medium';\n      else significance = 'low';\n    }\n    \n    // Make prediction\n    const prediction = await this.predictNextValue(historicalValues);\n    \n    return {\n      metric: metricName,\n      timeframe: '7d',\n      currentValue,\n      previousValue,\n      changePercent,\n      direction,\n      significance,\n      prediction,\n    };\n  }\n  \n  private async predictNextValue(values: { timestamp: Date; value: number }[]): Promise<{\n    nextValue: number;\n    confidence: number;\n    timeToTarget?: Date;\n  }> {\n    if (values.length < 5) {\n      return { nextValue: values[values.length - 1].value, confidence: 0.3 };\n    }\n    \n    // Simple linear regression for prediction\n    const n = values.length;\n    const x = values.map((_, i) => i);\n    const y = values.map(v => v.value);\n    \n    const sumX = x.reduce((sum, val) => sum + val, 0);\n    const sumY = y.reduce((sum, val) => sum + val, 0);\n    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);\n    const sumX2 = x.reduce((sum, val) => sum + val * val, 0);\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n    \n    // Predict next value\n    const nextValue = slope * n + intercept;\n    \n    // Calculate confidence based on R-squared\n    const yMean = sumY / n;\n    const ssRes = y.reduce((sum, val, i) => {\n      const predicted = slope * i + intercept;\n      return sum + Math.pow(val - predicted, 2);\n    }, 0);\n    const ssTot = y.reduce((sum, val) => sum + Math.pow(val - yMean, 2), 0);\n    \n    const rSquared = ssTot !== 0 ? 1 - (ssRes / ssTot) : 0;\n    const confidence = Math.max(0, Math.min(1, rSquared));\n    \n    return { nextValue, confidence };\n  }\n  \n  private async updateHealthIndicators(): Promise<void> {\n    const now = new Date();\n    const uptime = now.getTime() - this.systemStartTime.getTime();\n    \n    // Calculate subsystem health scores\n    const subsystemHealth = {\n      collection: this.calculateCollectionHealth(),\n      validation: this.calculateValidationHealth(),\n      scoring: this.calculateScoringHealth(),\n      alerting: this.calculateAlertingHealth(),\n      persistence: this.calculatePersistenceHealth(),\n    };\n    \n    // Calculate overall health\n    const healthValues = Object.values(subsystemHealth);\n    const overallHealth = healthValues.reduce((sum, h) => sum + h, 0) / healthValues.length;\n    \n    // Calculate performance indicators\n    const recentMetrics = this.getRecentMetrics(60 * 60 * 1000); // Last hour\n    const performanceIndicators = {\n      latency: this.systemMetrics.latency,\n      throughput: this.systemMetrics.throughput,\n      errorRate: this.systemMetrics.errorRate,\n      availability: this.calculateAvailability(uptime),\n    };\n    \n    // Calculate capacity metrics\n    const capacityMetrics = {\n      currentLoad: this.calculateCurrentLoad(),\n      maxCapacity: this.calculateMaxCapacity(),\n      utilizationRate: this.calculateUtilizationRate(),\n      queueDepth: this.metricsBuffer.length,\n    };\n    \n    this.healthIndicators = {\n      timestamp: now,\n      overallHealth,\n      subsystemHealth,\n      performanceIndicators,\n      capacityMetrics,\n    };\n  }\n  \n  private async performPredictiveAnalysis(): Promise<void> {\n    try {\n      const metrics = ['overallAccuracy', 'humanInterventionRate', 'systemReliability'];\n      \n      for (const metric of metrics) {\n        const prediction = await this.generatePrediction(metric);\n        if (prediction) {\n          this.predictions.set(metric, prediction);\n        }\n      }\n      \n    } catch (error) {\n      this.logger.error('Error in predictive analysis', error);\n    }\n  }\n  \n  private async generatePrediction(metricName: string): Promise<SystemPrediction | null> {\n    const historicalValues = await this.getHistoricalValues(metricName, 336); // Last 2 weeks\n    \n    if (historicalValues.length < 20) return null;\n    \n    const currentValue = historicalValues[historicalValues.length - 1].value;\n    \n    // Generate predictions for different timeframes\n    const shortTerm = await this.predictValue(historicalValues, 24); // 1 day\n    const mediumTerm = await this.predictValue(historicalValues, 168); // 1 week\n    const longTerm = await this.predictValue(historicalValues, 720); // 1 month\n    \n    // Identify factors affecting the prediction\n    const factors = await this.identifyPredictionFactors(metricName, historicalValues);\n    \n    // Generate recommendations\n    const recommendations = this.generatePredictionRecommendations(metricName, shortTerm, factors);\n    \n    return {\n      metric: metricName,\n      currentValue,\n      predictions: {\n        shortTerm: { ...shortTerm, timeframe: '1 day' },\n        mediumTerm: { ...mediumTerm, timeframe: '1 week' },\n        longTerm: { ...longTerm, timeframe: '1 month' },\n      },\n      factors,\n      recommendations,\n    };\n  }\n  \n  private async predictValue(\n    values: { timestamp: Date; value: number }[],\n    hoursAhead: number\n  ): Promise<{ value: number; confidence: number }> {\n    // Use exponential smoothing for prediction\n    const alpha = 0.3; // Smoothing parameter\n    let smoothedValue = values[0].value;\n    \n    for (let i = 1; i < values.length; i++) {\n      smoothedValue = alpha * values[i].value + (1 - alpha) * smoothedValue;\n    }\n    \n    // Simple confidence calculation based on recent variance\n    const recentValues = values.slice(-20).map(v => v.value);\n    const variance = this.calculateVariance(recentValues);\n    const confidence = Math.max(0.1, Math.min(0.9, 1 - Math.sqrt(variance)));\n    \n    return { value: smoothedValue, confidence };\n  }\n  \n  private async identifyPredictionFactors(\n    metricName: string,\n    values: { timestamp: Date; value: number }[]\n  ): Promise<PredictionFactor[]> {\n    const factors: PredictionFactor[] = [];\n    \n    // Trend factor\n    const trend = this.systemTrends.get(metricName);\n    if (trend) {\n      factors.push({\n        name: 'Historical Trend',\n        impact: trend.direction === 'improving' ? 0.3 : trend.direction === 'declining' ? -0.3 : 0,\n        confidence: trend.significance === 'high' ? 0.8 : trend.significance === 'medium' ? 0.6 : 0.4,\n        description: `${trend.direction} trend with ${trend.significance} significance`,\n      });\n    }\n    \n    // System load factor\n    const currentLoad = this.healthIndicators.capacityMetrics.utilizationRate;\n    if (currentLoad > 0.8) {\n      factors.push({\n        name: 'High System Load',\n        impact: -0.2,\n        confidence: 0.7,\n        description: 'High system utilization may impact performance',\n      });\n    }\n    \n    // Error rate factor\n    if (this.systemMetrics.errorRate > 0.05) {\n      factors.push({\n        name: 'Elevated Error Rate',\n        impact: -0.4,\n        confidence: 0.8,\n        description: 'High error rate may continue to impact metrics',\n      });\n    }\n    \n    return factors;\n  }\n  \n  // ========================================================================================\n  // Utility Methods\n  // ========================================================================================\n  \n  private getRecentMetrics(timeWindowMs: number): TruthMetric[] {\n    const cutoff = new Date(Date.now() - timeWindowMs);\n    return this.historicalMetrics.filter(m => m.timestamp >= cutoff);\n  }\n  \n  private async getHistoricalValues(\n    metricName: string,\n    hoursBack: number\n  ): Promise<{ timestamp: Date; value: number }[]> {\n    // This would typically query a time-series database\n    // For now, simulate historical data based on current metrics\n    const values: { timestamp: Date; value: number }[] = [];\n    const now = Date.now();\n    const hourMs = 60 * 60 * 1000;\n    \n    let currentValue = (this.systemMetrics as any)[metricName] || 0.8;\n    \n    for (let i = hoursBack; i >= 0; i--) {\n      const timestamp = new Date(now - (i * hourMs));\n      \n      // Add some realistic variation\n      const variation = (Math.random() - 0.5) * 0.1;\n      const value = Math.max(0, Math.min(1, currentValue + variation));\n      \n      values.push({ timestamp, value });\n      currentValue = value;\n    }\n    \n    return values;\n  }\n  \n  private getTimeSpan(metrics: TruthMetric[]): number {\n    if (metrics.length < 2) return 0;\n    \n    const timestamps = metrics.map(m => m.timestamp.getTime()).sort((a, b) => a - b);\n    return timestamps[timestamps.length - 1] - timestamps[0];\n  }\n  \n  private getAccuracyRange(accuracy: number): string {\n    if (accuracy >= 0.95) return '95-100%';\n    if (accuracy >= 0.90) return '90-95%';\n    if (accuracy >= 0.80) return '80-90%';\n    if (accuracy >= 0.70) return '70-80%';\n    return '<70%';\n  }\n  \n  private calculateSystemEfficiency(metrics: TruthMetric[]): number {\n    if (metrics.length === 0) return 0.8;\n    \n    // Efficiency based on validation success rate and automation rate\n    const successRate = metrics.filter(m => m.validation.isValid).length / metrics.length;\n    const automationRate = metrics.filter(\n      m => m.context.verificationMethod === 'automated'\n    ).length / metrics.length;\n    \n    return (successRate * 0.6) + (automationRate * 0.4);\n  }\n  \n  private calculateVariance(values: number[]): number {\n    if (values.length === 0) return 0;\n    \n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));\n    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;\n  }\n  \n  private isCriticalMetric(metric: TruthMetric): boolean {\n    return (\n      metric.metricType === 'accuracy' ||\n      metric.value < 0.7 ||\n      metric.validation.errors.some(e => e.severity === 'critical')\n    );\n  }\n  \n  private calculateCollectionHealth(): number {\n    // Health based on collection throughput and error rate\n    const targetThroughput = 100; // metrics per hour\n    const currentThroughput = this.systemMetrics.throughput;\n    const throughputScore = Math.min(1, currentThroughput / targetThroughput);\n    \n    const errorScore = Math.max(0, 1 - (this.systemMetrics.errorRate * 10));\n    \n    return (throughputScore * 0.7) + (errorScore * 0.3);\n  }\n  \n  private calculateValidationHealth(): number {\n    // Health based on validation success rate and processing time\n    const successRate = this.systemMetrics.successRate / 100;\n    const latencyScore = this.systemMetrics.latency > 0 ? \n      Math.max(0.1, Math.min(1, 5000 / this.systemMetrics.latency)) : 1;\n    \n    return (successRate * 0.8) + (latencyScore * 0.2);\n  }\n  \n  private calculateScoringHealth(): number {\n    // Health based on scoring coverage and accuracy\n    const coverageScore = this.systemMetrics.agentCount > 0 ? \n      Math.min(1, this.systemMetrics.activeAgents / this.systemMetrics.agentCount) : 1;\n    \n    return coverageScore;\n  }\n  \n  private calculateAlertingHealth(): number {\n    // Health based on alert responsiveness\n    return 0.95; // Placeholder\n  }\n  \n  private calculatePersistenceHealth(): number {\n    // Health based on data persistence success\n    return 0.98; // Placeholder\n  }\n  \n  private calculateAvailability(uptimeMs: number): number {\n    // Simple availability calculation\n    const uptimeHours = uptimeMs / (60 * 60 * 1000);\n    return Math.min(1, uptimeHours / (uptimeHours + 0.1)); // Assume minimal downtime\n  }\n  \n  private calculateCurrentLoad(): number {\n    // Load based on current processing\n    return this.metricsBuffer.length;\n  }\n  \n  private calculateMaxCapacity(): number {\n    // Maximum capacity based on configuration\n    return this.config.bufferSize;\n  }\n  \n  private calculateUtilizationRate(): number {\n    // Utilization rate\n    const maxCapacity = this.calculateMaxCapacity();\n    return maxCapacity > 0 ? this.calculateCurrentLoad() / maxCapacity : 0;\n  }\n  \n  private generatePredictionRecommendations(\n    metricName: string,\n    prediction: { value: number; confidence: number },\n    factors: PredictionFactor[]\n  ): string[] {\n    const recommendations: string[] = [];\n    \n    // Low confidence recommendations\n    if (prediction.confidence < 0.5) {\n      recommendations.push('Increase data collection frequency for better predictions');\n      recommendations.push('Implement additional monitoring points');\n    }\n    \n    // Metric-specific recommendations\n    if (metricName === 'overallAccuracy' && prediction.value < 0.9) {\n      recommendations.push('Implement additional validation checks');\n      recommendations.push('Consider agent retraining or calibration');\n    }\n    \n    if (metricName === 'humanInterventionRate' && prediction.value > 0.15) {\n      recommendations.push('Analyze common intervention patterns');\n      recommendations.push('Improve automated decision-making capabilities');\n    }\n    \n    // Factor-based recommendations\n    factors.forEach(factor => {\n      if (factor.impact < -0.3) {\n        recommendations.push(`Address ${factor.name}: ${factor.description}`);\n      }\n    });\n    \n    return recommendations;\n  }\n  \n  private initializeSystemMetrics(): void {\n    this.systemMetrics = {\n      timestamp: new Date(),\n      overallAccuracy: 0.95,\n      humanInterventionRate: 0.05,\n      systemReliability: 0.98,\n      agentCount: 0,\n      activeAgents: 0,\n      totalTasks: 0,\n      verifiedTasks: 0,\n      criticalFailures: 0,\n      recoveryTime: 0,\n      efficiency: 0.85,\n      distributionMetrics: {\n        taskDistribution: {},\n        accuracyDistribution: {},\n        complexityDistribution: {},\n        errorTypeDistribution: {},\n      },\n    };\n  }\n  \n  private initializeHealthIndicators(): void {\n    this.healthIndicators = {\n      timestamp: new Date(),\n      overallHealth: 0.95,\n      subsystemHealth: {\n        collection: 0.95,\n        validation: 0.92,\n        scoring: 0.90,\n        alerting: 0.98,\n        persistence: 0.96,\n      },\n      performanceIndicators: {\n        latency: 500,\n        throughput: 50,\n        errorRate: 0.02,\n        availability: 0.99,\n      },\n      capacityMetrics: {\n        currentLoad: 0,\n        maxCapacity: 1000,\n        utilizationRate: 0,\n        queueDepth: 0,\n      },\n    };\n  }\n  \n  // ========================================================================================\n  // Public API\n  // ========================================================================================\n  \n  getSystemMetrics(): SystemTruthMetrics {\n    return { ...this.systemMetrics };\n  }\n  \n  getHealthIndicators(): SystemHealthIndicators {\n    return { ...this.healthIndicators };\n  }\n  \n  getSystemTrends(): SystemTrend[] {\n    return Array.from(this.systemTrends.values());\n  }\n  \n  getTrend(metricName: string): SystemTrend | undefined {\n    return this.systemTrends.get(metricName);\n  }\n  \n  getPredictions(): SystemPrediction[] {\n    return Array.from(this.predictions.values());\n  }\n  \n  getPrediction(metricName: string): SystemPrediction | undefined {\n    return this.predictions.get(metricName);\n  }\n  \n  getDistributionAnalysis(metricName: string): DistributionAnalysis | undefined {\n    return this.distributionAnalyses.get(metricName);\n  }\n  \n  async performComprehensiveAnalysis(): Promise<{\n    systemHealth: SystemHealthIndicators;\n    trends: SystemTrend[];\n    predictions: SystemPrediction[];\n    recommendations: string[];\n  }> {\n    await this.performPeriodicAnalysis();\n    await this.performPredictiveAnalysis();\n    \n    const recommendations = this.generateSystemRecommendations();\n    \n    return {\n      systemHealth: this.healthIndicators,\n      trends: Array.from(this.systemTrends.values()),\n      predictions: Array.from(this.predictions.values()),\n      recommendations,\n    };\n  }\n  \n  private generateSystemRecommendations(): string[] {\n    const recommendations: string[] = [];\n    \n    // Health-based recommendations\n    if (this.healthIndicators.overallHealth < 0.8) {\n      recommendations.push('System health is degraded - investigate subsystem issues');\n    }\n    \n    // Performance-based recommendations\n    if (this.healthIndicators.performanceIndicators.errorRate > 0.05) {\n      recommendations.push('High error rate detected - review validation processes');\n    }\n    \n    // Capacity-based recommendations\n    if (this.healthIndicators.capacityMetrics.utilizationRate > 0.8) {\n      recommendations.push('High system utilization - consider scaling resources');\n    }\n    \n    // Trend-based recommendations\n    this.systemTrends.forEach(trend => {\n      if (trend.direction === 'declining' && trend.significance === 'high') {\n        recommendations.push(`${trend.metric} is declining significantly - immediate attention required`);\n      }\n    });\n    \n    return recommendations;\n  }\n  \n  getSystemStatistics(): {\n    totalMetricsProcessed: number;\n    systemUptime: number;\n    averageProcessingRate: number;\n    healthScore: number;\n    lastAnalysis: Date;\n  } {\n    const uptime = Date.now() - this.systemStartTime.getTime();\n    const processingRate = uptime > 0 ? (this.totalMetricsProcessed / (uptime / 1000)) : 0;\n    \n    return {\n      totalMetricsProcessed: this.totalMetricsProcessed,\n      systemUptime: uptime,\n      averageProcessingRate: processingRate,\n      healthScore: this.healthIndicators.overallHealth,\n      lastAnalysis: this.lastAnalysisTime,\n    };\n  }\n}"],"names":["SystemTruthTracker","config","logger","systemMetrics","healthIndicators","historicalMetrics","systemTrends","Map","distributionAnalyses","predictions","metricsBuffer","analysisInterval","predictionInterval","lastAnalysisTime","Date","totalMetricsProcessed","systemStartTime","initializeSystemMetrics","initializeHealthIndicators","initialize","info","startPeriodicAnalysis","startPredictiveAnalysis","shutdown","clearInterval","performComprehensiveAnalysis","updateSystemMetric","metric","push","length","slice","isCriticalMetric","updateRealTimeMetrics","recentMetrics","getRecentMetrics","accuracyMetrics","filter","m","metricType","overallAccuracy","reduce","sum","value","totalTasks","humanInterventions","context","verificationMethod","humanInterventionRate","validTasks","validation","isValid","systemReliability","uniqueAgents","Set","map","agentId","activeAgents","size","verifiedTasks","criticalErrors","errors","some","e","severity","criticalFailures","efficiency","calculateSystemEfficiency","timestamp","setInterval","performPeriodicAnalysis","performPredictiveAnalysis","processMetricsBuffer","updateDistributionMetrics","analyzeTrends","updateHealthIndicators","error","batch","splice","updateSystemMetricsFromBatch","analyzeDistributions","metrics","metricsByType","forEach","has","set","get","weightedSum","confidence","totalWeight","timeSpan","getTimeSpan","throughput","validationTimes","automatedChecks","c","executionTime","t","latency","errorCount","errorRate","successCount","successRate","taskTypes","taskType","distributionMetrics","taskDistribution","Object","fromEntries","accuracyRanges","range","getAccuracyRange","accuracyDistribution","complexityTypes","complexity","complexityDistribution","errorTypes","type","errorTypeDistribution","trend","calculateTrend","metricName","historicalValues","getHistoricalValues","midpoint","Math","floor","earlierPeriod","laterPeriod","previousValue","v","currentValue","changePercent","direction","significance","abs","prediction","predictNextValue","timeframe","values","nextValue","n","x","_","i","y","sumX","val","sumY","sumXY","sumX2","slope","intercept","yMean","ssRes","predicted","pow","ssTot","rSquared","max","min","now","uptime","getTime","subsystemHealth","collection","calculateCollectionHealth","calculateValidationHealth","scoring","calculateScoringHealth","alerting","calculateAlertingHealth","persistence","calculatePersistenceHealth","healthValues","overallHealth","h","performanceIndicators","availability","calculateAvailability","capacityMetrics","currentLoad","calculateCurrentLoad","maxCapacity","calculateMaxCapacity","utilizationRate","calculateUtilizationRate","queueDepth","generatePrediction","shortTerm","predictValue","mediumTerm","longTerm","factors","identifyPredictionFactors","recommendations","generatePredictionRecommendations","hoursAhead","alpha","smoothedValue","recentValues","variance","calculateVariance","sqrt","name","impact","description","timeWindowMs","cutoff","hoursBack","hourMs","variation","random","timestamps","sort","a","b","accuracy","automationRate","mean","squaredDiffs","diff","targetThroughput","currentThroughput","throughputScore","errorScore","latencyScore","coverageScore","agentCount","uptimeMs","uptimeHours","bufferSize","factor","recoveryTime","getSystemMetrics","getHealthIndicators","getSystemTrends","Array","from","getTrend","getPredictions","getPrediction","getDistributionAnalysis","generateSystemRecommendations","systemHealth","trends","getSystemStatistics","processingRate","systemUptime","averageProcessingRate","healthScore","lastAnalysis"],"mappings":"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"}