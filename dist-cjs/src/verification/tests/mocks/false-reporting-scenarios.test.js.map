{"version":3,"sources":["../../../../../src/verification/tests/mocks/false-reporting-scenarios.test.ts"],"sourcesContent":["/**\n * Mock Agent Scenarios for False Reporting Detection Tests\n * \n * Tests various scenarios where agents might provide false or misleading reports:\n * - Intentional false claims about task completion\n * - Exaggerated performance improvements\n * - Hidden failures in implementation\n * - Inconsistent reporting between agents\n * - Fabricated test results and evidence\n */\n\nimport { jest } from '@jest/globals';\nimport { EventEmitter } from 'events';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\n// Import verification components\nimport TruthScoreCalculator from '../../../../.claude/helpers/truth-score.js';\n\ninterface MockAgent {\n  id: string;\n  type: string;\n  deceptionLevel: number; // 0 = honest, 1 = completely deceptive\n  deceptionStrategy: DeceptionStrategy;\n  behaviorPattern: BehaviorPattern;\n  reportHistory: AgentReport[];\n  detectedAs: 'honest' | 'suspicious' | 'deceptive' | 'unknown';\n}\n\ninterface DeceptionStrategy {\n  type: 'overconfident' | 'fabrication' | 'selective_reporting' | 'gaslighting' | 'collusion';\n  parameters: Record<string, any>;\n}\n\ninterface BehaviorPattern {\n  consistency: number; // 0-1, how consistent the agent's reports are\n  timeToReport: number; // Average time to submit reports (ms)\n  detailLevel: number; // 0-1, how detailed the reports are\n  evidenceQuality: number; // 0-1, quality of evidence provided\n}\n\ninterface AgentReport {\n  id: string;\n  agentId: string;\n  taskId: string;\n  claimedOutcome: TaskOutcome;\n  evidence: any;\n  timestamp: number;\n  truthScore?: number;\n  verified: boolean;\n  conflicts: string[];\n}\n\ninterface TaskOutcome {\n  success: boolean;\n  testsPass: boolean;\n  noErrors: boolean;\n  performance: {\n    improvement: number;\n    metrics: Record<string, number>;\n  };\n  quality: {\n    codeQuality: number;\n    documentation: number;\n    maintainability: number;\n  };\n}\n\ninterface VerificationResult {\n  reportId: string;\n  agentId: string;\n  truthScore: number;\n  deceptionDetected: boolean;\n  deceptionType: string[];\n  confidence: number;\n  evidence: any;\n  recommendations: string[];\n}\n\ndescribe('False Reporting Detection Scenarios', () => {\n  let tempDir: string;\n  let truthCalculator: any;\n  let deceptionDetector: DeceptionDetector;\n  let mockAgents: Map<string, MockAgent>;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'false-reporting-test-'));\n    \n    // Setup truth score calculator\n    truthCalculator = new TruthScoreCalculator();\n    truthCalculator.configPath = path.join(tempDir, 'verification.json');\n    truthCalculator.memoryPath = path.join(tempDir, 'truth-scores');\n    await truthCalculator.init();\n    \n    // Setup deception detector\n    deceptionDetector = new DeceptionDetector(truthCalculator, tempDir);\n    await deceptionDetector.initialize();\n    \n    // Create mock agents with different deception strategies\n    mockAgents = new Map();\n    await createMockAgentScenarios();\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  async function createMockAgentScenarios() {\n    const agentConfigs = [\n      // Honest baseline agent\n      {\n        id: 'honest-agent-001',\n        type: 'coder',\n        deceptionLevel: 0,\n        deceptionStrategy: { type: 'overconfident', parameters: {} },\n        behaviorPattern: {\n          consistency: 0.95,\n          timeToReport: 5000,\n          detailLevel: 0.8,\n          evidenceQuality: 0.9\n        }\n      },\n      // Overconfident agent\n      {\n        id: 'overconfident-agent-002',\n        type: 'coder',\n        deceptionLevel: 0.3,\n        deceptionStrategy: {\n          type: 'overconfident',\n          parameters: { confidenceMultiplier: 1.5, hideMinorIssues: true }\n        },\n        behaviorPattern: {\n          consistency: 0.7,\n          timeToReport: 3000,\n          detailLevel: 0.6,\n          evidenceQuality: 0.7\n        }\n      },\n      // Fabricating agent\n      {\n        id: 'fabricating-agent-003',\n        type: 'tester',\n        deceptionLevel: 0.8,\n        deceptionStrategy: {\n          type: 'fabrication',\n          parameters: { fabricateResults: true, fakePassRate: 0.95 }\n        },\n        behaviorPattern: {\n          consistency: 0.4,\n          timeToReport: 1000, // Reports very quickly (suspicious)\n          detailLevel: 0.9, // High detail to seem legitimate\n          evidenceQuality: 0.3 // Low quality evidence\n        }\n      },\n      // Selective reporting agent\n      {\n        id: 'selective-agent-004',\n        type: 'reviewer',\n        deceptionLevel: 0.5,\n        deceptionStrategy: {\n          type: 'selective_reporting',\n          parameters: { reportOnlyPositives: true, hideFailures: true }\n        },\n        behaviorPattern: {\n          consistency: 0.8,\n          timeToReport: 7000,\n          detailLevel: 0.5,\n          evidenceQuality: 0.6\n        }\n      },\n      // Gaslighting agent\n      {\n        id: 'gaslighting-agent-005',\n        type: 'coordinator',\n        deceptionLevel: 0.9,\n        deceptionStrategy: {\n          type: 'gaslighting',\n          parameters: { contradictOthers: true, rewriteHistory: true }\n        },\n        behaviorPattern: {\n          consistency: 0.2,\n          timeToReport: 4000,\n          detailLevel: 0.7,\n          evidenceQuality: 0.4\n        }\n      }\n    ];\n\n    for (const config of agentConfigs) {\n      const agent = createMockAgent(config);\n      mockAgents.set(config.id, agent);\n    }\n  }\n\n  function createMockAgent(config: any): MockAgent {\n    return {\n      id: config.id,\n      type: config.type,\n      deceptionLevel: config.deceptionLevel,\n      deceptionStrategy: config.deceptionStrategy,\n      behaviorPattern: config.behaviorPattern,\n      reportHistory: [],\n      detectedAs: 'unknown'\n    };\n  }\n\n  describe('Overconfident Agent Scenarios', () => {\n    test('should detect agent consistently overestimating success rates', async () => {\n      const agent = mockAgents.get('overconfident-agent-002')!;\n      const reports: AgentReport[] = [];\n\n      // Generate series of overconfident reports\n      for (let i = 0; i < 20; i++) {\n        const actualSuccess = Math.random() > 0.3; // 70% actual success rate\n        const claimedSuccess = actualSuccess || Math.random() > 0.2; // Claims 94% success rate\n\n        const report = generateReport(agent, `task-${i}`, {\n          actualOutcome: {\n            success: actualSuccess,\n            testsPass: actualSuccess,\n            noErrors: actualSuccess,\n            performance: { improvement: Math.random() * 0.2, metrics: {} },\n            quality: { codeQuality: Math.random() * 0.3 + 0.4, documentation: 0.5, maintainability: 0.6 }\n          },\n          claimedOutcome: {\n            success: claimedSuccess,\n            testsPass: claimedSuccess,\n            noErrors: claimedSuccess,\n            performance: { improvement: Math.random() * 0.3 + 0.2, metrics: {} }, // Exaggerated\n            quality: { codeQuality: Math.random() * 0.2 + 0.8, documentation: 0.9, maintainability: 0.9 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      // Analyze pattern for deception\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('overconfidence');\n      expect(analysis.confidence).toBeGreaterThan(0.7);\n      expect(analysis.truthScore).toBeLessThan(0.6);\n\n      // Check specific indicators\n      expect(analysis.evidence.successRateDiscrepancy).toBeGreaterThan(0.15);\n      expect(analysis.evidence.performanceExaggeration).toBeGreaterThan(0.1);\n      expect(analysis.recommendations).toContain('Implement additional verification for this agent');\n    });\n\n    test('should detect pattern of hiding minor issues', async () => {\n      const agent = mockAgents.get('overconfident-agent-002')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports where agent hides minor issues\n      for (let i = 0; i < 15; i++) {\n        const minorIssues = Math.floor(Math.random() * 5) + 1; // 1-5 minor issues\n        const majorIssues = Math.random() > 0.8 ? 1 : 0; // Occasional major issue\n\n        const report = generateReport(agent, `minor-issues-task-${i}`, {\n          actualOutcome: {\n            success: majorIssues === 0,\n            testsPass: true,\n            noErrors: false, // Has minor errors\n            performance: { improvement: 0.1, metrics: { minorIssues, majorIssues } },\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true, // Claims no errors\n            performance: { improvement: 0.15, metrics: { minorIssues: 0, majorIssues: 0 } },\n            quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('issue_hiding');\n      expect(analysis.evidence.hiddenIssuesCount).toBeGreaterThan(10);\n      expect(analysis.recommendations).toContain('Require detailed issue reporting');\n    });\n  });\n\n  describe('Evidence Fabrication Scenarios', () => {\n    test('should detect fabricated test results', async () => {\n      const agent = mockAgents.get('fabricating-agent-003')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports with fabricated test results\n      for (let i = 0; i < 25; i++) {\n        const actualTestResults = {\n          total: 100,\n          passed: Math.floor(Math.random() * 30) + 60, // 60-90% pass rate\n          failed: 0,\n          skipped: 0\n        };\n        actualTestResults.failed = actualTestResults.total - actualTestResults.passed;\n\n        const fabricatedResults = {\n          total: 100,\n          passed: Math.floor(Math.random() * 5) + 95, // 95-100% pass rate\n          failed: 0,\n          skipped: 0\n        };\n        fabricatedResults.failed = fabricatedResults.total - fabricatedResults.passed;\n\n        const report = generateReport(agent, `fabrication-task-${i}`, {\n          actualOutcome: {\n            success: actualTestResults.passed > 80,\n            testsPass: actualTestResults.passed === actualTestResults.total,\n            noErrors: false,\n            performance: { improvement: 0.05, metrics: actualTestResults },\n            quality: { codeQuality: 0.6, documentation: 0.5, maintainability: 0.6 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.15, metrics: fabricatedResults },\n            quality: { codeQuality: 0.95, documentation: 0.9, maintainability: 0.95 }\n          },\n          evidence: {\n            testResults: fabricatedResults,\n            executionTime: Math.random() * 100 + 50, // Suspiciously consistent timing\n            testLogs: generateFakeTestLogs(fabricatedResults)\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('fabrication');\n      expect(analysis.deceptionType).toContain('unrealistic_results');\n      expect(analysis.confidence).toBeGreaterThan(0.8);\n\n      // Check fabrication indicators\n      expect(analysis.evidence.unrealisticSuccessRate).toBe(true);\n      expect(analysis.evidence.suspiciouslyFastReporting).toBe(true);\n      expect(analysis.evidence.evidenceInconsistency).toBeGreaterThan(0.5);\n    });\n\n    test('should detect impossible performance improvements', async () => {\n      const agent = mockAgents.get('fabricating-agent-003')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports with impossible performance claims\n      for (let i = 0; i < 10; i++) {\n        const report = generateReport(agent, `impossible-perf-task-${i}`, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: {\n              improvement: Math.random() * 0.1 + 0.05, // 5-15% actual improvement\n              metrics: {\n                responseTime: 1000,\n                throughput: 100,\n                memoryUsage: 500\n              }\n            },\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: {\n              improvement: Math.random() * 0.5 + 0.8, // 80-130% claimed improvement (impossible)\n              metrics: {\n                responseTime: 100, // 10x improvement\n                throughput: 1000, // 10x improvement\n                memoryUsage: 50 // 10x improvement\n              }\n            },\n            quality: { codeQuality: 0.99, documentation: 0.99, maintainability: 0.99 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('impossible_claims');\n      expect(analysis.evidence.impossiblePerformanceGains).toBe(true);\n      expect(analysis.recommendations).toContain('Require third-party verification for performance claims');\n    });\n  });\n\n  describe('Selective Reporting Scenarios', () => {\n    test('should detect agent that only reports successes', async () => {\n      const agent = mockAgents.get('selective-agent-004')!;\n      const reports: AgentReport[] = [];\n\n      // Generate mixed actual outcomes but agent only reports successes\n      const actualOutcomes = [];\n      for (let i = 0; i < 30; i++) {\n        const success = Math.random() > 0.4; // 60% actual success rate\n        actualOutcomes.push(success);\n\n        // Agent only reports the successful ones\n        if (success || Math.random() > 0.9) { // Reports 90% of successes, 10% of failures\n          const report = generateReport(agent, `selective-task-${i}`, {\n            actualOutcome: {\n              success,\n              testsPass: success,\n              noErrors: success,\n              performance: { improvement: success ? 0.1 : -0.05, metrics: {} },\n              quality: { codeQuality: success ? 0.8 : 0.4, documentation: 0.6, maintainability: 0.7 }\n            },\n            claimedOutcome: {\n              success: true, // Always claims success\n              testsPass: true,\n              noErrors: true,\n              performance: { improvement: 0.12, metrics: {} },\n              quality: { codeQuality: 0.85, documentation: 0.8, maintainability: 0.8 }\n            }\n          });\n\n          reports.push(report);\n          agent.reportHistory.push(report);\n        }\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('selective_reporting');\n      expect(analysis.evidence.missingFailureReports).toBe(true);\n      expect(analysis.evidence.suspiciousSuccessRate).toBeGreaterThan(0.95);\n      expect(analysis.recommendations).toContain('Mandatory reporting of all task outcomes');\n    });\n\n    test('should detect cherry-picked metrics reporting', async () => {\n      const agent = mockAgents.get('selective-agent-004')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports where agent only reports favorable metrics\n      for (let i = 0; i < 20; i++) {\n        const fullMetrics = {\n          responseTime: Math.random() * 1000 + 500, // 500-1500ms\n          throughput: Math.random() * 200 + 50, // 50-250 rps\n          memoryUsage: Math.random() * 800 + 200, // 200-1000MB\n          errorRate: Math.random() * 0.1, // 0-10% errors\n          cpuUsage: Math.random() * 100, // 0-100% CPU\n          diskIO: Math.random() * 1000 // 0-1000 IOPS\n        };\n\n        // Agent only reports the best 2-3 metrics\n        const favorableMetrics = Object.entries(fullMetrics)\n          .sort(([keyA, valueA], [keyB, valueB]) => {\n            // Sort by how \"good\" the metric looks (lower is better for most)\n            const goodValues = { responseTime: -valueA, errorRate: -valueA, default: valueB };\n            return (goodValues[keyA] || goodValues.default) - (goodValues[keyB] || goodValues.default);\n          })\n          .slice(0, 3)\n          .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});\n\n        const report = generateReport(agent, `cherry-pick-task-${i}`, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: fullMetrics.errorRate < 0.05,\n            performance: { improvement: 0.05, metrics: fullMetrics },\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.15, metrics: favorableMetrics },\n            quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('cherry_picking');\n      expect(analysis.evidence.incompleteMetricsReporting).toBe(true);\n      expect(analysis.recommendations).toContain('Require comprehensive metrics reporting');\n    });\n  });\n\n  describe('Gaslighting and Manipulation Scenarios', () => {\n    test('should detect agent contradicting previous statements', async () => {\n      const agent = mockAgents.get('gaslighting-agent-005')!;\n      const reports: AgentReport[] = [];\n\n      // Generate contradictory reports about the same tasks\n      const taskIds = Array.from({ length: 5 }, (_, i) => `contradiction-task-${i}`);\n\n      for (const taskId of taskIds) {\n        // First report - claims failure\n        const firstReport = generateReport(agent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.1, metrics: {} },\n            quality: { codeQuality: 0.8, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: false,\n            testsPass: false,\n            noErrors: false,\n            performance: { improvement: -0.05, metrics: {} },\n            quality: { codeQuality: 0.4, documentation: 0.3, maintainability: 0.5 }\n          },\n          timestamp: Date.now()\n        });\n\n        // Second report - claims success for same task\n        const secondReport = generateReport(agent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.1, metrics: {} },\n            quality: { codeQuality: 0.8, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.2, metrics: {} },\n            quality: { codeQuality: 0.95, documentation: 0.9, maintainability: 0.95 }\n          },\n          timestamp: Date.now() + 60000 // 1 minute later\n        });\n\n        reports.push(firstReport, secondReport);\n        agent.reportHistory.push(firstReport, secondReport);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('gaslighting');\n      expect(analysis.deceptionType).toContain('contradictory_statements');\n      expect(analysis.evidence.contradictionCount).toBeGreaterThan(3);\n      expect(analysis.recommendations).toContain('Implement immutable audit trail for agent reports');\n    });\n\n    test('should detect agent attempting to discredit other agents', async () => {\n      const gaslightingAgent = mockAgents.get('gaslighting-agent-005')!;\n      const honestAgent = mockAgents.get('honest-agent-001')!;\n      const reports: AgentReport[] = [];\n\n      // Generate scenario where gaslighting agent contradicts honest agent\n      for (let i = 0; i < 10; i++) {\n        const taskId = `discredit-task-${i}`;\n\n        // Honest agent reports realistic outcome\n        const honestReport = generateReport(honestAgent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.08, metrics: {} },\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.08, metrics: {} },\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\n          }\n        });\n\n        // Gaslighting agent contradicts with false negative report\n        const gaslightingReport = generateReport(gaslightingAgent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.08, metrics: {} },\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: false,\n            testsPass: false,\n            noErrors: false,\n            performance: { improvement: -0.1, metrics: {} },\n            quality: { codeQuality: 0.3, documentation: 0.2, maintainability: 0.4 }\n          },\n          evidence: {\n            contradicts: honestReport.id,\n            claimsOtherAgentWrong: true\n          }\n        });\n\n        reports.push(honestReport, gaslightingReport);\n        gaslightingAgent.reportHistory.push(gaslightingReport);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(gaslightingAgent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('discrediting_others');\n      expect(analysis.evidence.contradictionsWithOtherAgents).toBeGreaterThan(7);\n      expect(analysis.evidence.systematicDisagreement).toBe(true);\n    });\n  });\n\n  describe('Collusion Detection', () => {\n    test('should detect agents colluding to hide failures', async () => {\n      const colludingAgents = [\n        mockAgents.get('overconfident-agent-002')!,\n        mockAgents.get('selective-agent-004')!\n      ];\n\n      const reports: AgentReport[] = [];\n      const sharedFailures = ['shared-failure-1', 'shared-failure-2', 'shared-failure-3'];\n\n      // Generate coordinated false reports\n      for (const taskId of sharedFailures) {\n        for (const agent of colludingAgents) {\n          const report = generateReport(agent, taskId, {\n            actualOutcome: {\n              success: false,\n              testsPass: false,\n              noErrors: false,\n              performance: { improvement: -0.05, metrics: {} },\n              quality: { codeQuality: 0.3, documentation: 0.2, maintainability: 0.4 }\n            },\n            claimedOutcome: {\n              success: true,\n              testsPass: true,\n              noErrors: true,\n              performance: { improvement: 0.15, metrics: {} },\n              quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\n            },\n            evidence: {\n              crossReferencedWith: colludingAgents.map(a => a.id).filter(id => id !== agent.id)\n            }\n          });\n\n          reports.push(report);\n          agent.reportHistory.push(report);\n        }\n      }\n\n      // Analyze for collusion patterns\n      const collusionAnalysis = await deceptionDetector.analyzeCollusionPatterns(\n        colludingAgents.map(a => a.id),\n        reports\n      );\n\n      expect(collusionAnalysis.collusionDetected).toBe(true);\n      expect(collusionAnalysis.collusionType).toContain('coordinated_false_reporting');\n      expect(collusionAnalysis.confidence).toBeGreaterThan(0.7);\n      expect(collusionAnalysis.evidence.synchronizedReporting).toBe(true);\n      expect(collusionAnalysis.evidence.identicalFalseClaims).toBeGreaterThan(2);\n    });\n  });\n\n  // Helper functions\n  function generateReport(\n    agent: MockAgent,\n    taskId: string,\n    scenario: {\n      actualOutcome: TaskOutcome;\n      claimedOutcome: TaskOutcome;\n      evidence?: any;\n      timestamp?: number;\n    }\n  ): AgentReport {\n    const reportId = `report-${Date.now()}-${Math.random()}`;\n    \n    // Apply agent's deception strategy\n    const modifiedClaim = applyDeceptionStrategy(agent, scenario.claimedOutcome);\n    \n    // Generate evidence based on agent's behavior pattern\n    const evidence = generateEvidence(agent, scenario.actualOutcome, modifiedClaim, scenario.evidence);\n\n    return {\n      id: reportId,\n      agentId: agent.id,\n      taskId,\n      claimedOutcome: modifiedClaim,\n      evidence,\n      timestamp: scenario.timestamp || Date.now(),\n      verified: false,\n      conflicts: []\n    };\n  }\n\n  function applyDeceptionStrategy(agent: MockAgent, claimedOutcome: TaskOutcome): TaskOutcome {\n    const strategy = agent.deceptionStrategy;\n    const deceptionLevel = agent.deceptionLevel;\n    const modified = JSON.parse(JSON.stringify(claimedOutcome));\n\n    switch (strategy.type) {\n      case 'overconfident':\n        if (strategy.parameters.confidenceMultiplier) {\n          modified.performance.improvement *= strategy.parameters.confidenceMultiplier;\n          modified.quality.codeQuality = Math.min(1, modified.quality.codeQuality * 1.2);\n        }\n        if (strategy.parameters.hideMinorIssues) {\n          modified.noErrors = true;\n        }\n        break;\n\n      case 'fabrication':\n        if (strategy.parameters.fabricateResults) {\n          modified.success = true;\n          modified.testsPass = true;\n          modified.performance.improvement = Math.random() * 0.5 + 0.3;\n        }\n        break;\n\n      case 'selective_reporting':\n        if (strategy.parameters.reportOnlyPositives && !modified.success) {\n          return null; // Don't report failures\n        }\n        break;\n\n      case 'gaslighting':\n        // Randomly flip outcomes to create contradictions\n        if (Math.random() < deceptionLevel * 0.5) {\n          modified.success = !modified.success;\n          modified.testsPass = !modified.testsPass;\n        }\n        break;\n    }\n\n    return modified;\n  }\n\n  function generateEvidence(\n    agent: MockAgent,\n    actualOutcome: TaskOutcome,\n    claimedOutcome: TaskOutcome,\n    additionalEvidence?: any\n  ): any {\n    const evidence: any = {\n      ...additionalEvidence,\n      reportingTime: agent.behaviorPattern.timeToReport + (Math.random() - 0.5) * 1000,\n      detailLevel: agent.behaviorPattern.detailLevel,\n      evidenceQuality: agent.behaviorPattern.evidenceQuality\n    };\n\n    // Add inconsistencies based on deception level\n    if (agent.deceptionLevel > 0.5) {\n      evidence.inconsistencies = [\n        'Test logs don\\'t match reported results',\n        'Performance metrics seem unrealistic',\n        'Evidence quality unusually low'\n      ];\n    }\n\n    return evidence;\n  }\n\n  function generateFakeTestLogs(testResults: any): string {\n    // Generate fake test logs that look real but have inconsistencies\n    const logs = [];\n    logs.push(`Running ${testResults.total} tests...`);\n    logs.push(`PASS: ${testResults.passed} tests`);\n    if (testResults.failed > 0) {\n      logs.push(`FAIL: ${testResults.failed} tests`);\n    }\n    logs.push('All tests completed successfully!'); // Contradictory message\n    return logs.join('\\n');\n  }\n});\n\n// Mock Deception Detector Implementation\nclass DeceptionDetector {\n  private truthCalculator: any;\n  private dataPath: string;\n  private behaviorProfiles: Map<string, any> = new Map();\n\n  constructor(truthCalculator: any, dataPath: string) {\n    this.truthCalculator = truthCalculator;\n    this.dataPath = dataPath;\n  }\n\n  async initialize() {\n    await fs.mkdir(path.join(this.dataPath, 'deception-analysis'), { recursive: true });\n  }\n\n  async analyzeAgentPattern(agentId: string, reports: AgentReport[]): Promise<VerificationResult> {\n    const analysis = {\n      reportId: `analysis-${agentId}`,\n      agentId,\n      truthScore: 0,\n      deceptionDetected: false,\n      deceptionType: [],\n      confidence: 0,\n      evidence: {},\n      recommendations: []\n    };\n\n    // Calculate truth scores for all reports\n    const truthScores = reports.map(report => {\n      return this.calculateReportTruthScore(report);\n    });\n\n    analysis.truthScore = truthScores.reduce((sum, score) => sum + score, 0) / truthScores.length;\n\n    // Detect overconfidence pattern\n    const successClaimRate = reports.filter(r => r.claimedOutcome.success).length / reports.length;\n    const avgTruthScore = analysis.truthScore;\n    \n    if (successClaimRate > 0.9 && avgTruthScore < 0.7) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('overconfidence');\n      analysis.evidence.successRateDiscrepancy = successClaimRate - avgTruthScore;\n    }\n\n    // Detect issue hiding\n    const hiddenIssues = reports.filter(r => \n      r.claimedOutcome.noErrors && r.evidence?.inconsistencies?.length > 0\n    ).length;\n    \n    if (hiddenIssues > reports.length * 0.5) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('issue_hiding');\n      analysis.evidence.hiddenIssuesCount = hiddenIssues;\n    }\n\n    // Detect fabrication\n    const unrealisticResults = reports.filter(r => \n      r.claimedOutcome.performance.improvement > 0.5 || // >50% improvement\n      r.claimedOutcome.quality.codeQuality > 0.95 // >95% quality\n    ).length;\n\n    if (unrealisticResults > 0) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('fabrication', 'unrealistic_results');\n      analysis.evidence.unrealisticSuccessRate = true;\n    }\n\n    // Detect fast reporting (suspicious)\n    const avgReportingTime = reports.reduce((sum, r) => sum + (r.evidence?.reportingTime || 5000), 0) / reports.length;\n    if (avgReportingTime < 2000) {\n      analysis.evidence.suspiciouslyFastReporting = true;\n    }\n\n    // Detect impossible claims\n    const impossibleClaims = reports.filter(r =>\n      r.claimedOutcome.performance.improvement > 1.0 // >100% improvement\n    ).length;\n\n    if (impossibleClaims > 0) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('impossible_claims');\n      analysis.evidence.impossiblePerformanceGains = true;\n    }\n\n    // Detect selective reporting\n    const allSuccesses = reports.every(r => r.claimedOutcome.success);\n    if (allSuccesses && reports.length > 10) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('selective_reporting');\n      analysis.evidence.missingFailureReports = true;\n      analysis.evidence.suspiciousSuccessRate = 1.0;\n    }\n\n    // Detect cherry picking\n    const incompleteMetrics = reports.filter(r => {\n      const metrics = r.claimedOutcome.performance.metrics;\n      return Object.keys(metrics).length < 3; // Less than 3 metrics reported\n    }).length;\n\n    if (incompleteMetrics > reports.length * 0.7) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('cherry_picking');\n      analysis.evidence.incompleteMetricsReporting = true;\n    }\n\n    // Detect contradictions\n    const contradictions = this.detectContradictions(reports);\n    if (contradictions > 0) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('gaslighting', 'contradictory_statements');\n      analysis.evidence.contradictionCount = contradictions;\n    }\n\n    // Calculate confidence\n    analysis.confidence = Math.min(1.0, analysis.deceptionType.length * 0.3 + (1 - analysis.truthScore));\n\n    // Generate recommendations\n    if (analysis.deceptionDetected) {\n      analysis.recommendations = this.generateRecommendations(analysis.deceptionType);\n    }\n\n    return analysis;\n  }\n\n  async analyzeCollusionPatterns(agentIds: string[], reports: AgentReport[]): Promise<any> {\n    const agentReports = new Map();\n    \n    // Group reports by agent\n    for (const report of reports) {\n      if (!agentReports.has(report.agentId)) {\n        agentReports.set(report.agentId, []);\n      }\n      agentReports.get(report.agentId).push(report);\n    }\n\n    // Look for synchronization patterns\n    const taskReports = new Map();\n    for (const report of reports) {\n      if (!taskReports.has(report.taskId)) {\n        taskReports.set(report.taskId, []);\n      }\n      taskReports.get(report.taskId).push(report);\n    }\n\n    let synchronizedReporting = 0;\n    let identicalFalseClaims = 0;\n\n    for (const [taskId, taskReportsArray] of taskReports) {\n      if (taskReportsArray.length > 1) {\n        // Check for synchronized timing\n        const timestamps = taskReportsArray.map(r => r.timestamp);\n        const maxTimestamp = Math.max(...timestamps);\n        const minTimestamp = Math.min(...timestamps);\n        \n        if (maxTimestamp - minTimestamp < 60000) { // Within 1 minute\n          synchronizedReporting++;\n        }\n\n        // Check for identical false claims\n        const claims = taskReportsArray.map(r => JSON.stringify(r.claimedOutcome));\n        const uniqueClaims = new Set(claims);\n        \n        if (uniqueClaims.size === 1 && taskReportsArray[0].claimedOutcome.success) {\n          // All agents claim same success - check if it's false\n          const avgTruthScore = taskReportsArray.reduce((sum, r) => \n            sum + this.calculateReportTruthScore(r), 0) / taskReportsArray.length;\n          \n          if (avgTruthScore < 0.5) {\n            identicalFalseClaims++;\n          }\n        }\n      }\n    }\n\n    return {\n      collusionDetected: synchronizedReporting > 0 || identicalFalseClaims > 0,\n      collusionType: ['coordinated_false_reporting'],\n      confidence: Math.min(1.0, (synchronizedReporting + identicalFalseClaims) * 0.3),\n      evidence: {\n        synchronizedReporting: synchronizedReporting > 0,\n        identicalFalseClaims,\n        analysedTasks: taskReports.size,\n        involvedAgents: agentIds\n      }\n    };\n  }\n\n  private calculateReportTruthScore(report: AgentReport): number {\n    // Simplified truth score calculation\n    let score = 0.8; // Base score\n\n    // Penalize for inconsistencies\n    if (report.evidence?.inconsistencies?.length > 0) {\n      score -= report.evidence.inconsistencies.length * 0.1;\n    }\n\n    // Penalize for unrealistic claims\n    if (report.claimedOutcome.performance.improvement > 0.5) {\n      score -= 0.3;\n    }\n\n    if (report.claimedOutcome.quality.codeQuality > 0.95) {\n      score -= 0.2;\n    }\n\n    // Penalize for fast reporting\n    if (report.evidence?.reportingTime < 2000) {\n      score -= 0.1;\n    }\n\n    return Math.max(0, Math.min(1, score));\n  }\n\n  private detectContradictions(reports: AgentReport[]): number {\n    let contradictions = 0;\n    const taskReports = new Map();\n\n    // Group by task\n    for (const report of reports) {\n      if (!taskReports.has(report.taskId)) {\n        taskReports.set(report.taskId, []);\n      }\n      taskReports.get(report.taskId).push(report);\n    }\n\n    // Check for contradictory reports on same task\n    for (const [taskId, taskReportsArray] of taskReports) {\n      if (taskReportsArray.length > 1) {\n        for (let i = 0; i < taskReportsArray.length - 1; i++) {\n          const report1 = taskReportsArray[i];\n          const report2 = taskReportsArray[i + 1];\n          \n          if (report1.claimedOutcome.success !== report2.claimedOutcome.success) {\n            contradictions++;\n          }\n        }\n      }\n    }\n\n    return contradictions;\n  }\n\n  private generateRecommendations(deceptionTypes: string[]): string[] {\n    const recommendations = [];\n\n    if (deceptionTypes.includes('overconfidence')) {\n      recommendations.push('Implement additional verification for this agent');\n      recommendations.push('Require independent validation of claims');\n    }\n\n    if (deceptionTypes.includes('fabrication')) {\n      recommendations.push('Require third-party verification for performance claims');\n      recommendations.push('Implement automated evidence validation');\n    }\n\n    if (deceptionTypes.includes('selective_reporting')) {\n      recommendations.push('Mandatory reporting of all task outcomes');\n      recommendations.push('Automated detection of missing reports');\n    }\n\n    if (deceptionTypes.includes('cherry_picking')) {\n      recommendations.push('Require comprehensive metrics reporting');\n      recommendations.push('Standardize required evidence formats');\n    }\n\n    if (deceptionTypes.includes('gaslighting')) {\n      recommendations.push('Implement immutable audit trail for agent reports');\n      recommendations.push('Enable cross-agent verification workflows');\n    }\n\n    return recommendations;\n  }\n}"],"names":["fs","path","os","TruthScoreCalculator","describe","tempDir","truthCalculator","deceptionDetector","mockAgents","beforeEach","mkdtemp","join","tmpdir","configPath","memoryPath","init","DeceptionDetector","initialize","Map","createMockAgentScenarios","afterEach","rm","recursive","force","agentConfigs","id","type","deceptionLevel","deceptionStrategy","parameters","behaviorPattern","consistency","timeToReport","detailLevel","evidenceQuality","confidenceMultiplier","hideMinorIssues","fabricateResults","fakePassRate","reportOnlyPositives","hideFailures","contradictOthers","rewriteHistory","config","agent","createMockAgent","set","reportHistory","detectedAs","test","get","reports","i","actualSuccess","Math","random","claimedSuccess","report","generateReport","actualOutcome","success","testsPass","noErrors","performance","improvement","metrics","quality","codeQuality","documentation","maintainability","claimedOutcome","push","analysis","analyzeAgentPattern","expect","deceptionDetected","toBe","deceptionType","toContain","confidence","toBeGreaterThan","truthScore","toBeLessThan","evidence","successRateDiscrepancy","performanceExaggeration","recommendations","minorIssues","floor","majorIssues","hiddenIssuesCount","actualTestResults","total","passed","failed","skipped","fabricatedResults","testResults","executionTime","testLogs","generateFakeTestLogs","unrealisticSuccessRate","suspiciouslyFastReporting","evidenceInconsistency","responseTime","throughput","memoryUsage","impossiblePerformanceGains","actualOutcomes","missingFailureReports","suspiciousSuccessRate","fullMetrics","errorRate","cpuUsage","diskIO","favorableMetrics","Object","entries","sort","keyA","valueA","keyB","valueB","goodValues","default","slice","reduce","obj","key","value","incompleteMetricsReporting","taskIds","Array","from","length","_","taskId","firstReport","timestamp","Date","now","secondReport","contradictionCount","gaslightingAgent","honestAgent","honestReport","gaslightingReport","contradicts","claimsOtherAgentWrong","contradictionsWithOtherAgents","systematicDisagreement","colludingAgents","sharedFailures","crossReferencedWith","map","a","filter","collusionAnalysis","analyzeCollusionPatterns","collusionDetected","collusionType","synchronizedReporting","identicalFalseClaims","scenario","reportId","modifiedClaim","applyDeceptionStrategy","generateEvidence","agentId","verified","conflicts","strategy","modified","JSON","parse","stringify","min","additionalEvidence","reportingTime","inconsistencies","logs","dataPath","behaviorProfiles","mkdir","truthScores","calculateReportTruthScore","sum","score","successClaimRate","r","avgTruthScore","hiddenIssues","unrealisticResults","avgReportingTime","impossibleClaims","allSuccesses","every","incompleteMetrics","keys","contradictions","detectContradictions","generateRecommendations","agentIds","agentReports","has","taskReports","taskReportsArray","timestamps","maxTimestamp","max","minTimestamp","claims","uniqueClaims","Set","size","analysedTasks","involvedAgents","report1","report2","deceptionTypes","includes"],"mappings":"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"}