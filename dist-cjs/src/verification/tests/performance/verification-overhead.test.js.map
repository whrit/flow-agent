{"version":3,"sources":["../../../../../src/verification/tests/performance/verification-overhead.test.ts"],"sourcesContent":["/**\n * Performance Benchmark Tests for Verification Overhead\n * \n * Tests the performance impact of the verification system including:\n * - Truth scoring calculation performance\n * - Memory usage during verification\n * - Throughput under load\n * - Latency impact on agent communication\n */\n\nimport { jest } from '@jest/globals';\nimport { performance } from 'perf_hooks';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\n// Import verification components\nimport TruthScoreCalculator from '../../../../.claude/helpers/truth-score.js';\n\ninterface PerformanceMetrics {\n  operations: number;\n  totalTime: number;\n  averageTime: number;\n  throughput: number;\n  memoryUsage: {\n    initial: number;\n    peak: number;\n    final: number;\n    delta: number;\n  };\n  p50: number;\n  p95: number;\n  p99: number;\n}\n\ninterface BenchmarkResult {\n  testName: string;\n  metrics: PerformanceMetrics;\n  passed: boolean;\n  thresholds: BenchmarkThresholds;\n}\n\ninterface BenchmarkThresholds {\n  maxAverageTime: number;\n  minThroughput: number;\n  maxMemoryDelta: number;\n  maxP99Latency: number;\n}\n\ndescribe('Verification System Performance Benchmarks', () => {\n  let tempDir: string;\n  let calculator: any;\n  let performanceResults: BenchmarkResult[] = [];\n\n  beforeAll(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'verification-perf-'));\n    \n    // Setup truth score calculator\n    calculator = new TruthScoreCalculator();\n    calculator.configPath = path.join(tempDir, 'verification.json');\n    calculator.memoryPath = path.join(tempDir, 'truth-scores');\n    await calculator.init();\n  });\n\n  afterAll(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n    \n    // Generate performance report\n    await generatePerformanceReport(performanceResults);\n  });\n\n  describe('Truth Score Calculation Performance', () => {\n    test('should calculate truth scores efficiently at scale', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 5, // 5ms per calculation\n        minThroughput: 200, // 200 calculations per second\n        maxMemoryDelta: 50 * 1024 * 1024, // 50MB max memory increase\n        maxP99Latency: 20 // 20ms p99 latency\n      };\n\n      const operations = 1000;\n      const evidenceVariants = generateEvidenceVariants(10);\n      const durations: number[] = [];\n      \n      const initialMemory = process.memoryUsage().heapUsed;\n      let peakMemory = initialMemory;\n\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const evidence = evidenceVariants[i % evidenceVariants.length];\n        \n        const operationStart = performance.now();\n        const score = calculator.calculateScore(evidence);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        // Track memory usage\n        const currentMemory = process.memoryUsage().heapUsed;\n        peakMemory = Math.max(peakMemory, currentMemory);\n        \n        // Verify score is valid\n        expect(score).toBeGreaterThanOrEqual(0);\n        expect(score).toBeLessThanOrEqual(1);\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n      \n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: peakMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Truth Score Calculation Performance',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      // Assert performance requirements\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\n      expect(metrics.p99).toBeLessThanOrEqual(thresholds.maxP99Latency);\n    });\n\n    test('should handle concurrent truth score calculations efficiently', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 8, // 8ms per calculation (slightly higher for concurrency)\n        minThroughput: 150, // 150 calculations per second\n        maxMemoryDelta: 100 * 1024 * 1024, // 100MB max memory increase\n        maxP99Latency: 30 // 30ms p99 latency\n      };\n\n      const concurrency = 10;\n      const operationsPerWorker = 100;\n      const totalOperations = concurrency * operationsPerWorker;\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      // Create concurrent workers\n      const workerPromises = Array.from({ length: concurrency }, async (_, workerIndex) => {\n        const workerDurations: number[] = [];\n        const evidenceVariants = generateEvidenceVariants(5);\n\n        for (let i = 0; i < operationsPerWorker; i++) {\n          const evidence = evidenceVariants[i % evidenceVariants.length];\n          \n          const operationStart = performance.now();\n          const score = calculator.calculateScore(evidence);\n          const operationEnd = performance.now();\n          \n          workerDurations.push(operationEnd - operationStart);\n          \n          expect(score).toBeGreaterThanOrEqual(0);\n          expect(score).toBeLessThanOrEqual(1);\n\n          // Add small delay to simulate realistic workload\n          if (i % 10 === 0) {\n            await new Promise(resolve => setTimeout(resolve, 1));\n          }\n        }\n\n        return workerDurations;\n      });\n\n      const allDurations = (await Promise.all(workerPromises)).flat();\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(totalOperations, allDurations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory, // Simplified for concurrent case\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Concurrent Truth Score Calculation',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\n    }, 30000);\n  });\n\n  describe('Memory Usage Optimization', () => {\n    test('should maintain stable memory usage during extended operations', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 10, // 10ms per operation\n        minThroughput: 100, // 100 operations per second\n        maxMemoryDelta: 20 * 1024 * 1024, // 20MB max memory increase\n        maxP99Latency: 50 // 50ms p99 latency\n      };\n\n      const operations = 2000;\n      const evidenceVariants = generateEvidenceVariants(20);\n      const durations: number[] = [];\n      const memorySnapshots: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      memorySnapshots.push(initialMemory);\n\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const evidence = evidenceVariants[i % evidenceVariants.length];\n        \n        const operationStart = performance.now();\n        \n        // Perform multiple operations to test memory accumulation\n        const score1 = calculator.calculateScore(evidence);\n        const comparison = calculator.compareClaimToReality(\n          { tests_pass: true, no_lint_errors: true },\n          { tests_pass: score1 > 0.8, lint_errors: score1 > 0.9 ? 0 : 2 }\n        );\n        \n        const operationEnd = performance.now();\n        durations.push(operationEnd - operationStart);\n\n        // Take memory snapshots every 100 operations\n        if (i % 100 === 0) {\n          const currentMemory = process.memoryUsage().heapUsed;\n          memorySnapshots.push(currentMemory);\n\n          // Force garbage collection every 500 operations to test cleanup\n          if (i % 500 === 0 && global.gc) {\n            global.gc();\n          }\n        }\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n      const peakMemory = Math.max(...memorySnapshots);\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: peakMemory,\n        final: finalMemory\n      });\n\n      // Check for memory leaks by analyzing memory growth trend\n      const memoryGrowthRate = (finalMemory - initialMemory) / operations;\n      expect(memoryGrowthRate).toBeLessThan(1000); // Less than 1KB per operation\n\n      const result: BenchmarkResult = {\n        testName: 'Extended Memory Usage Stability',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds) && memoryGrowthRate < 1000,\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\n    }, 45000);\n\n    test('should efficiently handle large evidence datasets', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 15, // 15ms per operation (larger datasets)\n        minThroughput: 70, // 70 operations per second\n        maxMemoryDelta: 150 * 1024 * 1024, // 150MB max memory increase\n        maxP99Latency: 100 // 100ms p99 latency\n      };\n\n      const operations = 500;\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        // Create large evidence objects\n        const largeEvidence = generateLargeEvidence(i);\n        \n        const operationStart = performance.now();\n        const score = calculator.calculateScore(largeEvidence);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        expect(score).toBeGreaterThanOrEqual(0);\n        expect(score).toBeLessThanOrEqual(1);\n\n        // Cleanup large objects to prevent memory accumulation\n        if (i % 50 === 0 && global.gc) {\n          global.gc();\n        }\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Large Evidence Dataset Handling',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n    }, 30000);\n  });\n\n  describe('Truth Score Storage Performance', () => {\n    test('should store truth scores efficiently at high volume', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 20, // 20ms per storage operation\n        minThroughput: 50, // 50 storage operations per second\n        maxMemoryDelta: 100 * 1024 * 1024, // 100MB max memory increase\n        maxP99Latency: 100 // 100ms p99 latency\n      };\n\n      const operations = 200; // Reduced for storage operations\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const agentId = `agent-${i % 10}`;\n        const taskId = `task-${i}`;\n        const score = Math.random();\n        const evidence = generateEvidenceVariants(1)[0];\n\n        const operationStart = performance.now();\n        await calculator.storeTruthScore(agentId, taskId, score, evidence);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'High Volume Truth Score Storage',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n\n      // Verify all files were created\n      const files = await fs.readdir(calculator.memoryPath);\n      expect(files.length).toBe(operations);\n    }, 30000);\n\n    test('should retrieve agent history efficiently', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 50, // 50ms per history retrieval\n        minThroughput: 20, // 20 retrievals per second\n        maxMemoryDelta: 50 * 1024 * 1024, // 50MB max memory increase\n        maxP99Latency: 200 // 200ms p99 latency\n      };\n\n      // First, create test data\n      const agents = Array.from({ length: 10 }, (_, i) => `perf-agent-${i}`);\n      for (const agentId of agents) {\n        for (let i = 0; i < 50; i++) {\n          await calculator.storeTruthScore(\n            agentId,\n            `history-task-${i}`,\n            Math.random(),\n            { test: `data-${i}` }\n          );\n        }\n      }\n\n      const operations = 100;\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const agentId = agents[i % agents.length];\n        const limit = Math.floor(Math.random() * 20) + 5; // 5-24 entries\n\n        const operationStart = performance.now();\n        const history = await calculator.getAgentHistory(agentId, limit);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        expect(history.length).toBeLessThanOrEqual(limit);\n        expect(history.length).toBeGreaterThan(0);\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Agent History Retrieval Performance',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n    }, 45000);\n  });\n\n  describe('Report Generation Performance', () => {\n    test('should generate reports efficiently with large datasets', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 1000, // 1 second per report generation\n        minThroughput: 1, // 1 report per second\n        maxMemoryDelta: 200 * 1024 * 1024, // 200MB max memory increase\n        maxP99Latency: 3000 // 3 second p99 latency\n      };\n\n      // Create large dataset for report generation\n      const agents = Array.from({ length: 50 }, (_, i) => `report-agent-${i}`);\n      for (const agentId of agents) {\n        for (let i = 0; i < 100; i++) {\n          await calculator.storeTruthScore(\n            agentId,\n            `report-task-${i}`,\n            Math.random(),\n            { complexity: Math.random(), quality: Math.random() }\n          );\n        }\n      }\n\n      const operations = 10; // Fewer operations for expensive report generation\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const format = i % 2 === 0 ? 'json' : 'markdown';\n\n        const operationStart = performance.now();\n        const report = await calculator.generateReport(format);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        if (format === 'json') {\n          expect(typeof report).toBe('object');\n          expect(report.total_verifications).toBeGreaterThan(0);\n          expect(Object.keys(report.agents).length).toBe(agents.length);\n        } else {\n          expect(typeof report).toBe('string');\n          expect(report).toContain('# Truth Score Report');\n          expect(report).toContain('Agent Performance');\n        }\n\n        // Force garbage collection between operations\n        if (global.gc) {\n          global.gc();\n        }\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Large Dataset Report Generation',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n    }, 60000);\n  });\n\n  describe('System Load Testing', () => {\n    test('should maintain performance under sustained load', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 25, // 25ms average under load\n        minThroughput: 40, // 40 operations per second\n        maxMemoryDelta: 300 * 1024 * 1024, // 300MB max memory increase\n        maxP99Latency: 150 // 150ms p99 latency\n      };\n\n      const loadDuration = 15000; // 15 seconds of sustained load\n      const batchSize = 10;\n      const batchInterval = 100; // 100ms between batches\n\n      const durations: number[] = [];\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n      \n      let operationCount = 0;\n      const evidenceVariants = generateEvidenceVariants(5);\n\n      const loadTestPromise = new Promise<void>((resolve) => {\n        const interval = setInterval(async () => {\n          if (performance.now() - startTime >= loadDuration) {\n            clearInterval(interval);\n            resolve();\n            return;\n          }\n\n          // Process batch of operations\n          const batchPromises = Array.from({ length: batchSize }, async (_, i) => {\n            const evidence = evidenceVariants[(operationCount + i) % evidenceVariants.length];\n            \n            const operationStart = performance.now();\n            \n            // Mixed operations to simulate realistic load\n            if (i % 3 === 0) {\n              const score = calculator.calculateScore(evidence);\n              expect(score).toBeGreaterThanOrEqual(0);\n            } else if (i % 3 === 1) {\n              const comparison = calculator.compareClaimToReality(\n                { tests_pass: true },\n                { tests_pass: Math.random() > 0.5 }\n              );\n              expect(comparison.truth_score).toBeGreaterThanOrEqual(0);\n            } else {\n              await calculator.storeTruthScore(\n                `load-agent-${operationCount + i}`,\n                `load-task-${operationCount + i}`,\n                Math.random(),\n                evidence\n              );\n            }\n            \n            const operationEnd = performance.now();\n            durations.push(operationEnd - operationStart);\n          });\n\n          await Promise.all(batchPromises);\n          operationCount += batchSize;\n        }, batchInterval);\n      });\n\n      await loadTestPromise;\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operationCount, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Sustained Load Performance',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n      expect(operationCount).toBeGreaterThan(100); // Should process significant number of operations\n    }, 20000);\n  });\n\n  // Helper functions\n  function generateEvidenceVariants(count: number): any[] {\n    return Array.from({ length: count }, (_, i) => ({\n      test_results: {\n        passed: Math.floor(Math.random() * 20),\n        total: 20\n      },\n      lint_results: {\n        errors: Math.floor(Math.random() * 5)\n      },\n      type_results: {\n        errors: Math.floor(Math.random() * 3)\n      },\n      build_results: {\n        success: Math.random() > 0.2\n      },\n      performance_metrics: {\n        response_time: Math.random() * 500 + 50,\n        memory_usage: Math.random() * 100 + 50\n      },\n      complexity_score: Math.random(),\n      variant_id: i\n    }));\n  }\n\n  function generateLargeEvidence(index: number): any {\n    return {\n      test_results: {\n        passed: Math.floor(Math.random() * 100),\n        total: 100,\n        detailed_results: Array.from({ length: 100 }, (_, i) => ({\n          test_name: `test_${i}`,\n          status: Math.random() > 0.1 ? 'passed' : 'failed',\n          duration: Math.random() * 1000,\n          memory_usage: Math.random() * 50\n        }))\n      },\n      lint_results: {\n        errors: Math.floor(Math.random() * 10),\n        warnings: Math.floor(Math.random() * 20),\n        file_reports: Array.from({ length: 50 }, (_, i) => ({\n          file: `file_${i}.js`,\n          issues: Math.floor(Math.random() * 5)\n        }))\n      },\n      build_results: {\n        success: Math.random() > 0.1,\n        build_log: 'x'.repeat(10000), // 10KB of build log data\n        dependencies: Array.from({ length: 200 }, (_, i) => `package_${i}`)\n      },\n      performance_data: {\n        metrics: Array.from({ length: 1000 }, () => Math.random() * 100),\n        timestamps: Array.from({ length: 1000 }, (_, i) => Date.now() + i * 1000)\n      },\n      index\n    };\n  }\n\n  function calculatePerformanceMetrics(\n    operations: number,\n    durations: number[],\n    startTime: number,\n    endTime: number,\n    memory: { initial: number; peak: number; final: number }\n  ): PerformanceMetrics {\n    const totalTime = endTime - startTime;\n    const averageTime = durations.reduce((a, b) => a + b, 0) / durations.length;\n    const throughput = (operations / totalTime) * 1000; // Operations per second\n\n    const sortedDurations = durations.sort((a, b) => a - b);\n    const p50 = sortedDurations[Math.floor(sortedDurations.length * 0.5)];\n    const p95 = sortedDurations[Math.floor(sortedDurations.length * 0.95)];\n    const p99 = sortedDurations[Math.floor(sortedDurations.length * 0.99)];\n\n    return {\n      operations,\n      totalTime,\n      averageTime,\n      throughput,\n      memoryUsage: {\n        initial: memory.initial,\n        peak: memory.peak,\n        final: memory.final,\n        delta: memory.final - memory.initial\n      },\n      p50,\n      p95,\n      p99\n    };\n  }\n\n  function validateBenchmark(metrics: PerformanceMetrics, thresholds: BenchmarkThresholds): boolean {\n    return (\n      metrics.averageTime <= thresholds.maxAverageTime &&\n      metrics.throughput >= thresholds.minThroughput &&\n      metrics.memoryUsage.delta <= thresholds.maxMemoryDelta &&\n      metrics.p99 <= thresholds.maxP99Latency\n    );\n  }\n\n  async function generatePerformanceReport(results: BenchmarkResult[]) {\n    const reportPath = path.join(tempDir, 'performance-report.json');\n    const report = {\n      timestamp: new Date().toISOString(),\n      summary: {\n        totalTests: results.length,\n        passedTests: results.filter(r => r.passed).length,\n        failedTests: results.filter(r => !r.passed).length\n      },\n      results: results.map(r => ({\n        testName: r.testName,\n        passed: r.passed,\n        metrics: {\n          averageTime: `${r.metrics.averageTime.toFixed(2)}ms`,\n          throughput: `${r.metrics.throughput.toFixed(2)} ops/sec`,\n          memoryDelta: `${(r.metrics.memoryUsage.delta / 1024 / 1024).toFixed(2)}MB`,\n          p99Latency: `${r.metrics.p99.toFixed(2)}ms`\n        },\n        thresholds: {\n          maxAverageTime: `${r.thresholds.maxAverageTime}ms`,\n          minThroughput: `${r.thresholds.minThroughput} ops/sec`,\n          maxMemoryDelta: `${(r.thresholds.maxMemoryDelta / 1024 / 1024).toFixed(0)}MB`,\n          maxP99Latency: `${r.thresholds.maxP99Latency}ms`\n        }\n      }))\n    };\n\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n    console.log(`Performance report generated: ${reportPath}`);\n  }\n});"],"names":["performance","fs","path","os","TruthScoreCalculator","describe","tempDir","calculator","performanceResults","beforeAll","mkdtemp","join","tmpdir","configPath","memoryPath","init","afterAll","rm","recursive","force","generatePerformanceReport","test","thresholds","maxAverageTime","minThroughput","maxMemoryDelta","maxP99Latency","operations","evidenceVariants","generateEvidenceVariants","durations","initialMemory","process","memoryUsage","heapUsed","peakMemory","startTime","now","i","evidence","length","operationStart","score","calculateScore","operationEnd","push","currentMemory","Math","max","expect","toBeGreaterThanOrEqual","toBeLessThanOrEqual","endTime","finalMemory","metrics","calculatePerformanceMetrics","initial","peak","final","result","testName","passed","validateBenchmark","averageTime","throughput","delta","p99","concurrency","operationsPerWorker","totalOperations","workerPromises","Array","from","_","workerIndex","workerDurations","Promise","resolve","setTimeout","allDurations","all","flat","memorySnapshots","score1","comparison","compareClaimToReality","tests_pass","no_lint_errors","lint_errors","global","gc","memoryGrowthRate","toBeLessThan","largeEvidence","generateLargeEvidence","agentId","taskId","random","storeTruthScore","files","readdir","toBe","agents","limit","floor","history","getAgentHistory","toBeGreaterThan","complexity","quality","format","report","generateReport","total_verifications","Object","keys","toContain","loadDuration","batchSize","batchInterval","operationCount","loadTestPromise","interval","setInterval","clearInterval","batchPromises","truth_score","count","test_results","total","lint_results","errors","type_results","build_results","success","performance_metrics","response_time","memory_usage","complexity_score","variant_id","index","detailed_results","test_name","status","duration","warnings","file_reports","file","issues","build_log","repeat","dependencies","performance_data","timestamps","Date","memory","totalTime","reduce","a","b","sortedDurations","sort","p50","p95","results","reportPath","timestamp","toISOString","summary","totalTests","passedTests","filter","r","failedTests","map","toFixed","memoryDelta","p99Latency","writeFile","JSON","stringify","console","log"],"mappings":"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"}