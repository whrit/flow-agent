{"version":3,"sources":["../../../src/monitoring/health-check.ts"],"sourcesContent":["/**\n * Health Check System for Claude Flow v2.0.0\n */\n\nimport { EventBus } from '../core/event-bus.js';\nimport { Logger } from '../core/logger.js';\nimport { SystemIntegration } from '../integration/system-integration.js';\nimport type {\n  HealthCheckResult,\n  ComponentStatus,\n  SystemHealth,\n  SystemMetrics,\n} from '../integration/types.js';\nimport { getErrorMessage } from '../utils/error-handler.js';\n\nexport interface HealthCheckConfig {\n  interval?: number; // Health check interval in ms (default: 30000)\n  timeout?: number; // Health check timeout in ms (default: 5000)\n  retries?: number; // Number of retries for failed checks (default: 3)\n  enableMetrics?: boolean; // Collect system metrics (default: true)\n  enableAlerts?: boolean; // Send alerts on health issues (default: true)\n}\n\nexport interface AlertConfig {\n  webhook?: string;\n  email?: string;\n  slack?: string;\n  threshold?: number; // Alert threshold for unhealthy components\n}\n\nexport class HealthCheckManager {\n  private eventBus: EventBus;\n  private logger: Logger;\n  private systemIntegration: SystemIntegration;\n  private config: Required<HealthCheckConfig>;\n  private intervalId: NodeJS.Timeout | null = null;\n  private healthHistory: Map<string, HealthCheckResult[]> = new Map();\n  private isRunning = false;\n  private lastMetrics: SystemMetrics | null = null;\n\n  constructor(eventBus: EventBus, logger: Logger, config: HealthCheckConfig = {}) {\n    this.eventBus = eventBus;\n    this.logger = logger;\n    this.systemIntegration = SystemIntegration.getInstance();\n\n    this.config = {\n      interval: config.interval || 30000, // 30 seconds\n      timeout: config.timeout || 5000, // 5 seconds\n      retries: config.retries || 3,\n      enableMetrics: config.enableMetrics !== false,\n      enableAlerts: config.enableAlerts !== false,\n    };\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Start health monitoring\n   */\n  start(): void {\n    if (this.isRunning) {\n      this.logger.warn('Health check manager already running');\n      return;\n    }\n\n    this.logger.info('Starting health check monitoring');\n    this.isRunning = true;\n\n    // Perform initial health check\n    this.performHealthCheck();\n\n    // Set up periodic health checks\n    this.intervalId = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.interval);\n\n    this.eventBus.emit('health:monitor:started', {\n      interval: this.config.interval,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stop(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    this.logger.info('Stopping health check monitoring');\n    this.isRunning = false;\n\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n\n    this.eventBus.emit('health:monitor:stopped', {\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Perform comprehensive health check\n   */\n  async performHealthCheck(): Promise<SystemHealth> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.debug('Performing system health check');\n\n      // Get system health from integration manager\n      const systemHealth = await this.systemIntegration.getSystemHealth();\n\n      // Perform individual component checks\n      const componentChecks = await this.checkAllComponents();\n\n      // Collect system metrics if enabled\n      if (this.config.enableMetrics) {\n        this.lastMetrics = await this.collectSystemMetrics();\n      }\n\n      // Store health history\n      this.storeHealthHistory(componentChecks);\n\n      // Check for alerts\n      if (this.config.enableAlerts) {\n        await this.checkForAlerts(systemHealth);\n      }\n\n      const duration = Date.now() - startTime;\n      this.logger.debug(`Health check completed in ${duration}ms`);\n\n      // Emit health check event\n      this.eventBus.emit('health:check:completed', {\n        health: systemHealth,\n        metrics: this.lastMetrics,\n        duration,\n        timestamp: Date.now(),\n      });\n\n      return systemHealth;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.logger.error('Health check failed:', getErrorMessage(error));\n\n      this.eventBus.emit('health:check:failed', {\n        error: getErrorMessage(error),\n        duration,\n        timestamp: Date.now(),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Check all system components\n   */\n  private async checkAllComponents(): Promise<HealthCheckResult[]> {\n    const components = [\n      'orchestrator',\n      'configManager',\n      'memoryManager',\n      'agentManager',\n      'swarmCoordinator',\n      'taskEngine',\n      'monitor',\n      'mcpServer',\n    ];\n\n    const checks = await Promise.allSettled(\n      components.map((component) => this.checkComponent(component)),\n    );\n\n    return checks.map((result, index) => {\n      if (result.status === 'fulfilled') {\n        return result.value;\n      } else {\n        return {\n          component: components[index],\n          healthy: false,\n          message: getErrorMessage(result.reason),\n          timestamp: Date.now(),\n        };\n      }\n    });\n  }\n\n  /**\n   * Check individual component health\n   */\n  private async checkComponent(componentName: string): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n\n    try {\n      const component = this.systemIntegration.getComponent(componentName);\n\n      if (!component) {\n        return {\n          component: componentName,\n          healthy: false,\n          message: 'Component not found',\n          timestamp: Date.now(),\n        };\n      }\n\n      // Try to call health check method if available\n      if (typeof component.healthCheck === 'function') {\n        const result = await Promise.race([\n          component.healthCheck(),\n          new Promise((_, reject) =>\n            setTimeout(() => reject(new Error('Health check timeout')), this.config.timeout),\n          ),\n        ]);\n        return result as HealthCheckResult;\n      }\n\n      // Basic availability check\n      const duration = Date.now() - startTime;\n      return {\n        component: componentName,\n        healthy: true,\n        message: 'Component available',\n        metrics: { responseTime: duration },\n        timestamp: Date.now(),\n      };\n    } catch (error) {\n      return {\n        component: componentName,\n        healthy: false,\n        message: getErrorMessage(error),\n        timestamp: Date.now(),\n      };\n    }\n  }\n\n  /**\n   * Collect system metrics\n   */\n  private async collectSystemMetrics(): Promise<SystemMetrics> {\n    const startTime = Date.now();\n\n    try {\n      // Get system resource usage\n      const memoryUsage = process.memoryUsage();\n      const cpuUsage = process.cpuUsage();\n\n      // Get component-specific metrics\n      const agentManager = this.systemIntegration.getComponent('agentManager');\n      const taskEngine = this.systemIntegration.getComponent('taskEngine');\n\n      let activeAgents = 0;\n      let activeTasks = 0;\n      let queuedTasks = 0;\n      let completedTasks = 0;\n\n      if (agentManager && typeof agentManager.getMetrics === 'function') {\n        const agentMetrics = await agentManager.getMetrics();\n        activeAgents = agentMetrics.activeAgents || 0;\n      }\n\n      if (taskEngine && typeof taskEngine.getMetrics === 'function') {\n        const taskMetrics = await taskEngine.getMetrics();\n        activeTasks = taskMetrics.activeTasks || 0;\n        queuedTasks = taskMetrics.queuedTasks || 0;\n        completedTasks = taskMetrics.completedTasks || 0;\n      }\n\n      return {\n        cpu: (cpuUsage.user + cpuUsage.system) / 1000000, // Convert to percentage\n        memory: (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100,\n        network: 0, // Placeholder - would need additional monitoring\n        disk: 0, // Placeholder - would need additional monitoring\n        activeAgents,\n        activeTasks,\n        queuedTasks,\n        completedTasks,\n        errorCount: this.getErrorCount(),\n        uptime: process.uptime() * 1000,\n        timestamp: Date.now(),\n      };\n    } catch (error) {\n      this.logger.error('Failed to collect system metrics:', getErrorMessage(error));\n      return {\n        cpu: 0,\n        memory: 0,\n        network: 0,\n        disk: 0,\n        activeAgents: 0,\n        activeTasks: 0,\n        queuedTasks: 0,\n        completedTasks: 0,\n        errorCount: 0,\n        uptime: process.uptime() * 1000,\n        timestamp: Date.now(),\n      };\n    }\n  }\n\n  /**\n   * Store health check history\n   */\n  private storeHealthHistory(results: HealthCheckResult[]): void {\n    const maxHistorySize = 100; // Keep last 100 health checks per component\n\n    results.forEach((result) => {\n      if (!this.healthHistory.has(result.component)) {\n        this.healthHistory.set(result.component, []);\n      }\n\n      const history = this.healthHistory.get(result.component)!;\n      history.push(result);\n\n      // Trim history if too large\n      if (history.length > maxHistorySize) {\n        history.splice(0, history.length - maxHistorySize);\n      }\n    });\n  }\n\n  /**\n   * Check for alerts and send notifications\n   */\n  private async checkForAlerts(health: SystemHealth): Promise<void> {\n    const unhealthyComponents = Object.values(health.components).filter(\n      (component) => component.status === 'unhealthy',\n    );\n\n    if (unhealthyComponents.length > 0) {\n      const alert = {\n        type: 'component_failure',\n        severity: 'high',\n        message: `${unhealthyComponents.length} component(s) are unhealthy`,\n        components: unhealthyComponents.map((c) => c.component),\n        timestamp: Date.now(),\n      };\n\n      this.eventBus.emit('health:alert', alert);\n      this.logger.warn('Health alert triggered:', alert.message);\n    }\n\n    // Check system metrics for anomalies\n    if (this.lastMetrics) {\n      const alerts = [];\n\n      if (this.lastMetrics.cpu > 90) {\n        alerts.push({\n          type: 'high_cpu',\n          severity: 'medium',\n          message: `High CPU usage: ${this.lastMetrics.cpu.toFixed(1)}%`,\n          value: this.lastMetrics.cpu,\n        });\n      }\n\n      if (this.lastMetrics.memory > 90) {\n        alerts.push({\n          type: 'high_memory',\n          severity: 'medium',\n          message: `High memory usage: ${this.lastMetrics.memory.toFixed(1)}%`,\n          value: this.lastMetrics.memory,\n        });\n      }\n\n      if (this.lastMetrics.errorCount > 10) {\n        alerts.push({\n          type: 'high_errors',\n          severity: 'high',\n          message: `High error count: ${this.lastMetrics.errorCount}`,\n          value: this.lastMetrics.errorCount,\n        });\n      }\n\n      alerts.forEach((alert) => {\n        this.eventBus.emit('health:alert', {\n          ...alert,\n          timestamp: Date.now(),\n        });\n      });\n    }\n  }\n\n  /**\n   * Get component health history\n   */\n  getHealthHistory(component?: string): HealthCheckResult[] {\n    if (component) {\n      return this.healthHistory.get(component) || [];\n    }\n\n    // Return all history\n    const allHistory: HealthCheckResult[] = [];\n    for (const history of this.healthHistory.values()) {\n      allHistory.push(...history);\n    }\n\n    return allHistory.sort((a, b) => b.timestamp - a.timestamp);\n  }\n\n  /**\n   * Get current system metrics\n   */\n  getCurrentMetrics(): SystemMetrics | null {\n    return this.lastMetrics;\n  }\n\n  /**\n   * Get system health status\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    return await this.systemIntegration.getSystemHealth();\n  }\n\n  /**\n   * Get error count from recent history\n   */\n  private getErrorCount(): number {\n    const recentTime = Date.now() - 300000; // Last 5 minutes\n    let errorCount = 0;\n\n    for (const history of this.healthHistory.values()) {\n      errorCount += history.filter(\n        (check) => check.timestamp > recentTime && !check.healthy,\n      ).length;\n    }\n\n    return errorCount;\n  }\n\n  /**\n   * Setup event handlers\n   */\n  private setupEventHandlers(): void {\n    // Listen for component status changes\n    this.eventBus.on('component:status:updated', (status: ComponentStatus) => {\n      if (status.status === 'unhealthy') {\n        this.logger.warn(`Component ${status.component} became unhealthy: ${status.message}`);\n      }\n    });\n\n    // Listen for system errors\n    this.eventBus.on('system:error', (error) => {\n      this.logger.error('System error detected:', error);\n    });\n  }\n\n  /**\n   * Check if monitoring is running\n   */\n  isMonitoring(): boolean {\n    return this.isRunning;\n  }\n\n  /**\n   * Get monitoring configuration\n   */\n  getConfig(): Required<HealthCheckConfig> {\n    return { ...this.config };\n  }\n}\n"],"names":["SystemIntegration","getErrorMessage","HealthCheckManager","eventBus","logger","systemIntegration","config","intervalId","healthHistory","Map","isRunning","lastMetrics","getInstance","interval","timeout","retries","enableMetrics","enableAlerts","setupEventHandlers","start","warn","info","performHealthCheck","setInterval","emit","timestamp","Date","now","stop","clearInterval","startTime","debug","systemHealth","getSystemHealth","componentChecks","checkAllComponents","collectSystemMetrics","storeHealthHistory","checkForAlerts","duration","health","metrics","error","components","checks","Promise","allSettled","map","component","checkComponent","result","index","status","value","healthy","message","reason","componentName","getComponent","healthCheck","race","_","reject","setTimeout","Error","responseTime","memoryUsage","process","cpuUsage","agentManager","taskEngine","activeAgents","activeTasks","queuedTasks","completedTasks","getMetrics","agentMetrics","taskMetrics","cpu","user","system","memory","heapUsed","heapTotal","network","disk","errorCount","getErrorCount","uptime","results","maxHistorySize","forEach","has","set","history","get","push","length","splice","unhealthyComponents","Object","values","filter","alert","type","severity","c","alerts","toFixed","getHealthHistory","allHistory","sort","a","b","getCurrentMetrics","recentTime","check","on","isMonitoring","getConfig"],"mappings":"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"}