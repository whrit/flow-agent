{"version":3,"sources":["../../../src/monitoring/real-time-monitor.ts"],"sourcesContent":["/**\n * Real-time monitoring system for swarm operations\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type {\n  SystemMetrics,\n  Alert,\n  AlertLevel,\n  AlertType,\n  MonitoringConfig,\n  AgentMetrics,\n  SwarmMetrics,\n  AgentId,\n} from '../swarm/types.js';\nimport type { DistributedMemorySystem } from '../memory/distributed-memory.js';\n\nexport interface MonitorConfig {\n  updateInterval: number;\n  retentionPeriod: number;\n  alertingEnabled: boolean;\n  alertThresholds: AlertThresholds;\n  metricsEnabled: boolean;\n  tracingEnabled: boolean;\n  dashboardEnabled: boolean;\n  exportEnabled: boolean;\n  exportFormat: 'json' | 'csv' | 'prometheus';\n  debugMode: boolean;\n}\n\nexport interface AlertThresholds {\n  cpu: { warning: number; critical: number };\n  memory: { warning: number; critical: number };\n  disk: { warning: number; critical: number };\n  errorRate: { warning: number; critical: number };\n  responseTime: { warning: number; critical: number };\n  queueDepth: { warning: number; critical: number };\n  agentHealth: { warning: number; critical: number };\n  swarmUtilization: { warning: number; critical: number };\n}\n\nexport interface MetricPoint {\n  timestamp: Date;\n  value: number;\n  tags: Record<string, string>;\n  metadata?: Record<string, any>;\n}\n\nexport interface TimeSeries {\n  name: string;\n  points: MetricPoint[];\n  aggregations: {\n    min: number;\n    max: number;\n    avg: number;\n    sum: number;\n    count: number;\n  };\n  lastUpdated: Date;\n}\n\nexport interface MonitoringDashboard {\n  title: string;\n  panels: DashboardPanel[];\n  refreshInterval: number;\n  timeRange: { start: Date; end: Date };\n  filters: Record<string, any>;\n}\n\nexport interface DashboardPanel {\n  id: string;\n  title: string;\n  type: 'line' | 'bar' | 'gauge' | 'table' | 'heatmap' | 'stat';\n  metrics: string[];\n  config: {\n    width: number;\n    height: number;\n    position: { x: number; y: number };\n    visualization: Record<string, any>;\n  };\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  enabled: boolean;\n  metric: string;\n  condition: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n  threshold: number;\n  duration: number; // How long condition must persist\n  severity: AlertLevel;\n  tags: Record<string, string>;\n  actions: AlertAction[];\n  suppressions: AlertSuppression[];\n}\n\nexport interface AlertAction {\n  type: 'email' | 'webhook' | 'slack' | 'log' | 'auto-scale' | 'restart';\n  config: Record<string, any>;\n  enabled: boolean;\n}\n\nexport interface AlertSuppression {\n  condition: string;\n  duration: number;\n  reason: string;\n}\n\nexport interface HealthCheck {\n  name: string;\n  type: 'http' | 'tcp' | 'custom';\n  target: string;\n  interval: number;\n  timeout: number;\n  retries: number;\n  expectedResponse?: any;\n  customCheck?: () => Promise<boolean>;\n}\n\n/**\n * Comprehensive real-time monitoring and alerting system\n */\nexport class RealTimeMonitor extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private memory: DistributedMemorySystem;\n  private config: MonitorConfig;\n\n  // Metrics storage\n  private timeSeries = new Map<string, TimeSeries>();\n  private activeAlerts = new Map<string, Alert>();\n  private alertHistory: Alert[] = [];\n\n  // Monitoring state\n  private monitoringInterval?: NodeJS.Timeout;\n  private healthCheckInterval?: NodeJS.Timeout;\n  private alertRules = new Map<string, AlertRule>();\n  private healthChecks = new Map<string, HealthCheck>();\n\n  // System state tracking\n  private systemMetrics: SystemMetrics;\n  private agentMetrics = new Map<string, AgentMetrics>();\n  private swarmMetrics: SwarmMetrics;\n\n  // Dashboards\n  private dashboards = new Map<string, MonitoringDashboard>();\n\n  // Performance tracking\n  private lastMetricsUpdate = new Date();\n  private metricsBuffer: MetricPoint[] = [];\n  private alertProcessor?: NodeJS.Timeout;\n\n  constructor(\n    config: Partial<MonitorConfig>,\n    logger: ILogger,\n    eventBus: IEventBus,\n    memory: DistributedMemorySystem,\n  ) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n    this.memory = memory;\n\n    this.config = {\n      updateInterval: 5000,\n      retentionPeriod: 86400000, // 24 hours\n      alertingEnabled: true,\n      alertThresholds: {\n        cpu: { warning: 70, critical: 90 },\n        memory: { warning: 80, critical: 95 },\n        disk: { warning: 85, critical: 95 },\n        errorRate: { warning: 5, critical: 10 },\n        responseTime: { warning: 5000, critical: 10000 },\n        queueDepth: { warning: 10, critical: 20 },\n        agentHealth: { warning: 0.7, critical: 0.5 },\n        swarmUtilization: { warning: 0.8, critical: 0.95 },\n      },\n      metricsEnabled: true,\n      tracingEnabled: true,\n      dashboardEnabled: true,\n      exportEnabled: false,\n      exportFormat: 'json',\n      debugMode: false,\n      ...config,\n    };\n\n    this.systemMetrics = this.initializeSystemMetrics();\n    this.swarmMetrics = this.initializeSwarmMetrics();\n\n    this.setupEventHandlers();\n    this.initializeDefaultAlertRules();\n    this.initializeDefaultDashboards();\n  }\n\n  private setupEventHandlers(): void {\n    // Agent events\n    this.eventBus.on('agent:metrics-update', (data) => {\n      this.updateAgentMetrics(data.agentId, data.metrics);\n    });\n\n    this.eventBus.on('agent:status-changed', (data) => {\n      this.recordMetric('agent.status.change', 1, {\n        agentId: data.agentId,\n        from: data.from,\n        to: data.to,\n      });\n    });\n\n    // Task events\n    this.eventBus.on('task:started', (data) => {\n      this.recordMetric('task.started', 1, { taskId: data.taskId, agentId: data.agentId });\n    });\n\n    this.eventBus.on('task:completed', (data) => {\n      this.recordMetric('task.completed', 1, { taskId: data.taskId });\n      this.recordMetric('task.duration', data.duration, { taskId: data.taskId });\n    });\n\n    this.eventBus.on('task:failed', (data) => {\n      this.recordMetric('task.failed', 1, { taskId: data.taskId, error: data.error });\n    });\n\n    // System events\n    this.eventBus.on('system:resource-update', (data) => {\n      this.updateSystemMetrics(data);\n    });\n\n    this.eventBus.on('swarm:metrics-update', (data) => {\n      this.updateSwarmMetrics(data.metrics);\n    });\n\n    // Error events\n    this.eventBus.on('error', (data) => {\n      this.handleError(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing real-time monitor', {\n      updateInterval: this.config.updateInterval,\n      alerting: this.config.alertingEnabled,\n      dashboard: this.config.dashboardEnabled,\n    });\n\n    // Start monitoring loops\n    this.startMetricsCollection();\n    this.startHealthChecks();\n\n    if (this.config.alertingEnabled) {\n      this.startAlertProcessing();\n    }\n\n    // Initialize default health checks\n    this.initializeHealthChecks();\n\n    this.emit('monitor:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down real-time monitor');\n\n    // Stop all intervals\n    if (this.monitoringInterval) clearInterval(this.monitoringInterval);\n    if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);\n    if (this.alertProcessor) clearInterval(this.alertProcessor);\n\n    // Flush any remaining metrics\n    await this.flushMetrics();\n\n    this.emit('monitor:shutdown');\n  }\n\n  // === METRICS COLLECTION ===\n\n  private startMetricsCollection(): void {\n    this.monitoringInterval = setInterval(() => {\n      this.collectSystemMetrics();\n      this.processMetricsBuffer();\n      this.cleanupOldMetrics();\n    }, this.config.updateInterval);\n\n    this.logger.info('Started metrics collection', {\n      interval: this.config.updateInterval,\n    });\n  }\n\n  private async collectSystemMetrics(): Promise<void> {\n    try {\n      // Update system metrics\n      this.systemMetrics = {\n        ...this.systemMetrics,\n        timestamp: new Date(),\n        cpuUsage: await this.getCpuUsage(),\n        memoryUsage: await this.getMemoryUsage(),\n        diskUsage: await this.getDiskUsage(),\n        networkUsage: await this.getNetworkUsage(),\n      };\n\n      // Record as time series\n      this.recordMetric('system.cpu', this.systemMetrics.cpuUsage);\n      this.recordMetric('system.memory', this.systemMetrics.memoryUsage);\n      this.recordMetric('system.disk', this.systemMetrics.diskUsage);\n      this.recordMetric('system.network', this.systemMetrics.networkUsage);\n\n      // Update swarm-level metrics\n      await this.updateSwarmLevelMetrics();\n    } catch (error) {\n      this.logger.error('Failed to collect system metrics', error);\n    }\n  }\n\n  private async updateSwarmLevelMetrics(): Promise<void> {\n    const agents = Array.from(this.agentMetrics.values());\n\n    this.swarmMetrics = {\n      ...this.swarmMetrics,\n      agentUtilization: this.calculateAgentUtilization(agents),\n      throughput: this.calculateSwarmThroughput(agents),\n      latency: this.calculateAverageLatency(agents),\n      efficiency: this.calculateSwarmEfficiency(agents),\n      reliability: this.calculateSwarmReliability(agents),\n      averageQuality: this.calculateAverageQuality(agents),\n    };\n\n    // Record swarm metrics\n    this.recordMetric('swarm.utilization', this.swarmMetrics.agentUtilization);\n    this.recordMetric('swarm.throughput', this.swarmMetrics.throughput);\n    this.recordMetric('swarm.latency', this.swarmMetrics.latency);\n    this.recordMetric('swarm.efficiency', this.swarmMetrics.efficiency);\n    this.recordMetric('swarm.reliability', this.swarmMetrics.reliability);\n  }\n\n  recordMetric(name: string, value: number, tags: Record<string, string> = {}): void {\n    const point: MetricPoint = {\n      timestamp: new Date(),\n      value,\n      tags,\n    };\n\n    // Add to buffer for batch processing\n    this.metricsBuffer.push({ ...point, tags: { ...tags, metric: name } });\n\n    // Immediate processing for critical metrics\n    if (this.isCriticalMetric(name)) {\n      this.processMetricPoint(name, point);\n    }\n  }\n\n  private processMetricsBuffer(): void {\n    if (this.metricsBuffer.length === 0) return;\n\n    // Group by metric name\n    const metricGroups = new Map<string, MetricPoint[]>();\n    for (const point of this.metricsBuffer) {\n      const metricName = point.tags.metric || 'unknown';\n      const group = metricGroups.get(metricName) || [];\n      group.push(point);\n      metricGroups.set(metricName, group);\n    }\n\n    // Process each metric group\n    for (const [metricName, points] of metricGroups) {\n      for (const point of points) {\n        this.processMetricPoint(metricName, point);\n      }\n    }\n\n    // Clear buffer\n    this.metricsBuffer = [];\n  }\n\n  private processMetricPoint(metricName: string, point: MetricPoint): void {\n    let series = this.timeSeries.get(metricName);\n\n    if (!series) {\n      series = {\n        name: metricName,\n        points: [],\n        aggregations: {\n          min: point.value,\n          max: point.value,\n          avg: point.value,\n          sum: point.value,\n          count: 1,\n        },\n        lastUpdated: point.timestamp,\n      };\n      this.timeSeries.set(metricName, series);\n    }\n\n    // Add point\n    series.points.push(point);\n    series.lastUpdated = point.timestamp;\n\n    // Update aggregations\n    series.aggregations.count++;\n    series.aggregations.sum += point.value;\n    series.aggregations.avg = series.aggregations.sum / series.aggregations.count;\n    series.aggregations.min = Math.min(series.aggregations.min, point.value);\n    series.aggregations.max = Math.max(series.aggregations.max, point.value);\n\n    // Trigger alert checking for this metric\n    if (this.config.alertingEnabled) {\n      this.checkAlertsForMetric(metricName, point);\n    }\n  }\n\n  // === ALERTING ===\n\n  private startAlertProcessing(): void {\n    this.alertProcessor = setInterval(() => {\n      this.processAlerts();\n    }, 1000); // Process alerts every second\n\n    this.logger.info('Started alert processing');\n  }\n\n  private processAlerts(): void {\n    const now = new Date();\n\n    // Check for alert resolution\n    for (const [alertId, alert] of this.activeAlerts) {\n      if (!alert.resolved) {\n        const rule = this.alertRules.get(alert.context.ruleId);\n        if (rule && this.isAlertResolved(rule, alert)) {\n          this.resolveAlert(alertId, 'condition_resolved');\n        }\n      }\n    }\n\n    // Clean up old resolved alerts\n    this.cleanupResolvedAlerts();\n  }\n\n  private checkAlertsForMetric(metricName: string, point: MetricPoint): void {\n    for (const [ruleId, rule] of this.alertRules) {\n      if (rule.enabled && rule.metric === metricName) {\n        this.evaluateAlertRule(rule, point);\n      }\n    }\n  }\n\n  private evaluateAlertRule(rule: AlertRule, point: MetricPoint): void {\n    const conditionMet = this.evaluateCondition(rule.condition, point.value, rule.threshold);\n\n    if (conditionMet) {\n      // Check if we already have an active alert for this rule\n      const existingAlert = Array.from(this.activeAlerts.values()).find(\n        (alert) => alert.context.ruleId === rule.id && !alert.resolved,\n      );\n\n      if (!existingAlert) {\n        this.createAlert(rule, point);\n      }\n    }\n  }\n\n  private createAlert(rule: AlertRule, triggeringPoint: MetricPoint): void {\n    const alertId = `alert-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n\n    const alert: Alert = {\n      id: alertId,\n      timestamp: new Date(),\n      level: rule.severity,\n      type: this.getAlertTypeFromMetric(rule.metric),\n      message: `${rule.name}: ${rule.metric} ${rule.condition} ${rule.threshold} (current: ${triggeringPoint.value})`,\n      source: 'real-time-monitor',\n      context: {\n        ruleId: rule.id,\n        metric: rule.metric,\n        value: triggeringPoint.value,\n        threshold: rule.threshold,\n        tags: { ...rule.tags, ...triggeringPoint.tags },\n      },\n      acknowledged: false,\n      resolved: false,\n      escalationLevel: 0,\n    };\n\n    this.activeAlerts.set(alertId, alert);\n    this.alertHistory.push(alert);\n\n    this.logger.warn('Alert created', {\n      alertId,\n      rule: rule.name,\n      metric: rule.metric,\n      value: triggeringPoint.value,\n      threshold: rule.threshold,\n    });\n\n    this.emit('alert:created', { alert });\n\n    // Execute alert actions\n    this.executeAlertActions(rule, alert);\n  }\n\n  private executeAlertActions(rule: AlertRule, alert: Alert): void {\n    for (const action of rule.actions) {\n      if (!action.enabled) continue;\n\n      try {\n        switch (action.type) {\n          case 'log':\n            this.logger.warn(`ALERT: ${alert.message}`, alert.context);\n            break;\n\n          case 'email':\n            this.sendEmailAlert(alert, action.config);\n            break;\n\n          case 'webhook':\n            this.sendWebhookAlert(alert, action.config);\n            break;\n\n          case 'auto-scale':\n            this.triggerAutoScale(alert, action.config);\n            break;\n\n          case 'restart':\n            this.triggerRestart(alert, action.config);\n            break;\n\n          default:\n            this.logger.warn('Unknown alert action type', { type: action.type });\n        }\n      } catch (error) {\n        this.logger.error('Failed to execute alert action', {\n          alertId: alert.id,\n          actionType: action.type,\n          error,\n        });\n      }\n    }\n  }\n\n  private resolveAlert(alertId: string, reason: string): void {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert) return;\n\n    alert.resolved = true;\n    alert.context.resolutionReason = reason;\n    alert.context.resolvedAt = new Date();\n\n    this.logger.info('Alert resolved', { alertId, reason });\n    this.emit('alert:resolved', { alert, reason });\n  }\n\n  // === HEALTH CHECKS ===\n\n  private startHealthChecks(): void {\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthChecks();\n    }, 30000); // Every 30 seconds\n\n    this.logger.info('Started health checks');\n  }\n\n  private async performHealthChecks(): Promise<void> {\n    const checks = Array.from(this.healthChecks.values());\n    const promises = checks.map((check) => this.executeHealthCheck(check));\n\n    await Promise.allSettled(promises);\n  }\n\n  private async executeHealthCheck(check: HealthCheck): Promise<void> {\n    try {\n      let isHealthy = false;\n\n      switch (check.type) {\n        case 'http':\n          isHealthy = await this.performHttpHealthCheck(check);\n          break;\n        case 'tcp':\n          isHealthy = await this.performTcpHealthCheck(check);\n          break;\n        case 'custom':\n          if (check.customCheck) {\n            isHealthy = await check.customCheck();\n          }\n          break;\n      }\n\n      this.recordMetric(`healthcheck.${check.name}`, isHealthy ? 1 : 0, {\n        type: check.type,\n        target: check.target,\n      });\n    } catch (error) {\n      this.logger.error('Health check failed', { check: check.name, error });\n      this.recordMetric(`healthcheck.${check.name}`, 0, {\n        type: check.type,\n        target: check.target,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  // === DASHBOARD MANAGEMENT ===\n\n  createDashboard(title: string, panels: DashboardPanel[]): string {\n    const dashboardId = `dashboard-${Date.now()}`;\n\n    const dashboard: MonitoringDashboard = {\n      title,\n      panels,\n      refreshInterval: 30000,\n      timeRange: {\n        start: new Date(Date.now() - 3600000), // Last hour\n        end: new Date(),\n      },\n      filters: {},\n    };\n\n    this.dashboards.set(dashboardId, dashboard);\n    this.emit('dashboard:created', { dashboardId, dashboard });\n\n    return dashboardId;\n  }\n\n  getDashboardData(dashboardId: string): any {\n    const dashboard = this.dashboards.get(dashboardId);\n    if (!dashboard) return null;\n\n    const data: any = {\n      dashboard,\n      panels: [],\n    };\n\n    for (const panel of dashboard.panels) {\n      const panelData = {\n        id: panel.id,\n        title: panel.title,\n        type: panel.type,\n        data: this.getPanelData(panel, dashboard.timeRange),\n      };\n      data.panels.push(panelData);\n    }\n\n    return data;\n  }\n\n  private getPanelData(panel: DashboardPanel, timeRange: { start: Date; end: Date }): any {\n    const data: any = {};\n\n    for (const metricName of panel.metrics) {\n      const series = this.timeSeries.get(metricName);\n      if (series) {\n        // Filter points by time range\n        const filteredPoints = series.points.filter(\n          (point) => point.timestamp >= timeRange.start && point.timestamp <= timeRange.end,\n        );\n\n        data[metricName] = {\n          points: filteredPoints,\n          aggregations: this.calculateAggregations(filteredPoints),\n        };\n      }\n    }\n\n    return data;\n  }\n\n  // === UTILITY METHODS ===\n\n  private async getCpuUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 100;\n  }\n\n  private async getMemoryUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 100;\n  }\n\n  private async getDiskUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 100;\n  }\n\n  private async getNetworkUsage(): Promise<number> {\n    // Placeholder - would use actual system APIs\n    return Math.random() * 1024 * 1024; // bytes\n  }\n\n  private updateAgentMetrics(agentId: string, metrics: AgentMetrics): void {\n    this.agentMetrics.set(agentId, metrics);\n\n    // Record individual agent metrics\n    this.recordMetric('agent.cpu', metrics.cpuUsage, { agentId });\n    this.recordMetric('agent.memory', metrics.memoryUsage, { agentId });\n    this.recordMetric('agent.tasks.completed', metrics.tasksCompleted, { agentId });\n    this.recordMetric('agent.tasks.failed', metrics.tasksFailed, { agentId });\n    this.recordMetric('agent.response.time', metrics.responseTime, { agentId });\n  }\n\n  private updateSystemMetrics(data: Partial<SystemMetrics>): void {\n    this.systemMetrics = { ...this.systemMetrics, ...data };\n  }\n\n  private updateSwarmMetrics(metrics: SwarmMetrics): void {\n    this.swarmMetrics = { ...this.swarmMetrics, ...metrics };\n  }\n\n  private handleError(data: any): void {\n    this.recordMetric('error.count', 1, {\n      type: data.type || 'unknown',\n      source: data.source || 'unknown',\n    });\n\n    // Create critical alert for errors\n    if (data.severity === 'critical') {\n      const alertId = `error-alert-${Date.now()}`;\n      const alert: Alert = {\n        id: alertId,\n        timestamp: new Date(),\n        level: 'critical',\n        type: 'system',\n        message: `Critical error: ${data.message}`,\n        source: data.source || 'unknown',\n        context: data,\n        acknowledged: false,\n        resolved: false,\n        escalationLevel: 0,\n      };\n\n      this.activeAlerts.set(alertId, alert);\n      this.emit('alert:created', { alert });\n    }\n  }\n\n  private isCriticalMetric(name: string): boolean {\n    const criticalMetrics = [\n      'system.cpu',\n      'system.memory',\n      'system.disk',\n      'agent.health',\n      'task.failed',\n      'error.count',\n    ];\n    return criticalMetrics.includes(name);\n  }\n\n  private evaluateCondition(condition: string, value: number, threshold: number): boolean {\n    switch (condition) {\n      case 'gt':\n        return value > threshold;\n      case 'gte':\n        return value >= threshold;\n      case 'lt':\n        return value < threshold;\n      case 'lte':\n        return value <= threshold;\n      case 'eq':\n        return value === threshold;\n      default:\n        return false;\n    }\n  }\n\n  private isAlertResolved(rule: AlertRule, alert: Alert): boolean {\n    // Get recent metric values\n    const series = this.timeSeries.get(rule.metric);\n    if (!series || series.points.length === 0) return false;\n\n    // Check if condition is no longer met\n    const recentPoints = series.points.slice(-5); // Last 5 points\n    const allResolved = recentPoints.every(\n      (point) => !this.evaluateCondition(rule.condition, point.value, rule.threshold),\n    );\n\n    return allResolved;\n  }\n\n  private getAlertTypeFromMetric(metric: string): AlertType {\n    if (metric.includes('system')) return 'system';\n    if (metric.includes('agent')) return 'agent';\n    if (metric.includes('task')) return 'task';\n    if (metric.includes('swarm')) return 'swarm';\n    if (metric.includes('performance')) return 'performance';\n    if (metric.includes('resource')) return 'resource';\n    return 'custom';\n  }\n\n  private calculateAgentUtilization(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0;\n    const totalUtilization = agents.reduce((sum, agent) => sum + agent.cpuUsage, 0);\n    return totalUtilization / agents.length;\n  }\n\n  private calculateSwarmThroughput(agents: AgentMetrics[]): number {\n    return agents.reduce((sum, agent) => sum + (agent.tasksCompleted || 0), 0);\n  }\n\n  private calculateAverageLatency(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0;\n    const totalLatency = agents.reduce((sum, agent) => sum + agent.responseTime, 0);\n    return totalLatency / agents.length;\n  }\n\n  private calculateSwarmEfficiency(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0;\n    const totalTasks = agents.reduce(\n      (sum, agent) => sum + (agent.tasksCompleted || 0) + (agent.tasksFailed || 0),\n      0,\n    );\n    const completedTasks = agents.reduce((sum, agent) => sum + (agent.tasksCompleted || 0), 0);\n    return totalTasks > 0 ? completedTasks / totalTasks : 1;\n  }\n\n  private calculateSwarmReliability(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 1;\n    const totalReliability = agents.reduce((sum, agent) => sum + (agent.successRate || 1), 0);\n    return totalReliability / agents.length;\n  }\n\n  private calculateAverageQuality(agents: AgentMetrics[]): number {\n    if (agents.length === 0) return 0.8;\n    const totalQuality = agents.reduce((sum, agent) => sum + (agent.codeQuality || 0.8), 0);\n    return totalQuality / agents.length;\n  }\n\n  private calculateAggregations(points: MetricPoint[]): any {\n    if (points.length === 0) {\n      return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };\n    }\n\n    const values = points.map((p) => p.value);\n    return {\n      min: Math.min(...values),\n      max: Math.max(...values),\n      avg: values.reduce((sum, val) => sum + val, 0) / values.length,\n      sum: values.reduce((sum, val) => sum + val, 0),\n      count: values.length,\n    };\n  }\n\n  private cleanupOldMetrics(): void {\n    const cutoff = new Date(Date.now() - this.config.retentionPeriod);\n\n    for (const [name, series] of this.timeSeries) {\n      series.points = series.points.filter((point) => point.timestamp > cutoff);\n\n      if (series.points.length === 0) {\n        this.timeSeries.delete(name);\n      }\n    }\n  }\n\n  private cleanupResolvedAlerts(): void {\n    const cutoff = new Date(Date.now() - 86400000); // 24 hours\n\n    // Remove old resolved alerts from active alerts\n    for (const [alertId, alert] of this.activeAlerts) {\n      if (alert.resolved && alert.timestamp < cutoff) {\n        this.activeAlerts.delete(alertId);\n      }\n    }\n\n    // Trim alert history\n    this.alertHistory = this.alertHistory.filter((alert) => alert.timestamp > cutoff).slice(-1000); // Keep last 1000 alerts max\n  }\n\n  private async flushMetrics(): Promise<void> {\n    if (this.metricsBuffer.length > 0) {\n      this.processMetricsBuffer();\n    }\n\n    // Persist metrics to memory if enabled\n    if (this.config.exportEnabled) {\n      await this.exportMetrics();\n    }\n  }\n\n  private async exportMetrics(): Promise<void> {\n    try {\n      const exportData = {\n        timestamp: new Date(),\n        timeSeries: Array.from(this.timeSeries.entries()),\n        systemMetrics: this.systemMetrics,\n        swarmMetrics: this.swarmMetrics,\n        activeAlerts: Array.from(this.activeAlerts.values()),\n      };\n\n      await this.memory.store('monitoring:export', exportData, {\n        type: 'monitoring-export',\n        partition: 'metrics',\n      });\n    } catch (error) {\n      this.logger.error('Failed to export metrics', error);\n    }\n  }\n\n  private initializeDefaultAlertRules(): void {\n    const rules: AlertRule[] = [\n      {\n        id: 'cpu-warning',\n        name: 'High CPU Usage',\n        enabled: true,\n        metric: 'system.cpu',\n        condition: 'gt',\n        threshold: this.config.alertThresholds.cpu.warning,\n        duration: 60000,\n        severity: 'warning',\n        tags: { category: 'system' },\n        actions: [{ type: 'log', config: {}, enabled: true }],\n        suppressions: [],\n      },\n      {\n        id: 'memory-critical',\n        name: 'Critical Memory Usage',\n        enabled: true,\n        metric: 'system.memory',\n        condition: 'gt',\n        threshold: this.config.alertThresholds.memory.critical,\n        duration: 30000,\n        severity: 'critical',\n        tags: { category: 'system' },\n        actions: [\n          { type: 'log', config: {}, enabled: true },\n          { type: 'auto-scale', config: { action: 'scale-down' }, enabled: true },\n        ],\n        suppressions: [],\n      },\n    ];\n\n    rules.forEach((rule) => this.alertRules.set(rule.id, rule));\n  }\n\n  private initializeDefaultDashboards(): void {\n    const systemDashboard = this.createDashboard('System Overview', [\n      {\n        id: 'cpu-panel',\n        title: 'CPU Usage',\n        type: 'line',\n        metrics: ['system.cpu'],\n        config: {\n          width: 6,\n          height: 4,\n          position: { x: 0, y: 0 },\n          visualization: { yAxis: { max: 100 } },\n        },\n      },\n      {\n        id: 'memory-panel',\n        title: 'Memory Usage',\n        type: 'gauge',\n        metrics: ['system.memory'],\n        config: {\n          width: 6,\n          height: 4,\n          position: { x: 6, y: 0 },\n          visualization: { max: 100, threshold: [70, 90] },\n        },\n      },\n    ]);\n\n    this.logger.info('Created default dashboard', { dashboardId: systemDashboard });\n  }\n\n  private initializeHealthChecks(): void {\n    // Add default health checks\n    this.healthChecks.set('system', {\n      name: 'system',\n      type: 'custom',\n      target: 'local',\n      interval: 30000,\n      timeout: 5000,\n      retries: 3,\n      customCheck: async () => {\n        // Basic system health check\n        return this.systemMetrics.cpuUsage < 95 && this.systemMetrics.memoryUsage < 95;\n      },\n    });\n  }\n\n  private async performHttpHealthCheck(check: HealthCheck): Promise<boolean> {\n    // Placeholder for HTTP health check\n    return true;\n  }\n\n  private async performTcpHealthCheck(check: HealthCheck): Promise<boolean> {\n    // Placeholder for TCP health check\n    return true;\n  }\n\n  private async sendEmailAlert(alert: Alert, config: any): Promise<void> {\n    // Placeholder for email alert\n    this.logger.info('Email alert sent', { alertId: alert.id });\n  }\n\n  private async sendWebhookAlert(alert: Alert, config: any): Promise<void> {\n    // Placeholder for webhook alert\n    this.logger.info('Webhook alert sent', { alertId: alert.id });\n  }\n\n  private async triggerAutoScale(alert: Alert, config: any): Promise<void> {\n    // Placeholder for auto-scaling\n    this.logger.info('Auto-scale triggered', { alertId: alert.id, action: config.action });\n    this.eventBus.emit('autoscale:triggered', { alert, config });\n  }\n\n  private async triggerRestart(alert: Alert, config: any): Promise<void> {\n    // Placeholder for restart action\n    this.logger.info('Restart triggered', { alertId: alert.id });\n    this.eventBus.emit('restart:triggered', { alert, config });\n  }\n\n  private initializeSystemMetrics(): SystemMetrics {\n    return {\n      timestamp: new Date(),\n      cpuUsage: 0,\n      memoryUsage: 0,\n      diskUsage: 0,\n      networkUsage: 0,\n      activeSwarms: 0,\n      totalAgents: 0,\n      activeAgents: 0,\n      totalTasks: 0,\n      runningTasks: 0,\n      throughput: 0,\n      latency: 0,\n      errorRate: 0,\n      successRate: 100,\n      resourceUtilization: {},\n      queueLengths: {},\n    };\n  }\n\n  private initializeSwarmMetrics(): SwarmMetrics {\n    return {\n      throughput: 0,\n      latency: 0,\n      efficiency: 1.0,\n      reliability: 1.0,\n      averageQuality: 0.8,\n      defectRate: 0,\n      reworkRate: 0,\n      resourceUtilization: {},\n      costEfficiency: 1.0,\n      agentUtilization: 0,\n      agentSatisfaction: 0.8,\n      collaborationEffectiveness: 0.8,\n      scheduleVariance: 0,\n      deadlineAdherence: 1.0,\n    };\n  }\n\n  // === PUBLIC API ===\n\n  getSystemMetrics(): SystemMetrics {\n    return { ...this.systemMetrics };\n  }\n\n  getSwarmMetrics(): SwarmMetrics {\n    return { ...this.swarmMetrics };\n  }\n\n  getActiveAlerts(): Alert[] {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  getAlertHistory(limit: number = 100): Alert[] {\n    return this.alertHistory.slice(-limit);\n  }\n\n  getTimeSeries(metricName: string): TimeSeries | undefined {\n    return this.timeSeries.get(metricName);\n  }\n\n  getAllTimeSeries(): TimeSeries[] {\n    return Array.from(this.timeSeries.values());\n  }\n\n  acknowledgeAlert(alertId: string, acknowledgedBy: string): void {\n    const alert = this.activeAlerts.get(alertId);\n    if (alert) {\n      alert.acknowledged = true;\n      alert.assignedTo = acknowledgedBy;\n      this.emit('alert:acknowledged', { alert, acknowledgedBy });\n    }\n  }\n\n  createAlertRule(rule: Omit<AlertRule, 'id'>): string {\n    const ruleId = `rule-${Date.now()}`;\n    this.alertRules.set(ruleId, { ...rule, id: ruleId });\n    return ruleId;\n  }\n\n  updateAlertRule(ruleId: string, updates: Partial<AlertRule>): void {\n    const rule = this.alertRules.get(ruleId);\n    if (rule) {\n      this.alertRules.set(ruleId, { ...rule, ...updates });\n    }\n  }\n\n  deleteAlertRule(ruleId: string): void {\n    this.alertRules.delete(ruleId);\n  }\n\n  getAlertRules(): AlertRule[] {\n    return Array.from(this.alertRules.values());\n  }\n\n  getMonitoringStatistics(): {\n    metricsCount: number;\n    activeAlerts: number;\n    alertRules: number;\n    healthChecks: number;\n    dashboards: number;\n    uptime: number;\n  } {\n    return {\n      metricsCount: this.timeSeries.size,\n      activeAlerts: this.activeAlerts.size,\n      alertRules: this.alertRules.size,\n      healthChecks: this.healthChecks.size,\n      dashboards: this.dashboards.size,\n      uptime: Date.now() - this.lastMetricsUpdate.getTime(),\n    };\n  }\n}\n"],"names":["EventEmitter","RealTimeMonitor","logger","eventBus","memory","config","timeSeries","Map","activeAlerts","alertHistory","monitoringInterval","healthCheckInterval","alertRules","healthChecks","systemMetrics","agentMetrics","swarmMetrics","dashboards","lastMetricsUpdate","Date","metricsBuffer","alertProcessor","updateInterval","retentionPeriod","alertingEnabled","alertThresholds","cpu","warning","critical","disk","errorRate","responseTime","queueDepth","agentHealth","swarmUtilization","metricsEnabled","tracingEnabled","dashboardEnabled","exportEnabled","exportFormat","debugMode","initializeSystemMetrics","initializeSwarmMetrics","setupEventHandlers","initializeDefaultAlertRules","initializeDefaultDashboards","on","data","updateAgentMetrics","agentId","metrics","recordMetric","from","to","taskId","duration","error","updateSystemMetrics","updateSwarmMetrics","handleError","initialize","info","alerting","dashboard","startMetricsCollection","startHealthChecks","startAlertProcessing","initializeHealthChecks","emit","shutdown","clearInterval","flushMetrics","setInterval","collectSystemMetrics","processMetricsBuffer","cleanupOldMetrics","interval","timestamp","cpuUsage","getCpuUsage","memoryUsage","getMemoryUsage","diskUsage","getDiskUsage","networkUsage","getNetworkUsage","updateSwarmLevelMetrics","agents","Array","values","agentUtilization","calculateAgentUtilization","throughput","calculateSwarmThroughput","latency","calculateAverageLatency","efficiency","calculateSwarmEfficiency","reliability","calculateSwarmReliability","averageQuality","calculateAverageQuality","name","value","tags","point","push","metric","isCriticalMetric","processMetricPoint","length","metricGroups","metricName","group","get","set","points","series","aggregations","min","max","avg","sum","count","lastUpdated","Math","checkAlertsForMetric","processAlerts","now","alertId","alert","resolved","rule","context","ruleId","isAlertResolved","resolveAlert","cleanupResolvedAlerts","enabled","evaluateAlertRule","conditionMet","evaluateCondition","condition","threshold","existingAlert","find","id","createAlert","triggeringPoint","random","toString","slice","level","severity","type","getAlertTypeFromMetric","message","source","acknowledged","escalationLevel","warn","executeAlertActions","action","actions","sendEmailAlert","sendWebhookAlert","triggerAutoScale","triggerRestart","actionType","reason","resolutionReason","resolvedAt","performHealthChecks","checks","promises","map","check","executeHealthCheck","Promise","allSettled","isHealthy","performHttpHealthCheck","performTcpHealthCheck","customCheck","target","Error","String","createDashboard","title","panels","dashboardId","refreshInterval","timeRange","start","end","filters","getDashboardData","panel","panelData","getPanelData","filteredPoints","filter","calculateAggregations","tasksCompleted","tasksFailed","criticalMetrics","includes","recentPoints","allResolved","every","totalUtilization","reduce","agent","totalLatency","totalTasks","completedTasks","totalReliability","successRate","totalQuality","codeQuality","p","val","cutoff","delete","exportMetrics","exportData","entries","store","partition","rules","category","suppressions","forEach","systemDashboard","width","height","position","x","y","visualization","yAxis","timeout","retries","activeSwarms","totalAgents","activeAgents","runningTasks","resourceUtilization","queueLengths","defectRate","reworkRate","costEfficiency","agentSatisfaction","collaborationEffectiveness","scheduleVariance","deadlineAdherence","getSystemMetrics","getSwarmMetrics","getActiveAlerts","getAlertHistory","limit","getTimeSeries","getAllTimeSeries","acknowledgeAlert","acknowledgedBy","assignedTo","createAlertRule","updateAlertRule","updates","deleteAlertRule","getAlertRules","getMonitoringStatistics","metricsCount","size","uptime","getTime"],"mappings":"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"}