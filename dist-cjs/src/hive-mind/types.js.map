{"version":3,"sources":["../../../src/hive-mind/types.ts"],"sourcesContent":["/**\n * Hive Mind Type Definitions\n *\n * Core types and interfaces for the Hive Mind system\n */\n\n// Swarm types\nexport type SwarmTopology = 'mesh' | 'hierarchical' | 'ring' | 'star' | 'specs-driven';\nexport type QueenMode = 'centralized' | 'distributed' | 'strategic';\n\nexport interface HiveMindConfig {\n  name: string;\n  topology: SwarmTopology;\n  maxAgents: number;\n  queenMode: QueenMode;\n  memoryTTL: number;\n  consensusThreshold: number;\n  autoSpawn: boolean;\n  enableConsensus?: boolean;\n  enableMemory?: boolean;\n  enableCommunication?: boolean;\n  enabledFeatures?: string[];\n  createdAt?: Date;\n}\n\n// Agent types\nexport type AgentType =\n  | 'coordinator'\n  | 'researcher'\n  | 'coder'\n  | 'analyst'\n  | 'architect'\n  | 'tester'\n  | 'reviewer'\n  | 'optimizer'\n  | 'documenter'\n  | 'monitor'\n  | 'specialist'\n  // Maestro specs-driven agent types\n  | 'requirements_analyst'\n  | 'design_architect'\n  | 'task_planner'\n  | 'implementation_coder'\n  | 'quality_reviewer'\n  | 'steering_documenter';\n\nexport type AgentStatus = 'idle' | 'busy' | 'active' | 'error' | 'offline';\n\nexport type AgentCapability =\n  | 'task_management'\n  | 'resource_allocation'\n  | 'consensus_building'\n  | 'information_gathering'\n  | 'pattern_recognition'\n  | 'knowledge_synthesis'\n  | 'code_generation'\n  | 'refactoring'\n  | 'debugging'\n  | 'data_analysis'\n  | 'performance_metrics'\n  | 'bottleneck_detection'\n  | 'system_design'\n  | 'architecture'\n  | 'architecture_patterns'\n  | 'integration_planning'\n  | 'technical_writing'\n  | 'test_generation'\n  | 'quality_assurance'\n  | 'edge_case_detection'\n  | 'code_review'\n  | 'standards_enforcement'\n  | 'best_practices'\n  | 'performance_optimization'\n  | 'resource_optimization'\n  | 'algorithm_improvement'\n  | 'documentation_generation'\n  | 'api_docs'\n  | 'user_guides'\n  | 'system_monitoring'\n  | 'health_checks'\n  | 'alerting'\n  | 'domain_expertise'\n  | 'custom_capabilities'\n  | 'problem_solving'\n  // Maestro specs-driven capabilities\n  | 'requirements_analysis'\n  | 'user_story_creation'\n  | 'acceptance_criteria'\n  | 'specs_driven_design'\n  | 'workflow_orchestration'\n  | 'governance';\n\nexport interface AgentConfig {\n  id?: string;\n  name: string;\n  type: AgentType;\n  swarmId: string;\n  capabilities: AgentCapability[];\n}\n\nexport interface AgentSpawnOptions {\n  type: AgentType;\n  name?: string;\n  capabilities?: AgentCapability[];\n  autoAssign?: boolean;\n  config?: Partial<AgentConfig>;\n  environment?: Partial<AgentEnvironment>;\n}\n\nexport interface AgentEnvironment {\n  workingDirectory?: string;\n  environmentVariables?: Record<string, string>;\n  resourceLimits?: {\n    maxMemory?: number;\n    maxCpu?: number;\n    timeout?: number;\n  };\n}\n\n// Task types\nexport type TaskPriority = 'low' | 'medium' | 'high' | 'critical';\nexport type TaskStrategy = 'parallel' | 'sequential' | 'adaptive' | 'consensus';\nexport type TaskStatus =\n  | 'pending'\n  | 'assigned'\n  | 'in_progress'\n  | 'completed'\n  | 'failed'\n  | 'cancelled';\n\nexport interface Task {\n  id: string;\n  swarmId: string;\n  description: string;\n  priority: TaskPriority;\n  strategy: TaskStrategy;\n  status: TaskStatus;\n  progress: number;\n  result?: any;\n  error?: string;\n  dependencies: string[];\n  assignedAgents: string[];\n  requireConsensus: boolean;\n  consensusAchieved?: boolean;\n  maxAgents: number;\n  requiredCapabilities: AgentCapability[];\n  createdAt: Date;\n  assignedAt?: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  metadata: any;\n}\n\nexport interface TaskSubmitOptions {\n  description: string;\n  priority: TaskPriority;\n  strategy: TaskStrategy;\n  dependencies?: string[];\n  assignTo?: string;\n  requireConsensus?: boolean;\n  maxAgents?: number;\n  requiredCapabilities?: AgentCapability[];\n  metadata?: any;\n}\n\nexport interface TaskAssignment {\n  role: string;\n  requiredCapabilities: AgentCapability[];\n  responsibilities: string[];\n  expectedOutput: string;\n  timeout: number;\n  canRunParallel: boolean;\n}\n\n// Communication types\nexport type MessageType =\n  | 'direct'\n  | 'broadcast'\n  | 'consensus'\n  | 'query'\n  | 'response'\n  | 'notification'\n  | 'task_assignment'\n  | 'progress_update'\n  | 'coordination'\n  | 'channel';\n\nexport type MessagePriority = 'low' | 'normal' | 'high' | 'urgent';\n\nexport interface Message {\n  id: string;\n  fromAgentId: string;\n  toAgentId: string | null;\n  swarmId: string;\n  type: MessageType;\n  content: any;\n  priority?: MessagePriority;\n  timestamp: Date;\n  requiresResponse: boolean;\n}\n\nexport interface CommunicationChannel {\n  name: string;\n  description: string;\n  type: 'public' | 'private';\n  subscribers: string[];\n  createdAt: Date;\n}\n\nexport interface CommunicationStats {\n  totalMessages: number;\n  avgLatency: number;\n  activeChannels: number;\n  messagesByType: Record<MessageType, number>;\n  throughput: number;\n}\n\n// Memory types\nexport interface MemoryEntry {\n  key: string;\n  namespace: string;\n  value: string;\n  ttl?: number;\n  createdAt: Date;\n  accessCount: number;\n  lastAccessedAt: Date;\n  expiresAt?: Date;\n}\n\nexport interface MemoryNamespace {\n  name: string;\n  description: string;\n  retentionPolicy: 'persistent' | 'time-based' | 'size-based';\n  ttl?: number;\n  maxEntries?: number;\n  lastOperation?: string;\n  lastOperationTime?: Date;\n}\n\nexport interface MemoryStats {\n  totalEntries: number;\n  totalSize: number;\n  byNamespace: Record<\n    string,\n    {\n      entries: number;\n      size: number;\n      avgTTL: number;\n    }\n  >;\n  cacheHitRate: number;\n  avgAccessTime: number;\n  hotKeys: string[];\n}\n\nexport interface MemorySearchOptions {\n  namespace?: string;\n  pattern?: string;\n  keyPrefix?: string;\n  minAccessCount?: number;\n  limit?: number;\n  sortBy?: 'access' | 'recent' | 'created';\n}\n\nexport interface MemoryPattern {\n  type: 'co-access' | 'temporal' | 'frequency';\n  keys: string[];\n  confidence: number;\n  frequency: number;\n}\n\n// Consensus types\nexport interface ConsensusProposal {\n  id: string;\n  swarmId: string;\n  taskId?: string;\n  proposal: any;\n  requiredThreshold: number;\n  deadline?: Date;\n  creator?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface ConsensusVote {\n  proposalId: string;\n  agentId: string;\n  vote: boolean;\n  reason?: string;\n  timestamp: Date;\n}\n\nexport interface ConsensusResult {\n  proposalId: string;\n  achieved: boolean;\n  finalRatio: number;\n  totalVotes: number;\n  positiveVotes: number;\n  negativeVotes: number;\n  participationRate: number;\n}\n\nexport interface VotingStrategy {\n  name: string;\n  description: string;\n  threshold: number;\n  recommend: (\n    proposal: ConsensusProposal,\n    analysis: any,\n  ) => {\n    vote: boolean;\n    confidence: number;\n    reasoning: string;\n    factors: string[];\n  };\n}\n\nexport interface ConsensusMetrics {\n  totalProposals: number;\n  achievedConsensus: number;\n  failedConsensus: number;\n  avgVotingTime: number;\n  avgParticipation: number;\n}\n\n// Orchestration types\nexport interface ExecutionPlan {\n  taskId: string;\n  strategy: TaskStrategy;\n  phases: string[];\n  phaseAssignments: TaskAssignment[][];\n  dependencies: string[];\n  checkpoints: any[];\n  parallelizable: boolean;\n  estimatedDuration: number;\n  resourceRequirements: any;\n}\n\nexport interface OrchestrationResult {\n  taskId: string;\n  success: boolean;\n  executionTime: number;\n  phaseResults: any[];\n  errors?: any[];\n}\n\nexport interface ExecutionResult {\n  success: boolean;\n  data: any;\n  executionTime: number;\n  agentId: string;\n  metadata?: any;\n}\n\n// Queen types\nexport interface QueenDecision {\n  id: string;\n  taskId: string;\n  strategy: CoordinationStrategy;\n  selectedAgents: string[];\n  executionPlan: any;\n  confidence: number;\n  rationale: string;\n  timestamp: Date;\n}\n\nexport interface CoordinationStrategy {\n  name: string;\n  description: string;\n  phases: string[];\n  maxAgents: number;\n  coordinationPoints: string[];\n  suitable_for: string[];\n}\n\n// Status types\nexport interface SwarmStatus {\n  swarmId: string;\n  name: string;\n  topology: SwarmTopology;\n  queenMode: QueenMode;\n  health: 'healthy' | 'degraded' | 'critical' | 'unknown';\n  uptime: number;\n  agents: Array<{\n    id: string;\n    name: string;\n    type: AgentType;\n    status: AgentStatus;\n    currentTask: string | null;\n    messageCount: number;\n    createdAt: number;\n  }>;\n  agentsByType: Record<AgentType, number>;\n  tasks: Array<{\n    id: string;\n    description: string;\n    status: TaskStatus;\n    priority: TaskPriority;\n    progress: number;\n    assignedAgent: string | null;\n  }>;\n  taskStats: {\n    total: number;\n    pending: number;\n    inProgress: number;\n    completed: number;\n    failed: number;\n  };\n  memoryStats: MemoryStats;\n  communicationStats: CommunicationStats;\n  performance: {\n    avgTaskCompletion: number;\n    messageThroughput: number;\n    consensusSuccessRate: number;\n    memoryHitRate: number;\n    agentUtilization: number;\n  };\n  warnings: string[];\n}\n\n// Neural pattern types\nexport interface NeuralPattern {\n  id: string;\n  swarmId: string;\n  patternType: 'coordination' | 'optimization' | 'prediction' | 'behavior';\n  patternData: any;\n  confidence: number;\n  usageCount: number;\n  successRate: number;\n  createdAt: Date;\n  lastUsedAt?: Date;\n}\n\n// Performance types\nexport interface PerformanceMetric {\n  swarmId: string;\n  agentId?: string;\n  metricType: string;\n  metricValue: number;\n  timestamp: Date;\n  metadata?: any;\n}\n"],"names":[],"mappings":"AAibA,WAOC"}