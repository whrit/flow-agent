{"version":3,"sources":["../../../../src/hive-mind/integration/SwarmOrchestrator.ts"],"sourcesContent":["/**\n * SwarmOrchestrator Class\n *\n * Orchestrates task distribution, agent coordination, and\n * execution strategies within the Hive Mind swarm.\n */\n\nimport { EventEmitter } from 'events';\nimport { HiveMind } from '../core/HiveMind.js';\nimport { Agent } from '../core/Agent.js';\nimport { DatabaseManager } from '../core/DatabaseManager.js';\nimport { MCPToolWrapper } from './MCPToolWrapper.js';\nimport {\n  Task,\n  TaskStrategy,\n  ExecutionPlan,\n  OrchestrationResult,\n  TaskAssignment,\n} from '../types.js';\n\nexport class SwarmOrchestrator extends EventEmitter {\n  private hiveMind: HiveMind;\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private executionPlans: Map<string, ExecutionPlan>;\n  private taskAssignments: Map<string, TaskAssignment[]>;\n  private activeExecutions: Map<string, any>;\n  private isActive: boolean = false;\n\n  constructor(hiveMind: HiveMind) {\n    super();\n    this.hiveMind = hiveMind;\n    this.executionPlans = new Map();\n    this.taskAssignments = new Map();\n    this.activeExecutions = new Map();\n  }\n\n  /**\n   * Initialize the orchestrator\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n    await this.mcpWrapper.initialize();\n\n    // Start orchestration loops\n    this.startTaskDistributor();\n    this.startProgressMonitor();\n    this.startLoadBalancer();\n\n    this.isActive = true;\n    this.emit('initialized');\n  }\n\n  /**\n   * Submit a task for orchestration\n   */\n  async submitTask(task: Task): Promise<void> {\n    // Create execution plan based on strategy\n    const plan = await this.createExecutionPlan(task);\n    this.executionPlans.set(task.id, plan);\n\n    // Orchestrate task using MCP tools\n    const orchestrationResult = await this.mcpWrapper.orchestrateTask({\n      task: task.description,\n      priority: task.priority,\n      strategy: task.strategy,\n      dependencies: task.dependencies,\n    });\n\n    if (orchestrationResult.success) {\n      // Start task execution\n      await this.executeTask(task, plan);\n    } else {\n      this.emit('orchestrationError', { task, error: orchestrationResult.error });\n    }\n  }\n\n  /**\n   * Create execution plan for a task\n   */\n  private async createExecutionPlan(task: Task): Promise<ExecutionPlan> {\n    const strategy = this.getStrategyImplementation(task.strategy);\n\n    // Analyze task complexity\n    const analysis = await this.analyzeTaskComplexity(task);\n\n    // Determine phases based on strategy and complexity\n    const phases = strategy.determinePhases(task, analysis);\n\n    // Create assignments for each phase\n    const phaseAssignments = await Promise.all(\n      phases.map((phase) => this.createPhaseAssignments(task, phase, analysis)),\n    );\n\n    return {\n      taskId: task.id,\n      strategy: task.strategy,\n      phases,\n      phaseAssignments,\n      dependencies: task.dependencies,\n      checkpoints: this.createCheckpoints(phases),\n      parallelizable: strategy.isParallelizable(task),\n      estimatedDuration: analysis.estimatedDuration,\n      resourceRequirements: analysis.resourceRequirements,\n    };\n  }\n\n  /**\n   * Execute task according to plan\n   */\n  private async executeTask(task: Task, plan: ExecutionPlan): Promise<void> {\n    const execution = {\n      taskId: task.id,\n      plan,\n      startTime: Date.now(),\n      currentPhase: 0,\n      phaseResults: [],\n      status: 'executing',\n    };\n\n    this.activeExecutions.set(task.id, execution);\n\n    try {\n      // Execute phases according to strategy\n      if (plan.parallelizable) {\n        await this.executeParallel(task, plan, execution);\n      } else {\n        await this.executeSequential(task, plan, execution);\n      }\n\n      // Mark task as completed\n      execution.status = 'completed';\n      await this.completeTask(task, execution);\n    } catch (error) {\n      execution.status = 'failed';\n      execution.error = error;\n      await this.handleTaskFailure(task, execution, error);\n    } finally {\n      this.activeExecutions.delete(task.id);\n    }\n  }\n\n  /**\n   * Execute phases in parallel\n   */\n  private async executeParallel(task: Task, plan: ExecutionPlan, execution: any): Promise<void> {\n    const parallelPhases = plan.phases.filter((_, index) =>\n      plan.phaseAssignments[index].some((a) => a.canRunParallel),\n    );\n\n    const results = await Promise.all(\n      parallelPhases.map((phase) => this.executePhase(task, phase, plan, execution)),\n    );\n\n    execution.phaseResults = results;\n  }\n\n  /**\n   * Execute phases sequentially\n   */\n  private async executeSequential(task: Task, plan: ExecutionPlan, execution: any): Promise<void> {\n    for (let i = 0; i < plan.phases.length; i++) {\n      const phase = plan.phases[i];\n      execution.currentPhase = i;\n\n      const result = await this.executePhase(task, phase, plan, execution);\n      execution.phaseResults.push(result);\n\n      // Check checkpoint\n      if (plan.checkpoints[i]) {\n        await this.evaluateCheckpoint(task, plan.checkpoints[i], execution);\n      }\n    }\n  }\n\n  /**\n   * Execute a single phase\n   */\n  private async executePhase(\n    task: Task,\n    phase: string,\n    plan: ExecutionPlan,\n    execution: any,\n  ): Promise<any> {\n    const phaseIndex = plan.phases.indexOf(phase);\n    const assignments = plan.phaseAssignments[phaseIndex];\n\n    // Assign agents to phase tasks\n    const agentAssignments = await this.assignAgentsToPhase(task, phase, assignments);\n\n    // Execute phase tasks\n    const phaseResults = await Promise.all(\n      agentAssignments.map((assignment) => this.executeAssignment(task, phase, assignment)),\n    );\n\n    // Aggregate phase results\n    return this.aggregatePhaseResults(phase, phaseResults);\n  }\n\n  /**\n   * Assign agents to phase tasks\n   */\n  private async assignAgentsToPhase(\n    task: Task,\n    phase: string,\n    assignments: TaskAssignment[],\n  ): Promise<any[]> {\n    const agentAssignments = [];\n\n    for (const assignment of assignments) {\n      // Find suitable agent\n      const agent = await this.findSuitableAgent(assignment.requiredCapabilities);\n\n      if (agent) {\n        await this.assignTaskToAgent(task.id, agent.id);\n        agentAssignments.push({\n          agent,\n          assignment,\n          phase,\n        });\n      } else {\n        // Queue for later assignment\n        this.queueAssignment(task.id, assignment);\n      }\n    }\n\n    return agentAssignments;\n  }\n\n  /**\n   * Execute a specific assignment\n   */\n  private async executeAssignment(task: Task, phase: string, assignment: any): Promise<any> {\n    const { agent, assignment: taskAssignment } = assignment;\n\n    // Send execution command to agent\n    await agent.assignTask(task.id, {\n      phase,\n      role: taskAssignment.role,\n      responsibilities: taskAssignment.responsibilities,\n      expectedOutput: taskAssignment.expectedOutput,\n    });\n\n    // Wait for completion or timeout\n    return this.waitForAgentCompletion(agent, task.id, taskAssignment.timeout);\n  }\n\n  /**\n   * Assign task to a specific agent\n   */\n  async assignTaskToAgent(taskId: string, agentId: string): Promise<void> {\n    // Update database\n    const task = await this.db.getTask(taskId);\n    const assignedAgents = JSON.parse(task.assigned_agents || '[]');\n\n    if (!assignedAgents.includes(agentId)) {\n      assignedAgents.push(agentId);\n      await this.db.updateTask(taskId, {\n        assigned_agents: JSON.stringify(assignedAgents),\n        status: 'assigned',\n      });\n    }\n\n    // Update agent\n    await this.db.updateAgent(agentId, {\n      current_task_id: taskId,\n      status: 'busy',\n    });\n\n    this.emit('taskAssigned', { taskId, agentId });\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(taskId: string): Promise<void> {\n    const execution = this.activeExecutions.get(taskId);\n\n    if (execution) {\n      execution.status = 'cancelled';\n\n      // Notify assigned agents\n      const task = await this.db.getTask(taskId);\n      const assignedAgents = JSON.parse(task.assigned_agents || '[]');\n\n      for (const agentId of assignedAgents) {\n        await this.notifyAgentTaskCancelled(agentId, taskId);\n      }\n    }\n\n    this.activeExecutions.delete(taskId);\n    this.executionPlans.delete(taskId);\n\n    this.emit('taskCancelled', { taskId });\n  }\n\n  /**\n   * Rebalance agent assignments\n   */\n  async rebalance(): Promise<void> {\n    // Get current load distribution\n    const loadDistribution = await this.analyzeLoadDistribution();\n\n    // Use MCP tool for load balancing\n    const balanceResult = await this.mcpWrapper.loadBalance({\n      tasks: loadDistribution.unassignedTasks,\n    });\n\n    if (balanceResult.success && balanceResult.data.reassignments) {\n      await this.applyReassignments(balanceResult.data.reassignments);\n    }\n\n    this.emit('rebalanced', { loadDistribution });\n  }\n\n  /**\n   * Strategy implementations\n   */\n  private getStrategyImplementation(strategy: TaskStrategy): any {\n    const strategies = {\n      parallel: {\n        determinePhases: (task: Task) => ['preparation', 'parallel-execution', 'aggregation'],\n        isParallelizable: () => true,\n        maxConcurrency: 5,\n      },\n      sequential: {\n        determinePhases: (task: Task) => ['analysis', 'planning', 'execution', 'validation'],\n        isParallelizable: () => false,\n        maxConcurrency: 1,\n      },\n      adaptive: {\n        determinePhases: (task: Task, analysis: any) => {\n          if (analysis.complexity === 'high') {\n            return ['deep-analysis', 'planning', 'phased-execution', 'integration', 'validation'];\n          }\n          return ['quick-analysis', 'execution', 'validation'];\n        },\n        isParallelizable: (task: Task) => !task.requireConsensus,\n        maxConcurrency: 3,\n      },\n      consensus: {\n        determinePhases: () => ['proposal', 'discussion', 'voting', 'execution', 'ratification'],\n        isParallelizable: () => false,\n        maxConcurrency: 1,\n      },\n    };\n\n    return strategies[strategy] || strategies.adaptive;\n  }\n\n  /**\n   * Analyze task complexity\n   */\n  private async analyzeTaskComplexity(task: Task): Promise<any> {\n    const analysis = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'task_complexity',\n      metadata: {\n        description: task.description,\n        priority: task.priority,\n        dependencies: task.dependencies.length,\n        requiresConsensus: task.requireConsensus,\n      },\n    });\n\n    return {\n      complexity: analysis.data?.complexity || 'medium',\n      estimatedDuration: analysis.data?.estimatedDuration || 3600000,\n      resourceRequirements: analysis.data?.resourceRequirements || {\n        minAgents: 1,\n        maxAgents: task.maxAgents,\n        capabilities: task.requiredCapabilities,\n      },\n    };\n  }\n\n  /**\n   * Create phase assignments\n   */\n  private async createPhaseAssignments(\n    task: Task,\n    phase: string,\n    analysis: any,\n  ): Promise<TaskAssignment[]> {\n    const assignments: TaskAssignment[] = [];\n\n    // Define assignments based on phase\n    switch (phase) {\n      case 'analysis':\n      case 'deep-analysis':\n        assignments.push({\n          role: 'analyst',\n          requiredCapabilities: ['data_analysis', 'pattern_recognition'],\n          responsibilities: ['Analyze task requirements', 'Identify patterns', 'Assess complexity'],\n          expectedOutput: 'Analysis report',\n          timeout: 300000, // 5 minutes\n          canRunParallel: false,\n        });\n        break;\n\n      case 'planning':\n        assignments.push({\n          role: 'architect',\n          requiredCapabilities: ['system_design', 'architecture_patterns'],\n          responsibilities: ['Design solution', 'Create implementation plan', 'Define interfaces'],\n          expectedOutput: 'Implementation plan',\n          timeout: 600000, // 10 minutes\n          canRunParallel: false,\n        });\n        break;\n\n      case 'execution':\n      case 'parallel-execution':\n        // Multiple execution assignments based on complexity\n        const executionCount = Math.min(analysis.resourceRequirements.maxAgents, 3);\n        for (let i = 0; i < executionCount; i++) {\n          assignments.push({\n            role: 'executor',\n            requiredCapabilities: task.requiredCapabilities,\n            responsibilities: ['Implement solution', 'Execute plan', 'Handle errors'],\n            expectedOutput: 'Execution results',\n            timeout: 1800000, // 30 minutes\n            canRunParallel: true,\n          });\n        }\n        break;\n\n      case 'validation':\n        assignments.push({\n          role: 'validator',\n          requiredCapabilities: ['quality_assurance', 'test_generation'],\n          responsibilities: ['Validate results', 'Run tests', 'Ensure quality'],\n          expectedOutput: 'Validation report',\n          timeout: 600000, // 10 minutes\n          canRunParallel: false,\n        });\n        break;\n\n      case 'consensus':\n      case 'voting':\n        assignments.push({\n          role: 'consensus-coordinator',\n          requiredCapabilities: ['consensus_building'],\n          responsibilities: ['Coordinate voting', 'Collect opinions', 'Determine consensus'],\n          expectedOutput: 'Consensus decision',\n          timeout: 300000, // 5 minutes\n          canRunParallel: false,\n        });\n        break;\n    }\n\n    return assignments;\n  }\n\n  /**\n   * Create execution checkpoints\n   */\n  private createCheckpoints(phases: string[]): any[] {\n    return phases.map((phase, index) => ({\n      phase,\n      index,\n      requiredProgress: Math.round(((index + 1) / phases.length) * 100),\n      validationCriteria: this.getValidationCriteria(phase),\n      failureThreshold: 0.3,\n    }));\n  }\n\n  /**\n   * Get validation criteria for a phase\n   */\n  private getValidationCriteria(phase: string): any[] {\n    const criteria: Record<string, any[]> = {\n      analysis: [\n        { name: 'completeness', weight: 0.4 },\n        { name: 'accuracy', weight: 0.6 },\n      ],\n      planning: [\n        { name: 'feasibility', weight: 0.5 },\n        { name: 'completeness', weight: 0.5 },\n      ],\n      execution: [\n        { name: 'correctness', weight: 0.7 },\n        { name: 'performance', weight: 0.3 },\n      ],\n      validation: [\n        { name: 'test_coverage', weight: 0.5 },\n        { name: 'quality_score', weight: 0.5 },\n      ],\n    };\n\n    return criteria[phase] || [{ name: 'completion', weight: 1.0 }];\n  }\n\n  /**\n   * Find suitable agent for capabilities\n   */\n  private async findSuitableAgent(requiredCapabilities: string[]): Promise<Agent | null> {\n    const agents = await this.hiveMind.getAgents();\n\n    // Filter available agents with required capabilities\n    const suitableAgents = agents.filter(\n      (agent) =>\n        agent.status === 'idle' &&\n        requiredCapabilities.every((cap) => agent.capabilities.includes(cap)),\n    );\n\n    if (suitableAgents.length === 0) {\n      return null;\n    }\n\n    // Select best agent based on performance history\n    return this.selectBestAgent(suitableAgents, requiredCapabilities);\n  }\n\n  /**\n   * Select best agent from candidates\n   */\n  private async selectBestAgent(agents: Agent[], capabilities: string[]): Promise<Agent> {\n    // Simple selection - in production would use performance metrics\n    const scores = await Promise.all(\n      agents.map(async (agent) => {\n        const performance = await this.db.getAgentPerformance(agent.id);\n        return {\n          agent,\n          score: performance?.successRate || 0.5,\n        };\n      }),\n    );\n\n    scores.sort((a, b) => b.score - a.score);\n    return scores[0].agent;\n  }\n\n  /**\n   * Wait for agent to complete task\n   */\n  private async waitForAgentCompletion(\n    agent: Agent,\n    taskId: string,\n    timeout: number,\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Agent ${agent.id} timeout on task ${taskId}`));\n      }, timeout);\n\n      const checkCompletion = async () => {\n        const agentState = await this.db.getAgent(agent.id);\n\n        if (agentState.current_task_id !== taskId) {\n          clearTimeout(timer);\n          clearInterval(interval);\n\n          // Get task result\n          const task = await this.db.getTask(taskId);\n          resolve(task.result ? JSON.parse(task.result) : {});\n        }\n      };\n\n      const interval = setInterval(checkCompletion, 1000);\n    });\n  }\n\n  /**\n   * Aggregate results from phase execution\n   */\n  private aggregatePhaseResults(phase: string, results: any[]): any {\n    return {\n      phase,\n      results,\n      summary: this.summarizeResults(results),\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Summarize phase results\n   */\n  private summarizeResults(results: any[]): any {\n    const successful = results.filter((r) => r.success).length;\n    const total = results.length;\n\n    return {\n      successRate: total > 0 ? successful / total : 0,\n      totalExecutions: total,\n      aggregatedData: results.map((r) => r.data).filter(Boolean),\n    };\n  }\n\n  /**\n   * Queue assignment for later\n   */\n  private queueAssignment(taskId: string, assignment: TaskAssignment): void {\n    if (!this.taskAssignments.has(taskId)) {\n      this.taskAssignments.set(taskId, []);\n    }\n\n    this.taskAssignments.get(taskId)!.push(assignment);\n    this.emit('assignmentQueued', { taskId, assignment });\n  }\n\n  /**\n   * Evaluate checkpoint\n   */\n  private async evaluateCheckpoint(task: Task, checkpoint: any, execution: any): Promise<void> {\n    const phaseResult = execution.phaseResults[checkpoint.index];\n\n    if (!phaseResult) return;\n\n    let score = 0;\n    for (const criterion of checkpoint.validationCriteria) {\n      const criterionScore = this.evaluateCriterion(phaseResult, criterion);\n      score += criterionScore * criterion.weight;\n    }\n\n    if (score < checkpoint.failureThreshold) {\n      throw new Error(`Checkpoint failed at phase ${checkpoint.phase}: score ${score}`);\n    }\n\n    this.emit('checkpointPassed', { task, checkpoint, score });\n  }\n\n  /**\n   * Evaluate validation criterion\n   */\n  private evaluateCriterion(result: any, criterion: any): number {\n    // Simplified evaluation - in production would be more sophisticated\n    if (result.summary && result.summary.successRate !== undefined) {\n      return result.summary.successRate;\n    }\n    return 0.7; // Default passing score\n  }\n\n  /**\n   * Complete task execution\n   */\n  private async completeTask(task: Task, execution: any): Promise<void> {\n    const finalResult = {\n      success: true,\n      executionTime: Date.now() - execution.startTime,\n      phases: execution.phaseResults,\n      summary: this.createExecutionSummary(execution),\n    };\n\n    await this.db.updateTask(task.id, {\n      status: 'completed',\n      result: JSON.stringify(finalResult),\n      progress: 100,\n      completed_at: new Date(),\n    });\n\n    this.emit('taskCompleted', { task, result: finalResult });\n  }\n\n  /**\n   * Handle task failure\n   */\n  private async handleTaskFailure(task: Task, execution: any, error: any): Promise<void> {\n    await this.db.updateTask(task.id, {\n      status: 'failed',\n      error: error.message,\n      completed_at: new Date(),\n    });\n\n    this.emit('taskFailed', { task, error });\n  }\n\n  /**\n   * Create execution summary\n   */\n  private createExecutionSummary(execution: any): any {\n    const phaseCount = execution.phaseResults.length;\n    const successfulPhases = execution.phaseResults.filter(\n      (r) => r.summary?.successRate > 0.5,\n    ).length;\n\n    return {\n      totalPhases: phaseCount,\n      successfulPhases,\n      overallSuccess: phaseCount > 0 ? successfulPhases / phaseCount : 0,\n      executionTime: Date.now() - execution.startTime,\n    };\n  }\n\n  /**\n   * Notify agent of task cancellation\n   */\n  private async notifyAgentTaskCancelled(agentId: string, taskId: string): Promise<void> {\n    // Send cancellation message to agent\n    await this.db.createCommunication({\n      from_agent_id: 'orchestrator',\n      to_agent_id: agentId,\n      swarm_id: this.hiveMind.id,\n      message_type: 'task_cancellation',\n      content: JSON.stringify({ taskId, reason: 'User cancelled' }),\n      priority: 'urgent',\n    });\n  }\n\n  /**\n   * Analyze load distribution\n   */\n  private async analyzeLoadDistribution(): Promise<any> {\n    const agents = await this.hiveMind.getAgents();\n    const tasks = await this.db.getActiveTasks(this.hiveMind.id);\n\n    const busyAgents = agents.filter((a) => a.status === 'busy');\n    const idleAgents = agents.filter((a) => a.status === 'idle');\n    const unassignedTasks = tasks.filter(\n      (t) => !t.assigned_agents || JSON.parse(t.assigned_agents).length === 0,\n    );\n\n    return {\n      totalAgents: agents.length,\n      busyAgents: busyAgents.length,\n      idleAgents: idleAgents.length,\n      activeTasks: tasks.length,\n      unassignedTasks: unassignedTasks.map((t) => ({\n        id: t.id,\n        priority: t.priority,\n        requiredCapabilities: JSON.parse(t.required_capabilities || '[]'),\n      })),\n      loadFactor: agents.length > 0 ? busyAgents.length / agents.length : 0,\n    };\n  }\n\n  /**\n   * Apply load balancing reassignments\n   */\n  private async applyReassignments(reassignments: any[]): Promise<void> {\n    for (const reassignment of reassignments) {\n      await this.reassignTask(reassignment.taskId, reassignment.fromAgent, reassignment.toAgent);\n    }\n  }\n\n  /**\n   * Reassign task from one agent to another\n   */\n  private async reassignTask(\n    taskId: string,\n    fromAgentId: string,\n    toAgentId: string,\n  ): Promise<void> {\n    // Update task assignment\n    await this.db.reassignTask(taskId, toAgentId);\n\n    // Update agent states\n    await this.db.updateAgent(fromAgentId, {\n      current_task_id: null,\n      status: 'idle',\n    });\n\n    await this.db.updateAgent(toAgentId, {\n      current_task_id: taskId,\n      status: 'busy',\n    });\n\n    // Notify agents\n    await this.notifyAgentReassignment(fromAgentId, toAgentId, taskId);\n  }\n\n  /**\n   * Notify agents of reassignment\n   */\n  private async notifyAgentReassignment(\n    fromAgentId: string,\n    toAgentId: string,\n    taskId: string,\n  ): Promise<void> {\n    // Notify source agent\n    await this.db.createCommunication({\n      from_agent_id: 'orchestrator',\n      to_agent_id: fromAgentId,\n      swarm_id: this.hiveMind.id,\n      message_type: 'task_reassignment',\n      content: JSON.stringify({ taskId, reassignedTo: toAgentId }),\n      priority: 'high',\n    });\n\n    // Notify target agent\n    const task = await this.db.getTask(taskId);\n    const plan = this.executionPlans.get(taskId);\n\n    await this.db.createCommunication({\n      from_agent_id: 'orchestrator',\n      to_agent_id: toAgentId,\n      swarm_id: this.hiveMind.id,\n      message_type: 'task_assignment',\n      content: JSON.stringify({\n        taskId,\n        task: task.description,\n        executionPlan: plan,\n      }),\n      priority: 'high',\n    });\n  }\n\n  /**\n   * Start task distributor loop\n   */\n  private startTaskDistributor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Check for queued assignments\n        for (const [taskId, assignments] of this.taskAssignments) {\n          for (const assignment of assignments) {\n            const agent = await this.findSuitableAgent(assignment.requiredCapabilities);\n            if (agent) {\n              await this.assignTaskToAgent(taskId, agent.id);\n              // Remove from queue\n              const remaining = assignments.filter((a) => a !== assignment);\n              if (remaining.length === 0) {\n                this.taskAssignments.delete(taskId);\n              } else {\n                this.taskAssignments.set(taskId, remaining);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 5000); // Every 5 seconds\n  }\n\n  /**\n   * Start progress monitor loop\n   */\n  private startProgressMonitor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Monitor active executions\n        for (const [taskId, execution] of this.activeExecutions) {\n          const task = await this.db.getTask(taskId);\n\n          if (task.status === 'in_progress') {\n            const progress = this.calculateProgress(execution);\n\n            if (progress !== task.progress) {\n              await this.db.updateTask(taskId, { progress });\n              this.emit('progressUpdate', { taskId, progress });\n            }\n          }\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 2000); // Every 2 seconds\n  }\n\n  /**\n   * Start load balancer loop\n   */\n  private startLoadBalancer(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        const load = await this.analyzeLoadDistribution();\n\n        // Trigger rebalancing if needed\n        if (\n          load.loadFactor > 0.8 &&\n          load.idleAgents.length > 0 &&\n          load.unassignedTasks.length > 0\n        ) {\n          await this.rebalance();\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 30000); // Every 30 seconds\n  }\n\n  /**\n   * Calculate task progress\n   */\n  private calculateProgress(execution: any): number {\n    if (!execution.plan || !execution.plan.phases) return 0;\n\n    const totalPhases = execution.plan.phases.length;\n    const completedPhases = execution.currentPhase;\n\n    return Math.round((completedPhases / totalPhases) * 100);\n  }\n\n  /**\n   * Shutdown orchestrator\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Cancel all active executions\n    for (const taskId of this.activeExecutions.keys()) {\n      await this.cancelTask(taskId);\n    }\n\n    this.emit('shutdown');\n  }\n}\n"],"names":["EventEmitter","DatabaseManager","MCPToolWrapper","SwarmOrchestrator","hiveMind","db","mcpWrapper","executionPlans","taskAssignments","activeExecutions","isActive","Map","initialize","getInstance","startTaskDistributor","startProgressMonitor","startLoadBalancer","emit","submitTask","task","plan","createExecutionPlan","set","id","orchestrationResult","orchestrateTask","description","priority","strategy","dependencies","success","executeTask","error","getStrategyImplementation","analysis","analyzeTaskComplexity","phases","determinePhases","phaseAssignments","Promise","all","map","phase","createPhaseAssignments","taskId","checkpoints","createCheckpoints","parallelizable","isParallelizable","estimatedDuration","resourceRequirements","execution","startTime","Date","now","currentPhase","phaseResults","status","executeParallel","executeSequential","completeTask","handleTaskFailure","delete","parallelPhases","filter","_","index","some","a","canRunParallel","results","executePhase","i","length","result","push","evaluateCheckpoint","phaseIndex","indexOf","assignments","agentAssignments","assignAgentsToPhase","assignment","executeAssignment","aggregatePhaseResults","agent","findSuitableAgent","requiredCapabilities","assignTaskToAgent","queueAssignment","taskAssignment","assignTask","role","responsibilities","expectedOutput","waitForAgentCompletion","timeout","agentId","getTask","assignedAgents","JSON","parse","assigned_agents","includes","updateTask","stringify","updateAgent","current_task_id","cancelTask","get","notifyAgentTaskCancelled","rebalance","loadDistribution","analyzeLoadDistribution","balanceResult","loadBalance","tasks","unassignedTasks","data","reassignments","applyReassignments","strategies","parallel","maxConcurrency","sequential","adaptive","complexity","requireConsensus","consensus","analyzePattern","action","operation","metadata","requiresConsensus","minAgents","maxAgents","capabilities","executionCount","Math","min","requiredProgress","round","validationCriteria","getValidationCriteria","failureThreshold","criteria","name","weight","planning","validation","agents","getAgents","suitableAgents","every","cap","selectBestAgent","scores","performance","getAgentPerformance","score","successRate","sort","b","resolve","reject","timer","setTimeout","Error","checkCompletion","agentState","getAgent","clearTimeout","clearInterval","interval","setInterval","summary","summarizeResults","timestamp","successful","r","total","totalExecutions","aggregatedData","Boolean","has","checkpoint","phaseResult","criterion","criterionScore","evaluateCriterion","undefined","finalResult","executionTime","createExecutionSummary","progress","completed_at","message","phaseCount","successfulPhases","totalPhases","overallSuccess","createCommunication","from_agent_id","to_agent_id","swarm_id","message_type","content","reason","getActiveTasks","busyAgents","idleAgents","t","totalAgents","activeTasks","required_capabilities","loadFactor","reassignment","reassignTask","fromAgent","toAgent","fromAgentId","toAgentId","notifyAgentReassignment","reassignedTo","executionPlan","remaining","calculateProgress","load","completedPhases","shutdown","keys"],"mappings":"AAOA,SAASA,YAAY,QAAQ,SAAS;AAGtC,SAASC,eAAe,QAAQ,6BAA6B;AAC7D,SAASC,cAAc,QAAQ,sBAAsB;AASrD,OAAO,MAAMC,0BAA0BH;IAC7BI,SAAmB;IACnBC,GAAoB;IACpBC,WAA2B;IAC3BC,eAA2C;IAC3CC,gBAA+C;IAC/CC,iBAAmC;IACnCC,WAAoB,MAAM;IAElC,YAAYN,QAAkB,CAAE;QAC9B,KAAK;QACL,IAAI,CAACA,QAAQ,GAAGA;QAChB,IAAI,CAACG,cAAc,GAAG,IAAII;QAC1B,IAAI,CAACH,eAAe,GAAG,IAAIG;QAC3B,IAAI,CAACF,gBAAgB,GAAG,IAAIE;IAC9B;IAKA,MAAMC,aAA4B;QAChC,IAAI,CAACP,EAAE,GAAG,MAAMJ,gBAAgBY,WAAW;QAC3C,IAAI,CAACP,UAAU,GAAG,IAAIJ;QACtB,MAAM,IAAI,CAACI,UAAU,CAACM,UAAU;QAGhC,IAAI,CAACE,oBAAoB;QACzB,IAAI,CAACC,oBAAoB;QACzB,IAAI,CAACC,iBAAiB;QAEtB,IAAI,CAACN,QAAQ,GAAG;QAChB,IAAI,CAACO,IAAI,CAAC;IACZ;IAKA,MAAMC,WAAWC,IAAU,EAAiB;QAE1C,MAAMC,OAAO,MAAM,IAAI,CAACC,mBAAmB,CAACF;QAC5C,IAAI,CAACZ,cAAc,CAACe,GAAG,CAACH,KAAKI,EAAE,EAAEH;QAGjC,MAAMI,sBAAsB,MAAM,IAAI,CAAClB,UAAU,CAACmB,eAAe,CAAC;YAChEN,MAAMA,KAAKO,WAAW;YACtBC,UAAUR,KAAKQ,QAAQ;YACvBC,UAAUT,KAAKS,QAAQ;YACvBC,cAAcV,KAAKU,YAAY;QACjC;QAEA,IAAIL,oBAAoBM,OAAO,EAAE;YAE/B,MAAM,IAAI,CAACC,WAAW,CAACZ,MAAMC;QAC/B,OAAO;YACL,IAAI,CAACH,IAAI,CAAC,sBAAsB;gBAAEE;gBAAMa,OAAOR,oBAAoBQ,KAAK;YAAC;QAC3E;IACF;IAKA,MAAcX,oBAAoBF,IAAU,EAA0B;QACpE,MAAMS,WAAW,IAAI,CAACK,yBAAyB,CAACd,KAAKS,QAAQ;QAG7D,MAAMM,WAAW,MAAM,IAAI,CAACC,qBAAqB,CAAChB;QAGlD,MAAMiB,SAASR,SAASS,eAAe,CAAClB,MAAMe;QAG9C,MAAMI,mBAAmB,MAAMC,QAAQC,GAAG,CACxCJ,OAAOK,GAAG,CAAC,CAACC,QAAU,IAAI,CAACC,sBAAsB,CAACxB,MAAMuB,OAAOR;QAGjE,OAAO;YACLU,QAAQzB,KAAKI,EAAE;YACfK,UAAUT,KAAKS,QAAQ;YACvBQ;YACAE;YACAT,cAAcV,KAAKU,YAAY;YAC/BgB,aAAa,IAAI,CAACC,iBAAiB,CAACV;YACpCW,gBAAgBnB,SAASoB,gBAAgB,CAAC7B;YAC1C8B,mBAAmBf,SAASe,iBAAiB;YAC7CC,sBAAsBhB,SAASgB,oBAAoB;QACrD;IACF;IAKA,MAAcnB,YAAYZ,IAAU,EAAEC,IAAmB,EAAiB;QACxE,MAAM+B,YAAY;YAChBP,QAAQzB,KAAKI,EAAE;YACfH;YACAgC,WAAWC,KAAKC,GAAG;YACnBC,cAAc;YACdC,cAAc,EAAE;YAChBC,QAAQ;QACV;QAEA,IAAI,CAAChD,gBAAgB,CAACa,GAAG,CAACH,KAAKI,EAAE,EAAE4B;QAEnC,IAAI;YAEF,IAAI/B,KAAK2B,cAAc,EAAE;gBACvB,MAAM,IAAI,CAACW,eAAe,CAACvC,MAAMC,MAAM+B;YACzC,OAAO;gBACL,MAAM,IAAI,CAACQ,iBAAiB,CAACxC,MAAMC,MAAM+B;YAC3C;YAGAA,UAAUM,MAAM,GAAG;YACnB,MAAM,IAAI,CAACG,YAAY,CAACzC,MAAMgC;QAChC,EAAE,OAAOnB,OAAO;YACdmB,UAAUM,MAAM,GAAG;YACnBN,UAAUnB,KAAK,GAAGA;YAClB,MAAM,IAAI,CAAC6B,iBAAiB,CAAC1C,MAAMgC,WAAWnB;QAChD,SAAU;YACR,IAAI,CAACvB,gBAAgB,CAACqD,MAAM,CAAC3C,KAAKI,EAAE;QACtC;IACF;IAKA,MAAcmC,gBAAgBvC,IAAU,EAAEC,IAAmB,EAAE+B,SAAc,EAAiB;QAC5F,MAAMY,iBAAiB3C,KAAKgB,MAAM,CAAC4B,MAAM,CAAC,CAACC,GAAGC,QAC5C9C,KAAKkB,gBAAgB,CAAC4B,MAAM,CAACC,IAAI,CAAC,CAACC,IAAMA,EAAEC,cAAc;QAG3D,MAAMC,UAAU,MAAM/B,QAAQC,GAAG,CAC/BuB,eAAetB,GAAG,CAAC,CAACC,QAAU,IAAI,CAAC6B,YAAY,CAACpD,MAAMuB,OAAOtB,MAAM+B;QAGrEA,UAAUK,YAAY,GAAGc;IAC3B;IAKA,MAAcX,kBAAkBxC,IAAU,EAAEC,IAAmB,EAAE+B,SAAc,EAAiB;QAC9F,IAAK,IAAIqB,IAAI,GAAGA,IAAIpD,KAAKgB,MAAM,CAACqC,MAAM,EAAED,IAAK;YAC3C,MAAM9B,QAAQtB,KAAKgB,MAAM,CAACoC,EAAE;YAC5BrB,UAAUI,YAAY,GAAGiB;YAEzB,MAAME,SAAS,MAAM,IAAI,CAACH,YAAY,CAACpD,MAAMuB,OAAOtB,MAAM+B;YAC1DA,UAAUK,YAAY,CAACmB,IAAI,CAACD;YAG5B,IAAItD,KAAKyB,WAAW,CAAC2B,EAAE,EAAE;gBACvB,MAAM,IAAI,CAACI,kBAAkB,CAACzD,MAAMC,KAAKyB,WAAW,CAAC2B,EAAE,EAAErB;YAC3D;QACF;IACF;IAKA,MAAcoB,aACZpD,IAAU,EACVuB,KAAa,EACbtB,IAAmB,EACnB+B,SAAc,EACA;QACd,MAAM0B,aAAazD,KAAKgB,MAAM,CAAC0C,OAAO,CAACpC;QACvC,MAAMqC,cAAc3D,KAAKkB,gBAAgB,CAACuC,WAAW;QAGrD,MAAMG,mBAAmB,MAAM,IAAI,CAACC,mBAAmB,CAAC9D,MAAMuB,OAAOqC;QAGrE,MAAMvB,eAAe,MAAMjB,QAAQC,GAAG,CACpCwC,iBAAiBvC,GAAG,CAAC,CAACyC,aAAe,IAAI,CAACC,iBAAiB,CAAChE,MAAMuB,OAAOwC;QAI3E,OAAO,IAAI,CAACE,qBAAqB,CAAC1C,OAAOc;IAC3C;IAKA,MAAcyB,oBACZ9D,IAAU,EACVuB,KAAa,EACbqC,WAA6B,EACb;QAChB,MAAMC,mBAAmB,EAAE;QAE3B,KAAK,MAAME,cAAcH,YAAa;YAEpC,MAAMM,QAAQ,MAAM,IAAI,CAACC,iBAAiB,CAACJ,WAAWK,oBAAoB;YAE1E,IAAIF,OAAO;gBACT,MAAM,IAAI,CAACG,iBAAiB,CAACrE,KAAKI,EAAE,EAAE8D,MAAM9D,EAAE;gBAC9CyD,iBAAiBL,IAAI,CAAC;oBACpBU;oBACAH;oBACAxC;gBACF;YACF,OAAO;gBAEL,IAAI,CAAC+C,eAAe,CAACtE,KAAKI,EAAE,EAAE2D;YAChC;QACF;QAEA,OAAOF;IACT;IAKA,MAAcG,kBAAkBhE,IAAU,EAAEuB,KAAa,EAAEwC,UAAe,EAAgB;QACxF,MAAM,EAAEG,KAAK,EAAEH,YAAYQ,cAAc,EAAE,GAAGR;QAG9C,MAAMG,MAAMM,UAAU,CAACxE,KAAKI,EAAE,EAAE;YAC9BmB;YACAkD,MAAMF,eAAeE,IAAI;YACzBC,kBAAkBH,eAAeG,gBAAgB;YACjDC,gBAAgBJ,eAAeI,cAAc;QAC/C;QAGA,OAAO,IAAI,CAACC,sBAAsB,CAACV,OAAOlE,KAAKI,EAAE,EAAEmE,eAAeM,OAAO;IAC3E;IAKA,MAAMR,kBAAkB5C,MAAc,EAAEqD,OAAe,EAAiB;QAEtE,MAAM9E,OAAO,MAAM,IAAI,CAACd,EAAE,CAAC6F,OAAO,CAACtD;QACnC,MAAMuD,iBAAiBC,KAAKC,KAAK,CAAClF,KAAKmF,eAAe,IAAI;QAE1D,IAAI,CAACH,eAAeI,QAAQ,CAACN,UAAU;YACrCE,eAAexB,IAAI,CAACsB;YACpB,MAAM,IAAI,CAAC5F,EAAE,CAACmG,UAAU,CAAC5D,QAAQ;gBAC/B0D,iBAAiBF,KAAKK,SAAS,CAACN;gBAChC1C,QAAQ;YACV;QACF;QAGA,MAAM,IAAI,CAACpD,EAAE,CAACqG,WAAW,CAACT,SAAS;YACjCU,iBAAiB/D;YACjBa,QAAQ;QACV;QAEA,IAAI,CAACxC,IAAI,CAAC,gBAAgB;YAAE2B;YAAQqD;QAAQ;IAC9C;IAKA,MAAMW,WAAWhE,MAAc,EAAiB;QAC9C,MAAMO,YAAY,IAAI,CAAC1C,gBAAgB,CAACoG,GAAG,CAACjE;QAE5C,IAAIO,WAAW;YACbA,UAAUM,MAAM,GAAG;YAGnB,MAAMtC,OAAO,MAAM,IAAI,CAACd,EAAE,CAAC6F,OAAO,CAACtD;YACnC,MAAMuD,iBAAiBC,KAAKC,KAAK,CAAClF,KAAKmF,eAAe,IAAI;YAE1D,KAAK,MAAML,WAAWE,eAAgB;gBACpC,MAAM,IAAI,CAACW,wBAAwB,CAACb,SAASrD;YAC/C;QACF;QAEA,IAAI,CAACnC,gBAAgB,CAACqD,MAAM,CAAClB;QAC7B,IAAI,CAACrC,cAAc,CAACuD,MAAM,CAAClB;QAE3B,IAAI,CAAC3B,IAAI,CAAC,iBAAiB;YAAE2B;QAAO;IACtC;IAKA,MAAMmE,YAA2B;QAE/B,MAAMC,mBAAmB,MAAM,IAAI,CAACC,uBAAuB;QAG3D,MAAMC,gBAAgB,MAAM,IAAI,CAAC5G,UAAU,CAAC6G,WAAW,CAAC;YACtDC,OAAOJ,iBAAiBK,eAAe;QACzC;QAEA,IAAIH,cAAcpF,OAAO,IAAIoF,cAAcI,IAAI,CAACC,aAAa,EAAE;YAC7D,MAAM,IAAI,CAACC,kBAAkB,CAACN,cAAcI,IAAI,CAACC,aAAa;QAChE;QAEA,IAAI,CAACtG,IAAI,CAAC,cAAc;YAAE+F;QAAiB;IAC7C;IAKQ/E,0BAA0BL,QAAsB,EAAO;QAC7D,MAAM6F,aAAa;YACjBC,UAAU;gBACRrF,iBAAiB,CAAClB,OAAe;wBAAC;wBAAe;wBAAsB;qBAAc;gBACrF6B,kBAAkB,IAAM;gBACxB2E,gBAAgB;YAClB;YACAC,YAAY;gBACVvF,iBAAiB,CAAClB,OAAe;wBAAC;wBAAY;wBAAY;wBAAa;qBAAa;gBACpF6B,kBAAkB,IAAM;gBACxB2E,gBAAgB;YAClB;YACAE,UAAU;gBACRxF,iBAAiB,CAAClB,MAAYe;oBAC5B,IAAIA,SAAS4F,UAAU,KAAK,QAAQ;wBAClC,OAAO;4BAAC;4BAAiB;4BAAY;4BAAoB;4BAAe;yBAAa;oBACvF;oBACA,OAAO;wBAAC;wBAAkB;wBAAa;qBAAa;gBACtD;gBACA9E,kBAAkB,CAAC7B,OAAe,CAACA,KAAK4G,gBAAgB;gBACxDJ,gBAAgB;YAClB;YACAK,WAAW;gBACT3F,iBAAiB,IAAM;wBAAC;wBAAY;wBAAc;wBAAU;wBAAa;qBAAe;gBACxFW,kBAAkB,IAAM;gBACxB2E,gBAAgB;YAClB;QACF;QAEA,OAAOF,UAAU,CAAC7F,SAAS,IAAI6F,WAAWI,QAAQ;IACpD;IAKA,MAAc1F,sBAAsBhB,IAAU,EAAgB;QAC5D,MAAMe,WAAW,MAAM,IAAI,CAAC5B,UAAU,CAAC2H,cAAc,CAAC;YACpDC,QAAQ;YACRC,WAAW;YACXC,UAAU;gBACR1G,aAAaP,KAAKO,WAAW;gBAC7BC,UAAUR,KAAKQ,QAAQ;gBACvBE,cAAcV,KAAKU,YAAY,CAAC4C,MAAM;gBACtC4D,mBAAmBlH,KAAK4G,gBAAgB;YAC1C;QACF;QAEA,OAAO;YACLD,YAAY5F,SAASoF,IAAI,EAAEQ,cAAc;YACzC7E,mBAAmBf,SAASoF,IAAI,EAAErE,qBAAqB;YACvDC,sBAAsBhB,SAASoF,IAAI,EAAEpE,wBAAwB;gBAC3DoF,WAAW;gBACXC,WAAWpH,KAAKoH,SAAS;gBACzBC,cAAcrH,KAAKoE,oBAAoB;YACzC;QACF;IACF;IAKA,MAAc5C,uBACZxB,IAAU,EACVuB,KAAa,EACbR,QAAa,EACc;QAC3B,MAAM6C,cAAgC,EAAE;QAGxC,OAAQrC;YACN,KAAK;YACL,KAAK;gBACHqC,YAAYJ,IAAI,CAAC;oBACfiB,MAAM;oBACNL,sBAAsB;wBAAC;wBAAiB;qBAAsB;oBAC9DM,kBAAkB;wBAAC;wBAA6B;wBAAqB;qBAAoB;oBACzFC,gBAAgB;oBAChBE,SAAS;oBACT3B,gBAAgB;gBAClB;gBACA;YAEF,KAAK;gBACHU,YAAYJ,IAAI,CAAC;oBACfiB,MAAM;oBACNL,sBAAsB;wBAAC;wBAAiB;qBAAwB;oBAChEM,kBAAkB;wBAAC;wBAAmB;wBAA8B;qBAAoB;oBACxFC,gBAAgB;oBAChBE,SAAS;oBACT3B,gBAAgB;gBAClB;gBACA;YAEF,KAAK;YACL,KAAK;gBAEH,MAAMoE,iBAAiBC,KAAKC,GAAG,CAACzG,SAASgB,oBAAoB,CAACqF,SAAS,EAAE;gBACzE,IAAK,IAAI/D,IAAI,GAAGA,IAAIiE,gBAAgBjE,IAAK;oBACvCO,YAAYJ,IAAI,CAAC;wBACfiB,MAAM;wBACNL,sBAAsBpE,KAAKoE,oBAAoB;wBAC/CM,kBAAkB;4BAAC;4BAAsB;4BAAgB;yBAAgB;wBACzEC,gBAAgB;wBAChBE,SAAS;wBACT3B,gBAAgB;oBAClB;gBACF;gBACA;YAEF,KAAK;gBACHU,YAAYJ,IAAI,CAAC;oBACfiB,MAAM;oBACNL,sBAAsB;wBAAC;wBAAqB;qBAAkB;oBAC9DM,kBAAkB;wBAAC;wBAAoB;wBAAa;qBAAiB;oBACrEC,gBAAgB;oBAChBE,SAAS;oBACT3B,gBAAgB;gBAClB;gBACA;YAEF,KAAK;YACL,KAAK;gBACHU,YAAYJ,IAAI,CAAC;oBACfiB,MAAM;oBACNL,sBAAsB;wBAAC;qBAAqB;oBAC5CM,kBAAkB;wBAAC;wBAAqB;wBAAoB;qBAAsB;oBAClFC,gBAAgB;oBAChBE,SAAS;oBACT3B,gBAAgB;gBAClB;gBACA;QACJ;QAEA,OAAOU;IACT;IAKQjC,kBAAkBV,MAAgB,EAAS;QACjD,OAAOA,OAAOK,GAAG,CAAC,CAACC,OAAOwB,QAAW,CAAA;gBACnCxB;gBACAwB;gBACA0E,kBAAkBF,KAAKG,KAAK,CAAC,AAAE3E,CAAAA,QAAQ,CAAA,IAAK9B,OAAOqC,MAAM,GAAI;gBAC7DqE,oBAAoB,IAAI,CAACC,qBAAqB,CAACrG;gBAC/CsG,kBAAkB;YACpB,CAAA;IACF;IAKQD,sBAAsBrG,KAAa,EAAS;QAClD,MAAMuG,WAAkC;YACtC/G,UAAU;gBACR;oBAAEgH,MAAM;oBAAgBC,QAAQ;gBAAI;gBACpC;oBAAED,MAAM;oBAAYC,QAAQ;gBAAI;aACjC;YACDC,UAAU;gBACR;oBAAEF,MAAM;oBAAeC,QAAQ;gBAAI;gBACnC;oBAAED,MAAM;oBAAgBC,QAAQ;gBAAI;aACrC;YACDhG,WAAW;gBACT;oBAAE+F,MAAM;oBAAeC,QAAQ;gBAAI;gBACnC;oBAAED,MAAM;oBAAeC,QAAQ;gBAAI;aACpC;YACDE,YAAY;gBACV;oBAAEH,MAAM;oBAAiBC,QAAQ;gBAAI;gBACrC;oBAAED,MAAM;oBAAiBC,QAAQ;gBAAI;aACtC;QACH;QAEA,OAAOF,QAAQ,CAACvG,MAAM,IAAI;YAAC;gBAAEwG,MAAM;gBAAcC,QAAQ;YAAI;SAAE;IACjE;IAKA,MAAc7D,kBAAkBC,oBAA8B,EAAyB;QACrF,MAAM+D,SAAS,MAAM,IAAI,CAAClJ,QAAQ,CAACmJ,SAAS;QAG5C,MAAMC,iBAAiBF,OAAOtF,MAAM,CAClC,CAACqB,QACCA,MAAM5B,MAAM,KAAK,UACjB8B,qBAAqBkE,KAAK,CAAC,CAACC,MAAQrE,MAAMmD,YAAY,CAACjC,QAAQ,CAACmD;QAGpE,IAAIF,eAAe/E,MAAM,KAAK,GAAG;YAC/B,OAAO;QACT;QAGA,OAAO,IAAI,CAACkF,eAAe,CAACH,gBAAgBjE;IAC9C;IAKA,MAAcoE,gBAAgBL,MAAe,EAAEd,YAAsB,EAAkB;QAErF,MAAMoB,SAAS,MAAMrH,QAAQC,GAAG,CAC9B8G,OAAO7G,GAAG,CAAC,OAAO4C;YAChB,MAAMwE,cAAc,MAAM,IAAI,CAACxJ,EAAE,CAACyJ,mBAAmB,CAACzE,MAAM9D,EAAE;YAC9D,OAAO;gBACL8D;gBACA0E,OAAOF,aAAaG,eAAe;YACrC;QACF;QAGFJ,OAAOK,IAAI,CAAC,CAAC7F,GAAG8F,IAAMA,EAAEH,KAAK,GAAG3F,EAAE2F,KAAK;QACvC,OAAOH,MAAM,CAAC,EAAE,CAACvE,KAAK;IACxB;IAKA,MAAcU,uBACZV,KAAY,EACZzC,MAAc,EACdoD,OAAe,EACD;QACd,OAAO,IAAIzD,QAAQ,CAAC4H,SAASC;YAC3B,MAAMC,QAAQC,WAAW;gBACvBF,OAAO,IAAIG,MAAM,CAAC,MAAM,EAAElF,MAAM9D,EAAE,CAAC,iBAAiB,EAAEqB,QAAQ;YAChE,GAAGoD;YAEH,MAAMwE,kBAAkB;gBACtB,MAAMC,aAAa,MAAM,IAAI,CAACpK,EAAE,CAACqK,QAAQ,CAACrF,MAAM9D,EAAE;gBAElD,IAAIkJ,WAAW9D,eAAe,KAAK/D,QAAQ;oBACzC+H,aAAaN;oBACbO,cAAcC;oBAGd,MAAM1J,OAAO,MAAM,IAAI,CAACd,EAAE,CAAC6F,OAAO,CAACtD;oBACnCuH,QAAQhJ,KAAKuD,MAAM,GAAG0B,KAAKC,KAAK,CAAClF,KAAKuD,MAAM,IAAI,CAAC;gBACnD;YACF;YAEA,MAAMmG,WAAWC,YAAYN,iBAAiB;QAChD;IACF;IAKQpF,sBAAsB1C,KAAa,EAAE4B,OAAc,EAAO;QAChE,OAAO;YACL5B;YACA4B;YACAyG,SAAS,IAAI,CAACC,gBAAgB,CAAC1G;YAC/B2G,WAAW,IAAI5H;QACjB;IACF;IAKQ2H,iBAAiB1G,OAAc,EAAO;QAC5C,MAAM4G,aAAa5G,QAAQN,MAAM,CAAC,CAACmH,IAAMA,EAAErJ,OAAO,EAAE2C,MAAM;QAC1D,MAAM2G,QAAQ9G,QAAQG,MAAM;QAE5B,OAAO;YACLuF,aAAaoB,QAAQ,IAAIF,aAAaE,QAAQ;YAC9CC,iBAAiBD;YACjBE,gBAAgBhH,QAAQ7B,GAAG,CAAC,CAAC0I,IAAMA,EAAE7D,IAAI,EAAEtD,MAAM,CAACuH;QACpD;IACF;IAKQ9F,gBAAgB7C,MAAc,EAAEsC,UAA0B,EAAQ;QACxE,IAAI,CAAC,IAAI,CAAC1E,eAAe,CAACgL,GAAG,CAAC5I,SAAS;YACrC,IAAI,CAACpC,eAAe,CAACc,GAAG,CAACsB,QAAQ,EAAE;QACrC;QAEA,IAAI,CAACpC,eAAe,CAACqG,GAAG,CAACjE,QAAS+B,IAAI,CAACO;QACvC,IAAI,CAACjE,IAAI,CAAC,oBAAoB;YAAE2B;YAAQsC;QAAW;IACrD;IAKA,MAAcN,mBAAmBzD,IAAU,EAAEsK,UAAe,EAAEtI,SAAc,EAAiB;QAC3F,MAAMuI,cAAcvI,UAAUK,YAAY,CAACiI,WAAWvH,KAAK,CAAC;QAE5D,IAAI,CAACwH,aAAa;QAElB,IAAI3B,QAAQ;QACZ,KAAK,MAAM4B,aAAaF,WAAW3C,kBAAkB,CAAE;YACrD,MAAM8C,iBAAiB,IAAI,CAACC,iBAAiB,CAACH,aAAaC;YAC3D5B,SAAS6B,iBAAiBD,UAAUxC,MAAM;QAC5C;QAEA,IAAIY,QAAQ0B,WAAWzC,gBAAgB,EAAE;YACvC,MAAM,IAAIuB,MAAM,CAAC,2BAA2B,EAAEkB,WAAW/I,KAAK,CAAC,QAAQ,EAAEqH,OAAO;QAClF;QAEA,IAAI,CAAC9I,IAAI,CAAC,oBAAoB;YAAEE;YAAMsK;YAAY1B;QAAM;IAC1D;IAKQ8B,kBAAkBnH,MAAW,EAAEiH,SAAc,EAAU;QAE7D,IAAIjH,OAAOqG,OAAO,IAAIrG,OAAOqG,OAAO,CAACf,WAAW,KAAK8B,WAAW;YAC9D,OAAOpH,OAAOqG,OAAO,CAACf,WAAW;QACnC;QACA,OAAO;IACT;IAKA,MAAcpG,aAAazC,IAAU,EAAEgC,SAAc,EAAiB;QACpE,MAAM4I,cAAc;YAClBjK,SAAS;YACTkK,eAAe3I,KAAKC,GAAG,KAAKH,UAAUC,SAAS;YAC/ChB,QAAQe,UAAUK,YAAY;YAC9BuH,SAAS,IAAI,CAACkB,sBAAsB,CAAC9I;QACvC;QAEA,MAAM,IAAI,CAAC9C,EAAE,CAACmG,UAAU,CAACrF,KAAKI,EAAE,EAAE;YAChCkC,QAAQ;YACRiB,QAAQ0B,KAAKK,SAAS,CAACsF;YACvBG,UAAU;YACVC,cAAc,IAAI9I;QACpB;QAEA,IAAI,CAACpC,IAAI,CAAC,iBAAiB;YAAEE;YAAMuD,QAAQqH;QAAY;IACzD;IAKA,MAAclI,kBAAkB1C,IAAU,EAAEgC,SAAc,EAAEnB,KAAU,EAAiB;QACrF,MAAM,IAAI,CAAC3B,EAAE,CAACmG,UAAU,CAACrF,KAAKI,EAAE,EAAE;YAChCkC,QAAQ;YACRzB,OAAOA,MAAMoK,OAAO;YACpBD,cAAc,IAAI9I;QACpB;QAEA,IAAI,CAACpC,IAAI,CAAC,cAAc;YAAEE;YAAMa;QAAM;IACxC;IAKQiK,uBAAuB9I,SAAc,EAAO;QAClD,MAAMkJ,aAAalJ,UAAUK,YAAY,CAACiB,MAAM;QAChD,MAAM6H,mBAAmBnJ,UAAUK,YAAY,CAACQ,MAAM,CACpD,CAACmH,IAAMA,EAAEJ,OAAO,EAAEf,cAAc,KAChCvF,MAAM;QAER,OAAO;YACL8H,aAAaF;YACbC;YACAE,gBAAgBH,aAAa,IAAIC,mBAAmBD,aAAa;YACjEL,eAAe3I,KAAKC,GAAG,KAAKH,UAAUC,SAAS;QACjD;IACF;IAKA,MAAc0D,yBAAyBb,OAAe,EAAErD,MAAc,EAAiB;QAErF,MAAM,IAAI,CAACvC,EAAE,CAACoM,mBAAmB,CAAC;YAChCC,eAAe;YACfC,aAAa1G;YACb2G,UAAU,IAAI,CAACxM,QAAQ,CAACmB,EAAE;YAC1BsL,cAAc;YACdC,SAAS1G,KAAKK,SAAS,CAAC;gBAAE7D;gBAAQmK,QAAQ;YAAiB;YAC3DpL,UAAU;QACZ;IACF;IAKA,MAAcsF,0BAAwC;QACpD,MAAMqC,SAAS,MAAM,IAAI,CAAClJ,QAAQ,CAACmJ,SAAS;QAC5C,MAAMnC,QAAQ,MAAM,IAAI,CAAC/G,EAAE,CAAC2M,cAAc,CAAC,IAAI,CAAC5M,QAAQ,CAACmB,EAAE;QAE3D,MAAM0L,aAAa3D,OAAOtF,MAAM,CAAC,CAACI,IAAMA,EAAEX,MAAM,KAAK;QACrD,MAAMyJ,aAAa5D,OAAOtF,MAAM,CAAC,CAACI,IAAMA,EAAEX,MAAM,KAAK;QACrD,MAAM4D,kBAAkBD,MAAMpD,MAAM,CAClC,CAACmJ,IAAM,CAACA,EAAE7G,eAAe,IAAIF,KAAKC,KAAK,CAAC8G,EAAE7G,eAAe,EAAE7B,MAAM,KAAK;QAGxE,OAAO;YACL2I,aAAa9D,OAAO7E,MAAM;YAC1BwI,YAAYA,WAAWxI,MAAM;YAC7ByI,YAAYA,WAAWzI,MAAM;YAC7B4I,aAAajG,MAAM3C,MAAM;YACzB4C,iBAAiBA,gBAAgB5E,GAAG,CAAC,CAAC0K,IAAO,CAAA;oBAC3C5L,IAAI4L,EAAE5L,EAAE;oBACRI,UAAUwL,EAAExL,QAAQ;oBACpB4D,sBAAsBa,KAAKC,KAAK,CAAC8G,EAAEG,qBAAqB,IAAI;gBAC9D,CAAA;YACAC,YAAYjE,OAAO7E,MAAM,GAAG,IAAIwI,WAAWxI,MAAM,GAAG6E,OAAO7E,MAAM,GAAG;QACtE;IACF;IAKA,MAAc+C,mBAAmBD,aAAoB,EAAiB;QACpE,KAAK,MAAMiG,gBAAgBjG,cAAe;YACxC,MAAM,IAAI,CAACkG,YAAY,CAACD,aAAa5K,MAAM,EAAE4K,aAAaE,SAAS,EAAEF,aAAaG,OAAO;QAC3F;IACF;IAKA,MAAcF,aACZ7K,MAAc,EACdgL,WAAmB,EACnBC,SAAiB,EACF;QAEf,MAAM,IAAI,CAACxN,EAAE,CAACoN,YAAY,CAAC7K,QAAQiL;QAGnC,MAAM,IAAI,CAACxN,EAAE,CAACqG,WAAW,CAACkH,aAAa;YACrCjH,iBAAiB;YACjBlD,QAAQ;QACV;QAEA,MAAM,IAAI,CAACpD,EAAE,CAACqG,WAAW,CAACmH,WAAW;YACnClH,iBAAiB/D;YACjBa,QAAQ;QACV;QAGA,MAAM,IAAI,CAACqK,uBAAuB,CAACF,aAAaC,WAAWjL;IAC7D;IAKA,MAAckL,wBACZF,WAAmB,EACnBC,SAAiB,EACjBjL,MAAc,EACC;QAEf,MAAM,IAAI,CAACvC,EAAE,CAACoM,mBAAmB,CAAC;YAChCC,eAAe;YACfC,aAAaiB;YACbhB,UAAU,IAAI,CAACxM,QAAQ,CAACmB,EAAE;YAC1BsL,cAAc;YACdC,SAAS1G,KAAKK,SAAS,CAAC;gBAAE7D;gBAAQmL,cAAcF;YAAU;YAC1DlM,UAAU;QACZ;QAGA,MAAMR,OAAO,MAAM,IAAI,CAACd,EAAE,CAAC6F,OAAO,CAACtD;QACnC,MAAMxB,OAAO,IAAI,CAACb,cAAc,CAACsG,GAAG,CAACjE;QAErC,MAAM,IAAI,CAACvC,EAAE,CAACoM,mBAAmB,CAAC;YAChCC,eAAe;YACfC,aAAakB;YACbjB,UAAU,IAAI,CAACxM,QAAQ,CAACmB,EAAE;YAC1BsL,cAAc;YACdC,SAAS1G,KAAKK,SAAS,CAAC;gBACtB7D;gBACAzB,MAAMA,KAAKO,WAAW;gBACtBsM,eAAe5M;YACjB;YACAO,UAAU;QACZ;IACF;IAKQb,uBAA6B;QACnCgK,YAAY;YACV,IAAI,CAAC,IAAI,CAACpK,QAAQ,EAAE;YAEpB,IAAI;gBAEF,KAAK,MAAM,CAACkC,QAAQmC,YAAY,IAAI,IAAI,CAACvE,eAAe,CAAE;oBACxD,KAAK,MAAM0E,cAAcH,YAAa;wBACpC,MAAMM,QAAQ,MAAM,IAAI,CAACC,iBAAiB,CAACJ,WAAWK,oBAAoB;wBAC1E,IAAIF,OAAO;4BACT,MAAM,IAAI,CAACG,iBAAiB,CAAC5C,QAAQyC,MAAM9D,EAAE;4BAE7C,MAAM0M,YAAYlJ,YAAYf,MAAM,CAAC,CAACI,IAAMA,MAAMc;4BAClD,IAAI+I,UAAUxJ,MAAM,KAAK,GAAG;gCAC1B,IAAI,CAACjE,eAAe,CAACsD,MAAM,CAAClB;4BAC9B,OAAO;gCACL,IAAI,CAACpC,eAAe,CAACc,GAAG,CAACsB,QAAQqL;4BACnC;wBACF;oBACF;gBACF;YACF,EAAE,OAAOjM,OAAO;gBACd,IAAI,CAACf,IAAI,CAAC,SAASe;YACrB;QACF,GAAG;IACL;IAKQjB,uBAA6B;QACnC+J,YAAY;YACV,IAAI,CAAC,IAAI,CAACpK,QAAQ,EAAE;YAEpB,IAAI;gBAEF,KAAK,MAAM,CAACkC,QAAQO,UAAU,IAAI,IAAI,CAAC1C,gBAAgB,CAAE;oBACvD,MAAMU,OAAO,MAAM,IAAI,CAACd,EAAE,CAAC6F,OAAO,CAACtD;oBAEnC,IAAIzB,KAAKsC,MAAM,KAAK,eAAe;wBACjC,MAAMyI,WAAW,IAAI,CAACgC,iBAAiB,CAAC/K;wBAExC,IAAI+I,aAAa/K,KAAK+K,QAAQ,EAAE;4BAC9B,MAAM,IAAI,CAAC7L,EAAE,CAACmG,UAAU,CAAC5D,QAAQ;gCAAEsJ;4BAAS;4BAC5C,IAAI,CAACjL,IAAI,CAAC,kBAAkB;gCAAE2B;gCAAQsJ;4BAAS;wBACjD;oBACF;gBACF;YACF,EAAE,OAAOlK,OAAO;gBACd,IAAI,CAACf,IAAI,CAAC,SAASe;YACrB;QACF,GAAG;IACL;IAKQhB,oBAA0B;QAChC8J,YAAY;YACV,IAAI,CAAC,IAAI,CAACpK,QAAQ,EAAE;YAEpB,IAAI;gBACF,MAAMyN,OAAO,MAAM,IAAI,CAAClH,uBAAuB;gBAG/C,IACEkH,KAAKZ,UAAU,GAAG,OAClBY,KAAKjB,UAAU,CAACzI,MAAM,GAAG,KACzB0J,KAAK9G,eAAe,CAAC5C,MAAM,GAAG,GAC9B;oBACA,MAAM,IAAI,CAACsC,SAAS;gBACtB;YACF,EAAE,OAAO/E,OAAO;gBACd,IAAI,CAACf,IAAI,CAAC,SAASe;YACrB;QACF,GAAG;IACL;IAKQkM,kBAAkB/K,SAAc,EAAU;QAChD,IAAI,CAACA,UAAU/B,IAAI,IAAI,CAAC+B,UAAU/B,IAAI,CAACgB,MAAM,EAAE,OAAO;QAEtD,MAAMmK,cAAcpJ,UAAU/B,IAAI,CAACgB,MAAM,CAACqC,MAAM;QAChD,MAAM2J,kBAAkBjL,UAAUI,YAAY;QAE9C,OAAOmF,KAAKG,KAAK,CAAC,AAACuF,kBAAkB7B,cAAe;IACtD;IAKA,MAAM8B,WAA0B;QAC9B,IAAI,CAAC3N,QAAQ,GAAG;QAGhB,KAAK,MAAMkC,UAAU,IAAI,CAACnC,gBAAgB,CAAC6N,IAAI,GAAI;YACjD,MAAM,IAAI,CAAC1H,UAAU,CAAChE;QACxB;QAEA,IAAI,CAAC3B,IAAI,CAAC;IACZ;AACF"}