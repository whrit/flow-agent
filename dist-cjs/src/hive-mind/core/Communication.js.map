{"version":3,"sources":["../../../../src/hive-mind/core/Communication.ts"],"sourcesContent":["/**\n * Communication Class\n *\n * Manages inter-agent messaging, broadcasts, and communication protocols\n * within the Hive Mind swarm.\n */\n\nimport { EventEmitter } from 'events';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { Agent } from './Agent.js';\nimport {\n  Message,\n  MessageType,\n  MessagePriority,\n  CommunicationStats,\n  CommunicationChannel,\n} from '../types.js';\n\nexport class Communication extends EventEmitter {\n  private swarmId: string;\n  private db: DatabaseManager;\n  private agents: Map<string, Agent>;\n  private channels: Map<string, CommunicationChannel>;\n  private messageQueue: Map<MessagePriority, Message[]>;\n  private stats: CommunicationStats;\n  private isActive: boolean = false;\n\n  constructor(swarmId: string) {\n    super();\n    this.swarmId = swarmId;\n    this.agents = new Map();\n    this.channels = new Map();\n    this.messageQueue = new Map([\n      ['urgent', []],\n      ['high', []],\n      ['normal', []],\n      ['low', []],\n    ]);\n\n    this.stats = {\n      totalMessages: 0,\n      avgLatency: 0,\n      activeChannels: 0,\n      messagesByType: {},\n      throughput: 0,\n    };\n  }\n\n  /**\n   * Initialize communication system\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n\n    // Set up default channels\n    this.setupDefaultChannels();\n\n    // Start message processing\n    this.startMessageProcessor();\n    this.startLatencyMonitor();\n    this.startStatsCollector();\n\n    this.isActive = true;\n    this.emit('initialized');\n  }\n\n  /**\n   * Add an agent to the communication network\n   */\n  addAgent(agent: Agent): void {\n    this.agents.set(agent.id, agent);\n\n    // Create agent-specific channels\n    this.createAgentChannels(agent);\n\n    // Subscribe agent to relevant channels\n    this.subscribeAgentToChannels(agent);\n\n    this.emit('agentAdded', { agentId: agent.id });\n  }\n\n  /**\n   * Remove an agent from the communication network\n   */\n  removeAgent(agentId: string): void {\n    this.agents.delete(agentId);\n\n    // Remove agent from channels\n    this.channels.forEach((channel) => {\n      channel.subscribers = channel.subscribers.filter((id) => id !== agentId);\n    });\n\n    this.emit('agentRemoved', { agentId });\n  }\n\n  /**\n   * Send a message\n   */\n  async sendMessage(message: Message): Promise<void> {\n    // Store in database\n    await this.db.createCommunication({\n      from_agent_id: message.fromAgentId,\n      to_agent_id: message.toAgentId,\n      swarm_id: this.swarmId,\n      message_type: message.type,\n      content: JSON.stringify(message.content),\n      priority: message.priority || 'normal',\n      requires_response: message.requiresResponse || false,\n    });\n\n    // Add to queue\n    const priority = message.priority || 'normal';\n    this.messageQueue.get(priority)!.push(message);\n\n    // Update stats\n    this.stats.totalMessages++;\n    this.stats.messagesByType[message.type] = (this.stats.messagesByType[message.type] || 0) + 1;\n\n    this.emit('messageSent', message);\n  }\n\n  /**\n   * Broadcast a message to all agents\n   */\n  async broadcast(\n    fromAgentId: string,\n    type: MessageType,\n    content: any,\n    priority: MessagePriority = 'normal',\n  ): Promise<void> {\n    const message: Message = {\n      id: this.generateMessageId(),\n      fromAgentId,\n      toAgentId: null, // null indicates broadcast\n      swarmId: this.swarmId,\n      type,\n      content,\n      priority,\n      timestamp: new Date(),\n      requiresResponse: false,\n    };\n\n    await this.sendMessage(message);\n  }\n\n  /**\n   * Send a message to a specific channel\n   */\n  async sendToChannel(\n    channelName: string,\n    fromAgentId: string,\n    content: any,\n    priority: MessagePriority = 'normal',\n  ): Promise<void> {\n    const channel = this.channels.get(channelName);\n    if (!channel) {\n      throw new Error(`Channel ${channelName} not found`);\n    }\n\n    // Send to all subscribers\n    for (const subscriberId of channel.subscribers) {\n      if (subscriberId !== fromAgentId) {\n        const message: Message = {\n          id: this.generateMessageId(),\n          fromAgentId,\n          toAgentId: subscriberId,\n          swarmId: this.swarmId,\n          type: 'channel',\n          content: {\n            channel: channelName,\n            data: content,\n          },\n          priority,\n          timestamp: new Date(),\n          requiresResponse: false,\n        };\n\n        await this.sendMessage(message);\n      }\n    }\n  }\n\n  /**\n   * Request response from an agent\n   */\n  async requestResponse(\n    fromAgentId: string,\n    toAgentId: string,\n    query: any,\n    timeout: number = 5000,\n  ): Promise<any> {\n    const message: Message = {\n      id: this.generateMessageId(),\n      fromAgentId,\n      toAgentId,\n      swarmId: this.swarmId,\n      type: 'query',\n      content: query,\n      priority: 'high',\n      timestamp: new Date(),\n      requiresResponse: true,\n    };\n\n    await this.sendMessage(message);\n\n    // Wait for response\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error('Response timeout'));\n      }, timeout);\n\n      const responseHandler = (response: Message) => {\n        if (response.content.queryId === message.id) {\n          clearTimeout(timer);\n          this.off('messageReceived', responseHandler);\n          resolve(response.content.response);\n        }\n      };\n\n      this.on('messageReceived', responseHandler);\n    });\n  }\n\n  /**\n   * Create a new communication channel\n   */\n  createChannel(name: string, description: string, type: 'public' | 'private' = 'public'): void {\n    if (this.channels.has(name)) {\n      throw new Error(`Channel ${name} already exists`);\n    }\n\n    const channel: CommunicationChannel = {\n      name,\n      description,\n      type,\n      subscribers: [],\n      createdAt: new Date(),\n    };\n\n    this.channels.set(name, channel);\n    this.stats.activeChannels++;\n\n    this.emit('channelCreated', { channel });\n  }\n\n  /**\n   * Subscribe an agent to a channel\n   */\n  subscribeToChannel(agentId: string, channelName: string): void {\n    const channel = this.channels.get(channelName);\n    if (!channel) {\n      throw new Error(`Channel ${channelName} not found`);\n    }\n\n    if (!channel.subscribers.includes(agentId)) {\n      channel.subscribers.push(agentId);\n      this.emit('channelSubscribed', { agentId, channelName });\n    }\n  }\n\n  /**\n   * Unsubscribe an agent from a channel\n   */\n  unsubscribeFromChannel(agentId: string, channelName: string): void {\n    const channel = this.channels.get(channelName);\n    if (!channel) {\n      return;\n    }\n\n    channel.subscribers = channel.subscribers.filter((id) => id !== agentId);\n    this.emit('channelUnsubscribed', { agentId, channelName });\n  }\n\n  /**\n   * Get communication statistics\n   */\n  async getStats(): Promise<CommunicationStats> {\n    // Calculate throughput\n    const recentMessages = await this.db.getRecentMessages(this.swarmId, 60000); // Last minute\n    this.stats.throughput = recentMessages.length;\n\n    return { ...this.stats };\n  }\n\n  /**\n   * Get pending messages for an agent\n   */\n  async getPendingMessages(agentId: string): Promise<Message[]> {\n    const messages = await this.db.getPendingMessages(agentId);\n\n    return messages.map((msg) => ({\n      id: msg.id.toString(),\n      fromAgentId: msg.from_agent_id,\n      toAgentId: msg.to_agent_id,\n      swarmId: msg.swarm_id,\n      type: msg.message_type as MessageType,\n      content: JSON.parse(msg.content),\n      priority: msg.priority as MessagePriority,\n      timestamp: new Date(msg.timestamp),\n      requiresResponse: msg.requires_response,\n    }));\n  }\n\n  /**\n   * Mark message as delivered\n   */\n  async markDelivered(messageId: string): Promise<void> {\n    await this.db.markMessageDelivered(messageId);\n  }\n\n  /**\n   * Mark message as read\n   */\n  async markRead(messageId: string): Promise<void> {\n    await this.db.markMessageRead(messageId);\n  }\n\n  /**\n   * Setup default communication channels\n   */\n  private setupDefaultChannels(): void {\n    // System channels\n    this.createChannel('system', 'System-wide notifications and alerts');\n    this.createChannel('coordination', 'Task coordination messages');\n    this.createChannel('consensus', 'Consensus voting and decisions');\n    this.createChannel('monitoring', 'Performance and health monitoring');\n\n    // Agent type channels\n    this.createChannel('coordinators', 'Coordinator agent communications');\n    this.createChannel('researchers', 'Researcher agent communications');\n    this.createChannel('coders', 'Coder agent communications');\n    this.createChannel('analysts', 'Analyst agent communications');\n  }\n\n  /**\n   * Create channels for a specific agent\n   */\n  private createAgentChannels(agent: Agent): void {\n    // Direct message channel\n    this.createChannel(`agent-${agent.id}`, `Direct messages for ${agent.name}`, 'private');\n\n    // Team channel if agent is coordinator\n    if (agent.type === 'coordinator') {\n      this.createChannel(`team-${agent.id}`, `Team channel led by ${agent.name}`);\n    }\n  }\n\n  /**\n   * Subscribe agent to relevant channels\n   */\n  private subscribeAgentToChannels(agent: Agent): void {\n    // Subscribe to system channels\n    this.subscribeToChannel(agent.id, 'system');\n    this.subscribeToChannel(agent.id, 'coordination');\n\n    // Subscribe to type-specific channel\n    const typeChannel = `${agent.type}s`;\n    if (this.channels.has(typeChannel)) {\n      this.subscribeToChannel(agent.id, typeChannel);\n    }\n\n    // Subscribe to own direct channel\n    this.subscribeToChannel(agent.id, `agent-${agent.id}`);\n\n    // Special subscriptions based on capabilities\n    if (agent.capabilities.includes('consensus_building')) {\n      this.subscribeToChannel(agent.id, 'consensus');\n    }\n\n    if (agent.capabilities.includes('system_monitoring')) {\n      this.subscribeToChannel(agent.id, 'monitoring');\n    }\n  }\n\n  /**\n   * Start message processor\n   */\n  private startMessageProcessor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Process messages by priority\n      for (const [priority, messages] of this.messageQueue) {\n        if (messages.length === 0) continue;\n\n        // Process batch of messages\n        const batch = messages.splice(0, 10); // Process up to 10 messages\n\n        for (const message of batch) {\n          await this.processMessage(message);\n        }\n      }\n    }, 100); // Every 100ms\n  }\n\n  /**\n   * Process a single message\n   */\n  private async processMessage(message: Message): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      if (message.toAgentId) {\n        // Direct message\n        const agent = this.agents.get(message.toAgentId);\n        if (agent) {\n          await agent.receiveMessage(message);\n          await this.markDelivered(message.id);\n        }\n      } else {\n        // Broadcast message\n        for (const agent of this.agents.values()) {\n          if (agent.id !== message.fromAgentId) {\n            await agent.receiveMessage(message);\n          }\n        }\n      }\n\n      // Update latency stats\n      const latency = Date.now() - startTime;\n      this.updateLatencyStats(latency);\n\n      this.emit('messageProcessed', { message, latency });\n    } catch (error) {\n      this.emit('messageError', { message, error });\n    }\n  }\n\n  /**\n   * Update latency statistics\n   */\n  private updateLatencyStats(latency: number): void {\n    // Simple moving average\n    this.stats.avgLatency = this.stats.avgLatency * 0.9 + latency * 0.1;\n  }\n\n  /**\n   * Start latency monitor\n   */\n  private startLatencyMonitor(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Check for high latency\n      if (this.stats.avgLatency > 1000) {\n        this.emit('highLatency', { avgLatency: this.stats.avgLatency });\n      }\n    }, 5000); // Every 5 seconds\n  }\n\n  /**\n   * Start statistics collector\n   */\n  private startStatsCollector(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Store stats in database\n      await this.db.storePerformanceMetric({\n        swarm_id: this.swarmId,\n        metric_type: 'communication_throughput',\n        metric_value: this.stats.throughput,\n      });\n\n      await this.db.storePerformanceMetric({\n        swarm_id: this.swarmId,\n        metric_type: 'communication_latency',\n        metric_value: this.stats.avgLatency,\n      });\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Generate unique message ID\n   */\n  private generateMessageId(): string {\n    return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Shutdown communication system\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Clear queues\n    this.messageQueue.forEach((queue) => (queue.length = 0));\n\n    // Clear channels\n    this.channels.clear();\n\n    this.emit('shutdown');\n  }\n}\n"],"names":["EventEmitter","DatabaseManager","Communication","swarmId","db","agents","channels","messageQueue","stats","isActive","Map","totalMessages","avgLatency","activeChannels","messagesByType","throughput","initialize","getInstance","setupDefaultChannels","startMessageProcessor","startLatencyMonitor","startStatsCollector","emit","addAgent","agent","set","id","createAgentChannels","subscribeAgentToChannels","agentId","removeAgent","delete","forEach","channel","subscribers","filter","sendMessage","message","createCommunication","from_agent_id","fromAgentId","to_agent_id","toAgentId","swarm_id","message_type","type","content","JSON","stringify","priority","requires_response","requiresResponse","get","push","broadcast","generateMessageId","timestamp","Date","sendToChannel","channelName","Error","subscriberId","data","requestResponse","query","timeout","Promise","resolve","reject","timer","setTimeout","responseHandler","response","queryId","clearTimeout","off","on","createChannel","name","description","has","createdAt","subscribeToChannel","includes","unsubscribeFromChannel","getStats","recentMessages","getRecentMessages","length","getPendingMessages","messages","map","msg","toString","parse","markDelivered","messageId","markMessageDelivered","markRead","markMessageRead","typeChannel","capabilities","setInterval","batch","splice","processMessage","startTime","now","receiveMessage","values","latency","updateLatencyStats","error","storePerformanceMetric","metric_type","metric_value","Math","random","substr","shutdown","queue","clear"],"mappings":"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"}