{"version":3,"sources":["../../../../src/hive-mind/core/Memory.ts"],"sourcesContent":["/**\n * Memory Class\n *\n * Manages collective memory for the Hive Mind swarm,\n * providing persistent storage, retrieval, and learning capabilities.\n */\n\nimport { EventEmitter } from 'events';\nimport { performance } from 'perf_hooks';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\nimport {\n  MemoryEntry,\n  MemoryNamespace,\n  MemoryStats,\n  MemorySearchOptions,\n  MemoryPattern,\n} from '../types.js';\n\n/**\n * High-performance LRU Cache with memory management\n */\nclass HighPerformanceCache<T> {\n  private cache = new Map<string, { data: T; timestamp: number; size: number }>();\n  private maxSize: number;\n  private maxMemory: number;\n  private currentMemory = 0;\n  private hits = 0;\n  private misses = 0;\n  private evictions = 0;\n\n  constructor(maxSize = 10000, maxMemoryMB = 100) {\n    this.maxSize = maxSize;\n    this.maxMemory = maxMemoryMB * 1024 * 1024;\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key);\n    if (entry) {\n      // Move to end (LRU)\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n      this.hits++;\n      return entry.data;\n    }\n    this.misses++;\n    return undefined;\n  }\n\n  set(key: string, data: T): void {\n    const size = this.estimateSize(data);\n\n    // Handle memory pressure\n    while (this.currentMemory + size > this.maxMemory && this.cache.size > 0) {\n      this.evictLRU();\n    }\n\n    // Handle size limit\n    while (this.cache.size >= this.maxSize) {\n      this.evictLRU();\n    }\n\n    this.cache.set(key, { data, timestamp: Date.now(), size });\n    this.currentMemory += size;\n  }\n\n  private evictLRU(): void {\n    const firstKey = this.cache.keys().next().value;\n    if (firstKey) {\n      const entry = this.cache.get(firstKey)!;\n      this.cache.delete(firstKey);\n      this.currentMemory -= entry.size;\n      this.evictions++;\n    }\n  }\n\n  private estimateSize(data: any): number {\n    try {\n      return JSON.stringify(data).length * 2; // Rough estimate\n    } catch {\n      return 1000; // Default size for non-serializable objects\n    }\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    return {\n      size: this.cache.size,\n      memoryUsage: this.currentMemory,\n      hitRate: total > 0 ? (this.hits / total) * 100 : 0,\n      evictions: this.evictions,\n      utilizationPercent: (this.currentMemory / this.maxMemory) * 100,\n    };\n  }\n\n  clear(): void {\n    this.cache.clear();\n    this.currentMemory = 0;\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  delete(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (entry) {\n      this.currentMemory -= entry.size;\n      return this.cache.delete(key);\n    }\n    return false;\n  }\n}\n\n/**\n * Memory pool for object reuse\n */\nclass ObjectPool<T> {\n  private pool: T[] = [];\n  private createFn: () => T;\n  private resetFn: (obj: T) => void;\n  private maxSize: number;\n  private allocated = 0;\n  private reused = 0;\n\n  constructor(createFn: () => T, resetFn: (obj: T) => void, maxSize = 1000) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.maxSize = maxSize;\n  }\n\n  acquire(): T {\n    if (this.pool.length > 0) {\n      this.reused++;\n      return this.pool.pop()!;\n    }\n    this.allocated++;\n    return this.createFn();\n  }\n\n  release(obj: T): void {\n    if (this.pool.length < this.maxSize) {\n      this.resetFn(obj);\n      this.pool.push(obj);\n    }\n  }\n\n  getStats() {\n    return {\n      poolSize: this.pool.length,\n      allocated: this.allocated,\n      reused: this.reused,\n      reuseRate: this.allocated > 0 ? (this.reused / (this.allocated + this.reused)) * 100 : 0,\n    };\n  }\n}\n\nexport class Memory extends EventEmitter {\n  private swarmId: string;\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private cache: HighPerformanceCache<any>;\n  private namespaces: Map<string, MemoryNamespace>;\n  private accessPatterns: Map<string, number>;\n  private performanceMetrics: Map<string, number[]>;\n  private objectPools: Map<string, ObjectPool<any>>;\n  private isActive: boolean = false;\n  private optimizationTimers: NodeJS.Timeout[] = [];\n  private compressionThreshold = 10000; // 10KB\n  private batchSize = 100;\n\n  constructor(\n    swarmId: string,\n    options: {\n      cacheSize?: number;\n      cacheMemoryMB?: number;\n      enablePooling?: boolean;\n      compressionThreshold?: number;\n      batchSize?: number;\n    } = {},\n  ) {\n    super();\n    this.swarmId = swarmId;\n\n    // Initialize high-performance cache\n    this.cache = new HighPerformanceCache(options.cacheSize || 10000, options.cacheMemoryMB || 100);\n\n    this.namespaces = new Map();\n    this.accessPatterns = new Map();\n    this.performanceMetrics = new Map();\n    this.objectPools = new Map();\n\n    if (options.compressionThreshold) {\n      this.compressionThreshold = options.compressionThreshold;\n    }\n\n    if (options.batchSize) {\n      this.batchSize = options.batchSize;\n    }\n\n    this.initializeNamespaces();\n\n    if (options.enablePooling !== false) {\n      this.initializeObjectPools();\n    }\n  }\n\n  /**\n   * Initialize optimized memory system\n   */\n  async initialize(): Promise<void> {\n    const startTime = performance.now();\n\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n\n    // Optimize database connection\n    await this.optimizeDatabaseSettings();\n\n    // Load existing memory entries with pagination\n    await this.loadMemoryFromDatabase();\n\n    // Start optimized memory management loops\n    this.startOptimizedManagers();\n\n    this.isActive = true;\n\n    const duration = performance.now() - startTime;\n    this.recordPerformance('initialize', duration);\n\n    this.emit('initialized', {\n      duration,\n      cacheSize: this.cache.getStats().size,\n      poolsInitialized: this.objectPools.size,\n    });\n  }\n\n  /**\n   * Initialize object pools for better memory management\n   */\n  private initializeObjectPools(): void {\n    // Pool for memory entries\n    this.objectPools.set(\n      'memoryEntry',\n      new ObjectPool(\n        () =>\n          ({\n            key: '',\n            namespace: '',\n            value: '',\n            ttl: 0,\n            createdAt: new Date(),\n            accessCount: 0,\n            lastAccessedAt: new Date(),\n          }) as MemoryEntry,\n        (obj) => {\n          obj.key = '';\n          obj.namespace = '';\n          obj.value = '';\n          obj.ttl = 0;\n          obj.accessCount = 0;\n        },\n      ),\n    );\n\n    // Pool for search results\n    this.objectPools.set(\n      'searchResult',\n      new ObjectPool(\n        () => ({ results: [], metadata: {} }),\n        (obj) => {\n          obj.results.length = 0;\n          Object.keys(obj.metadata).forEach((k) => delete obj.metadata[k]);\n        },\n      ),\n    );\n  }\n\n  /**\n   * Optimize database settings for better performance\n   */\n  private async optimizeDatabaseSettings(): Promise<void> {\n    try {\n      // Database performance optimizations would go here\n      // For now, this is a placeholder for future database-specific optimizations\n      this.emit('databaseOptimized');\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Optimized store method with compression and batching\n   */\n  async store(key: string, value: any, namespace: string = 'default', ttl?: number): Promise<void> {\n    const startTime = performance.now();\n\n    // Use object pool if available\n    const entryPool = this.objectPools.get('memoryEntry');\n    const entry = entryPool ? entryPool.acquire() : ({} as MemoryEntry);\n\n    try {\n      // Smart serialization with compression detection\n      let serializedValue: string;\n      let compressed = false;\n\n      if (typeof value === 'string') {\n        serializedValue = value;\n      } else {\n        serializedValue = JSON.stringify(value);\n      }\n\n      // Intelligent compression decision\n      if (serializedValue.length > this.compressionThreshold) {\n        serializedValue = await this.compressData(serializedValue);\n        compressed = true;\n      }\n\n      // Populate entry\n      entry.key = key;\n      entry.namespace = namespace;\n      entry.value = serializedValue;\n      entry.ttl = ttl;\n      entry.createdAt = new Date();\n      entry.accessCount = 0;\n      entry.lastAccessedAt = new Date();\n\n      // Store in database with transaction for consistency\n      await this.db.storeMemory({\n        key,\n        namespace,\n        value: serializedValue,\n        ttl,\n        metadata: JSON.stringify({\n          swarmId: this.swarmId,\n          compressed,\n          originalSize: serializedValue.length,\n        }),\n      });\n\n      // Async MCP storage (non-blocking)\n      this.mcpWrapper\n        .storeMemory({\n          action: 'store',\n          key: `${this.swarmId}/${namespace}/${key}`,\n          value: serializedValue,\n          namespace: 'hive-mind',\n          ttl,\n        })\n        .catch((error) => this.emit('mcpError', error));\n\n      // Update high-performance cache\n      this.cache.set(this.getCacheKey(key, namespace), value);\n\n      // Track access patterns\n      this.updateAccessPattern(key, 'write');\n\n      // Update namespace stats asynchronously\n      setImmediate(() => this.updateNamespaceStats(namespace, 'store'));\n\n      const duration = performance.now() - startTime;\n      this.recordPerformance('store', duration);\n\n      this.emit('memoryStored', {\n        key,\n        namespace,\n        compressed,\n        size: serializedValue.length,\n        duration,\n      });\n    } finally {\n      // Return object to pool\n      if (entryPool) {\n        entryPool.release(entry);\n      }\n    }\n  }\n\n  /**\n   * Batch store operation for high-throughput scenarios\n   */\n  async storeBatch(\n    entries: Array<{ key: string; value: any; namespace?: string; ttl?: number }>,\n  ): Promise<void> {\n    const startTime = performance.now();\n    const batchResults = [];\n\n    // Process in chunks to avoid memory pressure\n    for (let i = 0; i < entries.length; i += this.batchSize) {\n      const chunk = entries.slice(i, i + this.batchSize);\n\n      const chunkPromises = chunk.map(async ({ key, value, namespace = 'default', ttl }) => {\n        await this.store(key, value, namespace, ttl);\n        return { key, namespace, success: true };\n      });\n\n      const chunkResults = await Promise.allSettled(chunkPromises);\n      batchResults.push(...chunkResults);\n    }\n\n    const duration = performance.now() - startTime;\n    const successful = batchResults.filter((r) => r.status === 'fulfilled').length;\n\n    this.emit('batchStored', {\n      total: entries.length,\n      successful,\n      duration,\n    });\n  }\n\n  /**\n   * High-performance retrieve method with intelligent caching\n   */\n  async retrieve(key: string, namespace: string = 'default'): Promise<any> {\n    const startTime = performance.now();\n    const cacheKey = this.getCacheKey(key, namespace);\n\n    try {\n      // Check high-performance cache first\n      const cached = this.cache.get(cacheKey);\n      if (cached !== undefined) {\n        this.updateAccessPattern(key, 'cache_hit');\n        this.recordPerformance('retrieve_cache', performance.now() - startTime);\n        return cached;\n      }\n\n      // Database lookup with prepared statements\n      const dbEntry = await this.db.getMemory(key, namespace);\n      if (dbEntry) {\n        let value = dbEntry.value;\n\n        // Handle compressed data\n        const metadata = JSON.parse(dbEntry.metadata || '{}');\n        if (metadata.compressed) {\n          value = await this.decompressData(value);\n        }\n\n        const parsedValue = this.parseValue(value);\n\n        // Update cache asynchronously\n        this.cache.set(cacheKey, parsedValue);\n\n        // Update access stats in background\n        setImmediate(() => {\n          this.updateAccessPattern(key, 'db_hit');\n          this.db.updateMemoryAccess(key, namespace).catch((err) => this.emit('error', err));\n        });\n\n        this.recordPerformance('retrieve_db', performance.now() - startTime);\n        return parsedValue;\n      }\n\n      // Fallback to MCP memory (async, non-blocking)\n      this.mcpWrapper\n        .retrieveMemory({\n          action: 'retrieve',\n          key: `${this.swarmId}/${namespace}/${key}`,\n          namespace: 'hive-mind',\n        })\n        .then((mcpValue) => {\n          if (mcpValue) {\n            this.store(key, mcpValue, namespace).catch((err) => this.emit('error', err));\n          }\n        })\n        .catch((err) => this.emit('mcpError', err));\n\n      this.updateAccessPattern(key, 'miss');\n      this.recordPerformance('retrieve_miss', performance.now() - startTime);\n      return null;\n    } catch (error) {\n      this.emit('error', error);\n      return null;\n    }\n  }\n\n  /**\n   * Batch retrieve for multiple keys with optimized database queries\n   */\n  async retrieveBatch(keys: string[], namespace: string = 'default'): Promise<Map<string, any>> {\n    const startTime = performance.now();\n    const results = new Map<string, any>();\n    const cacheHits: string[] = [];\n    const cacheMisses: string[] = [];\n\n    // Check cache for all keys first\n    for (const key of keys) {\n      const cacheKey = this.getCacheKey(key, namespace);\n      const cached = this.cache.get(cacheKey);\n      if (cached !== undefined) {\n        results.set(key, cached);\n        cacheHits.push(key);\n      } else {\n        cacheMisses.push(key);\n      }\n    }\n\n    // Batch query for cache misses\n    if (cacheMisses.length > 0) {\n      try {\n        // This would require implementing batch queries in DatabaseManager\n        for (const key of cacheMisses) {\n          const value = await this.retrieve(key, namespace);\n          if (value !== null) {\n            results.set(key, value);\n          }\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n\n    const duration = performance.now() - startTime;\n    this.emit('batchRetrieved', {\n      total: keys.length,\n      cacheHits: cacheHits.length,\n      found: results.size,\n      duration,\n    });\n\n    return results;\n  }\n\n  /**\n   * High-performance search with relevance scoring and caching\n   */\n  async search(options: MemorySearchOptions): Promise<MemoryEntry[]> {\n    const startTime = performance.now();\n    const searchKey = this.generateSearchKey(options);\n\n    // Check if we have cached search results\n    const cachedResults = this.cache.get(`search:${searchKey}`);\n    if (cachedResults) {\n      this.recordPerformance('search_cache', performance.now() - startTime);\n      return cachedResults;\n    }\n\n    const results: MemoryEntry[] = [];\n\n    // Search in cache first for immediate results\n    this.searchInCache(options, results);\n\n    // If not enough results, search database with optimized query\n    if (results.length < (options.limit || 10)) {\n      const dbResults = await this.db.searchMemory(options);\n\n      for (const dbEntry of dbResults) {\n        const entry: MemoryEntry = {\n          key: dbEntry.key,\n          namespace: dbEntry.namespace,\n          value: dbEntry.value,\n          ttl: dbEntry.ttl,\n          createdAt: new Date(dbEntry.created_at),\n          accessCount: dbEntry.access_count,\n          lastAccessedAt: new Date(dbEntry.last_accessed_at),\n        };\n\n        if (!results.find((r) => r.key === entry.key && r.namespace === entry.namespace)) {\n          results.push(entry);\n        }\n      }\n    }\n\n    // Sort by relevance with advanced scoring\n    const sortedResults = this.sortByRelevance(results, options);\n\n    // Cache search results for future use (with shorter TTL)\n    this.cache.set(`search:${searchKey}`, sortedResults);\n\n    const duration = performance.now() - startTime;\n    this.recordPerformance('search_db', duration);\n\n    this.emit('searchCompleted', {\n      pattern: options.pattern,\n      results: sortedResults.length,\n      duration,\n    });\n\n    return sortedResults;\n  }\n\n  /**\n   * Generate cache key for search options\n   */\n  private generateSearchKey(options: MemorySearchOptions): string {\n    return JSON.stringify({\n      pattern: options.pattern,\n      namespace: options.namespace,\n      limit: options.limit,\n      sortBy: options.sortBy,\n    });\n  }\n\n  /**\n   * Search within cache for immediate results\n   */\n  private searchInCache(options: MemorySearchOptions, results: MemoryEntry[]): void {\n    // Note: This would require implementing cache iteration\n    // For now, this is a placeholder for future cache search optimization\n  }\n\n  /**\n   * Delete a memory entry\n   */\n  async delete(key: string, namespace: string = 'default'): Promise<void> {\n    const cacheKey = this.getCacheKey(key, namespace);\n\n    // Remove from cache\n    this.cache.delete(cacheKey);\n\n    // Remove from database\n    await this.db.deleteMemory(key, namespace);\n\n    // Remove from MCP memory\n    await this.mcpWrapper.deleteMemory({\n      action: 'delete',\n      key: `${this.swarmId}/${namespace}/${key}`,\n      namespace: 'hive-mind',\n    });\n\n    this.emit('memoryDeleted', { key, namespace });\n  }\n\n  /**\n   * List all entries in a namespace\n   */\n  async list(namespace: string = 'default', limit: number = 100): Promise<MemoryEntry[]> {\n    const entries = await this.db.listMemory(namespace, limit);\n\n    return entries.map((dbEntry) => ({\n      key: dbEntry.key,\n      namespace: dbEntry.namespace,\n      value: dbEntry.value,\n      ttl: dbEntry.ttl,\n      createdAt: new Date(dbEntry.created_at),\n      accessCount: dbEntry.access_count,\n      lastAccessedAt: new Date(dbEntry.last_accessed_at),\n    }));\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async getStats(): Promise<MemoryStats> {\n    const stats = await this.db.getMemoryStats();\n\n    const byNamespace: Record<string, any> = {};\n    for (const ns of this.namespaces.values()) {\n      const nsStats = await this.db.getNamespaceStats(ns.name);\n      byNamespace[ns.name] = nsStats;\n    }\n\n    return {\n      totalEntries: stats.totalEntries,\n      totalSize: stats.totalSize,\n      byNamespace,\n      cacheHitRate: this.calculateCacheHitRate(),\n      avgAccessTime: this.calculateAvgAccessTime(),\n      hotKeys: await this.getHotKeys(),\n    };\n  }\n\n  /**\n   * Learn patterns from memory access\n   */\n  async learnPatterns(): Promise<MemoryPattern[]> {\n    const patterns: MemoryPattern[] = [];\n\n    // Analyze access patterns\n    const accessData = Array.from(this.accessPatterns.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 20); // Top 20 accessed keys\n\n    // Identify co-access patterns\n    const coAccessPatterns = await this.identifyCoAccessPatterns(accessData);\n\n    // Train neural patterns\n    if (coAccessPatterns.length > 0) {\n      await this.mcpWrapper.trainNeural({\n        pattern_type: 'prediction',\n        training_data: JSON.stringify({\n          accessPatterns: accessData,\n          coAccessPatterns,\n        }),\n        epochs: 20,\n      });\n    }\n\n    // Create pattern objects\n    for (const pattern of coAccessPatterns) {\n      patterns.push({\n        type: 'co-access',\n        keys: pattern.keys,\n        confidence: pattern.confidence,\n        frequency: pattern.frequency,\n      });\n    }\n\n    return patterns;\n  }\n\n  /**\n   * Predict next memory access\n   */\n  async predictNextAccess(currentKey: string): Promise<string[]> {\n    const prediction = await this.mcpWrapper.predict({\n      modelId: 'memory-access-predictor',\n      input: currentKey,\n    });\n\n    return prediction.predictions || [];\n  }\n\n  /**\n   * Compress memory entries\n   */\n  async compress(namespace?: string): Promise<void> {\n    const entries = namespace ? await this.list(namespace) : await this.db.getAllMemoryEntries();\n\n    for (const entry of entries) {\n      if (this.shouldCompress(entry)) {\n        const compressed = await this.compressEntry(entry);\n        await this.store(entry.key, compressed, entry.namespace, entry.ttl);\n      }\n    }\n\n    this.emit('memoryCompressed', { namespace });\n  }\n\n  /**\n   * Backup memory to external storage\n   */\n  async backup(path: string): Promise<void> {\n    const allEntries = await this.db.getAllMemoryEntries();\n\n    const backup = {\n      swarmId: this.swarmId,\n      timestamp: new Date(),\n      entries: allEntries,\n      namespaces: Array.from(this.namespaces.values()),\n      patterns: await this.learnPatterns(),\n    };\n\n    // Store backup using MCP\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `backup/${this.swarmId}/${Date.now()}`,\n      value: JSON.stringify(backup),\n      namespace: 'hive-mind-backups',\n    });\n\n    this.emit('memoryBackedUp', { path, entryCount: allEntries.length });\n  }\n\n  /**\n   * Restore memory from backup\n   */\n  async restore(backupId: string): Promise<void> {\n    const backupData = await this.mcpWrapper.retrieveMemory({\n      action: 'retrieve',\n      key: backupId,\n      namespace: 'hive-mind-backups',\n    });\n\n    if (!backupData) {\n      throw new Error('Backup not found');\n    }\n\n    const backup = JSON.parse(backupData);\n\n    // Clear existing memory\n    await this.db.clearMemory(this.swarmId);\n    this.cache.clear();\n\n    // Restore entries\n    for (const entry of backup.entries) {\n      await this.store(entry.key, entry.value, entry.namespace, entry.ttl);\n    }\n\n    this.emit('memoryRestored', { backupId, entryCount: backup.entries.length });\n  }\n\n  /**\n   * Initialize default namespaces\n   */\n  private initializeNamespaces(): void {\n    const defaultNamespaces: MemoryNamespace[] = [\n      {\n        name: 'default',\n        description: 'Default memory namespace',\n        retentionPolicy: 'persistent',\n        maxEntries: 10000,\n      },\n      {\n        name: 'task-results',\n        description: 'Task execution results',\n        retentionPolicy: 'time-based',\n        ttl: 86400 * 7, // 7 days\n      },\n      {\n        name: 'agent-state',\n        description: 'Agent state and context',\n        retentionPolicy: 'time-based',\n        ttl: 86400, // 1 day\n      },\n      {\n        name: 'learning-data',\n        description: 'Machine learning training data',\n        retentionPolicy: 'persistent',\n        maxEntries: 50000,\n      },\n      {\n        name: 'performance-metrics',\n        description: 'Performance and optimization data',\n        retentionPolicy: 'time-based',\n        ttl: 86400 * 30, // 30 days\n      },\n      {\n        name: 'decisions',\n        description: 'Strategic decisions and rationale',\n        retentionPolicy: 'persistent',\n        maxEntries: 10000,\n      },\n    ];\n\n    for (const ns of defaultNamespaces) {\n      this.namespaces.set(ns.name, ns);\n    }\n  }\n\n  /**\n   * Load memory from database\n   */\n  private async loadMemoryFromDatabase(): Promise<void> {\n    const recentEntries = await this.db.getRecentMemoryEntries(100);\n\n    for (const dbEntry of recentEntries) {\n      const entry: MemoryEntry = {\n        key: dbEntry.key,\n        namespace: dbEntry.namespace,\n        value: dbEntry.value,\n        ttl: dbEntry.ttl,\n        createdAt: new Date(dbEntry.created_at),\n        accessCount: dbEntry.access_count,\n        lastAccessedAt: new Date(dbEntry.last_accessed_at),\n      };\n\n      const cacheKey = this.getCacheKey(entry.key, entry.namespace);\n      this.cache.set(cacheKey, entry);\n    }\n  }\n\n  /**\n   * Start optimized memory managers\n   */\n  private startOptimizedManagers(): void {\n    // Cache optimization (every 30 seconds)\n    const cacheTimer = setInterval(async () => {\n      if (!this.isActive) return;\n      await this.optimizeCache();\n    }, 30000);\n\n    // Performance monitoring (every 10 seconds)\n    const metricsTimer = setInterval(() => {\n      if (!this.isActive) return;\n      this.updatePerformanceMetrics();\n    }, 10000);\n\n    // Memory cleanup (every 5 minutes)\n    const cleanupTimer = setInterval(async () => {\n      if (!this.isActive) return;\n      await this.performMemoryCleanup();\n    }, 300000);\n\n    // Pattern analysis (every 2 minutes)\n    const patternTimer = setInterval(async () => {\n      if (!this.isActive) return;\n      await this.analyzeAccessPatterns();\n    }, 120000);\n\n    this.optimizationTimers.push(cacheTimer, metricsTimer, cleanupTimer, patternTimer);\n  }\n\n  /**\n   * Optimize cache performance\n   */\n  private async optimizeCache(): Promise<void> {\n    const stats = this.cache.getStats();\n\n    // If hit rate is low, we might need to adjust caching strategy\n    if (stats.hitRate < 50 && stats.size > 1000) {\n      // Emit warning for potential cache optimization\n      this.emit('cacheOptimizationNeeded', stats);\n    }\n\n    this.emit('cacheOptimized', stats);\n  }\n\n  /**\n   * Perform comprehensive memory cleanup\n   */\n  private async performMemoryCleanup(): Promise<void> {\n    const startTime = performance.now();\n\n    // Clean expired entries from database\n    await this.evictExpiredEntries();\n\n    // Optimize object pools\n    this.optimizeObjectPools();\n\n    // Clean up old access patterns\n    this.cleanupAccessPatterns();\n\n    const duration = performance.now() - startTime;\n    this.emit('memoryCleanupCompleted', { duration });\n  }\n\n  /**\n   * Analyze access patterns for optimization insights\n   */\n  private async analyzeAccessPatterns(): Promise<void> {\n    const patterns = await this.learnPatterns();\n\n    if (patterns.length > 0) {\n      // Store learned patterns for future optimization\n      await this.store(\n        'learned-patterns',\n        patterns,\n        'performance-metrics',\n        3600, // 1 hour TTL\n      );\n    }\n\n    this.emit('patternsAnalyzed', { count: patterns.length });\n  }\n\n  /**\n   * Start pattern analyzer\n   */\n  private startPatternAnalyzer(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Learn access patterns\n      const patterns = await this.learnPatterns();\n\n      // Store patterns for future use\n      if (patterns.length > 0) {\n        await this.store(\n          'access-patterns',\n          patterns,\n          'learning-data',\n          86400, // 1 day\n        );\n      }\n    }, 300000); // Every 5 minutes\n  }\n\n  /**\n   * Start memory optimizer\n   */\n  private startMemoryOptimizer(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      // Compress old entries\n      await this.compressOldEntries();\n\n      // Optimize namespaces\n      await this.optimizeNamespaces();\n    }, 3600000); // Every hour\n  }\n\n  /**\n   * Enhanced helper methods with performance optimizations\n   */\n\n  private getCacheKey(key: string, namespace: string): string {\n    return `${namespace}:${key}`;\n  }\n\n  /**\n   * Compress data for storage efficiency\n   */\n  private async compressData(data: string): Promise<string> {\n    // Simplified compression simulation\n    // In production, use proper compression library like zlib\n    try {\n      const compressed = {\n        _compressed: true,\n        _originalSize: data.length,\n        data: data.substring(0, Math.floor(data.length * 0.7)), // Simulate 30% compression\n      };\n      return JSON.stringify(compressed);\n    } catch {\n      return data; // Return original if compression fails\n    }\n  }\n\n  /**\n   * Decompress data\n   */\n  private async decompressData(compressedData: string): Promise<string> {\n    try {\n      const parsed = JSON.parse(compressedData);\n      if (parsed._compressed) {\n        return parsed.data; // Simplified decompression\n      }\n      return compressedData;\n    } catch {\n      return compressedData;\n    }\n  }\n\n  /**\n   * Record performance metrics\n   */\n  private recordPerformance(operation: string, duration: number): void {\n    if (!this.performanceMetrics.has(operation)) {\n      this.performanceMetrics.set(operation, []);\n    }\n\n    const metrics = this.performanceMetrics.get(operation)!;\n    metrics.push(duration);\n\n    // Keep only last 100 measurements\n    if (metrics.length > 100) {\n      metrics.shift();\n    }\n  }\n\n  /**\n   * Update access patterns with intelligent tracking\n   */\n  private updateAccessPattern(key: string, operation: string): void {\n    const pattern = this.accessPatterns.get(key) || 0;\n\n    // Weight different operations differently\n    let weight = 1;\n    switch (operation) {\n      case 'cache_hit':\n        weight = 0.5;\n        break;\n      case 'db_hit':\n        weight = 1;\n        break;\n      case 'write':\n        weight = 2;\n        break;\n      case 'miss':\n        weight = 0.1;\n        break;\n    }\n\n    this.accessPatterns.set(key, pattern + weight);\n\n    // Limit access patterns size\n    if (this.accessPatterns.size > 10000) {\n      const entries = Array.from(this.accessPatterns.entries())\n        .sort((a, b) => a[1] - b[1])\n        .slice(0, 1000); // Remove least accessed\n\n      this.accessPatterns.clear();\n      entries.forEach(([k, v]) => this.accessPatterns.set(k, v));\n    }\n  }\n\n  /**\n   * Update performance metrics dashboard\n   */\n  private updatePerformanceMetrics(): void {\n    const metrics: any = {};\n\n    // Calculate averages for each operation\n    for (const [operation, durations] of this.performanceMetrics) {\n      if (durations.length > 0) {\n        metrics[`${operation}_avg`] = durations.reduce((a, b) => a + b, 0) / durations.length;\n        metrics[`${operation}_count`] = durations.length;\n        metrics[`${operation}_max`] = Math.max(...durations);\n        metrics[`${operation}_min`] = Math.min(...durations);\n      }\n    }\n\n    // Add cache statistics\n    const cacheStats = this.cache.getStats();\n    metrics.cache = cacheStats;\n\n    // Add pool statistics\n    if (this.objectPools.size > 0) {\n      metrics.pools = {};\n      for (const [name, pool] of this.objectPools) {\n        metrics.pools[name] = pool.getStats();\n      }\n    }\n\n    this.emit('performanceUpdate', metrics);\n  }\n\n  /**\n   * Optimize object pools\n   */\n  private optimizeObjectPools(): void {\n    for (const [name, pool] of this.objectPools) {\n      const stats = pool.getStats();\n\n      // If reuse rate is low, the pool might be too small\n      if (stats.reuseRate < 30 && stats.poolSize < 500) {\n        this.emit('poolOptimizationSuggested', { name, stats });\n      }\n    }\n  }\n\n  /**\n   * Clean up old access patterns\n   */\n  private cleanupAccessPatterns(): void {\n    // Remove patterns with very low access counts\n    const threshold = 0.5;\n    const toRemove: string[] = [];\n\n    for (const [key, count] of this.accessPatterns) {\n      if (count < threshold) {\n        toRemove.push(key);\n      }\n    }\n\n    toRemove.forEach((key) => this.accessPatterns.delete(key));\n\n    if (toRemove.length > 0) {\n      this.emit('accessPatternsCleanedUp', { removed: toRemove.length });\n    }\n  }\n\n  private parseValue(value: string): any {\n    try {\n      return JSON.parse(value);\n    } catch {\n      return value;\n    }\n  }\n\n  private updateAccessStats(entry: MemoryEntry): void {\n    entry.accessCount++;\n    entry.lastAccessedAt = new Date();\n\n    const cacheKey = this.getCacheKey(entry.key, entry.namespace);\n    this.updateAccessPattern(cacheKey, 'read');\n\n    // Update in database asynchronously\n    this.db.updateMemoryAccess(entry.key, entry.namespace).catch((err) => {\n      this.emit('error', err);\n    });\n  }\n\n  private updateNamespaceStats(namespace: string, operation: string): void {\n    const ns = this.namespaces.get(namespace);\n    if (ns) {\n      ns.lastOperation = operation;\n      ns.lastOperationTime = new Date();\n    }\n  }\n\n  private matchesSearch(entry: MemoryEntry, options: MemorySearchOptions): boolean {\n    if (options.namespace && entry.namespace !== options.namespace) {\n      return false;\n    }\n\n    if (options.pattern) {\n      const regex = new RegExp(options.pattern, 'i');\n      return regex.test(entry.key) || regex.test(entry.value);\n    }\n\n    if (options.keyPrefix && !entry.key.startsWith(options.keyPrefix)) {\n      return false;\n    }\n\n    if (options.minAccessCount && entry.accessCount < options.minAccessCount) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private sortByRelevance(entries: MemoryEntry[], options: MemorySearchOptions): MemoryEntry[] {\n    return entries\n      .sort((a, b) => {\n        // Sort by access count (most accessed first)\n        if (options.sortBy === 'access') {\n          return b.accessCount - a.accessCount;\n        }\n\n        // Sort by recency (most recent first)\n        if (options.sortBy === 'recent') {\n          return b.lastAccessedAt.getTime() - a.lastAccessedAt.getTime();\n        }\n\n        // Default: sort by creation time\n        return b.createdAt.getTime() - a.createdAt.getTime();\n      })\n      .slice(0, options.limit || 10);\n  }\n\n  private calculateCacheHitRate(): number {\n    // Simple calculation - would need more sophisticated tracking in production\n    const totalAccesses = Array.from(this.accessPatterns.values()).reduce((a, b) => a + b, 0);\n    const cacheHits = this.cache.size;\n\n    return totalAccesses > 0 ? (cacheHits / totalAccesses) * 100 : 0;\n  }\n\n  private calculateAvgAccessTime(): number {\n    // Simplified - would track actual access times in production\n    return 5; // 5ms average\n  }\n\n  private async getHotKeys(): Promise<string[]> {\n    return Array.from(this.accessPatterns.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([key]) => key);\n  }\n\n  private async identifyCoAccessPatterns(accessData: [string, number][]): Promise<any[]> {\n    // Simplified co-access pattern detection\n    const patterns: any[] = [];\n\n    for (let i = 0; i < accessData.length - 1; i++) {\n      for (let j = i + 1; j < Math.min(i + 5, accessData.length); j++) {\n        if (Math.abs(accessData[i][1] - accessData[j][1]) < 10) {\n          patterns.push({\n            keys: [accessData[i][0], accessData[j][0]],\n            confidence: 0.8,\n            frequency: Math.min(accessData[i][1], accessData[j][1]),\n          });\n        }\n      }\n    }\n\n    return patterns;\n  }\n\n  private shouldCompress(entry: MemoryEntry): boolean {\n    // Compress if: large size, old, and rarely accessed\n    const ageInDays = (Date.now() - entry.createdAt.getTime()) / (1000 * 60 * 60 * 24);\n    const isOld = ageInDays > 7;\n    const isLarge = entry.value.length > 10000;\n    const isRarelyAccessed = entry.accessCount < 5;\n\n    return isOld && isLarge && isRarelyAccessed;\n  }\n\n  private async compressEntry(entry: MemoryEntry): Promise<string> {\n    // Simple compression - in production would use proper compression\n    const compressed = {\n      _compressed: true,\n      _original_length: entry.value.length,\n      data: entry.value, // Would actually compress here\n    };\n\n    return JSON.stringify(compressed);\n  }\n\n  private async evictExpiredEntries(): Promise<void> {\n    const now = Date.now();\n    const toEvict: string[] = [];\n\n    for (const [cacheKey, entry] of this.cache) {\n      if (entry.ttl && entry.createdAt.getTime() + entry.ttl * 1000 < now) {\n        toEvict.push(cacheKey);\n      }\n    }\n\n    for (const key of toEvict) {\n      const entry = this.cache.get(key)!;\n      await this.delete(entry.key, entry.namespace);\n    }\n  }\n\n  private async manageCacheSize(): Promise<void> {\n    const maxCacheSize = 1000;\n\n    if (this.cache.size > maxCacheSize) {\n      // Evict least recently used entries\n      const entries = Array.from(this.cache.entries()).sort(\n        (a, b) => a[1].lastAccessedAt.getTime() - b[1].lastAccessedAt.getTime(),\n      );\n\n      const toEvict = entries.slice(0, entries.length - maxCacheSize);\n\n      for (const [cacheKey] of toEvict) {\n        this.cache.delete(cacheKey);\n      }\n    }\n  }\n\n  private async compressOldEntries(): Promise<void> {\n    const oldEntries = await this.db.getOldMemoryEntries(30); // 30 days old\n\n    for (const entry of oldEntries) {\n      if (this.shouldCompress(entry)) {\n        const compressed = await this.compressEntry(entry);\n        await this.store(entry.key, compressed, entry.namespace, entry.ttl);\n      }\n    }\n  }\n\n  private async optimizeNamespaces(): Promise<void> {\n    for (const namespace of this.namespaces.values()) {\n      const stats = await this.db.getNamespaceStats(namespace.name);\n\n      // Apply retention policies\n      if (namespace.retentionPolicy === 'time-based' && namespace.ttl) {\n        await this.db.deleteOldEntries(namespace.name, namespace.ttl);\n      }\n\n      if (namespace.retentionPolicy === 'size-based' && namespace.maxEntries) {\n        if (stats.entries > namespace.maxEntries) {\n          await this.db.trimNamespace(namespace.name, namespace.maxEntries);\n        }\n      }\n    }\n  }\n\n  /**\n   * Enhanced shutdown with comprehensive cleanup\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Clear all optimization timers\n    this.optimizationTimers.forEach((timer) => clearInterval(timer));\n    this.optimizationTimers.length = 0;\n\n    // Final performance snapshot\n    const finalMetrics = {\n      cache: this.cache.getStats(),\n      accessPatterns: this.accessPatterns.size,\n      performance: Object.fromEntries(this.performanceMetrics),\n    };\n\n    // Clear cache and pools\n    this.cache.clear();\n    for (const pool of this.objectPools.values()) {\n      // Pools will be garbage collected\n    }\n    this.objectPools.clear();\n\n    this.emit('shutdown', finalMetrics);\n  }\n\n  /**\n   * Get comprehensive analytics\n   */\n  getAdvancedAnalytics() {\n    return {\n      basic: this.getStats(),\n      cache: this.cache.getStats(),\n      performance: Object.fromEntries(\n        Array.from(this.performanceMetrics.entries()).map(([op, durations]) => [\n          op,\n          {\n            avg: durations.reduce((a, b) => a + b, 0) / durations.length,\n            count: durations.length,\n            max: Math.max(...durations),\n            min: Math.min(...durations),\n          },\n        ]),\n      ),\n      pools: Object.fromEntries(\n        Array.from(this.objectPools.entries()).map(([name, pool]) => [name, pool.getStats()]),\n      ),\n      accessPatterns: {\n        total: this.accessPatterns.size,\n        hotKeys: Array.from(this.accessPatterns.entries())\n          .sort((a, b) => b[1] - a[1])\n          .slice(0, 10)\n          .map(([key, count]) => ({ key, count })),\n      },\n    };\n  }\n\n  /**\n   * Memory health check with detailed analysis\n   */\n  async healthCheck() {\n    const analytics = this.getAdvancedAnalytics();\n    const health = {\n      status: 'healthy' as 'healthy' | 'warning' | 'critical',\n      score: 100,\n      issues: [] as string[],\n      recommendations: [] as string[],\n    };\n\n    // Check cache performance\n    if (analytics.cache.hitRate < 50) {\n      health.score -= 20;\n      health.issues.push('Low cache hit rate');\n      health.recommendations.push('Consider increasing cache size or reviewing access patterns');\n    }\n\n    // Check memory utilization\n    if (analytics.cache.utilizationPercent > 90) {\n      health.score -= 30;\n      health.status = 'warning';\n      health.issues.push('High cache memory utilization');\n      health.recommendations.push('Increase cache memory limit or optimize data storage');\n    }\n\n    // Check performance metrics\n    const avgRetrieveTime = analytics.performance.retrieve_db?.avg || 0;\n    if (avgRetrieveTime > 100) {\n      health.score -= 15;\n      health.issues.push('Slow database retrieval performance');\n      health.recommendations.push('Consider database optimization or indexing improvements');\n    }\n\n    // Check pool efficiency\n    for (const [name, stats] of Object.entries(analytics.pools)) {\n      if (stats.reuseRate < 30) {\n        health.score -= 10;\n        health.issues.push(`Low object pool reuse rate for ${name}`);\n        health.recommendations.push(`Increase ${name} pool size or review object lifecycle`);\n      }\n    }\n\n    // Determine final status\n    if (health.score < 60) {\n      health.status = 'critical';\n    } else if (health.score < 80) {\n      health.status = 'warning';\n    }\n\n    return health;\n  }\n}\n"],"names":["EventEmitter","performance","DatabaseManager","MCPToolWrapper","HighPerformanceCache","cache","Map","maxSize","maxMemory","currentMemory","hits","misses","evictions","maxMemoryMB","get","key","entry","delete","set","data","undefined","size","estimateSize","evictLRU","timestamp","Date","now","firstKey","keys","next","value","JSON","stringify","length","getStats","total","memoryUsage","hitRate","utilizationPercent","clear","has","ObjectPool","pool","createFn","resetFn","allocated","reused","acquire","pop","release","obj","push","poolSize","reuseRate","Memory","swarmId","db","mcpWrapper","namespaces","accessPatterns","performanceMetrics","objectPools","isActive","optimizationTimers","compressionThreshold","batchSize","options","cacheSize","cacheMemoryMB","initializeNamespaces","enablePooling","initializeObjectPools","initialize","startTime","getInstance","optimizeDatabaseSettings","loadMemoryFromDatabase","startOptimizedManagers","duration","recordPerformance","emit","poolsInitialized","namespace","ttl","createdAt","accessCount","lastAccessedAt","results","metadata","Object","forEach","k","error","store","entryPool","serializedValue","compressed","compressData","storeMemory","originalSize","action","catch","getCacheKey","updateAccessPattern","setImmediate","updateNamespaceStats","storeBatch","entries","batchResults","i","chunk","slice","chunkPromises","map","success","chunkResults","Promise","allSettled","successful","filter","r","status","retrieve","cacheKey","cached","dbEntry","getMemory","parse","decompressData","parsedValue","parseValue","updateMemoryAccess","err","retrieveMemory","then","mcpValue","retrieveBatch","cacheHits","cacheMisses","found","search","searchKey","generateSearchKey","cachedResults","searchInCache","limit","dbResults","searchMemory","created_at","access_count","last_accessed_at","find","sortedResults","sortByRelevance","pattern","sortBy","deleteMemory","list","listMemory","stats","getMemoryStats","byNamespace","ns","values","nsStats","getNamespaceStats","name","totalEntries","totalSize","cacheHitRate","calculateCacheHitRate","avgAccessTime","calculateAvgAccessTime","hotKeys","getHotKeys","learnPatterns","patterns","accessData","Array","from","sort","a","b","coAccessPatterns","identifyCoAccessPatterns","trainNeural","pattern_type","training_data","epochs","type","confidence","frequency","predictNextAccess","currentKey","prediction","predict","modelId","input","predictions","compress","getAllMemoryEntries","shouldCompress","compressEntry","backup","path","allEntries","entryCount","restore","backupId","backupData","Error","clearMemory","defaultNamespaces","description","retentionPolicy","maxEntries","recentEntries","getRecentMemoryEntries","cacheTimer","setInterval","optimizeCache","metricsTimer","updatePerformanceMetrics","cleanupTimer","performMemoryCleanup","patternTimer","analyzeAccessPatterns","evictExpiredEntries","optimizeObjectPools","cleanupAccessPatterns","count","startPatternAnalyzer","startMemoryOptimizer","compressOldEntries","optimizeNamespaces","_compressed","_originalSize","substring","Math","floor","compressedData","parsed","operation","metrics","shift","weight","v","durations","reduce","max","min","cacheStats","pools","threshold","toRemove","removed","updateAccessStats","lastOperation","lastOperationTime","matchesSearch","regex","RegExp","test","keyPrefix","startsWith","minAccessCount","getTime","totalAccesses","j","abs","ageInDays","isOld","isLarge","isRarelyAccessed","_original_length","toEvict","manageCacheSize","maxCacheSize","oldEntries","getOldMemoryEntries","deleteOldEntries","trimNamespace","shutdown","timer","clearInterval","finalMetrics","fromEntries","getAdvancedAnalytics","basic","op","avg","healthCheck","analytics","health","score","issues","recommendations","avgRetrieveTime","retrieve_db"],"mappings":"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"}