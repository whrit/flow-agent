{"version":3,"sources":["../../../../src/hive-mind/core/Agent.ts"],"sourcesContent":["/**\n * Base Agent Class\n *\n * Foundation for all agent types in the Hive Mind swarm.\n * Provides core functionality for task execution, communication, and coordination.\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\nimport {\n  AgentType,\n  AgentStatus,\n  AgentCapability,\n  Task,\n  Message,\n  AgentConfig,\n  ExecutionResult,\n} from '../types.js';\n\nexport class Agent extends EventEmitter {\n  public readonly id: string;\n  public readonly name: string;\n  public readonly type: AgentType;\n  public readonly swarmId: string;\n  public readonly capabilities: AgentCapability[];\n  public readonly createdAt: Date;\n\n  public status: AgentStatus = 'idle';\n  public currentTask: string | null = null;\n  public messageCount: number = 0;\n\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private memory: Map<string, any>;\n  private communicationBuffer: Message[];\n  private lastHeartbeat: number;\n  private isActive: boolean = false;\n\n  constructor(config: AgentConfig) {\n    super();\n    this.id = config.id || uuidv4();\n    this.name = config.name;\n    this.type = config.type;\n    this.swarmId = config.swarmId;\n    this.capabilities = config.capabilities || [];\n    this.createdAt = new Date();\n\n    this.memory = new Map();\n    this.communicationBuffer = [];\n    this.lastHeartbeat = Date.now();\n  }\n\n  /**\n   * Initialize the agent\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n\n    // Load agent state from database if exists\n    const existingAgent = await this.db.getAgent(this.id);\n    if (existingAgent) {\n      this.status = existingAgent.status as AgentStatus;\n      this.currentTask = existingAgent.current_task_id;\n      this.messageCount = existingAgent.message_count;\n    }\n\n    // Start agent loops\n    this.startHeartbeatLoop();\n    this.startCommunicationLoop();\n    this.startLearningLoop();\n\n    this.isActive = true;\n    this.emit('initialized');\n  }\n\n  /**\n   * Assign a task to this agent\n   */\n  async assignTask(taskId: string, executionPlan: any): Promise<void> {\n    if (this.currentTask) {\n      throw new Error('Agent already has an active task');\n    }\n\n    this.currentTask = taskId;\n    this.status = 'busy';\n\n    // Update database\n    await this.db.updateAgent(this.id, {\n      status: 'busy',\n      current_task_id: taskId,\n    });\n\n    // Store task in memory\n    this.memory.set('current_task', { taskId, executionPlan, startTime: Date.now() });\n\n    // Start task execution\n    this.executeTask(taskId, executionPlan).catch((error) => {\n      this.emit('taskError', { taskId, error });\n    });\n\n    this.emit('taskAssigned', { taskId });\n  }\n\n  /**\n   * Execute assigned task\n   */\n  private async executeTask(taskId: string, executionPlan: any): Promise<void> {\n    try {\n      // Load task details\n      const task = await this.db.getTask(taskId);\n      if (!task) {\n        throw new Error('Task not found');\n      }\n\n      // Update task status\n      await this.db.updateTaskStatus(taskId, 'in_progress');\n\n      // Execute based on agent type\n      const result = await this.executeByType(task, executionPlan);\n\n      // Store result\n      await this.db.updateTask(taskId, {\n        status: 'completed',\n        result: JSON.stringify(result),\n        progress: 100,\n        completed_at: new Date(),\n      });\n\n      // Learn from execution\n      await this.learnFromExecution(task, result);\n\n      // Clear task\n      this.currentTask = null;\n      this.status = 'idle';\n\n      await this.db.updateAgent(this.id, {\n        status: 'idle',\n        current_task_id: null,\n        success_count: this.db.raw('success_count + 1'),\n      });\n\n      this.emit('taskCompleted', { taskId, result });\n    } catch (error) {\n      // Handle task failure\n      await this.handleTaskFailure(taskId, error);\n    }\n  }\n\n  /**\n   * Execute task based on agent type\n   */\n  protected async executeByType(task: any, executionPlan: any): Promise<ExecutionResult> {\n    // Base implementation - override in specialized agents\n    const startTime = Date.now();\n\n    // Simulate task execution phases\n    const phases = executionPlan.phases || ['analysis', 'execution', 'validation'];\n    const results: any[] = [];\n\n    for (const phase of phases) {\n      const phaseResult = await this.executePhase(phase, task, executionPlan);\n      results.push(phaseResult);\n\n      // Update progress\n      const progress = Math.round(((phases.indexOf(phase) + 1) / phases.length) * 100);\n      await this.updateTaskProgress(task.id, progress);\n\n      // Communicate progress\n      await this.communicateProgress(task.id, phase, progress);\n    }\n\n    return {\n      success: true,\n      data: results,\n      executionTime: Date.now() - startTime,\n      agentId: this.id,\n      metadata: {\n        phases: phases,\n        plan: executionPlan,\n      },\n    };\n  }\n\n  /**\n   * Execute a specific phase of the task\n   */\n  protected async executePhase(phase: string, task: any, plan: any): Promise<any> {\n    // Use MCP tools based on phase and agent capabilities\n    switch (phase) {\n      case 'analysis':\n        return this.performAnalysis(task);\n\n      case 'execution':\n        return this.performExecution(task, plan);\n\n      case 'validation':\n        return this.performValidation(task);\n\n      default:\n        return { phase, status: 'completed' };\n    }\n  }\n\n  /**\n   * Perform analysis phase\n   */\n  protected async performAnalysis(task: any): Promise<any> {\n    // Use neural analysis for task understanding\n    const analysis = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: `${this.type}_analysis`,\n      metadata: {\n        task: task.description,\n        agentType: this.type,\n        capabilities: this.capabilities,\n      },\n    });\n\n    // Store analysis in memory\n    await this.storeInMemory('task_analysis', analysis);\n\n    return {\n      phase: 'analysis',\n      complexity: analysis.complexity || 'medium',\n      estimatedTime: analysis.estimatedTime || 3600000,\n      requirements: analysis.requirements || [],\n    };\n  }\n\n  /**\n   * Perform execution phase\n   */\n  protected async performExecution(task: any, plan: any): Promise<any> {\n    // Base execution - specialized agents override this\n    const actions =\n      plan.agentAssignments?.find((a: any) => a.agentId === this.id)?.responsibilities || [];\n    const results = [];\n\n    for (const action of actions) {\n      const actionResult = await this.executeAction(action, task);\n      results.push(actionResult);\n    }\n\n    return {\n      phase: 'execution',\n      actions: actions,\n      results: results,\n    };\n  }\n\n  /**\n   * Perform validation phase\n   */\n  protected async performValidation(task: any): Promise<any> {\n    // Validate execution results\n    const validation = {\n      phase: 'validation',\n      checks: [],\n      passed: true,\n    };\n\n    // Basic validation checks\n    const checks = [\n      { name: 'completeness', passed: true },\n      { name: 'quality', passed: true },\n      { name: 'performance', passed: true },\n    ];\n\n    validation.checks = checks;\n    validation.passed = checks.every((c) => c.passed);\n\n    return validation;\n  }\n\n  /**\n   * Execute a specific action\n   */\n  protected async executeAction(action: string, task: any): Promise<any> {\n    // Base action execution\n    return {\n      action: action,\n      status: 'completed',\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Send a message to another agent or broadcast\n   */\n  async sendMessage(toAgentId: string | null, messageType: string, content: any): Promise<void> {\n    const message: Message = {\n      id: uuidv4(),\n      fromAgentId: this.id,\n      toAgentId,\n      swarmId: this.swarmId,\n      type: messageType,\n      content,\n      timestamp: new Date(),\n      requiresResponse: false,\n    };\n\n    // Store in database\n    await this.db.createCommunication({\n      from_agent_id: this.id,\n      to_agent_id: toAgentId,\n      swarm_id: this.swarmId,\n      message_type: messageType,\n      content: JSON.stringify(content),\n      priority: 'normal',\n    });\n\n    this.messageCount++;\n    this.emit('messageSent', message);\n  }\n\n  /**\n   * Receive and process a message\n   */\n  async receiveMessage(message: Message): Promise<void> {\n    this.communicationBuffer.push(message);\n    this.emit('messageReceived', message);\n  }\n\n  /**\n   * Vote on a consensus proposal\n   */\n  async voteOnProposal(proposalId: string, vote: boolean, reason?: string): Promise<void> {\n    await this.db.submitConsensusVote(proposalId, this.id, vote, reason);\n    this.emit('voteCast', { proposalId, vote, reason });\n  }\n\n  /**\n   * Update task progress\n   */\n  protected async updateTaskProgress(taskId: string, progress: number): Promise<void> {\n    await this.db.updateTask(taskId, {\n      progress,\n      last_progress_update: new Date(),\n    });\n  }\n\n  /**\n   * Communicate progress to other agents\n   */\n  protected async communicateProgress(\n    taskId: string,\n    phase: string,\n    progress: number,\n  ): Promise<void> {\n    await this.sendMessage(null, 'progress_update', {\n      taskId,\n      agentId: this.id,\n      phase,\n      progress,\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Store data in agent memory\n   */\n  protected async storeInMemory(key: string, value: any): Promise<void> {\n    this.memory.set(key, value);\n\n    // Also store in persistent memory\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `agent/${this.id}/${key}`,\n      value: JSON.stringify(value),\n      namespace: 'agent-memory',\n      ttl: 3600, // 1 hour\n    });\n  }\n\n  /**\n   * Retrieve from agent memory\n   */\n  protected async retrieveFromMemory(key: string): Promise<any> {\n    // Check local memory first\n    if (this.memory.has(key)) {\n      return this.memory.get(key);\n    }\n\n    // Check persistent memory\n    const result = await this.mcpWrapper.retrieveMemory({\n      action: 'retrieve',\n      key: `agent/${this.id}/${key}`,\n      namespace: 'agent-memory',\n    });\n\n    return result ? JSON.parse(result) : null;\n  }\n\n  /**\n   * Learn from task execution\n   */\n  protected async learnFromExecution(task: any, result: ExecutionResult): Promise<void> {\n    const learningData = {\n      taskType: this.detectTaskType(task.description),\n      agentType: this.type,\n      success: result.success,\n      executionTime: result.executionTime,\n      patterns: this.extractPatterns(task, result),\n    };\n\n    // Train neural patterns\n    await this.mcpWrapper.trainNeural({\n      pattern_type: 'optimization',\n      training_data: JSON.stringify(learningData),\n      epochs: 10,\n    });\n  }\n\n  /**\n   * Handle task failure\n   */\n  protected async handleTaskFailure(taskId: string, error: any): Promise<void> {\n    // Update task status\n    await this.db.updateTask(taskId, {\n      status: 'failed',\n      error: error.message,\n      completed_at: new Date(),\n    });\n\n    // Update agent stats\n    await this.db.updateAgent(this.id, {\n      status: 'idle',\n      current_task_id: null,\n      error_count: this.db.raw('error_count + 1'),\n    });\n\n    // Clear current task\n    this.currentTask = null;\n    this.status = 'idle';\n\n    // Notify swarm of failure\n    await this.sendMessage(null, 'task_failed', {\n      taskId,\n      agentId: this.id,\n      error: error.message,\n      timestamp: new Date(),\n    });\n\n    this.emit('taskFailed', { taskId, error });\n  }\n\n  /**\n   * Start heartbeat loop\n   */\n  private startHeartbeatLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      this.lastHeartbeat = Date.now();\n\n      // Update last active timestamp\n      await this.db.updateAgent(this.id, {\n        last_active_at: new Date(),\n      });\n\n      this.emit('heartbeat');\n    }, 30000); // Every 30 seconds\n  }\n\n  /**\n   * Start communication processing loop\n   */\n  private startCommunicationLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive || this.communicationBuffer.length === 0) return;\n\n      // Process buffered messages\n      const messages = [...this.communicationBuffer];\n      this.communicationBuffer = [];\n\n      for (const message of messages) {\n        await this.processMessage(message);\n      }\n    }, 1000); // Every second\n  }\n\n  /**\n   * Start learning loop\n   */\n  private startLearningLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Analyze recent patterns\n        const patterns = await this.analyzeRecentPatterns();\n\n        // Update capabilities if needed\n        await this.updateCapabilities(patterns);\n      } catch (error) {\n        this.emit('learningError', error);\n      }\n    }, 300000); // Every 5 minutes\n  }\n\n  /**\n   * Process incoming message\n   */\n  protected async processMessage(message: Message): Promise<void> {\n    switch (message.type) {\n      case 'task_assignment':\n        await this.handleTaskAssignment(message.content);\n        break;\n\n      case 'consensus':\n        await this.handleConsensusRequest(message.content);\n        break;\n\n      case 'query':\n        await this.handleQuery(message);\n        break;\n\n      case 'coordination':\n        await this.handleCoordination(message.content);\n        break;\n\n      default:\n        this.emit('unknownMessage', message);\n    }\n  }\n\n  /**\n   * Check if agent is responsive\n   */\n  isResponsive(): boolean {\n    const timeout = 60000; // 1 minute\n    return Date.now() - this.lastHeartbeat < timeout;\n  }\n\n  /**\n   * Get agent state\n   */\n  getState(): any {\n    return {\n      id: this.id,\n      name: this.name,\n      type: this.type,\n      status: this.status,\n      currentTask: this.currentTask,\n      capabilities: this.capabilities,\n      messageCount: this.messageCount,\n      isResponsive: this.isResponsive(),\n      memory: Object.fromEntries(this.memory),\n    };\n  }\n\n  /**\n   * Shutdown the agent\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n\n    // Update status in database\n    await this.db.updateAgent(this.id, {\n      status: 'offline',\n    });\n\n    // Clear memory\n    this.memory.clear();\n    this.communicationBuffer = [];\n\n    this.emit('shutdown');\n  }\n\n  // Helper methods\n\n  private detectTaskType(description: string): string {\n    const lower = description.toLowerCase();\n\n    if (lower.includes('research') || lower.includes('investigate')) return 'research';\n    if (lower.includes('develop') || lower.includes('implement')) return 'development';\n    if (lower.includes('analyze') || lower.includes('review')) return 'analysis';\n    if (lower.includes('test') || lower.includes('validate')) return 'testing';\n    if (lower.includes('optimize') || lower.includes('improve')) return 'optimization';\n\n    return 'general';\n  }\n\n  private extractPatterns(task: any, result: ExecutionResult): any {\n    return {\n      taskComplexity: task.priority,\n      executionStrategy: task.strategy,\n      phasesCompleted: result.metadata?.phases?.length || 0,\n      timePerPhase: result.executionTime / (result.metadata?.phases?.length || 1),\n    };\n  }\n\n  private async analyzeRecentPatterns(): Promise<any> {\n    return this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'agent_patterns',\n      metadata: {\n        agentId: this.id,\n        agentType: this.type,\n        timeframe: '1h',\n      },\n    });\n  }\n\n  private async updateCapabilities(patterns: any): Promise<void> {\n    if (patterns.suggestedCapabilities) {\n      // Update capabilities based on learning\n      const newCapabilities = patterns.suggestedCapabilities.filter(\n        (cap: string) => !this.capabilities.includes(cap),\n      );\n\n      if (newCapabilities.length > 0) {\n        this.capabilities.push(...newCapabilities);\n\n        await this.db.updateAgent(this.id, {\n          capabilities: JSON.stringify(this.capabilities),\n        });\n\n        this.emit('capabilitiesUpdated', newCapabilities);\n      }\n    }\n  }\n\n  private async handleTaskAssignment(content: any): Promise<void> {\n    // Handle incoming task assignment\n    if (!this.currentTask && content.taskId) {\n      await this.assignTask(content.taskId, content.executionPlan || {});\n    }\n  }\n\n  private async handleConsensusRequest(content: any): Promise<void> {\n    // Analyze proposal and vote\n    const analysis = await this.analyzeProposal(content);\n    await this.voteOnProposal(content.proposalId, analysis.vote, analysis.reason);\n  }\n\n  private async handleQuery(message: Message): Promise<void> {\n    // Respond to query\n    const response = await this.processQuery(message.content);\n\n    if (message.fromAgentId) {\n      await this.sendMessage(message.fromAgentId, 'response', {\n        queryId: message.id,\n        response,\n      });\n    }\n  }\n\n  private async handleCoordination(content: any): Promise<void> {\n    // Handle coordination messages\n    this.emit('coordinationReceived', content);\n  }\n\n  private async analyzeProposal(proposal: any): Promise<any> {\n    // Simple analysis - can be overridden by specialized agents\n    return {\n      vote: Math.random() > 0.3, // 70% approval rate\n      reason: 'Based on agent analysis',\n    };\n  }\n\n  private async processQuery(query: any): Promise<any> {\n    // Process and respond to queries\n    return {\n      agentId: this.id,\n      agentType: this.type,\n      status: this.status,\n      response: 'Query processed',\n    };\n  }\n}\n"],"names":["EventEmitter","v4","uuidv4","DatabaseManager","MCPToolWrapper","Agent","id","name","type","swarmId","capabilities","createdAt","status","currentTask","messageCount","db","mcpWrapper","memory","communicationBuffer","lastHeartbeat","isActive","config","Date","Map","now","initialize","getInstance","existingAgent","getAgent","current_task_id","message_count","startHeartbeatLoop","startCommunicationLoop","startLearningLoop","emit","assignTask","taskId","executionPlan","Error","updateAgent","set","startTime","executeTask","catch","error","task","getTask","updateTaskStatus","result","executeByType","updateTask","JSON","stringify","progress","completed_at","learnFromExecution","success_count","raw","handleTaskFailure","phases","results","phase","phaseResult","executePhase","push","Math","round","indexOf","length","updateTaskProgress","communicateProgress","success","data","executionTime","agentId","metadata","plan","performAnalysis","performExecution","performValidation","analysis","analyzePattern","action","operation","description","agentType","storeInMemory","complexity","estimatedTime","requirements","actions","agentAssignments","find","a","responsibilities","actionResult","executeAction","validation","checks","passed","every","c","timestamp","sendMessage","toAgentId","messageType","content","message","fromAgentId","requiresResponse","createCommunication","from_agent_id","to_agent_id","swarm_id","message_type","priority","receiveMessage","voteOnProposal","proposalId","vote","reason","submitConsensusVote","last_progress_update","key","value","storeMemory","namespace","ttl","retrieveFromMemory","has","get","retrieveMemory","parse","learningData","taskType","detectTaskType","patterns","extractPatterns","trainNeural","pattern_type","training_data","epochs","error_count","setInterval","last_active_at","messages","processMessage","analyzeRecentPatterns","updateCapabilities","handleTaskAssignment","handleConsensusRequest","handleQuery","handleCoordination","isResponsive","timeout","getState","Object","fromEntries","shutdown","clear","lower","toLowerCase","includes","taskComplexity","executionStrategy","strategy","phasesCompleted","timePerPhase","timeframe","suggestedCapabilities","newCapabilities","filter","cap","analyzeProposal","response","processQuery","queryId","proposal","random","query"],"mappings":"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"}