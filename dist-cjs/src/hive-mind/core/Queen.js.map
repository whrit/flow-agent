{"version":3,"sources":["../../../../src/hive-mind/core/Queen.ts"],"sourcesContent":["/**\n * Queen Coordinator Class\n *\n * The Queen manages high-level coordination, decision-making,\n * and strategic planning for the Hive Mind swarm.\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Agent } from './Agent.js';\nimport { DatabaseManager } from './DatabaseManager.js';\nimport { MCPToolWrapper } from '../integration/MCPToolWrapper.js';\nimport {\n  SwarmTopology,\n  Task,\n  AgentType,\n  QueenMode,\n  ConsensusProposal,\n  QueenDecision,\n  CoordinationStrategy,\n} from '../types.js';\n\ninterface QueenConfig {\n  swarmId: string;\n  mode: QueenMode;\n  topology: SwarmTopology;\n}\n\nexport class Queen extends EventEmitter {\n  private id: string;\n  private config: QueenConfig;\n  private agents: Map<string, Agent>;\n  private taskQueue: Map<string, Task>;\n  private strategies: Map<string, CoordinationStrategy>;\n  private db: DatabaseManager;\n  private mcpWrapper: MCPToolWrapper;\n  private isActive: boolean = false;\n\n  constructor(config: QueenConfig) {\n    super();\n    this.id = uuidv4();\n    this.config = config;\n    this.agents = new Map();\n    this.taskQueue = new Map();\n    this.strategies = new Map();\n    this.initializeStrategies();\n  }\n\n  /**\n   * Initialize the Queen and her coordination capabilities\n   */\n  async initialize(): Promise<void> {\n    this.db = await DatabaseManager.getInstance();\n    this.mcpWrapper = new MCPToolWrapper();\n\n    // Create Queen as a special coordinator agent\n    await this.db.createAgent({\n      id: this.id,\n      swarmId: this.config.swarmId,\n      name: 'Queen',\n      type: 'coordinator',\n      capabilities: JSON.stringify([\n        'strategic_planning',\n        'task_allocation',\n        'consensus_coordination',\n        'performance_optimization',\n        'swarm_governance',\n      ]),\n      status: 'active',\n      metadata: JSON.stringify({ role: 'queen', mode: this.config.mode }),\n    });\n\n    this.isActive = true;\n\n    // Start coordination loops\n    this.startCoordinationLoop();\n    this.startOptimizationLoop();\n\n    this.emit('initialized');\n  }\n\n  /**\n   * Register a new agent with the Queen\n   */\n  async registerAgent(agent: Agent): Promise<void> {\n    this.agents.set(agent.id, agent);\n\n    // Analyze agent capabilities and update strategies\n    await this.analyzeAgentCapabilities(agent);\n\n    // Notify other agents in distributed mode\n    if (this.config.mode === 'distributed') {\n      await this.broadcastAgentRegistration(agent);\n    }\n\n    this.emit('agentRegistered', { agent });\n  }\n\n  /**\n   * Handle task submission\n   */\n  async onTaskSubmitted(task: Task): Promise<QueenDecision> {\n    this.taskQueue.set(task.id, task);\n\n    // Analyze task requirements\n    const analysis = await this.analyzeTask(task);\n\n    // Make strategic decision\n    const decision = await this.makeStrategicDecision(task, analysis);\n\n    // If consensus required, initiate consensus process\n    if (task.requireConsensus) {\n      await this.initiateConsensus(task, decision);\n    }\n\n    // Apply decision\n    await this.applyDecision(decision);\n\n    this.emit('taskDecision', { task, decision });\n\n    return decision;\n  }\n\n  /**\n   * Make a strategic decision about task execution\n   */\n  private async makeStrategicDecision(task: Task, analysis: any): Promise<QueenDecision> {\n    // Use MCP neural capabilities for decision making\n    const neuralAnalysis = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'task_strategy',\n      metadata: {\n        task: task.description,\n        priority: task.priority,\n        topology: this.config.topology,\n        availableAgents: this.getAvailableAgents().length,\n      },\n    });\n\n    // Select optimal strategy\n    const strategy = this.selectOptimalStrategy(task, analysis, neuralAnalysis);\n\n    // Identify best agents for the task\n    const selectedAgents = await this.selectAgentsForTask(task, strategy);\n\n    // Create execution plan\n    const executionPlan = this.createExecutionPlan(task, selectedAgents, strategy);\n\n    return {\n      id: uuidv4(),\n      taskId: task.id,\n      strategy,\n      selectedAgents: selectedAgents.map((a) => a.id),\n      executionPlan,\n      confidence: analysis.confidence || 0.85,\n      rationale: analysis.rationale || 'Strategic analysis completed',\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Select optimal coordination strategy\n   */\n  private selectOptimalStrategy(\n    task: Task,\n    analysis: any,\n    neuralAnalysis: any,\n  ): CoordinationStrategy {\n    // Strategy selection based on multiple factors\n    const factors = {\n      taskComplexity: analysis.complexity || 'medium',\n      agentAvailability: this.getAvailableAgents().length,\n      topology: this.config.topology,\n      priority: task.priority,\n      consensusRequired: task.requireConsensus,\n    };\n\n    // Use topology-specific strategies\n    if (this.config.topology === 'hierarchical' && factors.taskComplexity === 'high') {\n      return this.strategies.get('hierarchical-cascade')!;\n    }\n\n    if (this.config.topology === 'mesh' && factors.consensusRequired) {\n      return this.strategies.get('mesh-consensus')!;\n    }\n\n    if (factors.priority === 'critical') {\n      return this.strategies.get('priority-fast-track')!;\n    }\n\n    // Default adaptive strategy\n    return this.strategies.get('adaptive-default')!;\n  }\n\n  /**\n   * Select best agents for a task\n   */\n  private async selectAgentsForTask(task: Task, strategy: CoordinationStrategy): Promise<Agent[]> {\n    const availableAgents = this.getAvailableAgents();\n    const requiredCapabilities = task.requiredCapabilities || [];\n\n    // Score agents based on capabilities and current load\n    const scoredAgents = await Promise.all(\n      availableAgents.map(async (agent) => {\n        const score = await this.scoreAgentForTask(agent, task, requiredCapabilities);\n        return { agent, score };\n      }),\n    );\n\n    // Sort by score and select top agents\n    scoredAgents.sort((a, b) => b.score - a.score);\n\n    const maxAgents = Math.min(task.maxAgents, strategy.maxAgents || 3);\n    return scoredAgents.slice(0, maxAgents).map((sa) => sa.agent);\n  }\n\n  /**\n   * Score an agent for a specific task\n   */\n  private async scoreAgentForTask(\n    agent: Agent,\n    task: Task,\n    requiredCapabilities: string[],\n  ): Promise<number> {\n    let score = 0;\n\n    // Capability match\n    const capabilityMatches = requiredCapabilities.filter((cap) =>\n      agent.capabilities.includes(cap),\n    ).length;\n    score += capabilityMatches * 10;\n\n    // Agent type suitability\n    const typeSuitability = this.getTypeSuitabilityForTask(agent.type, task);\n    score += typeSuitability * 5;\n\n    // Current workload (prefer less busy agents)\n    if (agent.status === 'idle') score += 8;\n    else if (agent.status === 'active') score += 4;\n\n    // Historical performance (from database)\n    const performance = await this.db.getAgentPerformance(agent.id);\n    if (performance) {\n      score += performance.successRate * 10;\n    }\n\n    // Specialty bonus\n    if (agent.type === 'specialist' && requiredCapabilities.length > 0) {\n      score += 5;\n    }\n\n    return score;\n  }\n\n  /**\n   * Get type suitability score for a task\n   */\n  private getTypeSuitabilityForTask(agentType: AgentType, task: Task): number {\n    const suitabilityMap: Record<string, Record<AgentType, number>> = {\n      research: {\n        researcher: 10,\n        analyst: 8,\n        specialist: 6,\n        coder: 4,\n        coordinator: 5,\n        architect: 5,\n        tester: 3,\n        reviewer: 4,\n        optimizer: 4,\n        documenter: 6,\n        monitor: 3,\n      },\n      development: {\n        coder: 10,\n        architect: 8,\n        tester: 7,\n        reviewer: 6,\n        coordinator: 5,\n        specialist: 6,\n        researcher: 4,\n        analyst: 4,\n        optimizer: 5,\n        documenter: 4,\n        monitor: 3,\n      },\n      analysis: {\n        analyst: 10,\n        researcher: 8,\n        specialist: 6,\n        reviewer: 5,\n        coordinator: 5,\n        architect: 4,\n        coder: 4,\n        tester: 3,\n        optimizer: 5,\n        documenter: 4,\n        monitor: 4,\n      },\n      testing: {\n        tester: 10,\n        reviewer: 8,\n        analyst: 6,\n        coder: 5,\n        coordinator: 4,\n        specialist: 5,\n        researcher: 3,\n        architect: 4,\n        optimizer: 4,\n        documenter: 3,\n        monitor: 4,\n      },\n      optimization: {\n        optimizer: 10,\n        analyst: 8,\n        coder: 7,\n        architect: 6,\n        coordinator: 5,\n        specialist: 6,\n        researcher: 4,\n        tester: 4,\n        reviewer: 5,\n        documenter: 3,\n        monitor: 4,\n      },\n    };\n\n    // Detect task type from description\n    const taskType = this.detectTaskType(task.description);\n    return suitabilityMap[taskType]?.[agentType] || 5;\n  }\n\n  /**\n   * Detect task type from description\n   */\n  private detectTaskType(description: string): string {\n    const lower = description.toLowerCase();\n\n    if (lower.includes('research') || lower.includes('investigate') || lower.includes('explore')) {\n      return 'research';\n    }\n    if (\n      lower.includes('develop') ||\n      lower.includes('implement') ||\n      lower.includes('build') ||\n      lower.includes('create')\n    ) {\n      return 'development';\n    }\n    if (lower.includes('analyze') || lower.includes('review') || lower.includes('assess')) {\n      return 'analysis';\n    }\n    if (lower.includes('test') || lower.includes('validate') || lower.includes('verify')) {\n      return 'testing';\n    }\n    if (lower.includes('optimize') || lower.includes('improve') || lower.includes('enhance')) {\n      return 'optimization';\n    }\n\n    return 'general';\n  }\n\n  /**\n   * Create execution plan for task\n   */\n  private createExecutionPlan(task: Task, agents: Agent[], strategy: CoordinationStrategy): any {\n    return {\n      phases: strategy.phases || ['preparation', 'execution', 'validation'],\n      agentAssignments: agents.map((agent) => ({\n        agentId: agent.id,\n        role: this.determineAgentRole(agent, task),\n        responsibilities: this.getAgentResponsibilities(agent, task),\n      })),\n      coordinationPoints: strategy.coordinationPoints || ['start', 'midpoint', 'completion'],\n      checkpoints: this.createCheckpoints(task, strategy),\n      fallbackPlan: this.createFallbackPlan(task, agents),\n    };\n  }\n\n  /**\n   * Initiate consensus process\n   */\n  private async initiateConsensus(task: Task, decision: QueenDecision): Promise<void> {\n    const proposal: ConsensusProposal = {\n      id: uuidv4(),\n      swarmId: this.config.swarmId,\n      taskId: task.id,\n      proposal: {\n        decision,\n        task: task.description,\n        rationale: decision.rationale,\n      },\n      requiredThreshold: 0.66,\n      deadline: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\n    };\n\n    await this.db.createConsensusProposal(proposal);\n\n    // Notify all agents to vote\n    await this.broadcastConsensusRequest(proposal);\n  }\n\n  /**\n   * Apply Queen's decision\n   */\n  private async applyDecision(decision: QueenDecision): Promise<void> {\n    // Update task with assignments\n    await this.db.updateTask(decision.taskId, {\n      assigned_agents: JSON.stringify(decision.selectedAgents),\n      status: 'assigned',\n      assigned_at: new Date(),\n    });\n\n    // Notify selected agents\n    for (const agentId of decision.selectedAgents) {\n      const agent = this.agents.get(agentId);\n      if (agent) {\n        await agent.assignTask(decision.taskId, decision.executionPlan);\n      }\n    }\n\n    // Store decision in memory for learning\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `decision/${decision.taskId}`,\n      value: JSON.stringify(decision),\n      namespace: 'queen-decisions',\n      ttl: 86400 * 7, // 7 days\n    });\n  }\n\n  /**\n   * Start coordination loop\n   */\n  private startCoordinationLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Monitor agent health\n        await this.monitorAgentHealth();\n\n        // Check task progress\n        await this.checkTaskProgress();\n\n        // Rebalance if needed\n        await this.checkRebalancing();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 5000); // Every 5 seconds\n  }\n\n  /**\n   * Start optimization loop\n   */\n  private startOptimizationLoop(): void {\n    setInterval(async () => {\n      if (!this.isActive) return;\n\n      try {\n        // Analyze performance patterns\n        await this.analyzePerformancePatterns();\n\n        // Optimize strategies\n        await this.optimizeStrategies();\n\n        // Train neural patterns\n        await this.trainNeuralPatterns();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Initialize coordination strategies\n   */\n  private initializeStrategies(): void {\n    // Hierarchical cascade strategy\n    this.strategies.set('hierarchical-cascade', {\n      name: 'Hierarchical Cascade',\n      description: 'Top-down task distribution with clear delegation',\n      phases: ['planning', 'delegation', 'execution', 'aggregation'],\n      maxAgents: 5,\n      coordinationPoints: ['phase-transition', 'milestone', 'completion'],\n      suitable_for: ['complex-tasks', 'multi-phase-projects'],\n    });\n\n    // Mesh consensus strategy\n    this.strategies.set('mesh-consensus', {\n      name: 'Mesh Consensus',\n      description: 'Peer-to-peer coordination with consensus requirements',\n      phases: ['proposal', 'discussion', 'consensus', 'execution'],\n      maxAgents: 7,\n      coordinationPoints: ['consensus-check', 'progress-sync', 'final-vote'],\n      suitable_for: ['critical-decisions', 'collaborative-tasks'],\n    });\n\n    // Priority fast-track strategy\n    this.strategies.set('priority-fast-track', {\n      name: 'Priority Fast Track',\n      description: 'Rapid execution for critical tasks',\n      phases: ['immediate-assignment', 'parallel-execution', 'quick-validation'],\n      maxAgents: 3,\n      coordinationPoints: ['start', 'critical-path', 'completion'],\n      suitable_for: ['urgent-tasks', 'critical-fixes'],\n    });\n\n    // Adaptive default strategy\n    this.strategies.set('adaptive-default', {\n      name: 'Adaptive Default',\n      description: 'Flexible strategy that adapts to task requirements',\n      phases: ['analysis', 'planning', 'execution', 'review'],\n      maxAgents: 4,\n      coordinationPoints: ['checkpoint', 'adaptation-point', 'completion'],\n      suitable_for: ['general-tasks', 'unknown-complexity'],\n    });\n  }\n\n  /**\n   * Helper methods\n   */\n\n  private getAvailableAgents(): Agent[] {\n    return Array.from(this.agents.values()).filter(\n      (agent) => agent.status === 'idle' || agent.status === 'active',\n    );\n  }\n\n  private async analyzeTask(task: Task): Promise<any> {\n    // Use MCP tools to analyze task complexity and requirements\n    return this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'task_analysis',\n      metadata: {\n        description: task.description,\n        priority: task.priority,\n        dependencies: task.dependencies,\n      },\n    });\n  }\n\n  private async analyzeAgentCapabilities(agent: Agent): Promise<void> {\n    // Analyze and store agent capability patterns\n    await this.mcpWrapper.storeMemory({\n      action: 'store',\n      key: `agent-capabilities/${agent.id}`,\n      value: JSON.stringify({\n        type: agent.type,\n        capabilities: agent.capabilities,\n        registeredAt: new Date(),\n      }),\n      namespace: 'agent-registry',\n    });\n  }\n\n  private async broadcastAgentRegistration(agent: Agent): Promise<void> {\n    // In distributed mode, notify other Queens/coordinators\n    await this.db.createCommunication({\n      from_agent_id: this.id,\n      to_agent_id: null, // broadcast\n      swarm_id: this.config.swarmId,\n      message_type: 'broadcast',\n      content: JSON.stringify({\n        type: 'agent_registered',\n        agent: {\n          id: agent.id,\n          type: agent.type,\n          capabilities: agent.capabilities,\n        },\n      }),\n      priority: 'high',\n    });\n  }\n\n  private async broadcastConsensusRequest(proposal: ConsensusProposal): Promise<void> {\n    await this.db.createCommunication({\n      from_agent_id: this.id,\n      to_agent_id: null, // broadcast\n      swarm_id: this.config.swarmId,\n      message_type: 'consensus',\n      content: JSON.stringify(proposal),\n      priority: 'urgent',\n      requires_response: true,\n    });\n  }\n\n  private determineAgentRole(agent: Agent, task: Task): string {\n    // Determine specific role based on agent type and task\n    const roleMap: Record<AgentType, string> = {\n      coordinator: 'lead',\n      researcher: 'investigator',\n      coder: 'implementer',\n      analyst: 'evaluator',\n      architect: 'designer',\n      tester: 'validator',\n      reviewer: 'auditor',\n      optimizer: 'enhancer',\n      documenter: 'recorder',\n      monitor: 'observer',\n      specialist: 'expert',\n    };\n\n    return roleMap[agent.type] || 'contributor';\n  }\n\n  private getAgentResponsibilities(agent: Agent, task: Task): string[] {\n    // Define specific responsibilities based on role\n    const responsibilityMap: Record<AgentType, string[]> = {\n      coordinator: ['coordinate team', 'track progress', 'resolve conflicts'],\n      researcher: ['gather information', 'identify patterns', 'provide insights'],\n      coder: ['implement solution', 'write tests', 'debug issues'],\n      analyst: ['analyze data', 'identify bottlenecks', 'suggest improvements'],\n      architect: ['design system', 'define interfaces', 'ensure scalability'],\n      tester: ['write tests', 'find bugs', 'validate functionality'],\n      reviewer: ['review code', 'ensure quality', 'suggest improvements'],\n      optimizer: ['improve performance', 'reduce complexity', 'optimize resources'],\n      documenter: ['create documentation', 'update guides', 'maintain clarity'],\n      monitor: ['track metrics', 'alert on issues', 'ensure health'],\n      specialist: ['provide expertise', 'solve complex problems', 'guide implementation'],\n    };\n\n    return responsibilityMap[agent.type] || ['contribute to task'];\n  }\n\n  private createCheckpoints(task: Task, strategy: CoordinationStrategy): any[] {\n    return strategy.coordinationPoints.map((point, index) => ({\n      name: point,\n      expectedProgress: Math.round(((index + 1) / strategy.coordinationPoints.length) * 100),\n      actions: ['status_check', 'sync_progress', 'adjust_strategy'],\n    }));\n  }\n\n  private createFallbackPlan(task: Task, agents: Agent[]): any {\n    return {\n      triggers: ['agent_failure', 'deadline_approaching', 'consensus_failure'],\n      actions: [\n        'reassign_to_available_agents',\n        'escalate_to_queen',\n        'activate_backup_agents',\n        'simplify_task_requirements',\n      ],\n      escalation_path: ['team_lead', 'queen', 'human_operator'],\n    };\n  }\n\n  private async monitorAgentHealth(): Promise<void> {\n    for (const agent of this.agents.values()) {\n      if (agent.status === 'error' || !agent.isResponsive()) {\n        await this.handleAgentFailure(agent);\n      }\n    }\n  }\n\n  private async checkTaskProgress(): Promise<void> {\n    const activeTasks = await this.db.getActiveTasks(this.config.swarmId);\n\n    for (const task of activeTasks) {\n      if (this.isTaskStalled(task)) {\n        await this.handleStalledTask(task);\n      }\n    }\n  }\n\n  private async checkRebalancing(): Promise<void> {\n    const stats = await this.db.getSwarmStats(this.config.swarmId);\n\n    if (stats.agentUtilization > 0.9 || stats.taskBacklog > stats.agentCount * 2) {\n      this.emit('rebalanceNeeded', stats);\n    }\n  }\n\n  private async analyzePerformancePatterns(): Promise<void> {\n    const patterns = await this.mcpWrapper.analyzePattern({\n      action: 'analyze',\n      operation: 'performance_patterns',\n      metadata: {\n        swarmId: this.config.swarmId,\n        timeframe: '1h',\n      },\n    });\n\n    if (patterns.recommendations) {\n      await this.applyPerformanceRecommendations(patterns.recommendations);\n    }\n  }\n\n  private async optimizeStrategies(): Promise<void> {\n    // Analyze strategy effectiveness and adjust\n    const strategyPerformance = await this.db.getStrategyPerformance(this.config.swarmId);\n\n    for (const [strategyName, performance] of Object.entries(strategyPerformance)) {\n      if (performance.successRate < 0.7) {\n        await this.adjustStrategy(strategyName, performance);\n      }\n    }\n  }\n\n  private async trainNeuralPatterns(): Promise<void> {\n    // Train neural network on successful patterns\n    const successfulDecisions = await this.db.getSuccessfulDecisions(this.config.swarmId);\n\n    if (successfulDecisions.length > 10) {\n      await this.mcpWrapper.trainNeural({\n        pattern_type: 'coordination',\n        training_data: JSON.stringify(successfulDecisions),\n        epochs: 50,\n      });\n    }\n  }\n\n  private async handleAgentFailure(agent: Agent): Promise<void> {\n    // Reassign agent's tasks\n    if (agent.currentTask) {\n      await this.reassignTask(agent.currentTask, agent.id);\n    }\n\n    // Mark agent as offline\n    await this.db.updateAgentStatus(agent.id, 'offline');\n\n    this.emit('agentFailed', { agent });\n  }\n\n  private async handleStalledTask(task: any): Promise<void> {\n    // Implement stalled task recovery\n    this.emit('taskStalled', { task });\n  }\n\n  private isTaskStalled(task: any): boolean {\n    // Check if task hasn't progressed in reasonable time\n    const stalledThreshold = 10 * 60 * 1000; // 10 minutes\n    return (\n      task.last_progress_update &&\n      Date.now() - new Date(task.last_progress_update).getTime() > stalledThreshold\n    );\n  }\n\n  private async reassignTask(taskId: string, fromAgentId: string): Promise<void> {\n    const availableAgents = this.getAvailableAgents().filter((a) => a.id !== fromAgentId);\n\n    if (availableAgents.length > 0) {\n      const newAgent = availableAgents[0]; // Simple selection, could be more sophisticated\n      await this.db.reassignTask(taskId, newAgent.id);\n      await newAgent.assignTask(taskId, {});\n    }\n  }\n\n  private async applyPerformanceRecommendations(recommendations: any[]): Promise<void> {\n    // Apply recommended optimizations\n    for (const rec of recommendations) {\n      this.emit('performanceRecommendation', rec);\n    }\n  }\n\n  private async adjustStrategy(strategyName: string, performance: any): Promise<void> {\n    const strategy = this.strategies.get(strategyName);\n    if (strategy) {\n      // Adjust strategy parameters based on performance\n      if (performance.avgCompletionTime > performance.targetTime) {\n        strategy.maxAgents = Math.min(strategy.maxAgents + 1, 10);\n      }\n\n      this.emit('strategyAdjusted', { strategyName, performance });\n    }\n  }\n\n  /**\n   * Shutdown the Queen\n   */\n  async shutdown(): Promise<void> {\n    this.isActive = false;\n    this.emit('shutdown');\n  }\n}\n"],"names":["EventEmitter","v4","uuidv4","DatabaseManager","MCPToolWrapper","Queen","id","config","agents","taskQueue","strategies","db","mcpWrapper","isActive","Map","initializeStrategies","initialize","getInstance","createAgent","swarmId","name","type","capabilities","JSON","stringify","status","metadata","role","mode","startCoordinationLoop","startOptimizationLoop","emit","registerAgent","agent","set","analyzeAgentCapabilities","broadcastAgentRegistration","onTaskSubmitted","task","analysis","analyzeTask","decision","makeStrategicDecision","requireConsensus","initiateConsensus","applyDecision","neuralAnalysis","analyzePattern","action","operation","description","priority","topology","availableAgents","getAvailableAgents","length","strategy","selectOptimalStrategy","selectedAgents","selectAgentsForTask","executionPlan","createExecutionPlan","taskId","map","a","confidence","rationale","timestamp","Date","factors","taskComplexity","complexity","agentAvailability","consensusRequired","get","requiredCapabilities","scoredAgents","Promise","all","score","scoreAgentForTask","sort","b","maxAgents","Math","min","slice","sa","capabilityMatches","filter","cap","includes","typeSuitability","getTypeSuitabilityForTask","performance","getAgentPerformance","successRate","agentType","suitabilityMap","research","researcher","analyst","specialist","coder","coordinator","architect","tester","reviewer","optimizer","documenter","monitor","development","testing","optimization","taskType","detectTaskType","lower","toLowerCase","phases","agentAssignments","agentId","determineAgentRole","responsibilities","getAgentResponsibilities","coordinationPoints","checkpoints","createCheckpoints","fallbackPlan","createFallbackPlan","proposal","requiredThreshold","deadline","now","createConsensusProposal","broadcastConsensusRequest","updateTask","assigned_agents","assigned_at","assignTask","storeMemory","key","value","namespace","ttl","setInterval","monitorAgentHealth","checkTaskProgress","checkRebalancing","error","analyzePerformancePatterns","optimizeStrategies","trainNeuralPatterns","suitable_for","Array","from","values","dependencies","registeredAt","createCommunication","from_agent_id","to_agent_id","swarm_id","message_type","content","requires_response","roleMap","responsibilityMap","point","index","expectedProgress","round","actions","triggers","escalation_path","isResponsive","handleAgentFailure","activeTasks","getActiveTasks","isTaskStalled","handleStalledTask","stats","getSwarmStats","agentUtilization","taskBacklog","agentCount","patterns","timeframe","recommendations","applyPerformanceRecommendations","strategyPerformance","getStrategyPerformance","strategyName","Object","entries","adjustStrategy","successfulDecisions","getSuccessfulDecisions","trainNeural","pattern_type","training_data","epochs","currentTask","reassignTask","updateAgentStatus","stalledThreshold","last_progress_update","getTime","fromAgentId","newAgent","rec","avgCompletionTime","targetTime","shutdown"],"mappings":"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"}