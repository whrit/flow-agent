{"version":3,"sources":["../../../src/hive-mind/memory.js"],"sourcesContent":["/**\n * Hive Mind Collective Memory System\n * \n * Provides distributed, persistent memory with intelligent caching,\n * pattern recognition, and cross-agent knowledge sharing\n */\n\nimport { EventEmitter } from 'node:events';\nimport { generateId } from '../utils/helpers.js';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\nexport class CollectiveMemory extends EventEmitter {\n  constructor(config = {}) {\n    super();\n    \n    this.config = {\n      persistenceDir: config.persistenceDir || './data/hive-memory',\n      maxMemorySize: config.maxMemorySize || 100 * 1024 * 1024, // 100MB\n      compressionThreshold: config.compressionThreshold || 10 * 1024, // 10KB\n      syncInterval: config.syncInterval || 30000, // 30 seconds\n      defaultTTL: config.defaultTTL || 7 * 24 * 60 * 60 * 1000, // 7 days\n      maxCacheSize: config.maxCacheSize || 1000,\n      enableCompression: config.enableCompression !== false,\n      enablePatternDetection: config.enablePatternDetection !== false,\n      shardCount: config.shardCount || 16,\n      ...config\n    };\n    \n    // Memory storage\n    this.memory = new Map(); // In-memory cache\n    this.memoryIndex = new Map(); // Search index\n    this.accessLog = new Map(); // Access patterns\n    this.shards = new Map(); // Distributed shards\n    \n    // Pattern detection\n    this.patterns = new Map();\n    this.relationships = new Map(); // Key relationships\n    this.hotKeys = new Set();\n    this.coldKeys = new Set();\n    \n    // Persistence\n    this.persistenceQueue = [];\n    this.lastSync = 0;\n    this.isDirty = false;\n    \n    // Statistics\n    this.stats = {\n      totalKeys: 0,\n      totalSize: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      patternDetections: 0,\n      compressionSaved: 0,\n      lastCleanup: 0\n    };\n    \n    this.initialized = false;\n    this.init();\n  }\n\n  /**\n   * Initialize the memory system\n   */\n  async init() {\n    try {\n      // Create persistence directory\n      await fs.mkdir(this.config.persistenceDir, { recursive: true });\n      \n      // Load existing memory\n      await this.loadFromDisk();\n      \n      // Initialize shards\n      this.initializeShards();\n      \n      // Start background tasks\n      this.startBackgroundTasks();\n      \n      this.initialized = true;\n      this.emit('initialized');\n      \n      console.log(`Collective memory initialized with ${this.memory.size} entries`);\n    } catch (error) {\n      console.error('Failed to initialize collective memory:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize distributed shards\n   */\n  initializeShards() {\n    for (let i = 0; i < this.config.shardCount; i++) {\n      this.shards.set(i, {\n        id: i,\n        keys: new Set(),\n        size: 0,\n        lastAccess: Date.now(),\n        hotness: 0\n      });\n    }\n  }\n\n  /**\n   * Get shard for a key\n   */\n  getShardForKey(key) {\n    const hash = this.hashKey(key);\n    return hash % this.config.shardCount;\n  }\n\n  /**\n   * Simple hash function for key distribution\n   */\n  hashKey(key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      const char = key.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return Math.abs(hash);\n  }\n\n  /**\n   * Store data in collective memory\n   */\n  async store(key, value, options = {}) {\n    if (!this.initialized) {\n      throw new Error('Memory system not initialized');\n    }\n\n    const namespace = options.namespace || 'default';\n    const ttl = options.ttl || this.config.defaultTTL;\n    const agent = options.agent || 'system';\n    const tags = options.tags || [];\n    const priority = options.priority || 'normal';\n    const compression = options.compression !== false && this.config.enableCompression;\n    \n    const fullKey = `${namespace}:${key}`;\n    const serializedValue = JSON.stringify(value);\n    const originalSize = Buffer.byteLength(serializedValue, 'utf8');\n    \n    let storedValue = serializedValue;\n    let compressed = false;\n    let compressionRatio = 1;\n    \n    // Apply compression if beneficial\n    if (compression && originalSize > this.config.compressionThreshold) {\n      const compressedValue = await this.compressData(serializedValue);\n      if (compressedValue.length < originalSize * 0.8) {\n        storedValue = compressedValue;\n        compressed = true;\n        compressionRatio = originalSize / compressedValue.length;\n        this.stats.compressionSaved += originalSize - compressedValue.length;\n      }\n    }\n    \n    const entry = {\n      key: fullKey,\n      value: storedValue,\n      originalValue: value, // Keep uncompressed for cache\n      size: Buffer.byteLength(storedValue, 'utf8'),\n      originalSize,\n      compressed,\n      compressionRatio,\n      namespace,\n      agent,\n      tags: new Set(tags),\n      priority,\n      \n      // Metadata\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      expiresAt: ttl ? Date.now() + ttl : null,\n      version: 1,\n      \n      // Access tracking\n      accessCount: 0,\n      lastAccessed: Date.now(),\n      accessHistory: [],\n      \n      // Relationships\n      relationships: new Set(),\n      derivedFrom: options.derivedFrom ? new Set([options.derivedFrom]) : new Set(),\n      \n      // Flags\n      persistent: options.persistent !== false,\n      shareable: options.shareable !== false,\n      cacheable: options.cacheable !== false\n    };\n    \n    // Update existing entry or create new\n    const existingEntry = this.memory.get(fullKey);\n    if (existingEntry) {\n      entry.version = existingEntry.version + 1;\n      entry.createdAt = existingEntry.createdAt;\n      entry.accessCount = existingEntry.accessCount;\n      entry.accessHistory = existingEntry.accessHistory;\n      entry.relationships = existingEntry.relationships;\n    }\n    \n    // Store in memory\n    this.memory.set(fullKey, entry);\n    this.updateIndex(fullKey, entry);\n    this.updateShard(fullKey, entry);\n    \n    // Update statistics\n    this.stats.totalKeys = this.memory.size;\n    this.stats.totalSize += entry.size;\n    if (existingEntry) {\n      this.stats.totalSize -= existingEntry.size;\n    }\n    \n    // Mark as dirty for persistence\n    this.isDirty = true;\n    this.queueForPersistence(entry);\n    \n    // Detect patterns if enabled\n    if (this.config.enablePatternDetection) {\n      this.detectPatterns(entry);\n    }\n    \n    // Update relationships\n    this.updateRelationships(fullKey, entry);\n    \n    this.emit('stored', {\n      key: fullKey,\n      size: entry.size,\n      compressed,\n      agent,\n      namespace\n    });\n    \n    // Cleanup if memory is getting full\n    if (this.memory.size > this.config.maxCacheSize) {\n      await this.cleanup();\n    }\n    \n    return fullKey;\n  }\n\n  /**\n   * Retrieve data from memory\n   */\n  async retrieve(key, options = {}) {\n    const namespace = options.namespace || 'default';\n    const fullKey = `${namespace}:${key}`;\n    const agent = options.agent || 'system';\n    const decompress = options.decompress !== false;\n    \n    let entry = this.memory.get(fullKey);\n    \n    if (entry) {\n      this.stats.cacheHits++;\n    } else {\n      this.stats.cacheMisses++;\n      \n      // Try to load from disk\n      entry = await this.loadFromDisk(fullKey);\n      if (entry) {\n        this.memory.set(fullKey, entry);\n      }\n    }\n    \n    if (!entry) {\n      return null;\n    }\n    \n    // Check expiration\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\n      await this.delete(key, { namespace });\n      return null;\n    }\n    \n    // Update access tracking\n    entry.accessCount++;\n    entry.lastAccessed = Date.now();\n    entry.accessHistory.push({\n      agent,\n      timestamp: Date.now(),\n      operation: 'read'\n    });\n    \n    // Keep recent access history limited\n    if (entry.accessHistory.length > 100) {\n      entry.accessHistory = entry.accessHistory.slice(-50);\n    }\n    \n    // Update hotness tracking\n    this.updateHotness(fullKey, entry);\n    \n    // Log access pattern\n    this.logAccess(fullKey, agent, 'read');\n    \n    this.emit('retrieved', {\n      key: fullKey,\n      agent,\n      accessCount: entry.accessCount\n    });\n    \n    // Return decompressed value if needed\n    if (entry.compressed && decompress) {\n      if (entry.originalValue) {\n        return entry.originalValue;\n      }\n      try {\n        const decompressed = await this.decompressData(entry.value);\n        const parsed = JSON.parse(decompressed);\n        entry.originalValue = parsed; // Cache for future access\n        return parsed;\n      } catch (error) {\n        console.error(`Failed to decompress data for key ${fullKey}:`, error);\n        return null;\n      }\n    }\n    \n    if (entry.originalValue) {\n      return entry.originalValue;\n    }\n    \n    try {\n      return JSON.parse(entry.value);\n    } catch (error) {\n      console.error(`Failed to parse data for key ${fullKey}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Delete data from memory\n   */\n  async delete(key, options = {}) {\n    const namespace = options.namespace || 'default';\n    const fullKey = `${namespace}:${key}`;\n    \n    const entry = this.memory.get(fullKey);\n    if (!entry) {\n      return false;\n    }\n    \n    // Remove from memory\n    this.memory.delete(fullKey);\n    this.removeFromIndex(fullKey);\n    this.removeFromShard(fullKey);\n    \n    // Update statistics\n    this.stats.totalKeys = this.memory.size;\n    this.stats.totalSize -= entry.size;\n    \n    // Remove relationships\n    this.removeRelationships(fullKey);\n    \n    // Mark for persistence cleanup\n    this.queueForDeletion(fullKey);\n    \n    this.emit('deleted', { key: fullKey });\n    \n    return true;\n  }\n\n  /**\n   * Search memory entries\n   */\n  async search(query, options = {}) {\n    const namespace = options.namespace;\n    const tags = options.tags;\n    const agent = options.agent;\n    const limit = options.limit || 100;\n    const sortBy = options.sortBy || 'relevance';\n    \n    let results = [];\n    \n    // Search through memory entries\n    for (const [key, entry] of this.memory) {\n      if (namespace && entry.namespace !== namespace) continue;\n      if (agent && entry.agent !== agent) continue;\n      \n      let score = 0;\n      \n      // Key matching\n      if (key.toLowerCase().includes(query.toLowerCase())) {\n        score += 10;\n      }\n      \n      // Tag matching\n      if (tags && tags.length > 0) {\n        const matchingTags = tags.filter(tag => entry.tags.has(tag));\n        score += matchingTags.length * 5;\n      }\n      \n      // Content search (basic)\n      if (entry.originalValue) {\n        const content = JSON.stringify(entry.originalValue).toLowerCase();\n        if (content.includes(query.toLowerCase())) {\n          score += 3;\n        }\n      }\n      \n      if (score > 0) {\n        results.push({\n          key,\n          entry,\n          score,\n          relevance: score\n        });\n      }\n    }\n    \n    // Sort results\n    switch (sortBy) {\n      case 'relevance':\n        results.sort((a, b) => b.score - a.score);\n        break;\n      case 'recent':\n        results.sort((a, b) => b.entry.lastAccessed - a.entry.lastAccessed);\n        break;\n      case 'created':\n        results.sort((a, b) => b.entry.createdAt - a.entry.createdAt);\n        break;\n      case 'access':\n        results.sort((a, b) => b.entry.accessCount - a.entry.accessCount);\n        break;\n    }\n    \n    return results.slice(0, limit).map(r => ({\n      key: r.key,\n      value: r.entry.originalValue || JSON.parse(r.entry.value),\n      score: r.score,\n      metadata: {\n        namespace: r.entry.namespace,\n        agent: r.entry.agent,\n        tags: Array.from(r.entry.tags),\n        accessCount: r.entry.accessCount,\n        lastAccessed: r.entry.lastAccessed,\n        createdAt: r.entry.createdAt\n      }\n    }));\n  }\n\n  /**\n   * Get related keys\n   */\n  getRelatedKeys(key, options = {}) {\n    const namespace = options.namespace || 'default';\n    const fullKey = `${namespace}:${key}`;\n    const maxResults = options.limit || 10;\n    \n    const relationships = this.relationships.get(fullKey);\n    if (!relationships) {\n      return [];\n    }\n    \n    return Array.from(relationships.entries())\n      .map(([relatedKey, strength]) => ({\n        key: relatedKey,\n        strength,\n        entry: this.memory.get(relatedKey)\n      }))\n      .filter(r => r.entry)\n      .sort((a, b) => b.strength - a.strength)\n      .slice(0, maxResults);\n  }\n\n  /**\n   * Share memory between agents\n   */\n  async shareMemory(fromAgent, toAgent, keys, options = {}) {\n    const shared = [];\n    const namespace = options.namespace || 'default';\n    \n    for (const key of keys) {\n      const fullKey = `${namespace}:${key}`;\n      const entry = this.memory.get(fullKey);\n      \n      if (!entry || !entry.shareable) {\n        continue;\n      }\n      \n      // Create shared copy\n      const sharedKey = `shared:${toAgent}:${key}`;\n      await this.store(sharedKey, entry.originalValue || JSON.parse(entry.value), {\n        namespace: 'shared',\n        agent: toAgent,\n        derivedFrom: fullKey,\n        tags: [...entry.tags, 'shared', 'from:' + fromAgent],\n        ttl: options.ttl || entry.expiresAt ? entry.expiresAt - Date.now() : undefined\n      });\n      \n      shared.push({\n        originalKey: fullKey,\n        sharedKey: `shared:${sharedKey}`,\n        agent: toAgent\n      });\n    }\n    \n    this.emit('memory:shared', {\n      fromAgent,\n      toAgent,\n      keys: shared.length\n    });\n    \n    return shared;\n  }\n\n  /**\n   * Pattern detection\n   */\n  detectPatterns(entry) {\n    // Co-access patterns\n    this.detectCoAccessPatterns(entry);\n    \n    // Temporal patterns\n    this.detectTemporalPatterns(entry);\n    \n    // Content similarity patterns\n    this.detectContentPatterns(entry);\n    \n    // Agent behavior patterns\n    this.detectAgentPatterns(entry);\n  }\n\n  /**\n   * Detect co-access patterns\n   */\n  detectCoAccessPatterns(entry) {\n    const recentAccesses = Array.from(this.accessLog.entries())\n      .filter(([_, log]) => Date.now() - log.timestamp < 3600000) // Last hour\n      .map(([key, log]) => key);\n    \n    if (recentAccesses.length < 2) return;\n    \n    for (const accessedKey of recentAccesses) {\n      if (accessedKey === entry.key) continue;\n      \n      const pattern = this.patterns.get(`co-access:${entry.key}:${accessedKey}`) || {\n        type: 'co-access',\n        keys: [entry.key, accessedKey],\n        frequency: 0,\n        confidence: 0,\n        lastSeen: 0\n      };\n      \n      pattern.frequency++;\n      pattern.lastSeen = Date.now();\n      pattern.confidence = Math.min(1.0, pattern.frequency / 10);\n      \n      this.patterns.set(`co-access:${entry.key}:${accessedKey}`, pattern);\n      \n      if (pattern.confidence > 0.7) {\n        this.updateRelationship(entry.key, accessedKey, pattern.confidence);\n      }\n    }\n  }\n\n  /**\n   * Detect temporal access patterns\n   */\n  detectTemporalPatterns(entry) {\n    if (entry.accessHistory.length < 5) return;\n    \n    const intervals = [];\n    for (let i = 1; i < entry.accessHistory.length; i++) {\n      intervals.push(entry.accessHistory[i].timestamp - entry.accessHistory[i-1].timestamp);\n    }\n    \n    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\n    const variance = intervals.reduce((sum, interval) => \n      sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;\n    \n    if (variance < avgInterval * 0.2) { // Low variance indicates pattern\n      const pattern = {\n        type: 'temporal',\n        key: entry.key,\n        avgInterval,\n        confidence: 1 - (variance / avgInterval),\n        nextPredicted: entry.lastAccessed + avgInterval\n      };\n      \n      this.patterns.set(`temporal:${entry.key}`, pattern);\n    }\n  }\n\n  /**\n   * Update key relationships\n   */\n  updateRelationship(key1, key2, strength) {\n    if (!this.relationships.has(key1)) {\n      this.relationships.set(key1, new Map());\n    }\n    if (!this.relationships.has(key2)) {\n      this.relationships.set(key2, new Map());\n    }\n    \n    this.relationships.get(key1).set(key2, strength);\n    this.relationships.get(key2).set(key1, strength);\n  }\n\n  /**\n   * Update memory index for search\n   */\n  updateIndex(key, entry) {\n    // Index by tags\n    for (const tag of entry.tags) {\n      if (!this.memoryIndex.has(`tag:${tag}`)) {\n        this.memoryIndex.set(`tag:${tag}`, new Set());\n      }\n      this.memoryIndex.get(`tag:${tag}`).add(key);\n    }\n    \n    // Index by agent\n    if (!this.memoryIndex.has(`agent:${entry.agent}`)) {\n      this.memoryIndex.set(`agent:${entry.agent}`, new Set());\n    }\n    this.memoryIndex.get(`agent:${entry.agent}`).add(key);\n    \n    // Index by namespace\n    if (!this.memoryIndex.has(`namespace:${entry.namespace}`)) {\n      this.memoryIndex.set(`namespace:${entry.namespace}`, new Set());\n    }\n    this.memoryIndex.get(`namespace:${entry.namespace}`).add(key);\n  }\n\n  /**\n   * Update shard information\n   */\n  updateShard(key, entry) {\n    const shardId = this.getShardForKey(key);\n    const shard = this.shards.get(shardId);\n    \n    if (!shard.keys.has(key)) {\n      shard.keys.add(key);\n      shard.size += entry.size;\n    }\n    \n    shard.lastAccess = Date.now();\n    shard.hotness = Math.min(10, shard.hotness + 0.1);\n  }\n\n  /**\n   * Update hotness tracking\n   */\n  updateHotness(key, entry) {\n    const now = Date.now();\n    const recentAccesses = entry.accessHistory.filter(\n      access => now - access.timestamp < 3600000 // Last hour\n    ).length;\n    \n    if (recentAccesses > 5) {\n      this.hotKeys.add(key);\n      this.coldKeys.delete(key);\n    } else if (recentAccesses === 0 && now - entry.lastAccessed > 86400000) {\n      this.coldKeys.add(key);\n      this.hotKeys.delete(key);\n    }\n  }\n\n  /**\n   * Log access pattern\n   */\n  logAccess(key, agent, operation) {\n    this.accessLog.set(key, {\n      key,\n      agent,\n      operation,\n      timestamp: Date.now()\n    });\n    \n    // Limit access log size\n    if (this.accessLog.size > 10000) {\n      const entries = Array.from(this.accessLog.entries())\n        .sort(([,a], [,b]) => b.timestamp - a.timestamp)\n        .slice(0, 5000);\n      \n      this.accessLog.clear();\n      for (const [key, log] of entries) {\n        this.accessLog.set(key, log);\n      }\n    }\n  }\n\n  /**\n   * Compress data\n   */\n  async compressData(data) {\n    // Simple compression - in production, use actual compression library\n    return Buffer.from(data).toString('base64');\n  }\n\n  /**\n   * Decompress data\n   */\n  async decompressData(data) {\n    // Simple decompression - in production, use actual compression library\n    return Buffer.from(data, 'base64').toString();\n  }\n\n  /**\n   * Queue entry for persistence\n   */\n  queueForPersistence(entry) {\n    this.persistenceQueue.push({\n      action: 'store',\n      entry\n    });\n  }\n\n  /**\n   * Queue key for deletion\n   */\n  queueForDeletion(key) {\n    this.persistenceQueue.push({\n      action: 'delete',\n      key\n    });\n  }\n\n  /**\n   * Save memory to disk\n   */\n  async saveToDisk() {\n    if (!this.isDirty && this.persistenceQueue.length === 0) {\n      return;\n    }\n    \n    try {\n      // Process persistence queue\n      for (const item of this.persistenceQueue) {\n        if (item.action === 'store') {\n          const filename = path.join(\n            this.config.persistenceDir,\n            `${item.entry.namespace}_${this.hashKey(item.entry.key) % 100}.json`\n          );\n          \n          let data = {};\n          try {\n            const existing = await fs.readFile(filename, 'utf8');\n            data = JSON.parse(existing);\n          } catch (error) {\n            // File doesn't exist, start with empty object\n          }\n          \n          data[item.entry.key] = {\n            ...item.entry,\n            accessHistory: [], // Don't persist full history\n            originalValue: undefined // Don't persist cached value\n          };\n          \n          await fs.writeFile(filename, JSON.stringify(data, null, 2));\n        } else if (item.action === 'delete') {\n          // Handle deletion from disk\n          const namespace = item.key.split(':')[0];\n          const filename = path.join(\n            this.config.persistenceDir,\n            `${namespace}_${this.hashKey(item.key) % 100}.json`\n          );\n          \n          try {\n            const existing = await fs.readFile(filename, 'utf8');\n            const data = JSON.parse(existing);\n            delete data[item.key];\n            await fs.writeFile(filename, JSON.stringify(data, null, 2));\n          } catch (error) {\n            // File doesn't exist or other error - ignore\n          }\n        }\n      }\n      \n      this.persistenceQueue = [];\n      this.isDirty = false;\n      this.lastSync = Date.now();\n      \n      this.emit('persisted', { entries: this.memory.size });\n    } catch (error) {\n      console.error('Failed to save memory to disk:', error);\n      this.emit('persistence:error', error);\n    }\n  }\n\n  /**\n   * Load memory from disk\n   */\n  async loadFromDisk(specificKey = null) {\n    try {\n      const files = await fs.readdir(this.config.persistenceDir);\n      \n      for (const file of files) {\n        if (!file.endsWith('.json')) continue;\n        \n        const filepath = path.join(this.config.persistenceDir, file);\n        const data = JSON.parse(await fs.readFile(filepath, 'utf8'));\n        \n        for (const [key, entry] of Object.entries(data)) {\n          if (specificKey && key !== specificKey) continue;\n          \n          // Restore entry\n          entry.tags = new Set(entry.tags || []);\n          entry.relationships = new Set(entry.relationships || []);\n          entry.derivedFrom = new Set(entry.derivedFrom || []);\n          entry.accessHistory = [];\n          entry.originalValue = undefined;\n          \n          this.memory.set(key, entry);\n          this.updateIndex(key, entry);\n          this.updateShard(key, entry);\n          \n          if (specificKey === key) {\n            return entry;\n          }\n        }\n      }\n      \n      return specificKey ? null : true;\n    } catch (error) {\n      console.error('Failed to load memory from disk:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Start background maintenance tasks\n   */\n  startBackgroundTasks() {\n    // Sync to disk periodically\n    setInterval(() => {\n      this.saveToDisk();\n    }, this.config.syncInterval);\n    \n    // Cleanup expired entries\n    setInterval(() => {\n      this.cleanup();\n    }, 60000); // Every minute\n    \n    // Update statistics\n    setInterval(() => {\n      this.updateStatistics();\n    }, 10000); // Every 10 seconds\n  }\n\n  /**\n   * Cleanup expired entries and optimize memory\n   */\n  async cleanup() {\n    const now = Date.now();\n    let cleaned = 0;\n    \n    for (const [key, entry] of this.memory) {\n      // Remove expired entries\n      if (entry.expiresAt && now > entry.expiresAt) {\n        await this.delete(key.split(':')[1], { namespace: entry.namespace });\n        cleaned++;\n        continue;\n      }\n      \n      // Remove old, rarely accessed entries if memory is full\n      if (this.memory.size > this.config.maxCacheSize * 0.9) {\n        const daysSinceAccess = (now - entry.lastAccessed) / 86400000;\n        if (daysSinceAccess > 7 && entry.accessCount < 2) {\n          await this.delete(key.split(':')[1], { namespace: entry.namespace });\n          cleaned++;\n        }\n      }\n    }\n    \n    this.stats.lastCleanup = now;\n    \n    if (cleaned > 0) {\n      this.emit('cleanup:completed', { entriesRemoved: cleaned });\n    }\n  }\n\n  /**\n   * Update internal statistics\n   */\n  updateStatistics() {\n    this.stats.totalKeys = this.memory.size;\n    this.stats.totalSize = Array.from(this.memory.values())\n      .reduce((sum, entry) => sum + entry.size, 0);\n  }\n\n  /**\n   * Get memory statistics\n   */\n  getStatistics() {\n    const hitRate = this.stats.cacheHits + this.stats.cacheMisses > 0 ?\n      this.stats.cacheHits / (this.stats.cacheHits + this.stats.cacheMisses) : 0;\n    \n    return {\n      ...this.stats,\n      hitRate,\n      hotKeys: this.hotKeys.size,\n      coldKeys: this.coldKeys.size,\n      patterns: this.patterns.size,\n      relationships: this.relationships.size,\n      shards: Array.from(this.shards.values()).map(s => ({\n        id: s.id,\n        keyCount: s.keys.size,\n        size: s.size,\n        hotness: s.hotness\n      })),\n      memoryUsage: {\n        used: this.stats.totalSize,\n        max: this.config.maxMemorySize,\n        percentage: (this.stats.totalSize / this.config.maxMemorySize) * 100\n      }\n    };\n  }\n\n  /**\n   * Remove entry from index\n   */\n  removeFromIndex(key) {\n    for (const [indexKey, keys] of this.memoryIndex) {\n      if (keys.has(key)) {\n        keys.delete(key);\n        if (keys.size === 0) {\n          this.memoryIndex.delete(indexKey);\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove entry from shard\n   */\n  removeFromShard(key) {\n    const shardId = this.getShardForKey(key);\n    const shard = this.shards.get(shardId);\n    \n    if (shard && shard.keys.has(key)) {\n      shard.keys.delete(key);\n      const entry = this.memory.get(key);\n      if (entry) {\n        shard.size -= entry.size;\n      }\n    }\n  }\n\n  /**\n   * Remove relationships for a key\n   */\n  removeRelationships(key) {\n    const relationships = this.relationships.get(key);\n    if (relationships) {\n      for (const relatedKey of relationships.keys()) {\n        const relatedRels = this.relationships.get(relatedKey);\n        if (relatedRels) {\n          relatedRels.delete(key);\n          if (relatedRels.size === 0) {\n            this.relationships.delete(relatedKey);\n          }\n        }\n      }\n      this.relationships.delete(key);\n    }\n  }\n\n  /**\n   * Shutdown memory system\n   */\n  async shutdown() {\n    console.log('Shutting down collective memory...');\n    \n    // Save all pending changes\n    await this.saveToDisk();\n    \n    this.emit('shutdown');\n    this.removeAllListeners();\n  }\n}"],"names":["EventEmitter","fs","path","CollectiveMemory","config","persistenceDir","maxMemorySize","compressionThreshold","syncInterval","defaultTTL","maxCacheSize","enableCompression","enablePatternDetection","shardCount","memory","Map","memoryIndex","accessLog","shards","patterns","relationships","hotKeys","Set","coldKeys","persistenceQueue","lastSync","isDirty","stats","totalKeys","totalSize","cacheHits","cacheMisses","patternDetections","compressionSaved","lastCleanup","initialized","init","mkdir","recursive","loadFromDisk","initializeShards","startBackgroundTasks","emit","console","log","size","error","i","set","id","keys","lastAccess","Date","now","hotness","getShardForKey","key","hash","hashKey","length","char","charCodeAt","Math","abs","store","value","options","Error","namespace","ttl","agent","tags","priority","compression","fullKey","serializedValue","JSON","stringify","originalSize","Buffer","byteLength","storedValue","compressed","compressionRatio","compressedValue","compressData","entry","originalValue","createdAt","updatedAt","expiresAt","version","accessCount","lastAccessed","accessHistory","derivedFrom","persistent","shareable","cacheable","existingEntry","get","updateIndex","updateShard","queueForPersistence","detectPatterns","updateRelationships","cleanup","retrieve","decompress","delete","push","timestamp","operation","slice","updateHotness","logAccess","decompressed","decompressData","parsed","parse","removeFromIndex","removeFromShard","removeRelationships","queueForDeletion","search","query","limit","sortBy","results","score","toLowerCase","includes","matchingTags","filter","tag","has","content","relevance","sort","a","b","map","r","metadata","Array","from","getRelatedKeys","maxResults","entries","relatedKey","strength","shareMemory","fromAgent","toAgent","shared","sharedKey","undefined","originalKey","detectCoAccessPatterns","detectTemporalPatterns","detectContentPatterns","detectAgentPatterns","recentAccesses","_","accessedKey","pattern","type","frequency","confidence","lastSeen","min","updateRelationship","intervals","avgInterval","reduce","sum","interval","variance","pow","nextPredicted","key1","key2","add","shardId","shard","access","clear","data","toString","action","saveToDisk","item","filename","join","existing","readFile","writeFile","split","specificKey","files","readdir","file","endsWith","filepath","Object","setInterval","updateStatistics","cleaned","daysSinceAccess","entriesRemoved","values","getStatistics","hitRate","s","keyCount","memoryUsage","used","max","percentage","indexKey","relatedRels","shutdown","removeAllListeners"],"mappings":"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"}