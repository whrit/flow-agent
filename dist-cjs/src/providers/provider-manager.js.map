{"version":3,"sources":["../../../src/providers/provider-manager.ts"],"sourcesContent":["/**\n * Provider Manager - Central orchestration for multi-LLM providers\n * Handles provider selection, fallback, load balancing, and cost optimization\n */\n\nimport { EventEmitter } from 'events';\nimport { ILogger } from '../core/logger.js';\nimport { ConfigManager } from '../config/config-manager.js';\nimport {\n  ILLMProvider,\n  LLMProvider,\n  LLMProviderConfig,\n  LLMRequest,\n  LLMResponse,\n  LLMStreamEvent,\n  LLMModel,\n  FallbackStrategy,\n  FallbackRule,\n  LoadBalancer,\n  ProviderMetrics,\n  CostOptimizer,\n  CostConstraints,\n  OptimizationResult,\n  RateLimiter,\n  ProviderMonitor,\n  CacheConfig,\n  LLMProviderError,\n  RateLimitError,\n  isRateLimitError,\n} from './types.js';\n\n// Import providers\nimport { AnthropicProvider } from './anthropic-provider.js';\nimport { OpenAIProvider } from './openai-provider.js';\nimport { GoogleProvider } from './google-provider.js';\nimport { CohereProvider } from './cohere-provider.js';\nimport { OllamaProvider } from './ollama-provider.js';\n\nexport interface ProviderManagerConfig {\n  providers: Record<LLMProvider, LLMProviderConfig>;\n  defaultProvider: LLMProvider;\n  fallbackStrategy?: FallbackStrategy;\n  loadBalancing?: {\n    enabled: boolean;\n    strategy: 'round-robin' | 'least-loaded' | 'latency-based' | 'cost-based';\n  };\n  costOptimization?: {\n    enabled: boolean;\n    maxCostPerRequest?: number;\n    preferredProviders?: LLMProvider[];\n  };\n  caching?: CacheConfig;\n  monitoring?: {\n    enabled: boolean;\n    metricsInterval: number;\n  };\n}\n\nexport class ProviderManager extends EventEmitter {\n  private providers: Map<LLMProvider, ILLMProvider> = new Map();\n  private logger: ILogger;\n  private config: ProviderManagerConfig;\n  private requestCount: Map<LLMProvider, number> = new Map();\n  private lastUsed: Map<LLMProvider, Date> = new Map();\n  private providerMetrics: Map<LLMProvider, ProviderMetrics[]> = new Map();\n  private cache: Map<string, { response: LLMResponse; timestamp: Date }> = new Map();\n  private currentProviderIndex = 0;\n\n  constructor(logger: ILogger, configManager: ConfigManager, config: ProviderManagerConfig) {\n    super();\n    this.logger = logger;\n    this.config = config;\n\n    // Initialize providers\n    this.initializeProviders();\n\n    // Start monitoring if enabled\n    if (config.monitoring?.enabled) {\n      this.startMonitoring();\n    }\n  }\n\n  /**\n   * Initialize all configured providers\n   */\n  private async initializeProviders(): Promise<void> {\n    for (const [providerName, providerConfig] of Object.entries(this.config.providers)) {\n      try {\n        const provider = await this.createProvider(providerName as LLMProvider, providerConfig);\n        if (provider) {\n          this.providers.set(providerName as LLMProvider, provider);\n          this.requestCount.set(providerName as LLMProvider, 0);\n          this.logger.info(`Initialized ${providerName} provider`);\n        }\n      } catch (error) {\n        this.logger.error(`Failed to initialize ${providerName} provider`, error);\n      }\n    }\n\n    if (this.providers.size === 0) {\n      throw new Error('No providers could be initialized');\n    }\n  }\n\n  /**\n   * Create a provider instance\n   */\n  private async createProvider(name: LLMProvider, config: LLMProviderConfig): Promise<ILLMProvider | null> {\n    const providerOptions = {\n      logger: this.logger,\n      config,\n    };\n\n    try {\n      let provider: ILLMProvider;\n\n      switch (name) {\n        case 'anthropic':\n          provider = new AnthropicProvider(providerOptions);\n          break;\n        case 'openai':\n          provider = new OpenAIProvider(providerOptions);\n          break;\n        case 'google':\n          provider = new GoogleProvider(providerOptions);\n          break;\n        case 'cohere':\n          provider = new CohereProvider(providerOptions);\n          break;\n        case 'ollama':\n          provider = new OllamaProvider(providerOptions);\n          break;\n        default:\n          this.logger.warn(`Unknown provider: ${name}`);\n          return null;\n      }\n\n      await provider.initialize();\n      \n      // Set up event listeners\n      provider.on('response', (data) => this.handleProviderResponse(name, data));\n      provider.on('error', (error) => this.handleProviderError(name, error));\n      provider.on('health_check', (result) => this.handleHealthCheck(name, result));\n\n      return provider;\n    } catch (error) {\n      this.logger.error(`Failed to create ${name} provider`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Complete a request using the appropriate provider\n   */\n  async complete(request: LLMRequest): Promise<LLMResponse> {\n    // Check cache first\n    if (this.config.caching?.enabled) {\n      const cached = this.checkCache(request);\n      if (cached) {\n        this.logger.debug('Returning cached response');\n        return cached;\n      }\n    }\n\n    // Select provider based on strategy\n    const provider = await this.selectProvider(request);\n    \n    try {\n      const response = await provider.complete(request);\n      \n      // Cache successful response\n      if (this.config.caching?.enabled) {\n        this.cacheResponse(request, response);\n      }\n      \n      // Update metrics\n      this.updateProviderMetrics(provider.name, {\n        success: true,\n        latency: response.latency || 0,\n        cost: response.cost?.totalCost || 0,\n      });\n      \n      return response;\n    } catch (error) {\n      // Handle error and potentially fallback\n      return this.handleRequestError(error, request, provider);\n    }\n  }\n\n  /**\n   * Stream complete a request\n   */\n  async *streamComplete(request: LLMRequest): AsyncIterable<LLMStreamEvent> {\n    const provider = await this.selectProvider(request);\n    \n    try {\n      yield* provider.streamComplete(request);\n      \n      // Update metrics\n      this.updateProviderMetrics(provider.name, {\n        success: true,\n        latency: 0, // Will be updated by stream events\n        cost: 0, // Will be updated by stream events\n      });\n    } catch (error) {\n      // Handle error and potentially fallback\n      const fallbackProvider = await this.getFallbackProvider(error, provider);\n      if (fallbackProvider) {\n        this.logger.info(`Falling back to ${fallbackProvider.name} provider`);\n        yield* fallbackProvider.streamComplete(request);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Select the best provider for a request\n   */\n  private async selectProvider(request: LLMRequest): Promise<ILLMProvider> {\n    // If specific provider requested\n    if (request.providerOptions?.preferredProvider) {\n      const provider = this.providers.get(request.providerOptions.preferredProvider);\n      if (provider && this.isProviderAvailable(provider)) {\n        return provider;\n      }\n    }\n\n    // Cost optimization\n    if (this.config.costOptimization?.enabled && request.costConstraints) {\n      const optimized = await this.selectOptimalProvider(request);\n      if (optimized) {\n        return optimized;\n      }\n    }\n\n    // Load balancing\n    if (this.config.loadBalancing?.enabled) {\n      return this.selectLoadBalancedProvider();\n    }\n\n    // Default provider\n    const defaultProvider = this.providers.get(this.config.defaultProvider);\n    if (defaultProvider && this.isProviderAvailable(defaultProvider)) {\n      return defaultProvider;\n    }\n\n    // First available provider\n    for (const provider of this.providers.values()) {\n      if (this.isProviderAvailable(provider)) {\n        return provider;\n      }\n    }\n\n    throw new Error('No available providers');\n  }\n\n  /**\n   * Select provider based on cost optimization\n   */\n  private async selectOptimalProvider(request: LLMRequest): Promise<ILLMProvider | null> {\n    let bestProvider: ILLMProvider | null = null;\n    let bestCost = Infinity;\n\n    for (const provider of this.providers.values()) {\n      if (!this.isProviderAvailable(provider)) continue;\n\n      try {\n        const estimate = await provider.estimateCost(request);\n        \n        if (estimate.estimatedCost.total < bestCost &&\n            (!request.costConstraints?.maxCostPerRequest || \n             estimate.estimatedCost.total <= request.costConstraints.maxCostPerRequest)) {\n          bestCost = estimate.estimatedCost.total;\n          bestProvider = provider;\n        }\n      } catch (error) {\n        this.logger.warn(`Failed to estimate cost for ${provider.name}`, error);\n      }\n    }\n\n    return bestProvider;\n  }\n\n  /**\n   * Select provider using load balancing\n   */\n  private selectLoadBalancedProvider(): ILLMProvider {\n    const availableProviders = Array.from(this.providers.values()).filter(p => \n      this.isProviderAvailable(p)\n    );\n\n    if (availableProviders.length === 0) {\n      throw new Error('No available providers');\n    }\n\n    switch (this.config.loadBalancing?.strategy) {\n      case 'round-robin':\n        return this.roundRobinSelect(availableProviders);\n        \n      case 'least-loaded':\n        return this.leastLoadedSelect(availableProviders);\n        \n      case 'latency-based':\n        return this.latencyBasedSelect(availableProviders);\n        \n      case 'cost-based':\n        return this.costBasedSelect(availableProviders);\n        \n      default:\n        return availableProviders[0];\n    }\n  }\n\n  /**\n   * Round-robin provider selection\n   */\n  private roundRobinSelect(providers: ILLMProvider[]): ILLMProvider {\n    const provider = providers[this.currentProviderIndex % providers.length];\n    this.currentProviderIndex++;\n    return provider;\n  }\n\n  /**\n   * Select least loaded provider\n   */\n  private leastLoadedSelect(providers: ILLMProvider[]): ILLMProvider {\n    let minLoad = Infinity;\n    let selectedProvider = providers[0];\n\n    for (const provider of providers) {\n      const status = provider.getStatus();\n      if (status.currentLoad < minLoad) {\n        minLoad = status.currentLoad;\n        selectedProvider = provider;\n      }\n    }\n\n    return selectedProvider;\n  }\n\n  /**\n   * Select provider with lowest latency\n   */\n  private latencyBasedSelect(providers: ILLMProvider[]): ILLMProvider {\n    let minLatency = Infinity;\n    let selectedProvider = providers[0];\n\n    for (const provider of providers) {\n      const metrics = this.providerMetrics.get(provider.name);\n      if (metrics && metrics.length > 0) {\n        const avgLatency = metrics.reduce((sum, m) => sum + m.latency, 0) / metrics.length;\n        if (avgLatency < minLatency) {\n          minLatency = avgLatency;\n          selectedProvider = provider;\n        }\n      }\n    }\n\n    return selectedProvider;\n  }\n\n  /**\n   * Select provider with lowest cost\n   */\n  private costBasedSelect(providers: ILLMProvider[]): ILLMProvider {\n    let minCost = Infinity;\n    let selectedProvider = providers[0];\n\n    for (const provider of providers) {\n      const metrics = this.providerMetrics.get(provider.name);\n      if (metrics && metrics.length > 0) {\n        const avgCost = metrics.reduce((sum, m) => sum + m.cost, 0) / metrics.length;\n        if (avgCost < minCost) {\n          minCost = avgCost;\n          selectedProvider = provider;\n        }\n      }\n    }\n\n    return selectedProvider;\n  }\n\n  /**\n   * Check if provider is available\n   */\n  private isProviderAvailable(provider: ILLMProvider): boolean {\n    const status = provider.getStatus();\n    return status.available;\n  }\n\n  /**\n   * Handle request error with fallback\n   */\n  private async handleRequestError(\n    error: unknown,\n    request: LLMRequest,\n    failedProvider: ILLMProvider\n  ): Promise<LLMResponse> {\n    this.logger.error(`Provider ${failedProvider.name} failed`, error);\n    \n    // Update metrics\n    this.updateProviderMetrics(failedProvider.name, {\n      success: false,\n      latency: 0,\n      cost: 0,\n    });\n\n    // Try fallback\n    const fallbackProvider = await this.getFallbackProvider(error, failedProvider);\n    if (fallbackProvider) {\n      this.logger.info(`Falling back to ${fallbackProvider.name} provider`);\n      return fallbackProvider.complete(request);\n    }\n\n    throw error;\n  }\n\n  /**\n   * Get fallback provider based on error\n   */\n  private async getFallbackProvider(\n    error: unknown,\n    failedProvider: ILLMProvider\n  ): Promise<ILLMProvider | null> {\n    if (!this.config.fallbackStrategy?.enabled) {\n      return null;\n    }\n\n    const errorCondition = this.getErrorCondition(error);\n    const fallbackRule = this.config.fallbackStrategy.rules.find(rule => \n      rule.condition === errorCondition\n    );\n\n    if (!fallbackRule) {\n      return null;\n    }\n\n    // Find first available fallback provider\n    for (const providerName of fallbackRule.fallbackProviders) {\n      const provider = this.providers.get(providerName);\n      if (provider && provider !== failedProvider && this.isProviderAvailable(provider)) {\n        return provider;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine error condition for fallback\n   */\n  private getErrorCondition(error: unknown): FallbackRule['condition'] {\n    if (isRateLimitError(error)) {\n      return 'rate_limit';\n    }\n    \n    if (error instanceof LLMProviderError) {\n      if (error.statusCode === 503) {\n        return 'unavailable';\n      }\n      if (error.code === 'TIMEOUT') {\n        return 'timeout';\n      }\n    }\n    \n    return 'error';\n  }\n\n  /**\n   * Cache management\n   */\n  private checkCache(request: LLMRequest): LLMResponse | null {\n    const cacheKey = this.generateCacheKey(request);\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached) {\n      const age = Date.now() - cached.timestamp.getTime();\n      if (age < (this.config.caching?.ttl || 3600) * 1000) {\n        return cached.response;\n      }\n      // Remove expired entry\n      this.cache.delete(cacheKey);\n    }\n    \n    return null;\n  }\n\n  private cacheResponse(request: LLMRequest, response: LLMResponse): void {\n    const cacheKey = this.generateCacheKey(request);\n    this.cache.set(cacheKey, {\n      response,\n      timestamp: new Date(),\n    });\n    \n    // Cleanup old cache entries\n    if (this.cache.size > 1000) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n  }\n\n  private generateCacheKey(request: LLMRequest): string {\n    return JSON.stringify({\n      model: request.model,\n      messages: request.messages,\n      temperature: request.temperature,\n      maxTokens: request.maxTokens,\n    });\n  }\n\n  /**\n   * Update provider metrics\n   */\n  private updateProviderMetrics(\n    provider: LLMProvider,\n    metrics: { success: boolean; latency: number; cost: number }\n  ): void {\n    const count = this.requestCount.get(provider) || 0;\n    this.requestCount.set(provider, count + 1);\n    this.lastUsed.set(provider, new Date());\n\n    const providerMetricsList = this.providerMetrics.get(provider) || [];\n    const errorRate = metrics.success ? 0 : 1;\n    const successRate = metrics.success ? 1 : 0;\n\n    providerMetricsList.push({\n      provider,\n      timestamp: new Date(),\n      latency: metrics.latency,\n      errorRate,\n      successRate,\n      load: this.providers.get(provider)?.getStatus().currentLoad || 0,\n      cost: metrics.cost,\n      availability: this.providers.get(provider)?.getStatus().available ? 1 : 0,\n    });\n\n    // Keep only recent metrics (last 100)\n    if (providerMetricsList.length > 100) {\n      providerMetricsList.shift();\n    }\n\n    this.providerMetrics.set(provider, providerMetricsList);\n  }\n\n  /**\n   * Event handlers\n   */\n  private handleProviderResponse(provider: LLMProvider, data: any): void {\n    this.emit('provider_response', { provider, ...data });\n  }\n\n  private handleProviderError(provider: LLMProvider, error: any): void {\n    this.emit('provider_error', { provider, error });\n  }\n\n  private handleHealthCheck(provider: LLMProvider, result: any): void {\n    this.emit('health_check', { provider, result });\n  }\n\n  /**\n   * Start monitoring\n   */\n  private startMonitoring(): void {\n    setInterval(() => {\n      this.emitMetrics();\n    }, this.config.monitoring?.metricsInterval || 60000);\n  }\n\n  /**\n   * Emit aggregated metrics\n   */\n  private emitMetrics(): void {\n    const metrics = {\n      providers: {} as Record<LLMProvider, any>,\n      totalRequests: 0,\n      totalCost: 0,\n      averageLatency: 0,\n    };\n\n    for (const [provider, count] of this.requestCount.entries()) {\n      const providerMetricsList = this.providerMetrics.get(provider) || [];\n      const avgLatency = providerMetricsList.length > 0\n        ? providerMetricsList.reduce((sum, m) => sum + m.latency, 0) / providerMetricsList.length\n        : 0;\n      const totalCost = providerMetricsList.reduce((sum, m) => sum + m.cost, 0);\n\n      metrics.providers[provider] = {\n        requests: count,\n        averageLatency: avgLatency,\n        totalCost,\n        lastUsed: this.lastUsed.get(provider),\n        available: this.providers.get(provider)?.getStatus().available,\n      };\n\n      metrics.totalRequests += count;\n      metrics.totalCost += totalCost;\n    }\n\n    if (metrics.totalRequests > 0) {\n      let totalLatency = 0;\n      let latencyCount = 0;\n      \n      for (const providerMetricsList of this.providerMetrics.values()) {\n        for (const metric of providerMetricsList) {\n          totalLatency += metric.latency;\n          latencyCount++;\n        }\n      }\n      \n      metrics.averageLatency = latencyCount > 0 ? totalLatency / latencyCount : 0;\n    }\n\n    this.emit('metrics', metrics);\n  }\n\n  /**\n   * Get available providers\n   */\n  getAvailableProviders(): LLMProvider[] {\n    return Array.from(this.providers.keys()).filter(name => {\n      const provider = this.providers.get(name);\n      return provider && this.isProviderAvailable(provider);\n    });\n  }\n\n  /**\n   * Get provider by name\n   */\n  getProvider(name: LLMProvider): ILLMProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  /**\n   * Get all providers\n   */\n  getAllProviders(): Map<LLMProvider, ILLMProvider> {\n    return new Map(this.providers);\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    for (const provider of this.providers.values()) {\n      provider.destroy();\n    }\n    \n    this.providers.clear();\n    this.cache.clear();\n    this.providerMetrics.clear();\n    this.removeAllListeners();\n  }\n}"],"names":["EventEmitter","LLMProviderError","isRateLimitError","AnthropicProvider","OpenAIProvider","GoogleProvider","CohereProvider","OllamaProvider","ProviderManager","providers","Map","logger","config","requestCount","lastUsed","providerMetrics","cache","currentProviderIndex","configManager","initializeProviders","monitoring","enabled","startMonitoring","providerName","providerConfig","Object","entries","provider","createProvider","set","info","error","size","Error","name","providerOptions","warn","initialize","on","data","handleProviderResponse","handleProviderError","result","handleHealthCheck","complete","request","caching","cached","checkCache","debug","selectProvider","response","cacheResponse","updateProviderMetrics","success","latency","cost","totalCost","handleRequestError","streamComplete","fallbackProvider","getFallbackProvider","preferredProvider","get","isProviderAvailable","costOptimization","costConstraints","optimized","selectOptimalProvider","loadBalancing","selectLoadBalancedProvider","defaultProvider","values","bestProvider","bestCost","Infinity","estimate","estimateCost","estimatedCost","total","maxCostPerRequest","availableProviders","Array","from","filter","p","length","strategy","roundRobinSelect","leastLoadedSelect","latencyBasedSelect","costBasedSelect","minLoad","selectedProvider","status","getStatus","currentLoad","minLatency","metrics","avgLatency","reduce","sum","m","minCost","avgCost","available","failedProvider","fallbackStrategy","errorCondition","getErrorCondition","fallbackRule","rules","find","rule","condition","fallbackProviders","statusCode","code","cacheKey","generateCacheKey","age","Date","now","timestamp","getTime","ttl","delete","oldestKey","keys","next","value","JSON","stringify","model","messages","temperature","maxTokens","count","providerMetricsList","errorRate","successRate","push","load","availability","shift","emit","setInterval","emitMetrics","metricsInterval","totalRequests","averageLatency","requests","totalLatency","latencyCount","metric","getAvailableProviders","getProvider","getAllProviders","destroy","clear","removeAllListeners"],"mappings":"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"}