{"version":3,"sources":["../../../src/agents/agent-loader.ts"],"sourcesContent":["/**\n * Dynamic Agent Loader - Reads agent definitions from .claude/agents/ directory\n * This is the single source of truth for all agent types in the system\n */\n\nimport { readFileSync, existsSync } from 'node:fs';\nimport { glob } from 'glob';\nimport { resolve, dirname } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\n\n// Legacy agent type mapping for backward compatibility\nconst LEGACY_AGENT_MAPPING = {\n  analyst: 'code-analyzer',\n  coordinator: 'task-orchestrator', \n  optimizer: 'perf-analyzer',\n  documenter: 'api-docs',\n  monitor: 'performance-benchmarker',\n  specialist: 'system-architect',\n  architect: 'system-architect',\n} as const;\n\n/**\n * Resolve legacy agent types to current equivalents\n */\nfunction resolveLegacyAgentType(legacyType: string): string {\n  return LEGACY_AGENT_MAPPING[legacyType as keyof typeof LEGACY_AGENT_MAPPING] || legacyType;\n}\n\nexport interface AgentDefinition {\n  name: string;\n  type?: string;\n  color?: string;\n  description: string;\n  capabilities?: string[];\n  priority?: 'low' | 'medium' | 'high' | 'critical';\n  hooks?: {\n    pre?: string;\n    post?: string;\n  };\n  content?: string; // The markdown content after frontmatter\n}\n\nexport interface AgentCategory {\n  name: string;\n  agents: AgentDefinition[];\n}\n\nclass AgentLoader {\n  private agentCache: Map<string, AgentDefinition> = new Map();\n  private categoriesCache: AgentCategory[] = [];\n  private lastLoadTime = 0;\n  private cacheExpiry = 60000; // 1 minute cache\n\n  /**\n   * Get the .claude/agents directory path\n   */\n  private getAgentsDirectory(): string {\n    // Start from current working directory and walk up to find .claude/agents\n    let currentDir = process.cwd();\n    \n    while (currentDir !== '/') {\n      const claudeAgentsPath = resolve(currentDir, '.claude', 'agents');\n      if (existsSync(claudeAgentsPath)) {\n        return claudeAgentsPath;\n      }\n      currentDir = dirname(currentDir);\n    }\n    \n    // Fallback to relative path\n    return resolve(process.cwd(), '.claude', 'agents');\n  }\n\n  /**\n   * Parse agent definition from markdown file\n   */\n  private parseAgentFile(filePath: string): AgentDefinition | null {\n    try {\n      const content = readFileSync(filePath, 'utf-8');\n      \n      // Split frontmatter and content\n      const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);\n      if (!frontmatterMatch) {\n        console.warn(`No frontmatter found in ${filePath}`);\n        return null;\n      }\n\n      const [, yamlContent, markdownContent] = frontmatterMatch;\n      const frontmatter = parseYaml(yamlContent);\n\n      if (!frontmatter.name || !frontmatter.metadata?.description) {\n        console.warn(`Missing required fields (name, metadata.description) in ${filePath}`);\n        return null;\n      }\n\n      return {\n        name: frontmatter.name,\n        type: frontmatter.type,\n        color: frontmatter.color,\n        description: frontmatter.metadata.description,\n        capabilities: frontmatter.metadata.capabilities || frontmatter.capabilities || [],\n        priority: frontmatter.priority || 'medium',\n        hooks: frontmatter.hooks,\n        content: markdownContent.trim(),\n      };\n    } catch (error) {\n      console.error(`Error parsing agent file ${filePath}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Load all agent definitions from .claude/agents directory\n   */\n  private async loadAgents(): Promise<void> {\n    const agentsDir = this.getAgentsDirectory();\n    \n    if (!existsSync(agentsDir)) {\n      console.warn(`Agents directory not found: ${agentsDir}`);\n      return;\n    }\n\n    // Find all .md files in the agents directory\n    const agentFiles = await glob('**/*.md', {\n      cwd: agentsDir,\n      ignore: ['**/README.md', '**/MIGRATION_SUMMARY.md'],\n      absolute: true,\n    });\n\n    // Clear cache\n    this.agentCache.clear();\n    this.categoriesCache = [];\n\n    // Track categories\n    const categoryMap = new Map<string, AgentDefinition[]>();\n\n    // Parse each agent file\n    for (const filePath of agentFiles) {\n      const agent = this.parseAgentFile(filePath);\n      if (agent) {\n        this.agentCache.set(agent.name, agent);\n        \n        // Determine category from file path\n        const relativePath = filePath.replace(agentsDir, '');\n        const pathParts = relativePath.split('/');\n        const category = pathParts[1] || 'uncategorized'; // First directory after agents/\n        \n        if (!categoryMap.has(category)) {\n          categoryMap.set(category, []);\n        }\n        categoryMap.get(category)!.push(agent);\n      }\n    }\n\n    // Build categories array\n    this.categoriesCache = Array.from(categoryMap.entries()).map(([name, agents]) => ({\n      name,\n      agents: agents.sort((a, b) => a.name.localeCompare(b.name)),\n    }));\n\n    this.lastLoadTime = Date.now();\n  }\n\n  /**\n   * Check if cache needs refresh\n   */\n  private needsRefresh(): boolean {\n    return Date.now() - this.lastLoadTime > this.cacheExpiry;\n  }\n\n  /**\n   * Ensure agents are loaded and cache is fresh\n   */\n  private async ensureLoaded(): Promise<void> {\n    if (this.agentCache.size === 0 || this.needsRefresh()) {\n      await this.loadAgents();\n    }\n  }\n\n  /**\n   * Get all available agent types\n   */\n  async getAvailableAgentTypes(): Promise<string[]> {\n    await this.ensureLoaded();\n    const currentTypes = Array.from(this.agentCache.keys());\n    const legacyTypes = Object.keys(LEGACY_AGENT_MAPPING);\n    // Return both current types and legacy types, removing duplicates\n    const combined = [...currentTypes, ...legacyTypes];\n    const uniqueTypes = Array.from(new Set(combined));\n    return uniqueTypes.sort();\n  }\n\n  /**\n   * Get agent definition by name\n   */\n  async getAgent(name: string): Promise<AgentDefinition | null> {\n    await this.ensureLoaded();\n    // First try the original name, then try the legacy mapping\n    return this.agentCache.get(name) || this.agentCache.get(resolveLegacyAgentType(name)) || null;\n  }\n\n  /**\n   * Get all agent definitions\n   */\n  async getAllAgents(): Promise<AgentDefinition[]> {\n    await this.ensureLoaded();\n    return Array.from(this.agentCache.values()).sort((a, b) => a.name.localeCompare(b.name));\n  }\n\n  /**\n   * Get agents organized by category\n   */\n  async getAgentCategories(): Promise<AgentCategory[]> {\n    await this.ensureLoaded();\n    return this.categoriesCache;\n  }\n\n  /**\n   * Search agents by capabilities, description, or name\n   */\n  async searchAgents(query: string): Promise<AgentDefinition[]> {\n    await this.ensureLoaded();\n    const lowerQuery = query.toLowerCase();\n    \n    return Array.from(this.agentCache.values()).filter(agent => {\n      return (\n        agent.name.toLowerCase().includes(lowerQuery) ||\n        agent.description.toLowerCase().includes(lowerQuery) ||\n        agent.capabilities?.some(cap => cap.toLowerCase().includes(lowerQuery)) ||\n        false\n      );\n    });\n  }\n\n  /**\n   * Check if an agent type is valid\n   */\n  async isValidAgentType(name: string): Promise<boolean> {\n    await this.ensureLoaded();\n    // First try the original name, then try the legacy mapping\n    return this.agentCache.has(name) || this.agentCache.has(resolveLegacyAgentType(name));\n  }\n\n  /**\n   * Get agents by category name\n   */\n  async getAgentsByCategory(category: string): Promise<AgentDefinition[]> {\n    const categories = await this.getAgentCategories();\n    const found = categories.find(cat => cat.name === category);\n    return found?.agents || [];\n  }\n\n  /**\n   * Force refresh the agent cache\n   */\n  async refresh(): Promise<void> {\n    this.lastLoadTime = 0; // Force reload\n    await this.loadAgents();\n  }\n}\n\n// Singleton instance\nexport const agentLoader = new AgentLoader();\n\n// Convenience functions\nexport const getAvailableAgentTypes = () => agentLoader.getAvailableAgentTypes();\nexport const getAgent = (name: string) => agentLoader.getAgent(name);\nexport const getAllAgents = () => agentLoader.getAllAgents();\nexport const getAgentCategories = () => agentLoader.getAgentCategories();\nexport const searchAgents = (query: string) => agentLoader.searchAgents(query);\nexport const isValidAgentType = (name: string) => agentLoader.isValidAgentType(name);\nexport const getAgentsByCategory = (category: string) => agentLoader.getAgentsByCategory(category);\nexport const refreshAgents = () => agentLoader.refresh();\n\n// Export legacy mapping utilities\nexport { resolveLegacyAgentType, LEGACY_AGENT_MAPPING };"],"names":["readFileSync","existsSync","glob","resolve","dirname","parse","parseYaml","LEGACY_AGENT_MAPPING","analyst","coordinator","optimizer","documenter","monitor","specialist","architect","resolveLegacyAgentType","legacyType","AgentLoader","agentCache","Map","categoriesCache","lastLoadTime","cacheExpiry","getAgentsDirectory","currentDir","process","cwd","claudeAgentsPath","parseAgentFile","filePath","content","frontmatterMatch","match","console","warn","yamlContent","markdownContent","frontmatter","name","metadata","description","type","color","capabilities","priority","hooks","trim","error","loadAgents","agentsDir","agentFiles","ignore","absolute","clear","categoryMap","agent","set","relativePath","replace","pathParts","split","category","has","get","push","Array","from","entries","map","agents","sort","a","b","localeCompare","Date","now","needsRefresh","ensureLoaded","size","getAvailableAgentTypes","currentTypes","keys","legacyTypes","Object","combined","uniqueTypes","Set","getAgent","getAllAgents","values","getAgentCategories","searchAgents","query","lowerQuery","toLowerCase","filter","includes","some","cap","isValidAgentType","getAgentsByCategory","categories","found","find","cat","refresh","agentLoader","refreshAgents"],"mappings":"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"}