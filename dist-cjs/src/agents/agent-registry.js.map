{"version":3,"sources":["../../../src/agents/agent-registry.ts"],"sourcesContent":["/**\n * Agent Registry with Memory Integration\n * Provides persistent storage and coordination for agent management\n */\n\nimport type { DistributedMemorySystem } from '../memory/distributed-memory.js';\nimport type { AgentState, AgentId, AgentType, AgentStatus } from '../swarm/types.js';\nimport { EventEmitter } from 'node:events';\n\nexport interface AgentRegistryEntry {\n  agent: AgentState;\n  createdAt: Date;\n  lastUpdated: Date;\n  tags: string[];\n  metadata: Record<string, any>;\n}\n\nexport interface AgentQuery {\n  type?: AgentType;\n  status?: AgentStatus;\n  tags?: string[];\n  healthThreshold?: number;\n  namePattern?: string;\n  createdAfter?: Date;\n  lastActiveAfter?: Date;\n}\n\nexport interface AgentStatistics {\n  totalAgents: number;\n  byType: Record<AgentType, number>;\n  byStatus: Record<AgentStatus, number>;\n  averageHealth: number;\n  activeAgents: number;\n  totalUptime: number;\n  tasksCompleted: number;\n  successRate: number;\n}\n\n/**\n * Centralized agent registry with persistent storage\n */\nexport class AgentRegistry extends EventEmitter {\n  private memory: DistributedMemorySystem;\n  private namespace: string;\n  private cache = new Map<string, AgentRegistryEntry>();\n  private cacheExpiry = 60000; // 1 minute\n  private lastCacheUpdate = 0;\n\n  constructor(memory: DistributedMemorySystem, namespace: string = 'agents') {\n    super();\n    this.memory = memory;\n    this.namespace = namespace;\n  }\n\n  async initialize(): Promise<void> {\n    await this.loadFromMemory();\n    this.emit('registry:initialized');\n  }\n\n  /**\n   * Register a new agent in the registry\n   */\n  async registerAgent(agent: AgentState, tags: string[] = []): Promise<void> {\n    const entry: AgentRegistryEntry = {\n      agent,\n      createdAt: new Date(),\n      lastUpdated: new Date(),\n      tags: [...tags, agent.type, agent.status],\n      metadata: {\n        registeredBy: 'agent-manager',\n        version: '1.0.0',\n      },\n    };\n\n    // Store in memory\n    const key = this.getAgentKey(agent.id.id);\n    await this.memory.store(key, entry, {\n      type: 'agent-registry',\n      tags: entry.tags,\n      partition: this.namespace,\n    });\n\n    // Update cache\n    this.cache.set(agent.id.id, entry);\n\n    this.emit('agent:registered', { agentId: agent.id.id, agent });\n  }\n\n  /**\n   * Update agent information in registry\n   */\n  async updateAgent(agentId: string, updates: Partial<AgentState>): Promise<void> {\n    const entry = await this.getAgentEntry(agentId);\n    if (!entry) {\n      throw new Error(`Agent ${agentId} not found in registry`);\n    }\n\n    // Merge updates\n    entry.agent = { ...entry.agent, ...updates };\n    entry.lastUpdated = new Date();\n    entry.tags = [\n      entry.agent.type,\n      entry.agent.status,\n      ...entry.tags.filter((t) => t !== entry.agent.type && t !== entry.agent.status),\n    ];\n\n    // Store updated entry\n    const key = this.getAgentKey(agentId);\n    await this.memory.store(key, entry, {\n      type: 'agent-registry',\n      tags: entry.tags,\n      partition: this.namespace,\n    });\n\n    // Update cache\n    this.cache.set(agentId, entry);\n\n    this.emit('agent:updated', { agentId, agent: entry.agent });\n  }\n\n  /**\n   * Remove agent from registry\n   */\n  async unregisterAgent(agentId: string, preserveHistory: boolean = true): Promise<void> {\n    const entry = await this.getAgentEntry(agentId);\n    if (!entry) {\n      return; // Already removed\n    }\n\n    if (preserveHistory) {\n      // Move to archived partition\n      const archiveKey = this.getArchiveKey(agentId);\n      await this.memory.store(\n        archiveKey,\n        {\n          ...entry,\n          archivedAt: new Date(),\n          reason: 'agent_removed',\n        },\n        {\n          type: 'agent-archive',\n          tags: [...entry.tags, 'archived'],\n          partition: 'archived',\n        },\n      );\n    }\n\n    // Remove from active registry\n    const key = this.getAgentKey(agentId);\n    await this.memory.deleteEntry(key);\n\n    // Remove from cache\n    this.cache.delete(agentId);\n\n    this.emit('agent:unregistered', { agentId, preserved: preserveHistory });\n  }\n\n  /**\n   * Get agent by ID\n   */\n  async getAgent(agentId: string): Promise<AgentState | null> {\n    const entry = await this.getAgentEntry(agentId);\n    return entry?.agent || null;\n  }\n\n  /**\n   * Get agent entry with metadata\n   */\n  async getAgentEntry(agentId: string): Promise<AgentRegistryEntry | null> {\n    // Check cache first\n    if (this.cache.has(agentId) && this.isCacheValid()) {\n      return this.cache.get(agentId) || null;\n    }\n\n    // Load from memory\n    const key = this.getAgentKey(agentId);\n    const memoryEntry = await this.memory.retrieve(key);\n\n    if (memoryEntry && memoryEntry.value) {\n      // Convert MemoryEntry to AgentRegistryEntry\n      const registryEntry: AgentRegistryEntry = memoryEntry.value as AgentRegistryEntry;\n      this.cache.set(agentId, registryEntry);\n      return registryEntry;\n    }\n\n    return null;\n  }\n\n  /**\n   * Query agents by criteria\n   */\n  async queryAgents(query: AgentQuery = {}): Promise<AgentState[]> {\n    await this.refreshCacheIfNeeded();\n\n    let agents = Array.from(this.cache.values()).map((entry) => entry.agent);\n\n    // Apply filters\n    if (query.type) {\n      agents = agents.filter((agent) => agent.type === query.type);\n    }\n\n    if (query.status) {\n      agents = agents.filter((agent) => agent.status === query.status);\n    }\n\n    if (query.healthThreshold !== undefined) {\n      agents = agents.filter((agent) => agent.health >= query.healthThreshold!);\n    }\n\n    if (query.namePattern) {\n      const pattern = new RegExp(query.namePattern, 'i');\n      agents = agents.filter((agent) => pattern.test(agent.name));\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      const entries = Array.from(this.cache.values());\n      const matchingEntries = entries.filter((entry) =>\n        query.tags!.some((tag) => entry.tags.includes(tag)),\n      );\n      agents = matchingEntries.map((entry) => entry.agent);\n    }\n\n    if (query.createdAfter) {\n      const entries = Array.from(this.cache.values());\n      const matchingEntries = entries.filter((entry) => entry.createdAt >= query.createdAfter!);\n      agents = matchingEntries.map((entry) => entry.agent);\n    }\n\n    if (query.lastActiveAfter) {\n      agents = agents.filter((agent) => agent.metrics.lastActivity >= query.lastActiveAfter!);\n    }\n\n    return agents;\n  }\n\n  /**\n   * Get all registered agents\n   */\n  async getAllAgents(): Promise<AgentState[]> {\n    return this.queryAgents();\n  }\n\n  /**\n   * Get agents by type\n   */\n  async getAgentsByType(type: AgentType): Promise<AgentState[]> {\n    return this.queryAgents({ type });\n  }\n\n  /**\n   * Get agents by status\n   */\n  async getAgentsByStatus(status: AgentStatus): Promise<AgentState[]> {\n    return this.queryAgents({ status });\n  }\n\n  /**\n   * Get healthy agents\n   */\n  async getHealthyAgents(threshold: number = 0.7): Promise<AgentState[]> {\n    return this.queryAgents({ healthThreshold: threshold });\n  }\n\n  /**\n   * Get registry statistics\n   */\n  async getStatistics(): Promise<AgentStatistics> {\n    const agents = await this.getAllAgents();\n\n    const stats: AgentStatistics = {\n      totalAgents: agents.length,\n      byType: {} as Record<AgentType, number>,\n      byStatus: {} as Record<AgentStatus, number>,\n      averageHealth: 0,\n      activeAgents: 0,\n      totalUptime: 0,\n      tasksCompleted: 0,\n      successRate: 0,\n    };\n\n    if (agents.length === 0) {\n      return stats;\n    }\n\n    // Count by type and status\n    for (const agent of agents) {\n      stats.byType[agent.type] = (stats.byType[agent.type] || 0) + 1;\n      stats.byStatus[agent.status] = (stats.byStatus[agent.status] || 0) + 1;\n\n      if (agent.status === 'idle' || agent.status === 'busy') {\n        stats.activeAgents++;\n      }\n\n      stats.totalUptime += agent.metrics.totalUptime;\n      stats.tasksCompleted += agent.metrics.tasksCompleted;\n    }\n\n    // Calculate averages\n    stats.averageHealth = agents.reduce((sum, agent) => sum + agent.health, 0) / agents.length;\n\n    const totalTasks = agents.reduce(\n      (sum, agent) => sum + agent.metrics.tasksCompleted + agent.metrics.tasksFailed,\n      0,\n    );\n\n    if (totalTasks > 0) {\n      stats.successRate = stats.tasksCompleted / totalTasks;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Search agents by capabilities\n   */\n  async searchByCapabilities(requiredCapabilities: string[]): Promise<AgentState[]> {\n    const agents = await this.getAllAgents();\n\n    return agents.filter((agent) => {\n      const capabilities = [\n        ...agent.capabilities.languages,\n        ...agent.capabilities.frameworks,\n        ...agent.capabilities.domains,\n        ...agent.capabilities.tools,\n      ];\n\n      return requiredCapabilities.every((required) =>\n        capabilities.some((cap) => cap.toLowerCase().includes(required.toLowerCase())),\n      );\n    });\n  }\n\n  /**\n   * Find best agent for task\n   */\n  async findBestAgent(\n    taskType: string,\n    requiredCapabilities: string[] = [],\n    preferredAgent?: string,\n  ): Promise<AgentState | null> {\n    let candidates = await this.getHealthyAgents(0.5);\n\n    // Filter by capabilities if specified\n    if (requiredCapabilities.length > 0) {\n      candidates = await this.searchByCapabilities(requiredCapabilities);\n    }\n\n    // Prefer specific agent if available and healthy\n    if (preferredAgent) {\n      const preferred = candidates.find(\n        (agent) => agent.id.id === preferredAgent || agent.name === preferredAgent,\n      );\n      if (preferred) return preferred;\n    }\n\n    // Filter by availability\n    candidates = candidates.filter(\n      (agent) =>\n        agent.status === 'idle' &&\n        agent.workload < 0.8 &&\n        agent.capabilities.maxConcurrentTasks > 0,\n    );\n\n    if (candidates.length === 0) return null;\n\n    // Score candidates\n    const scored = candidates.map((agent) => ({\n      agent,\n      score: this.calculateAgentScore(agent, taskType, requiredCapabilities),\n    }));\n\n    // Sort by score (highest first)\n    scored.sort((a, b) => b.score - a.score);\n\n    return scored[0]?.agent || null;\n  }\n\n  /**\n   * Store agent coordination data\n   */\n  async storeCoordinationData(agentId: string, data: any): Promise<void> {\n    const key = `coordination:${agentId}`;\n    await this.memory.store(\n      key,\n      {\n        agentId,\n        data,\n        timestamp: new Date(),\n      },\n      {\n        type: 'agent-coordination',\n        tags: ['coordination', agentId],\n        partition: this.namespace,\n      },\n    );\n  }\n\n  /**\n   * Retrieve agent coordination data\n   */\n  async getCoordinationData(agentId: string): Promise<any> {\n    const key = `coordination:${agentId}`;\n    const result = await this.memory.retrieve(key);\n    return result?.value || null;\n  }\n\n  // === PRIVATE METHODS ===\n\n  private async loadFromMemory(): Promise<void> {\n    try {\n      const entries = await this.memory.query({\n        type: 'state' as const,\n        namespace: this.namespace,\n      });\n\n      this.cache.clear();\n      for (const entry of entries) {\n        if (entry.value && entry.value.agent) {\n          this.cache.set(entry.value.agent.id.id, entry.value);\n        }\n      }\n\n      this.lastCacheUpdate = Date.now();\n    } catch (error) {\n      console.warn('Failed to load agent registry from memory:', error);\n    }\n  }\n\n  private async refreshCacheIfNeeded(): Promise<void> {\n    if (!this.isCacheValid()) {\n      await this.loadFromMemory();\n    }\n  }\n\n  private isCacheValid(): boolean {\n    return Date.now() - this.lastCacheUpdate < this.cacheExpiry;\n  }\n\n  private getAgentKey(agentId: string): string {\n    return `agent:${agentId}`;\n  }\n\n  private getArchiveKey(agentId: string): string {\n    return `archived:${agentId}:${Date.now()}`;\n  }\n\n  private calculateAgentScore(\n    agent: AgentState,\n    taskType: string,\n    requiredCapabilities: string[],\n  ): number {\n    let score = 0;\n\n    // Base health score (0-40 points)\n    score += agent.health * 40;\n\n    // Success rate score (0-30 points)\n    score += agent.metrics.successRate * 30;\n\n    // Availability score (0-20 points)\n    const availability = 1 - agent.workload;\n    score += availability * 20;\n\n    // Capability match score (0-10 points)\n    if (requiredCapabilities.length > 0) {\n      const agentCaps = [\n        ...agent.capabilities.languages,\n        ...agent.capabilities.frameworks,\n        ...agent.capabilities.domains,\n        ...agent.capabilities.tools,\n      ];\n\n      const matches = requiredCapabilities.filter((required) =>\n        agentCaps.some((cap) => cap.toLowerCase().includes(required.toLowerCase())),\n      );\n\n      score += (matches.length / requiredCapabilities.length) * 10;\n    }\n\n    return score;\n  }\n}\n"],"names":["EventEmitter","AgentRegistry","memory","namespace","cache","Map","cacheExpiry","lastCacheUpdate","initialize","loadFromMemory","emit","registerAgent","agent","tags","entry","createdAt","Date","lastUpdated","type","status","metadata","registeredBy","version","key","getAgentKey","id","store","partition","set","agentId","updateAgent","updates","getAgentEntry","Error","filter","t","unregisterAgent","preserveHistory","archiveKey","getArchiveKey","archivedAt","reason","deleteEntry","delete","preserved","getAgent","has","isCacheValid","get","memoryEntry","retrieve","value","registryEntry","queryAgents","query","refreshCacheIfNeeded","agents","Array","from","values","map","healthThreshold","undefined","health","namePattern","pattern","RegExp","test","name","length","entries","matchingEntries","some","tag","includes","createdAfter","lastActiveAfter","metrics","lastActivity","getAllAgents","getAgentsByType","getAgentsByStatus","getHealthyAgents","threshold","getStatistics","stats","totalAgents","byType","byStatus","averageHealth","activeAgents","totalUptime","tasksCompleted","successRate","reduce","sum","totalTasks","tasksFailed","searchByCapabilities","requiredCapabilities","capabilities","languages","frameworks","domains","tools","every","required","cap","toLowerCase","findBestAgent","taskType","preferredAgent","candidates","preferred","find","workload","maxConcurrentTasks","scored","score","calculateAgentScore","sort","a","b","storeCoordinationData","data","timestamp","getCoordinationData","result","clear","now","error","console","warn","availability","agentCaps","matches"],"mappings":"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"}