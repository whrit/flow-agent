{"version":3,"sources":["../../../src/__tests__/hook-matchers.test.ts"],"sourcesContent":["/**\n * Hook Matchers Tests\n *\n * Comprehensive test suite for hook pattern matching system\n */\n\nimport { describe, it, expect, beforeEach, afterEach } from '@jest/globals';\nimport {\n  HookMatcher,\n  createFilePathMatcher,\n  createAgentTypeMatcher,\n  createOperationMatcher,\n  createContextMatcher,\n  createCompositePattern,\n  hookMatcher,\n} from '../hooks/hook-matchers.js';\nimport type {\n  HookRegistration,\n  AgenticHookContext,\n  HookFilter,\n} from '../services/agentic-flow-hooks/types.js';\n\n// ===== Test Helpers =====\n\nfunction createMockContext(overrides?: Partial<AgenticHookContext>): AgenticHookContext {\n  return {\n    sessionId: 'test-session',\n    timestamp: Date.now(),\n    correlationId: 'test-correlation',\n    metadata: {},\n    memory: {\n      namespace: 'test',\n      provider: 'memory',\n      cache: new Map(),\n    },\n    neural: {\n      modelId: 'test-model',\n      patterns: {\n        add: () => {},\n        get: () => undefined,\n        findSimilar: () => [],\n        getByType: () => [],\n        prune: () => {},\n        export: () => [],\n        import: () => {},\n      },\n      training: {\n        epoch: 0,\n        loss: 0,\n        accuracy: 0,\n        learningRate: 0.001,\n        optimizer: 'adam',\n        checkpoints: [],\n      },\n    },\n    performance: {\n      metrics: new Map(),\n      bottlenecks: [],\n      optimizations: [],\n    },\n    ...overrides,\n  };\n}\n\nfunction createMockHook(overrides?: Partial<HookRegistration>): HookRegistration {\n  return {\n    id: 'test-hook',\n    type: 'workflow-step',\n    handler: async () => ({ continue: true }),\n    priority: 10,\n    ...overrides,\n  };\n}\n\n// ===== Tests =====\n\ndescribe('HookMatcher', () => {\n  let matcher: HookMatcher;\n\n  beforeEach(() => {\n    matcher = new HookMatcher({\n      cacheEnabled: true,\n      cacheTTL: 60000,\n      matchStrategy: 'all',\n    });\n  });\n\n  afterEach(() => {\n    matcher.clearCache();\n  });\n\n  describe('File Path Matching', () => {\n    it('should match glob patterns', () => {\n      const fileMatcher = createFilePathMatcher(['src/**/*.ts']);\n      const result = matcher.matchFilePath('src/hooks/test.ts', fileMatcher.patterns);\n\n      expect(result).toBe(true);\n    });\n\n    it('should not match non-matching paths', () => {\n      const fileMatcher = createFilePathMatcher(['src/**/*.ts']);\n      const result = matcher.matchFilePath('dist/build.js', fileMatcher.patterns);\n\n      expect(result).toBe(false);\n    });\n\n    it('should support multiple patterns', () => {\n      const fileMatcher = createFilePathMatcher(['src/**/*.ts', 'tests/**/*.test.ts']);\n\n      expect(matcher.matchFilePath('src/hooks/test.ts', fileMatcher.patterns)).toBe(true);\n      expect(matcher.matchFilePath('tests/unit/test.test.ts', fileMatcher.patterns)).toBe(true);\n      expect(matcher.matchFilePath('docs/readme.md', fileMatcher.patterns)).toBe(false);\n    });\n\n    it('should support inverted patterns', () => {\n      const fileMatcher = createFilePathMatcher(['**/*.ts'], { inverted: true });\n      const result = matcher.matchFilePath('src/test.ts', fileMatcher.patterns);\n\n      expect(result).toBe(true);\n    });\n\n    it('should match exact paths', () => {\n      const fileMatcher = createFilePathMatcher(['src/index.ts']);\n\n      expect(matcher.matchFilePath('src/index.ts', fileMatcher.patterns)).toBe(true);\n      expect(matcher.matchFilePath('src/other.ts', fileMatcher.patterns)).toBe(false);\n    });\n  });\n\n  describe('Agent Type Matching', () => {\n    it('should match agent types', () => {\n      const agentMatcher = createAgentTypeMatcher(['researcher', 'coder']);\n\n      expect(matcher.matchAgentType('researcher', agentMatcher)).toBe(true);\n      expect(matcher.matchAgentType('coder', agentMatcher)).toBe(true);\n      expect(matcher.matchAgentType('tester', agentMatcher)).toBe(false);\n    });\n\n    it('should support wildcard matching', () => {\n      const agentMatcher = createAgentTypeMatcher(['*']);\n\n      expect(matcher.matchAgentType('researcher', agentMatcher)).toBe(true);\n      expect(matcher.matchAgentType('any-type', agentMatcher)).toBe(true);\n    });\n\n    it('should support exclusions', () => {\n      const agentMatcher = createAgentTypeMatcher(['*'], ['tester']);\n\n      expect(matcher.matchAgentType('researcher', agentMatcher)).toBe(true);\n      expect(matcher.matchAgentType('tester', agentMatcher)).toBe(false);\n    });\n  });\n\n  describe('Operation Matching', () => {\n    it('should match operation types', () => {\n      const opMatcher = createOperationMatcher(['store', 'retrieve']);\n\n      expect(matcher.matchOperation('store', opMatcher)).toBe(true);\n      expect(matcher.matchOperation('retrieve', opMatcher)).toBe(true);\n      expect(matcher.matchOperation('delete', opMatcher)).toBe(false);\n    });\n\n    it('should support wildcard operations', () => {\n      const opMatcher = createOperationMatcher(['*']);\n\n      expect(matcher.matchOperation('store', opMatcher)).toBe(true);\n      expect(matcher.matchOperation('any-operation', opMatcher)).toBe(true);\n    });\n\n    it('should support operation exclusions', () => {\n      const opMatcher = createOperationMatcher(['*'], ['delete']);\n\n      expect(matcher.matchOperation('store', opMatcher)).toBe(true);\n      expect(matcher.matchOperation('delete', opMatcher)).toBe(false);\n    });\n  });\n\n  describe('Context Matching', () => {\n    it('should match context conditions - equality', () => {\n      const contextMatcher = createContextMatcher([\n        { field: 'sessionId', operator: 'eq', value: 'test-session' },\n      ]);\n\n      const context = createMockContext({ sessionId: 'test-session' });\n      const hook = createMockHook({\n        filter: { conditions: contextMatcher.conditions },\n      });\n\n      expect(hook.filter).toBeDefined();\n    });\n\n    it('should match nested context values', () => {\n      const contextMatcher = createContextMatcher([\n        { field: 'metadata.agentType', operator: 'eq', value: 'researcher' },\n      ]);\n\n      const context = createMockContext({\n        metadata: { agentType: 'researcher' },\n      });\n\n      expect(context.metadata?.agentType).toBe('researcher');\n    });\n\n    it('should support comparison operators', () => {\n      const contextMatcher = createContextMatcher([\n        { field: 'timestamp', operator: 'gt', value: Date.now() - 10000 },\n      ]);\n\n      const context = createMockContext({ timestamp: Date.now() });\n\n      expect(context.timestamp).toBeGreaterThan(Date.now() - 10000);\n    });\n\n    it('should support array contains', () => {\n      const contextMatcher = createContextMatcher([\n        { field: 'metadata.tags', operator: 'in', value: ['test', 'unit'] },\n      ]);\n\n      expect(contextMatcher.conditions[0].operator).toBe('in');\n    });\n  });\n\n  describe('Full Hook Matching', () => {\n    it('should match hook with file pattern', async () => {\n      const hook = createMockHook({\n        filter: {\n          patterns: [/src\\/.*\\.ts$/],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { file: 'src/hooks/test.ts' };\n\n      const result = await matcher.match(hook, context, payload);\n\n      expect(result.matched).toBe(true);\n      expect(result.cacheHit).toBe(false);\n    });\n\n    it('should match hook with operation filter', async () => {\n      const hook = createMockHook({\n        filter: {\n          operations: ['store', 'retrieve'],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'store' };\n\n      const result = await matcher.match(hook, context, payload);\n\n      expect(result.matched).toBe(true);\n    });\n\n    it('should not match hook with mismatched filter', async () => {\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'delete' };\n\n      const result = await matcher.match(hook, context, payload);\n\n      expect(result.matched).toBe(false);\n    });\n\n    it('should match hooks without filters (match all)', async () => {\n      const hook = createMockHook({\n        filter: undefined,\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'any' };\n\n      const result = await matcher.match(hook, context, payload);\n\n      expect(result.matched).toBe(true);\n      expect(result.matchedRules).toContain('*');\n    });\n  });\n\n  describe('Caching', () => {\n    it('should cache match results', async () => {\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'store' };\n\n      // First call\n      const result1 = await matcher.match(hook, context, payload);\n      expect(result1.cacheHit).toBe(false);\n\n      // Second call should hit cache\n      const result2 = await matcher.match(hook, context, payload);\n      expect(result2.cacheHit).toBe(true);\n      expect(result2.matched).toBe(result1.matched);\n    });\n\n    it('should clear cache', async () => {\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'store' };\n\n      await matcher.match(hook, context, payload);\n\n      const statsBefore = matcher.getCacheStats();\n      expect(statsBefore.size).toBeGreaterThan(0);\n\n      matcher.clearCache();\n\n      const statsAfter = matcher.getCacheStats();\n      expect(statsAfter.size).toBe(0);\n    });\n\n    it('should prune expired entries', async () => {\n      const shortTTLMatcher = new HookMatcher({\n        cacheEnabled: true,\n        cacheTTL: 100, // 100ms\n      });\n\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'store' };\n\n      await shortTTLMatcher.match(hook, context, payload);\n\n      // Wait for expiration\n      await new Promise(resolve => setTimeout(resolve, 150));\n\n      const pruned = shortTTLMatcher.pruneCache();\n      expect(pruned).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Performance', () => {\n    it('should be fast for simple matches', async () => {\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { operation: 'store' };\n\n      const result = await matcher.match(hook, context, payload);\n\n      expect(result.executionTime).toBeLessThan(10); // Less than 10ms\n    });\n\n    it('should be faster with cache', async () => {\n      const hook = createMockHook({\n        filter: {\n          patterns: [/src\\/.*\\.ts$/],\n        },\n      });\n\n      const context = createMockContext();\n      const payload = { file: 'src/hooks/test.ts' };\n\n      // First call (no cache)\n      const result1 = await matcher.match(hook, context, payload);\n      const time1 = result1.executionTime;\n\n      // Second call (cached)\n      const result2 = await matcher.match(hook, context, payload);\n      const time2 = result2.executionTime;\n\n      expect(time2).toBeLessThanOrEqual(time1);\n      expect(result2.cacheHit).toBe(true);\n    });\n  });\n\n  describe('Composite Patterns', () => {\n    it('should match AND composite patterns', () => {\n      const composite = createCompositePattern('AND', [\n        { type: 'glob', pattern: 'src/**/*.ts' },\n        { type: 'regex', pattern: /test/ },\n      ]);\n\n      expect(composite.operator).toBe('AND');\n      expect(composite.patterns).toHaveLength(2);\n    });\n\n    it('should match OR composite patterns', () => {\n      const composite = createCompositePattern('OR', [\n        { type: 'glob', pattern: 'src/**/*.ts' },\n        { type: 'glob', pattern: 'tests/**/*.test.ts' },\n      ]);\n\n      expect(composite.operator).toBe('OR');\n      expect(composite.patterns).toHaveLength(2);\n    });\n  });\n\n  describe('Match Strategies', () => {\n    it('should use ALL strategy (all rules must match)', async () => {\n      const allMatcher = new HookMatcher({ matchStrategy: 'all' });\n\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n          patterns: [/src\\/.*\\.ts$/],\n        },\n      });\n\n      const context = createMockContext();\n\n      // Both match\n      const payload1 = { operation: 'store', file: 'src/test.ts' };\n      const result1 = await allMatcher.match(hook, context, payload1);\n      expect(result1.matched).toBe(true);\n\n      // Only one matches\n      const payload2 = { operation: 'store', file: 'dist/test.js' };\n      const result2 = await allMatcher.match(hook, context, payload2);\n      expect(result2.matched).toBe(false);\n    });\n\n    it('should use ANY strategy (at least one rule must match)', async () => {\n      const anyMatcher = new HookMatcher({ matchStrategy: 'any' });\n\n      const hook = createMockHook({\n        filter: {\n          operations: ['store'],\n          patterns: [/src\\/.*\\.ts$/],\n        },\n      });\n\n      const context = createMockContext();\n\n      // Only one matches\n      const payload = { operation: 'delete', file: 'src/test.ts' };\n      const result = await anyMatcher.match(hook, context, payload);\n\n      expect(result.matched).toBe(true);\n    });\n  });\n});\n\ndescribe('Singleton Instance', () => {\n  it('should export singleton instance', () => {\n    expect(hookMatcher).toBeInstanceOf(HookMatcher);\n  });\n\n  it('should maintain state across calls', async () => {\n    const hook = createMockHook({\n      filter: {\n        operations: ['test'],\n      },\n    });\n\n    const context = createMockContext();\n    const payload = { operation: 'test' };\n\n    await hookMatcher.match(hook, context, payload);\n    const stats = hookMatcher.getCacheStats();\n\n    expect(stats.size).toBeGreaterThan(0);\n  });\n});"],"names":["describe","it","expect","beforeEach","afterEach","HookMatcher","createFilePathMatcher","createAgentTypeMatcher","createOperationMatcher","createContextMatcher","createCompositePattern","hookMatcher","createMockContext","overrides","sessionId","timestamp","Date","now","correlationId","metadata","memory","namespace","provider","cache","Map","neural","modelId","patterns","add","get","undefined","findSimilar","getByType","prune","export","import","training","epoch","loss","accuracy","learningRate","optimizer","checkpoints","performance","metrics","bottlenecks","optimizations","createMockHook","id","type","handler","continue","priority","matcher","cacheEnabled","cacheTTL","matchStrategy","clearCache","fileMatcher","result","matchFilePath","toBe","inverted","agentMatcher","matchAgentType","opMatcher","matchOperation","contextMatcher","field","operator","value","context","hook","filter","conditions","toBeDefined","agentType","toBeGreaterThan","payload","file","match","matched","cacheHit","operations","operation","matchedRules","toContain","result1","result2","statsBefore","getCacheStats","size","statsAfter","shortTTLMatcher","Promise","resolve","setTimeout","pruned","pruneCache","executionTime","toBeLessThan","time1","time2","toBeLessThanOrEqual","composite","pattern","toHaveLength","allMatcher","payload1","payload2","anyMatcher","toBeInstanceOf","stats"],"mappings":"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"}