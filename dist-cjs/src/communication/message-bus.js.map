{"version":3,"sources":["../../../src/communication/message-bus.ts"],"sourcesContent":["/**\n * Advanced messaging and communication layer for swarm coordination\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../core/logger.js';\nimport type { IEventBus } from '../core/event-bus.js';\nimport type { SwarmEvent, EventType, AgentId, CommunicationStrategy } from '../swarm/types.js';\nimport { generateId } from '../utils/helpers.js';\n\nexport interface MessageBusConfig {\n  strategy: CommunicationStrategy;\n  enablePersistence: boolean;\n  enableReliability: boolean;\n  enableOrdering: boolean;\n  enableFiltering: boolean;\n  maxMessageSize: number;\n  maxQueueSize: number;\n  messageRetention: number;\n  acknowledgmentTimeout: number;\n  retryAttempts: number;\n  backoffMultiplier: number;\n  compressionEnabled: boolean;\n  encryptionEnabled: boolean;\n  metricsEnabled: boolean;\n  debugMode: boolean;\n}\n\nexport interface Message {\n  id: string;\n  type: string;\n  sender: AgentId;\n  receivers: AgentId[];\n  content: any;\n  metadata: MessageMetadata;\n  timestamp: Date;\n  expiresAt?: Date;\n  priority: MessagePriority;\n  reliability: ReliabilityLevel;\n}\n\nexport interface MessageMetadata {\n  correlationId?: string;\n  causationId?: string;\n  replyTo?: string;\n  ttl?: number;\n  compressed: boolean;\n  encrypted: boolean;\n  size: number;\n  contentType: string;\n  encoding: string;\n  checksum?: string;\n  route?: string[];\n  deadLetterReason?: string;\n  deadLetterTimestamp?: Date;\n}\n\nexport interface MessageChannel {\n  id: string;\n  name: string;\n  type: ChannelType;\n  participants: AgentId[];\n  config: ChannelConfig;\n  statistics: ChannelStatistics;\n  filters: MessageFilter[];\n  middleware: ChannelMiddleware[];\n}\n\nexport interface ChannelConfig {\n  persistent: boolean;\n  ordered: boolean;\n  reliable: boolean;\n  maxParticipants: number;\n  maxMessageSize: number;\n  maxQueueDepth: number;\n  retentionPeriod: number;\n  accessControl: AccessControlConfig;\n}\n\nexport interface AccessControlConfig {\n  readPermission: 'public' | 'participants' | 'restricted';\n  writePermission: 'public' | 'participants' | 'restricted';\n  adminPermission: 'creator' | 'administrators' | 'system';\n  allowedSenders: AgentId[];\n  allowedReceivers: AgentId[];\n  bannedAgents: AgentId[];\n}\n\nexport interface ChannelStatistics {\n  messagesTotal: number;\n  messagesDelivered: number;\n  messagesFailed: number;\n  bytesTransferred: number;\n  averageLatency: number;\n  throughput: number;\n  errorRate: number;\n  participantCount: number;\n  lastActivity: Date;\n}\n\nexport interface MessageFilter {\n  id: string;\n  name: string;\n  enabled: boolean;\n  conditions: FilterCondition[];\n  action: 'allow' | 'deny' | 'modify' | 'route';\n  priority: number;\n}\n\nexport interface FilterCondition {\n  field: string;\n  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'matches' | 'in';\n  value: any;\n  caseSensitive?: boolean;\n}\n\nexport interface ChannelMiddleware {\n  id: string;\n  name: string;\n  enabled: boolean;\n  order: number;\n  process: (message: Message, context: MiddlewareContext) => Promise<Message | null>;\n}\n\nexport interface MiddlewareContext {\n  channel: MessageChannel;\n  direction: 'inbound' | 'outbound';\n  agent: AgentId;\n  metadata: Record<string, any>;\n}\n\nexport interface MessageQueue {\n  id: string;\n  name: string;\n  type: QueueType;\n  messages: Message[];\n  config: QueueConfig;\n  subscribers: QueueSubscriber[];\n  statistics: QueueStatistics;\n}\n\nexport interface QueueConfig {\n  maxSize: number;\n  persistent: boolean;\n  ordered: boolean;\n  durability: 'memory' | 'disk' | 'distributed';\n  deliveryMode: 'at-most-once' | 'at-least-once' | 'exactly-once';\n  deadLetterQueue?: string;\n  retryPolicy: RetryPolicy;\n}\n\nexport interface QueueSubscriber {\n  id: string;\n  agent: AgentId;\n  filter?: MessageFilter;\n  ackMode: 'auto' | 'manual';\n  prefetchCount: number;\n  lastActivity: Date;\n}\n\nexport interface QueueStatistics {\n  depth: number;\n  enqueueRate: number;\n  dequeueRate: number;\n  throughput: number;\n  averageWaitTime: number;\n  subscriberCount: number;\n  deadLetterCount: number;\n}\n\nexport interface RetryPolicy {\n  maxAttempts: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n}\n\nexport interface TopicSubscription {\n  id: string;\n  topic: string;\n  subscriber: AgentId;\n  filter?: MessageFilter;\n  ackRequired: boolean;\n  qos: QualityOfService;\n  createdAt: Date;\n  lastMessage?: Date;\n}\n\nexport interface RoutingRule {\n  id: string;\n  name: string;\n  enabled: boolean;\n  priority: number;\n  conditions: FilterCondition[];\n  actions: RoutingAction[];\n}\n\nexport interface RoutingAction {\n  type: 'forward' | 'duplicate' | 'transform' | 'aggregate' | 'delay';\n  target?: string;\n  config: Record<string, any>;\n}\n\nexport type MessagePriority = 'low' | 'normal' | 'high' | 'critical';\nexport type ReliabilityLevel = 'best-effort' | 'at-least-once' | 'exactly-once';\nexport type ChannelType = 'direct' | 'broadcast' | 'multicast' | 'topic' | 'queue';\nexport type QueueType = 'fifo' | 'lifo' | 'priority' | 'delay' | 'round-robin';\nexport type QualityOfService = 0 | 1 | 2; // MQTT-style QoS levels\n\n/**\n * Advanced message bus with support for multiple communication patterns\n */\nexport class MessageBus extends EventEmitter {\n  private logger: ILogger;\n  private eventBus: IEventBus;\n  private config: MessageBusConfig;\n\n  // Core messaging components\n  private channels = new Map<string, MessageChannel>();\n  private queues = new Map<string, MessageQueue>();\n  private subscriptions = new Map<string, TopicSubscription>();\n  private routingRules = new Map<string, RoutingRule>();\n\n  // Message tracking\n  private messageStore = new Map<string, Message>();\n  private deliveryReceipts = new Map<string, DeliveryReceipt>();\n  private acknowledgments = new Map<string, MessageAcknowledgment>();\n\n  // Routing and delivery\n  private router: MessageRouter;\n  private deliveryManager: DeliveryManager;\n  private retryManager: RetryManager;\n\n  // Performance monitoring\n  private metrics: MessageBusMetrics;\n  private metricsInterval?: NodeJS.Timeout;\n\n  constructor(config: Partial<MessageBusConfig>, logger: ILogger, eventBus: IEventBus) {\n    super();\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.config = {\n      strategy: 'event-driven',\n      enablePersistence: true,\n      enableReliability: true,\n      enableOrdering: false,\n      enableFiltering: true,\n      maxMessageSize: 1024 * 1024, // 1MB\n      maxQueueSize: 10000,\n      messageRetention: 86400000, // 24 hours\n      acknowledgmentTimeout: 30000,\n      retryAttempts: 3,\n      backoffMultiplier: 2,\n      compressionEnabled: false,\n      encryptionEnabled: false,\n      metricsEnabled: true,\n      debugMode: false,\n      ...config,\n    };\n\n    this.router = new MessageRouter(this.config, this.logger);\n    this.deliveryManager = new DeliveryManager(this.config, this.logger);\n    this.retryManager = new RetryManager(this.config, this.logger);\n    this.metrics = new MessageBusMetrics();\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('agent:connected', (data) => {\n      if (hasAgentId(data)) {\n        this.handleAgentConnected(data.agentId);\n      }\n    });\n\n    this.eventBus.on('agent:disconnected', (data) => {\n      if (hasAgentId(data)) {\n        this.handleAgentDisconnected(data.agentId);\n      }\n    });\n\n    this.deliveryManager.on('delivery:success', (data) => {\n      this.handleDeliverySuccess(data);\n    });\n\n    this.deliveryManager.on('delivery:failure', (data) => {\n      this.handleDeliveryFailure(data);\n    });\n\n    this.retryManager.on('retry:exhausted', (data) => {\n      this.handleRetryExhausted(data);\n    });\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing message bus', {\n      strategy: this.config.strategy,\n      persistence: this.config.enablePersistence,\n      reliability: this.config.enableReliability,\n    });\n\n    // Initialize components\n    await this.router.initialize();\n    await this.deliveryManager.initialize();\n    await this.retryManager.initialize();\n\n    // Create default channels\n    await this.createDefaultChannels();\n\n    // Start metrics collection\n    if (this.config.metricsEnabled) {\n      this.startMetricsCollection();\n    }\n\n    this.emit('messagebus:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down message bus');\n\n    // Stop metrics collection\n    if (this.metricsInterval) {\n      clearInterval(this.metricsInterval);\n    }\n\n    // Shutdown components\n    await this.retryManager.shutdown();\n    await this.deliveryManager.shutdown();\n    await this.router.shutdown();\n\n    // Persist any remaining messages if enabled\n    if (this.config.enablePersistence) {\n      await this.persistMessages();\n    }\n\n    this.emit('messagebus:shutdown');\n  }\n\n  // === MESSAGE OPERATIONS ===\n\n  async sendMessage(\n    type: string,\n    content: any,\n    sender: AgentId,\n    receivers: AgentId | AgentId[],\n    options: {\n      priority?: MessagePriority;\n      reliability?: ReliabilityLevel;\n      ttl?: number;\n      correlationId?: string;\n      replyTo?: string;\n      channel?: string;\n    } = {},\n  ): Promise<string> {\n    const messageId = generateId('msg');\n    const now = new Date();\n\n    const receiversArray = Array.isArray(receivers) ? receivers : [receivers];\n\n    const message: Message = {\n      id: messageId,\n      type,\n      sender,\n      receivers: receiversArray,\n      content: await this.processContent(content),\n      metadata: {\n        correlationId: options.correlationId,\n        replyTo: options.replyTo,\n        ttl: options.ttl,\n        compressed: this.config.compressionEnabled,\n        encrypted: this.config.encryptionEnabled,\n        size: this.calculateSize(content),\n        contentType: this.detectContentType(content),\n        encoding: 'utf-8',\n        route: [sender.id],\n      },\n      timestamp: now,\n      expiresAt: options.ttl ? new Date(now.getTime() + options.ttl) : undefined,\n      priority: options.priority || 'normal',\n      reliability: options.reliability || 'best-effort',\n    };\n\n    // Validate message\n    this.validateMessage(message);\n\n    // Store message if persistence is enabled\n    if (this.config.enablePersistence) {\n      this.messageStore.set(messageId, message);\n    }\n\n    // Route and deliver message\n    await this.routeMessage(message, options.channel);\n\n    this.metrics.recordMessageSent(message);\n\n    this.logger.debug('Message sent', {\n      messageId,\n      type,\n      sender: sender.id,\n      receivers: receiversArray.map((r) => r.id),\n      size: message.metadata.size,\n    });\n\n    this.emit('message:sent', { message });\n\n    return messageId;\n  }\n\n  async broadcastMessage(\n    type: string,\n    content: any,\n    sender: AgentId,\n    options: {\n      channel?: string;\n      filter?: MessageFilter;\n      priority?: MessagePriority;\n      ttl?: number;\n    } = {},\n  ): Promise<string> {\n    const channel = options.channel\n      ? this.channels.get(options.channel)\n      : this.getDefaultBroadcastChannel();\n\n    if (!channel) {\n      throw new Error('No broadcast channel available');\n    }\n\n    // Get all participants as receivers\n    let receivers = channel.participants.filter((p) => p.id !== sender.id);\n\n    // Apply filter if provided\n    if (options.filter) {\n      receivers = await this.filterReceivers(receivers, options.filter, { type, content });\n    }\n\n    return this.sendMessage(type, content, sender, receivers, {\n      priority: options.priority,\n      ttl: options.ttl,\n      channel: channel.id,\n    });\n  }\n\n  async subscribeToTopic(\n    topic: string,\n    subscriber: AgentId,\n    options: {\n      filter?: MessageFilter;\n      qos?: QualityOfService;\n      ackRequired?: boolean;\n    } = {},\n  ): Promise<string> {\n    const subscriptionId = generateId('sub');\n\n    const subscription: TopicSubscription = {\n      id: subscriptionId,\n      topic,\n      subscriber,\n      filter: options.filter,\n      ackRequired: options.ackRequired || false,\n      qos: options.qos || 0,\n      createdAt: new Date(),\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    this.logger.info('Topic subscription created', {\n      subscriptionId,\n      topic,\n      subscriber: subscriber.id,\n      qos: subscription.qos,\n    });\n\n    this.emit('subscription:created', { subscription });\n\n    return subscriptionId;\n  }\n\n  async unsubscribeFromTopic(subscriptionId: string): Promise<void> {\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) {\n      throw new Error(`Subscription ${subscriptionId} not found`);\n    }\n\n    this.subscriptions.delete(subscriptionId);\n\n    this.logger.info('Topic subscription removed', {\n      subscriptionId,\n      topic: subscription.topic,\n      subscriber: subscription.subscriber.id,\n    });\n\n    this.emit('subscription:removed', { subscription });\n  }\n\n  async acknowledgeMessage(messageId: string, agentId: AgentId): Promise<void> {\n    const message = this.messageStore.get(messageId);\n    if (!message) {\n      throw new Error(`Message ${messageId} not found`);\n    }\n\n    const ack: MessageAcknowledgment = {\n      messageId,\n      agentId,\n      timestamp: new Date(),\n      status: 'acknowledged',\n    };\n\n    this.acknowledgments.set(`${messageId}:${agentId.id}`, ack);\n\n    this.logger.debug('Message acknowledged', {\n      messageId,\n      agentId: agentId.id,\n    });\n\n    this.emit('message:acknowledged', { messageId, agentId });\n\n    // Check if all receivers have acknowledged\n    this.checkAllAcknowledgments(message);\n  }\n\n  // === CHANNEL MANAGEMENT ===\n\n  async createChannel(\n    name: string,\n    type: ChannelType,\n    config: Partial<ChannelConfig> = {},\n  ): Promise<string> {\n    const channelId = generateId('channel');\n\n    const channel: MessageChannel = {\n      id: channelId,\n      name,\n      type,\n      participants: [],\n      config: {\n        persistent: true,\n        ordered: false,\n        reliable: true,\n        maxParticipants: 1000,\n        maxMessageSize: this.config.maxMessageSize,\n        maxQueueDepth: this.config.maxQueueSize,\n        retentionPeriod: this.config.messageRetention,\n        accessControl: {\n          readPermission: 'participants',\n          writePermission: 'participants',\n          adminPermission: 'creator',\n          allowedSenders: [],\n          allowedReceivers: [],\n          bannedAgents: [],\n        },\n        ...config,\n      },\n      statistics: this.createChannelStatistics(),\n      filters: [],\n      middleware: [],\n    };\n\n    this.channels.set(channelId, channel);\n\n    this.logger.info('Channel created', {\n      channelId,\n      name,\n      type,\n      config: channel.config,\n    });\n\n    this.emit('channel:created', { channel });\n\n    return channelId;\n  }\n\n  async joinChannel(channelId: string, agentId: AgentId): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    // Check access permissions\n    if (!this.canJoinChannel(channel, agentId)) {\n      throw new Error(`Agent ${agentId.id} not allowed to join channel ${channelId}`);\n    }\n\n    // Check capacity\n    if (channel.participants.length >= channel.config.maxParticipants) {\n      throw new Error(`Channel ${channelId} is at capacity`);\n    }\n\n    // Add participant if not already present\n    if (!channel.participants.some((p) => p.id === agentId.id)) {\n      channel.participants.push(agentId);\n      channel.statistics.participantCount = channel.participants.length;\n    }\n\n    this.logger.info('Agent joined channel', {\n      channelId,\n      agentId: agentId.id,\n      participantCount: channel.participants.length,\n    });\n\n    this.emit('channel:joined', { channelId, agentId });\n  }\n\n  async leaveChannel(channelId: string, agentId: AgentId): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    // Remove participant\n    channel.participants = channel.participants.filter((p) => p.id !== agentId.id);\n    channel.statistics.participantCount = channel.participants.length;\n\n    this.logger.info('Agent left channel', {\n      channelId,\n      agentId: agentId.id,\n      participantCount: channel.participants.length,\n    });\n\n    this.emit('channel:left', { channelId, agentId });\n  }\n\n  // === QUEUE MANAGEMENT ===\n\n  async createQueue(\n    name: string,\n    type: QueueType,\n    config: Partial<QueueConfig> = {},\n  ): Promise<string> {\n    const queueId = generateId('queue');\n\n    const queue: MessageQueue = {\n      id: queueId,\n      name,\n      type,\n      messages: [],\n      config: {\n        maxSize: this.config.maxQueueSize,\n        persistent: this.config.enablePersistence,\n        ordered: this.config.enableOrdering,\n        durability: 'memory',\n        deliveryMode: 'at-least-once',\n        retryPolicy: {\n          maxAttempts: this.config.retryAttempts,\n          initialDelay: 1000,\n          maxDelay: 30000,\n          backoffMultiplier: this.config.backoffMultiplier,\n          jitter: true,\n        },\n        ...config,\n      },\n      subscribers: [],\n      statistics: this.createQueueStatistics(),\n    };\n\n    this.queues.set(queueId, queue);\n\n    this.logger.info('Queue created', {\n      queueId,\n      name,\n      type,\n      config: queue.config,\n    });\n\n    this.emit('queue:created', { queue });\n\n    return queueId;\n  }\n\n  async enqueueMessage(queueId: string, message: Message): Promise<void> {\n    const queue = this.queues.get(queueId);\n    if (!queue) {\n      throw new Error(`Queue ${queueId} not found`);\n    }\n\n    // Check queue capacity\n    if (queue.messages.length >= queue.config.maxSize) {\n      if (queue.config.deadLetterQueue) {\n        await this.sendToDeadLetterQueue(queue.config.deadLetterQueue, message, 'queue_full');\n        return;\n      } else {\n        throw new Error(`Queue ${queueId} is full`);\n      }\n    }\n\n    // Insert message based on queue type\n    this.insertMessageInQueue(queue, message);\n\n    queue.statistics.depth = queue.messages.length;\n    queue.statistics.enqueueRate++;\n\n    this.logger.debug('Message enqueued', {\n      queueId,\n      messageId: message.id,\n      queueDepth: queue.messages.length,\n    });\n\n    this.emit('message:enqueued', { queueId, message });\n\n    // Process queue for delivery\n    await this.processQueue(queue);\n  }\n\n  async dequeueMessage(queueId: string, subscriberId: string): Promise<Message | null> {\n    const queue = this.queues.get(queueId);\n    if (!queue) {\n      throw new Error(`Queue ${queueId} not found`);\n    }\n\n    const subscriber = queue.subscribers.find((s) => s.id === subscriberId);\n    if (!subscriber) {\n      throw new Error(`Subscriber ${subscriberId} not found in queue ${queueId}`);\n    }\n\n    // Find next eligible message\n    let message: Message | null = null;\n    let messageIndex = -1;\n\n    for (let i = 0; i < queue.messages.length; i++) {\n      const msg = queue.messages[i];\n\n      // Check if message matches subscriber filter\n      if (subscriber.filter && !this.matchesFilter(msg, subscriber.filter)) {\n        continue;\n      }\n\n      message = msg;\n      messageIndex = i;\n      break;\n    }\n\n    if (!message) {\n      return null;\n    }\n\n    // Remove message from queue (for at-least-once, remove after ack)\n    if (queue.config.deliveryMode === 'at-most-once') {\n      queue.messages.splice(messageIndex, 1);\n    }\n\n    queue.statistics.depth = queue.messages.length;\n    queue.statistics.dequeueRate++;\n    subscriber.lastActivity = new Date();\n\n    this.logger.debug('Message dequeued', {\n      queueId,\n      messageId: message.id,\n      subscriberId,\n      queueDepth: queue.messages.length,\n    });\n\n    this.emit('message:dequeued', { queueId, message, subscriberId });\n\n    return message;\n  }\n\n  // === ROUTING AND DELIVERY ===\n\n  private async routeMessage(message: Message, preferredChannel?: string): Promise<void> {\n    // Apply routing rules\n    const route = await this.router.calculateRoute(message, preferredChannel);\n\n    // Update message route\n    message.metadata.route = [...(message.metadata.route || []), ...route.hops];\n\n    // Deliver to targets\n    for (const target of route.targets) {\n      await this.deliverMessage(message, target);\n    }\n  }\n\n  private async deliverMessage(message: Message, target: DeliveryTarget): Promise<void> {\n    try {\n      await this.deliveryManager.deliver(message, target);\n      this.metrics.recordDeliverySuccess(message);\n    } catch (error) {\n      this.metrics.recordDeliveryFailure(message);\n\n      // Handle delivery failure based on reliability level\n      if (message.reliability !== 'best-effort') {\n        await this.retryManager.scheduleRetry(message, target, error);\n      }\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  private validateMessage(message: Message): void {\n    if (message.metadata.size > this.config.maxMessageSize) {\n      throw new Error(\n        `Message size ${message.metadata.size} exceeds limit ${this.config.maxMessageSize}`,\n      );\n    }\n\n    if (message.expiresAt && message.expiresAt <= new Date()) {\n      throw new Error('Message has already expired');\n    }\n\n    if (message.receivers.length === 0) {\n      throw new Error('Message must have at least one receiver');\n    }\n  }\n\n  private async processContent(content: any): Promise<any> {\n    let processed = content;\n\n    // Compress if enabled\n    if (this.config.compressionEnabled) {\n      processed = await this.compress(processed);\n    }\n\n    // Encrypt if enabled\n    if (this.config.encryptionEnabled) {\n      processed = await this.encrypt(processed);\n    }\n\n    return processed;\n  }\n\n  private calculateSize(content: any): number {\n    return JSON.stringify(content).length;\n  }\n\n  private detectContentType(content: any): string {\n    if (typeof content === 'string') return 'text/plain';\n    if (typeof content === 'object') return 'application/json';\n    if (Buffer.isBuffer(content)) return 'application/octet-stream';\n    return 'application/unknown';\n  }\n\n  private async filterReceivers(\n    receivers: AgentId[],\n    filter: MessageFilter,\n    context: any,\n  ): Promise<AgentId[]> {\n    // Placeholder for receiver filtering logic\n    return receivers;\n  }\n\n  private canJoinChannel(channel: MessageChannel, agentId: AgentId): boolean {\n    const acl = channel.config.accessControl;\n\n    // Check banned list\n    if (acl.bannedAgents.some((banned) => banned.id === agentId.id)) {\n      return false;\n    }\n\n    // Check allowed list (if specified)\n    if (acl.allowedSenders.length > 0) {\n      return acl.allowedSenders.some((allowed) => allowed.id === agentId.id);\n    }\n\n    return true;\n  }\n\n  private matchesFilter(message: Message, filter: MessageFilter): boolean {\n    return filter.conditions.every((condition) => {\n      const fieldValue = this.getFieldValue(message, condition.field);\n      return this.evaluateCondition(fieldValue, condition.operator, condition.value);\n    });\n  }\n\n  private getFieldValue(message: Message, field: string): any {\n    const parts = field.split('.');\n    let value: any = message;\n\n    for (const part of parts) {\n      value = value?.[part];\n    }\n\n    return value;\n  }\n\n  private evaluateCondition(fieldValue: any, operator: string, compareValue: any): boolean {\n    switch (operator) {\n      case 'eq':\n        return fieldValue === compareValue;\n      case 'ne':\n        return fieldValue !== compareValue;\n      case 'gt':\n        return fieldValue > compareValue;\n      case 'lt':\n        return fieldValue < compareValue;\n      case 'contains':\n        return String(fieldValue).includes(String(compareValue));\n      case 'matches':\n        return new RegExp(compareValue).test(String(fieldValue));\n      case 'in':\n        return Array.isArray(compareValue) && compareValue.includes(fieldValue);\n      default:\n        return false;\n    }\n  }\n\n  private insertMessageInQueue(queue: MessageQueue, message: Message): void {\n    switch (queue.type) {\n      case 'fifo':\n        queue.messages.push(message);\n        break;\n      case 'lifo':\n        queue.messages.unshift(message);\n        break;\n      case 'priority':\n        this.insertByPriority(queue.messages, message);\n        break;\n      case 'delay':\n        this.insertByTimestamp(queue.messages, message);\n        break;\n      default:\n        queue.messages.push(message);\n    }\n  }\n\n  private insertByPriority(messages: Message[], message: Message): void {\n    const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };\n    const messagePriority = priorityOrder[message.priority];\n\n    let insertIndex = messages.length;\n    for (let i = 0; i < messages.length; i++) {\n      const currentPriority = priorityOrder[messages[i].priority];\n      if (messagePriority < currentPriority) {\n        insertIndex = i;\n        break;\n      }\n    }\n\n    messages.splice(insertIndex, 0, message);\n  }\n\n  private insertByTimestamp(messages: Message[], message: Message): void {\n    const targetTime = message.expiresAt || message.timestamp;\n\n    let insertIndex = messages.length;\n    for (let i = 0; i < messages.length; i++) {\n      const currentTime = messages[i].expiresAt || messages[i].timestamp;\n      if (targetTime <= currentTime) {\n        insertIndex = i;\n        break;\n      }\n    }\n\n    messages.splice(insertIndex, 0, message);\n  }\n\n  private async processQueue(queue: MessageQueue): Promise<void> {\n    // Process messages for subscribers\n    for (const subscriber of queue.subscribers) {\n      if (subscriber.prefetchCount > 0) {\n        // Deliver up to prefetch count\n        for (let i = 0; i < subscriber.prefetchCount; i++) {\n          const message = await this.dequeueMessage(queue.id, subscriber.id);\n          if (!message) break;\n\n          await this.deliverMessageToSubscriber(message, subscriber);\n        }\n      }\n    }\n  }\n\n  private async deliverMessageToSubscriber(\n    message: Message,\n    subscriber: QueueSubscriber,\n  ): Promise<void> {\n    try {\n      // Deliver message to subscriber\n      this.emit('message:delivered', {\n        message,\n        subscriber: subscriber.agent,\n      });\n\n      // Handle acknowledgment if required\n      if (subscriber.ackMode === 'auto') {\n        await this.acknowledgeMessage(message.id, subscriber.agent);\n      }\n    } catch (error) {\n      this.logger.error('Failed to deliver message to subscriber', {\n        messageId: message.id,\n        subscriberId: subscriber.id,\n        error,\n      });\n    }\n  }\n\n  private checkAllAcknowledgments(message: Message): void {\n    const requiredAcks = message.receivers.length;\n    const receivedAcks = message.receivers.filter((receiver) =>\n      this.acknowledgments.has(`${message.id}:${receiver.id}`),\n    ).length;\n\n    if (receivedAcks === requiredAcks) {\n      this.emit('message:fully-acknowledged', { message });\n\n      // Clean up acknowledgments\n      message.receivers.forEach((receiver) => {\n        this.acknowledgments.delete(`${message.id}:${receiver.id}`);\n      });\n    }\n  }\n\n  private async createDefaultChannels(): Promise<void> {\n    // System broadcast channel\n    await this.createChannel('system-broadcast', 'broadcast', {\n      persistent: true,\n      reliable: true,\n      maxParticipants: 10000,\n    });\n\n    // Agent coordination channel\n    await this.createChannel('agent-coordination', 'multicast', {\n      persistent: true,\n      reliable: true,\n      ordered: true,\n    });\n\n    // Task distribution channel\n    await this.createChannel('task-distribution', 'topic', {\n      persistent: true,\n      reliable: false,\n    });\n  }\n\n  private getDefaultBroadcastChannel(): MessageChannel | undefined {\n    return Array.from(this.channels.values()).find((channel) => channel.type === 'broadcast');\n  }\n\n  private createChannelStatistics(): ChannelStatistics {\n    return {\n      messagesTotal: 0,\n      messagesDelivered: 0,\n      messagesFailed: 0,\n      bytesTransferred: 0,\n      averageLatency: 0,\n      throughput: 0,\n      errorRate: 0,\n      participantCount: 0,\n      lastActivity: new Date(),\n    };\n  }\n\n  private createQueueStatistics(): QueueStatistics {\n    return {\n      depth: 0,\n      enqueueRate: 0,\n      dequeueRate: 0,\n      throughput: 0,\n      averageWaitTime: 0,\n      subscriberCount: 0,\n      deadLetterCount: 0,\n    };\n  }\n\n  private startMetricsCollection(): void {\n    this.metricsInterval = setInterval(() => {\n      this.updateMetrics();\n    }, 10000); // Every 10 seconds\n  }\n\n  private updateMetrics(): void {\n    // Update channel statistics\n    for (const channel of this.channels.values()) {\n      // Calculate throughput, latency, etc.\n      this.updateChannelStatistics(channel);\n    }\n\n    // Update queue statistics\n    for (const queue of this.queues.values()) {\n      this.updateQueueStatistics(queue);\n    }\n\n    // Emit metrics event\n    this.emit('metrics:updated', { metrics: this.getMetrics() });\n  }\n\n  private updateChannelStatistics(channel: MessageChannel): void {\n    // Placeholder for channel statistics calculation\n    channel.statistics.lastActivity = new Date();\n  }\n\n  private updateQueueStatistics(queue: MessageQueue): void {\n    // Placeholder for queue statistics calculation\n    queue.statistics.depth = queue.messages.length;\n  }\n\n  private handleAgentConnected(agentId: AgentId): void {\n    this.logger.info('Agent connected to message bus', { agentId: agentId.id });\n    this.emit('agent:connected', { agentId });\n  }\n\n  private handleAgentDisconnected(agentId: AgentId): void {\n    this.logger.info('Agent disconnected from message bus', { agentId: agentId.id });\n\n    // Remove from all channels\n    for (const channel of this.channels.values()) {\n      channel.participants = channel.participants.filter((p) => p.id !== agentId.id);\n    }\n\n    // Remove subscriptions\n    for (const [subId, subscription] of this.subscriptions) {\n      if (subscription.subscriber.id === agentId.id) {\n        this.subscriptions.delete(subId);\n      }\n    }\n\n    this.emit('agent:disconnected', { agentId });\n  }\n\n  private handleDeliverySuccess(data: any): void {\n    this.metrics.recordDeliverySuccess(data.message);\n  }\n\n  private handleDeliveryFailure(data: any): void {\n    this.metrics.recordDeliveryFailure(data.message);\n  }\n\n  private handleRetryExhausted(data: any): void {\n    this.logger.error('Message delivery retry exhausted', {\n      messageId: data.message.id,\n      target: data.target,\n    });\n\n    // Send to dead letter queue if configured\n    this.sendToDeadLetterQueue('system-dlq', data.message, 'retry_exhausted');\n  }\n\n  private async sendToDeadLetterQueue(\n    queueId: string,\n    message: Message,\n    reason: string,\n  ): Promise<void> {\n    try {\n      message.metadata.deadLetterReason = reason;\n      message.metadata.deadLetterTimestamp = new Date();\n\n      await this.enqueueMessage(queueId, message);\n    } catch (error) {\n      this.logger.error('Failed to send message to dead letter queue', {\n        messageId: message.id,\n        queueId,\n        reason,\n        error,\n      });\n    }\n  }\n\n  private async compress(content: any): Promise<any> {\n    // Placeholder for compression\n    return content;\n  }\n\n  private async encrypt(content: any): Promise<any> {\n    // Placeholder for encryption\n    return content;\n  }\n\n  private async persistMessages(): Promise<void> {\n    // Placeholder for message persistence\n    this.logger.info('Persisting messages', { count: this.messageStore.size });\n  }\n\n  // === PUBLIC API ===\n\n  getChannel(channelId: string): MessageChannel | undefined {\n    return this.channels.get(channelId);\n  }\n\n  getAllChannels(): MessageChannel[] {\n    return Array.from(this.channels.values());\n  }\n\n  getQueue(queueId: string): MessageQueue | undefined {\n    return this.queues.get(queueId);\n  }\n\n  getAllQueues(): MessageQueue[] {\n    return Array.from(this.queues.values());\n  }\n\n  getSubscription(subscriptionId: string): TopicSubscription | undefined {\n    return this.subscriptions.get(subscriptionId);\n  }\n\n  getAllSubscriptions(): TopicSubscription[] {\n    return Array.from(this.subscriptions.values());\n  }\n\n  getMetrics(): any {\n    return {\n      channels: this.channels.size,\n      queues: this.queues.size,\n      subscriptions: this.subscriptions.size,\n      storedMessages: this.messageStore.size,\n      deliveryReceipts: this.deliveryReceipts.size,\n      acknowledgments: this.acknowledgments.size,\n      busMetrics: this.metrics.getMetrics(),\n    };\n  }\n\n  getMessage(messageId: string): Message | undefined {\n    return this.messageStore.get(messageId);\n  }\n\n  async addChannelFilter(channelId: string, filter: MessageFilter): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    channel.filters.push(filter);\n    channel.filters.sort((a, b) => a.priority - b.priority);\n  }\n\n  async addChannelMiddleware(channelId: string, middleware: ChannelMiddleware): Promise<void> {\n    const channel = this.channels.get(channelId);\n    if (!channel) {\n      throw new Error(`Channel ${channelId} not found`);\n    }\n\n    channel.middleware.push(middleware);\n    channel.middleware.sort((a, b) => a.order - b.order);\n  }\n}\n\n// === HELPER CLASSES ===\n\ninterface DeliveryReceipt {\n  messageId: string;\n  target: string;\n  status: 'delivered' | 'failed' | 'pending';\n  timestamp: Date;\n  attempts: number;\n  error?: string;\n}\n\ninterface MessageAcknowledgment {\n  messageId: string;\n  agentId: AgentId;\n  timestamp: Date;\n  status: 'acknowledged' | 'rejected';\n}\n\ninterface DeliveryTarget {\n  type: 'agent' | 'channel' | 'queue' | 'topic';\n  id: string;\n  address?: string;\n}\n\ninterface RouteResult {\n  targets: DeliveryTarget[];\n  hops: string[];\n  cost: number;\n}\n\nclass MessageRouter {\n  constructor(\n    private config: MessageBusConfig,\n    private logger: ILogger,\n  ) {}\n\n  async initialize(): Promise<void> {\n    this.logger.debug('Message router initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.debug('Message router shutdown');\n  }\n\n  async calculateRoute(message: Message, preferredChannel?: string): Promise<RouteResult> {\n    const targets: DeliveryTarget[] = [];\n    const hops: string[] = [];\n\n    // Simple routing - direct to receivers\n    for (const receiver of message.receivers) {\n      targets.push({\n        type: 'agent',\n        id: receiver.id,\n      });\n      hops.push(receiver.id);\n    }\n\n    return {\n      targets,\n      hops,\n      cost: targets.length,\n    };\n  }\n}\n\nclass DeliveryManager extends EventEmitter {\n  constructor(\n    private config: MessageBusConfig,\n    private logger: ILogger,\n  ) {\n    super();\n  }\n\n  async initialize(): Promise<void> {\n    this.logger.debug('Delivery manager initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.debug('Delivery manager shutdown');\n  }\n\n  async deliver(message: Message, target: DeliveryTarget): Promise<void> {\n    // Simulate delivery\n    this.logger.debug('Delivering message', {\n      messageId: message.id,\n      target: target.id,\n      type: target.type,\n    });\n\n    // Emit delivery success\n    this.emit('delivery:success', { message, target });\n  }\n}\n\nclass RetryManager extends EventEmitter {\n  private retryQueue: Array<{ message: Message; target: DeliveryTarget; attempts: number }> = [];\n  private retryInterval?: NodeJS.Timeout;\n\n  constructor(\n    private config: MessageBusConfig,\n    private logger: ILogger,\n  ) {\n    super();\n  }\n\n  async initialize(): Promise<void> {\n    this.startRetryProcessor();\n    this.logger.debug('Retry manager initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.retryInterval) {\n      clearInterval(this.retryInterval);\n    }\n    this.logger.debug('Retry manager shutdown');\n  }\n\n  async scheduleRetry(message: Message, target: DeliveryTarget, error: any): Promise<void> {\n    const existingEntry = this.retryQueue.find(\n      (entry) => entry.message.id === message.id && entry.target.id === target.id,\n    );\n\n    if (existingEntry) {\n      existingEntry.attempts++;\n    } else {\n      this.retryQueue.push({ message, target, attempts: 1 });\n    }\n\n    this.logger.debug('Retry scheduled', {\n      messageId: message.id,\n      target: target.id,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n\n  private startRetryProcessor(): void {\n    this.retryInterval = setInterval(() => {\n      this.processRetries();\n    }, 5000); // Process retries every 5 seconds\n  }\n\n  private async processRetries(): Promise<void> {\n    const now = Date.now();\n    const toRetry = this.retryQueue.filter((entry) => {\n      const delay = this.calculateDelay(entry.attempts);\n      return now >= entry.message.timestamp.getTime() + delay;\n    });\n\n    for (const entry of toRetry) {\n      if (entry.attempts >= this.config.retryAttempts) {\n        // Remove from retry queue and emit exhausted event\n        this.retryQueue = this.retryQueue.filter((r) => r !== entry);\n        this.emit('retry:exhausted', entry);\n      } else {\n        // Retry delivery\n        try {\n          // Simulate retry delivery\n          this.logger.debug('Retrying message delivery', {\n            messageId: entry.message.id,\n            attempt: entry.attempts,\n          });\n\n          // Remove from retry queue on success\n          this.retryQueue = this.retryQueue.filter((r) => r !== entry);\n        } catch (error) {\n          // Keep in retry queue for next attempt\n          this.logger.warn('Retry attempt failed', {\n            messageId: entry.message.id,\n            attempt: entry.attempts,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      }\n    }\n  }\n\n  private calculateDelay(attempts: number): number {\n    const baseDelay = 1000; // 1 second\n    return Math.min(\n      baseDelay * Math.pow(this.config.backoffMultiplier, attempts - 1),\n      30000, // Max 30 seconds\n    );\n  }\n}\n\nclass MessageBusMetrics {\n  private messagesSent = 0;\n  private messagesDelivered = 0;\n  private messagesFailed = 0;\n  private bytesTransferred = 0;\n  private deliveryLatencies: number[] = [];\n\n  recordMessageSent(message: Message): void {\n    this.messagesSent++;\n    this.bytesTransferred += message.metadata.size;\n  }\n\n  recordDeliverySuccess(message: Message): void {\n    this.messagesDelivered++;\n    const latency = Date.now() - message.timestamp.getTime();\n    this.deliveryLatencies.push(latency);\n\n    // Keep only last 1000 latencies\n    if (this.deliveryLatencies.length > 1000) {\n      this.deliveryLatencies.shift();\n    }\n  }\n\n  recordDeliveryFailure(message: Message): void {\n    this.messagesFailed++;\n  }\n\n  getMetrics(): any {\n    const avgLatency =\n      this.deliveryLatencies.length > 0\n        ? this.deliveryLatencies.reduce((sum, lat) => sum + lat, 0) / this.deliveryLatencies.length\n        : 0;\n\n    return {\n      messagesSent: this.messagesSent,\n      messagesDelivered: this.messagesDelivered,\n      messagesFailed: this.messagesFailed,\n      bytesTransferred: this.bytesTransferred,\n      averageLatency: avgLatency,\n      successRate: this.messagesSent > 0 ? (this.messagesDelivered / this.messagesSent) * 100 : 100,\n    };\n  }\n}\n"],"names":["EventEmitter","generateId","MessageBus","logger","eventBus","config","channels","Map","queues","subscriptions","routingRules","messageStore","deliveryReceipts","acknowledgments","router","deliveryManager","retryManager","metrics","metricsInterval","strategy","enablePersistence","enableReliability","enableOrdering","enableFiltering","maxMessageSize","maxQueueSize","messageRetention","acknowledgmentTimeout","retryAttempts","backoffMultiplier","compressionEnabled","encryptionEnabled","metricsEnabled","debugMode","MessageRouter","DeliveryManager","RetryManager","MessageBusMetrics","setupEventHandlers","on","data","hasAgentId","handleAgentConnected","agentId","handleAgentDisconnected","handleDeliverySuccess","handleDeliveryFailure","handleRetryExhausted","initialize","info","persistence","reliability","createDefaultChannels","startMetricsCollection","emit","shutdown","clearInterval","persistMessages","sendMessage","type","content","sender","receivers","options","messageId","now","Date","receiversArray","Array","isArray","message","id","processContent","metadata","correlationId","replyTo","ttl","compressed","encrypted","size","calculateSize","contentType","detectContentType","encoding","route","timestamp","expiresAt","getTime","undefined","priority","validateMessage","set","routeMessage","channel","recordMessageSent","debug","map","r","broadcastMessage","get","getDefaultBroadcastChannel","Error","participants","filter","p","filterReceivers","subscribeToTopic","topic","subscriber","subscriptionId","subscription","ackRequired","qos","createdAt","unsubscribeFromTopic","delete","acknowledgeMessage","ack","status","checkAllAcknowledgments","createChannel","name","channelId","persistent","ordered","reliable","maxParticipants","maxQueueDepth","retentionPeriod","accessControl","readPermission","writePermission","adminPermission","allowedSenders","allowedReceivers","bannedAgents","statistics","createChannelStatistics","filters","middleware","joinChannel","canJoinChannel","length","some","push","participantCount","leaveChannel","createQueue","queueId","queue","messages","maxSize","durability","deliveryMode","retryPolicy","maxAttempts","initialDelay","maxDelay","jitter","subscribers","createQueueStatistics","enqueueMessage","deadLetterQueue","sendToDeadLetterQueue","insertMessageInQueue","depth","enqueueRate","queueDepth","processQueue","dequeueMessage","subscriberId","find","s","messageIndex","i","msg","matchesFilter","splice","dequeueRate","lastActivity","preferredChannel","calculateRoute","hops","target","targets","deliverMessage","deliver","recordDeliverySuccess","error","recordDeliveryFailure","scheduleRetry","processed","compress","encrypt","JSON","stringify","Buffer","isBuffer","context","acl","banned","allowed","conditions","every","condition","fieldValue","getFieldValue","field","evaluateCondition","operator","value","parts","split","part","compareValue","String","includes","RegExp","test","unshift","insertByPriority","insertByTimestamp","priorityOrder","critical","high","normal","low","messagePriority","insertIndex","currentPriority","targetTime","currentTime","prefetchCount","deliverMessageToSubscriber","agent","ackMode","requiredAcks","receivedAcks","receiver","has","forEach","from","values","messagesTotal","messagesDelivered","messagesFailed","bytesTransferred","averageLatency","throughput","errorRate","averageWaitTime","subscriberCount","deadLetterCount","setInterval","updateMetrics","updateChannelStatistics","updateQueueStatistics","getMetrics","subId","reason","deadLetterReason","deadLetterTimestamp","count","getChannel","getAllChannels","getQueue","getAllQueues","getSubscription","getAllSubscriptions","storedMessages","busMetrics","getMessage","addChannelFilter","sort","a","b","addChannelMiddleware","order","cost","retryQueue","retryInterval","startRetryProcessor","existingEntry","entry","attempts","processRetries","toRetry","delay","calculateDelay","attempt","warn","baseDelay","Math","min","pow","messagesSent","deliveryLatencies","latency","shift","avgLatency","reduce","sum","lat","successRate"],"mappings":"AAIA,SAASA,YAAY,QAAQ,cAAc;AAI3C,SAASC,UAAU,QAAQ,sBAAsB;AA6MjD,OAAO,MAAMC,mBAAmBF;IACtBG,OAAgB;IAChBC,SAAoB;IACpBC,OAAyB;IAGzBC,WAAW,IAAIC,MAA8B;IAC7CC,SAAS,IAAID,MAA4B;IACzCE,gBAAgB,IAAIF,MAAiC;IACrDG,eAAe,IAAIH,MAA2B;IAG9CI,eAAe,IAAIJ,MAAuB;IAC1CK,mBAAmB,IAAIL,MAA+B;IACtDM,kBAAkB,IAAIN,MAAqC;IAG3DO,OAAsB;IACtBC,gBAAiC;IACjCC,aAA2B;IAG3BC,QAA2B;IAC3BC,gBAAiC;IAEzC,YAAYb,MAAiC,EAAEF,MAAe,EAAEC,QAAmB,CAAE;QACnF,KAAK;QACL,IAAI,CAACD,MAAM,GAAGA;QACd,IAAI,CAACC,QAAQ,GAAGA;QAEhB,IAAI,CAACC,MAAM,GAAG;YACZc,UAAU;YACVC,mBAAmB;YACnBC,mBAAmB;YACnBC,gBAAgB;YAChBC,iBAAiB;YACjBC,gBAAgB,OAAO;YACvBC,cAAc;YACdC,kBAAkB;YAClBC,uBAAuB;YACvBC,eAAe;YACfC,mBAAmB;YACnBC,oBAAoB;YACpBC,mBAAmB;YACnBC,gBAAgB;YAChBC,WAAW;YACX,GAAG5B,MAAM;QACX;QAEA,IAAI,CAACS,MAAM,GAAG,IAAIoB,cAAc,IAAI,CAAC7B,MAAM,EAAE,IAAI,CAACF,MAAM;QACxD,IAAI,CAACY,eAAe,GAAG,IAAIoB,gBAAgB,IAAI,CAAC9B,MAAM,EAAE,IAAI,CAACF,MAAM;QACnE,IAAI,CAACa,YAAY,GAAG,IAAIoB,aAAa,IAAI,CAAC/B,MAAM,EAAE,IAAI,CAACF,MAAM;QAC7D,IAAI,CAACc,OAAO,GAAG,IAAIoB;QAEnB,IAAI,CAACC,kBAAkB;IACzB;IAEQA,qBAA2B;QACjC,IAAI,CAAClC,QAAQ,CAACmC,EAAE,CAAC,mBAAmB,CAACC;YACnC,IAAIC,WAAWD,OAAO;gBACpB,IAAI,CAACE,oBAAoB,CAACF,KAAKG,OAAO;YACxC;QACF;QAEA,IAAI,CAACvC,QAAQ,CAACmC,EAAE,CAAC,sBAAsB,CAACC;YACtC,IAAIC,WAAWD,OAAO;gBACpB,IAAI,CAACI,uBAAuB,CAACJ,KAAKG,OAAO;YAC3C;QACF;QAEA,IAAI,CAAC5B,eAAe,CAACwB,EAAE,CAAC,oBAAoB,CAACC;YAC3C,IAAI,CAACK,qBAAqB,CAACL;QAC7B;QAEA,IAAI,CAACzB,eAAe,CAACwB,EAAE,CAAC,oBAAoB,CAACC;YAC3C,IAAI,CAACM,qBAAqB,CAACN;QAC7B;QAEA,IAAI,CAACxB,YAAY,CAACuB,EAAE,CAAC,mBAAmB,CAACC;YACvC,IAAI,CAACO,oBAAoB,CAACP;QAC5B;IACF;IAEA,MAAMQ,aAA4B;QAChC,IAAI,CAAC7C,MAAM,CAAC8C,IAAI,CAAC,4BAA4B;YAC3C9B,UAAU,IAAI,CAACd,MAAM,CAACc,QAAQ;YAC9B+B,aAAa,IAAI,CAAC7C,MAAM,CAACe,iBAAiB;YAC1C+B,aAAa,IAAI,CAAC9C,MAAM,CAACgB,iBAAiB;QAC5C;QAGA,MAAM,IAAI,CAACP,MAAM,CAACkC,UAAU;QAC5B,MAAM,IAAI,CAACjC,eAAe,CAACiC,UAAU;QACrC,MAAM,IAAI,CAAChC,YAAY,CAACgC,UAAU;QAGlC,MAAM,IAAI,CAACI,qBAAqB;QAGhC,IAAI,IAAI,CAAC/C,MAAM,CAAC2B,cAAc,EAAE;YAC9B,IAAI,CAACqB,sBAAsB;QAC7B;QAEA,IAAI,CAACC,IAAI,CAAC;IACZ;IAEA,MAAMC,WAA0B;QAC9B,IAAI,CAACpD,MAAM,CAAC8C,IAAI,CAAC;QAGjB,IAAI,IAAI,CAAC/B,eAAe,EAAE;YACxBsC,cAAc,IAAI,CAACtC,eAAe;QACpC;QAGA,MAAM,IAAI,CAACF,YAAY,CAACuC,QAAQ;QAChC,MAAM,IAAI,CAACxC,eAAe,CAACwC,QAAQ;QACnC,MAAM,IAAI,CAACzC,MAAM,CAACyC,QAAQ;QAG1B,IAAI,IAAI,CAAClD,MAAM,CAACe,iBAAiB,EAAE;YACjC,MAAM,IAAI,CAACqC,eAAe;QAC5B;QAEA,IAAI,CAACH,IAAI,CAAC;IACZ;IAIA,MAAMI,YACJC,IAAY,EACZC,OAAY,EACZC,MAAe,EACfC,SAA8B,EAC9BC,UAOI,CAAC,CAAC,EACW;QACjB,MAAMC,YAAY/D,WAAW;QAC7B,MAAMgE,MAAM,IAAIC;QAEhB,MAAMC,iBAAiBC,MAAMC,OAAO,CAACP,aAAaA,YAAY;YAACA;SAAU;QAEzE,MAAMQ,UAAmB;YACvBC,IAAIP;YACJL;YACAE;YACAC,WAAWK;YACXP,SAAS,MAAM,IAAI,CAACY,cAAc,CAACZ;YACnCa,UAAU;gBACRC,eAAeX,QAAQW,aAAa;gBACpCC,SAASZ,QAAQY,OAAO;gBACxBC,KAAKb,QAAQa,GAAG;gBAChBC,YAAY,IAAI,CAACxE,MAAM,CAACyB,kBAAkB;gBAC1CgD,WAAW,IAAI,CAACzE,MAAM,CAAC0B,iBAAiB;gBACxCgD,MAAM,IAAI,CAACC,aAAa,CAACpB;gBACzBqB,aAAa,IAAI,CAACC,iBAAiB,CAACtB;gBACpCuB,UAAU;gBACVC,OAAO;oBAACvB,OAAOU,EAAE;iBAAC;YACpB;YACAc,WAAWpB;YACXqB,WAAWvB,QAAQa,GAAG,GAAG,IAAIV,KAAKD,IAAIsB,OAAO,KAAKxB,QAAQa,GAAG,IAAIY;YACjEC,UAAU1B,QAAQ0B,QAAQ,IAAI;YAC9BtC,aAAaY,QAAQZ,WAAW,IAAI;QACtC;QAGA,IAAI,CAACuC,eAAe,CAACpB;QAGrB,IAAI,IAAI,CAACjE,MAAM,CAACe,iBAAiB,EAAE;YACjC,IAAI,CAACT,YAAY,CAACgF,GAAG,CAAC3B,WAAWM;QACnC;QAGA,MAAM,IAAI,CAACsB,YAAY,CAACtB,SAASP,QAAQ8B,OAAO;QAEhD,IAAI,CAAC5E,OAAO,CAAC6E,iBAAiB,CAACxB;QAE/B,IAAI,CAACnE,MAAM,CAAC4F,KAAK,CAAC,gBAAgB;YAChC/B;YACAL;YACAE,QAAQA,OAAOU,EAAE;YACjBT,WAAWK,eAAe6B,GAAG,CAAC,CAACC,IAAMA,EAAE1B,EAAE;YACzCQ,MAAMT,QAAQG,QAAQ,CAACM,IAAI;QAC7B;QAEA,IAAI,CAACzB,IAAI,CAAC,gBAAgB;YAAEgB;QAAQ;QAEpC,OAAON;IACT;IAEA,MAAMkC,iBACJvC,IAAY,EACZC,OAAY,EACZC,MAAe,EACfE,UAKI,CAAC,CAAC,EACW;QACjB,MAAM8B,UAAU9B,QAAQ8B,OAAO,GAC3B,IAAI,CAACvF,QAAQ,CAAC6F,GAAG,CAACpC,QAAQ8B,OAAO,IACjC,IAAI,CAACO,0BAA0B;QAEnC,IAAI,CAACP,SAAS;YACZ,MAAM,IAAIQ,MAAM;QAClB;QAGA,IAAIvC,YAAY+B,QAAQS,YAAY,CAACC,MAAM,CAAC,CAACC,IAAMA,EAAEjC,EAAE,KAAKV,OAAOU,EAAE;QAGrE,IAAIR,QAAQwC,MAAM,EAAE;YAClBzC,YAAY,MAAM,IAAI,CAAC2C,eAAe,CAAC3C,WAAWC,QAAQwC,MAAM,EAAE;gBAAE5C;gBAAMC;YAAQ;QACpF;QAEA,OAAO,IAAI,CAACF,WAAW,CAACC,MAAMC,SAASC,QAAQC,WAAW;YACxD2B,UAAU1B,QAAQ0B,QAAQ;YAC1Bb,KAAKb,QAAQa,GAAG;YAChBiB,SAASA,QAAQtB,EAAE;QACrB;IACF;IAEA,MAAMmC,iBACJC,KAAa,EACbC,UAAmB,EACnB7C,UAII,CAAC,CAAC,EACW;QACjB,MAAM8C,iBAAiB5G,WAAW;QAElC,MAAM6G,eAAkC;YACtCvC,IAAIsC;YACJF;YACAC;YACAL,QAAQxC,QAAQwC,MAAM;YACtBQ,aAAahD,QAAQgD,WAAW,IAAI;YACpCC,KAAKjD,QAAQiD,GAAG,IAAI;YACpBC,WAAW,IAAI/C;QACjB;QAEA,IAAI,CAACzD,aAAa,CAACkF,GAAG,CAACkB,gBAAgBC;QAEvC,IAAI,CAAC3G,MAAM,CAAC8C,IAAI,CAAC,8BAA8B;YAC7C4D;YACAF;YACAC,YAAYA,WAAWrC,EAAE;YACzByC,KAAKF,aAAaE,GAAG;QACvB;QAEA,IAAI,CAAC1D,IAAI,CAAC,wBAAwB;YAAEwD;QAAa;QAEjD,OAAOD;IACT;IAEA,MAAMK,qBAAqBL,cAAsB,EAAiB;QAChE,MAAMC,eAAe,IAAI,CAACrG,aAAa,CAAC0F,GAAG,CAACU;QAC5C,IAAI,CAACC,cAAc;YACjB,MAAM,IAAIT,MAAM,CAAC,aAAa,EAAEQ,eAAe,UAAU,CAAC;QAC5D;QAEA,IAAI,CAACpG,aAAa,CAAC0G,MAAM,CAACN;QAE1B,IAAI,CAAC1G,MAAM,CAAC8C,IAAI,CAAC,8BAA8B;YAC7C4D;YACAF,OAAOG,aAAaH,KAAK;YACzBC,YAAYE,aAAaF,UAAU,CAACrC,EAAE;QACxC;QAEA,IAAI,CAACjB,IAAI,CAAC,wBAAwB;YAAEwD;QAAa;IACnD;IAEA,MAAMM,mBAAmBpD,SAAiB,EAAErB,OAAgB,EAAiB;QAC3E,MAAM2B,UAAU,IAAI,CAAC3D,YAAY,CAACwF,GAAG,CAACnC;QACtC,IAAI,CAACM,SAAS;YACZ,MAAM,IAAI+B,MAAM,CAAC,QAAQ,EAAErC,UAAU,UAAU,CAAC;QAClD;QAEA,MAAMqD,MAA6B;YACjCrD;YACArB;YACA0C,WAAW,IAAInB;YACfoD,QAAQ;QACV;QAEA,IAAI,CAACzG,eAAe,CAAC8E,GAAG,CAAC,GAAG3B,UAAU,CAAC,EAAErB,QAAQ4B,EAAE,EAAE,EAAE8C;QAEvD,IAAI,CAAClH,MAAM,CAAC4F,KAAK,CAAC,wBAAwB;YACxC/B;YACArB,SAASA,QAAQ4B,EAAE;QACrB;QAEA,IAAI,CAACjB,IAAI,CAAC,wBAAwB;YAAEU;YAAWrB;QAAQ;QAGvD,IAAI,CAAC4E,uBAAuB,CAACjD;IAC/B;IAIA,MAAMkD,cACJC,IAAY,EACZ9D,IAAiB,EACjBtD,SAAiC,CAAC,CAAC,EAClB;QACjB,MAAMqH,YAAYzH,WAAW;QAE7B,MAAM4F,UAA0B;YAC9BtB,IAAImD;YACJD;YACA9D;YACA2C,cAAc,EAAE;YAChBjG,QAAQ;gBACNsH,YAAY;gBACZC,SAAS;gBACTC,UAAU;gBACVC,iBAAiB;gBACjBtG,gBAAgB,IAAI,CAACnB,MAAM,CAACmB,cAAc;gBAC1CuG,eAAe,IAAI,CAAC1H,MAAM,CAACoB,YAAY;gBACvCuG,iBAAiB,IAAI,CAAC3H,MAAM,CAACqB,gBAAgB;gBAC7CuG,eAAe;oBACbC,gBAAgB;oBAChBC,iBAAiB;oBACjBC,iBAAiB;oBACjBC,gBAAgB,EAAE;oBAClBC,kBAAkB,EAAE;oBACpBC,cAAc,EAAE;gBAClB;gBACA,GAAGlI,MAAM;YACX;YACAmI,YAAY,IAAI,CAACC,uBAAuB;YACxCC,SAAS,EAAE;YACXC,YAAY,EAAE;QAChB;QAEA,IAAI,CAACrI,QAAQ,CAACqF,GAAG,CAAC+B,WAAW7B;QAE7B,IAAI,CAAC1F,MAAM,CAAC8C,IAAI,CAAC,mBAAmB;YAClCyE;YACAD;YACA9D;YACAtD,QAAQwF,QAAQxF,MAAM;QACxB;QAEA,IAAI,CAACiD,IAAI,CAAC,mBAAmB;YAAEuC;QAAQ;QAEvC,OAAO6B;IACT;IAEA,MAAMkB,YAAYlB,SAAiB,EAAE/E,OAAgB,EAAiB;QACpE,MAAMkD,UAAU,IAAI,CAACvF,QAAQ,CAAC6F,GAAG,CAACuB;QAClC,IAAI,CAAC7B,SAAS;YACZ,MAAM,IAAIQ,MAAM,CAAC,QAAQ,EAAEqB,UAAU,UAAU,CAAC;QAClD;QAGA,IAAI,CAAC,IAAI,CAACmB,cAAc,CAAChD,SAASlD,UAAU;YAC1C,MAAM,IAAI0D,MAAM,CAAC,MAAM,EAAE1D,QAAQ4B,EAAE,CAAC,6BAA6B,EAAEmD,WAAW;QAChF;QAGA,IAAI7B,QAAQS,YAAY,CAACwC,MAAM,IAAIjD,QAAQxF,MAAM,CAACyH,eAAe,EAAE;YACjE,MAAM,IAAIzB,MAAM,CAAC,QAAQ,EAAEqB,UAAU,eAAe,CAAC;QACvD;QAGA,IAAI,CAAC7B,QAAQS,YAAY,CAACyC,IAAI,CAAC,CAACvC,IAAMA,EAAEjC,EAAE,KAAK5B,QAAQ4B,EAAE,GAAG;YAC1DsB,QAAQS,YAAY,CAAC0C,IAAI,CAACrG;YAC1BkD,QAAQ2C,UAAU,CAACS,gBAAgB,GAAGpD,QAAQS,YAAY,CAACwC,MAAM;QACnE;QAEA,IAAI,CAAC3I,MAAM,CAAC8C,IAAI,CAAC,wBAAwB;YACvCyE;YACA/E,SAASA,QAAQ4B,EAAE;YACnB0E,kBAAkBpD,QAAQS,YAAY,CAACwC,MAAM;QAC/C;QAEA,IAAI,CAACxF,IAAI,CAAC,kBAAkB;YAAEoE;YAAW/E;QAAQ;IACnD;IAEA,MAAMuG,aAAaxB,SAAiB,EAAE/E,OAAgB,EAAiB;QACrE,MAAMkD,UAAU,IAAI,CAACvF,QAAQ,CAAC6F,GAAG,CAACuB;QAClC,IAAI,CAAC7B,SAAS;YACZ,MAAM,IAAIQ,MAAM,CAAC,QAAQ,EAAEqB,UAAU,UAAU,CAAC;QAClD;QAGA7B,QAAQS,YAAY,GAAGT,QAAQS,YAAY,CAACC,MAAM,CAAC,CAACC,IAAMA,EAAEjC,EAAE,KAAK5B,QAAQ4B,EAAE;QAC7EsB,QAAQ2C,UAAU,CAACS,gBAAgB,GAAGpD,QAAQS,YAAY,CAACwC,MAAM;QAEjE,IAAI,CAAC3I,MAAM,CAAC8C,IAAI,CAAC,sBAAsB;YACrCyE;YACA/E,SAASA,QAAQ4B,EAAE;YACnB0E,kBAAkBpD,QAAQS,YAAY,CAACwC,MAAM;QAC/C;QAEA,IAAI,CAACxF,IAAI,CAAC,gBAAgB;YAAEoE;YAAW/E;QAAQ;IACjD;IAIA,MAAMwG,YACJ1B,IAAY,EACZ9D,IAAe,EACftD,SAA+B,CAAC,CAAC,EAChB;QACjB,MAAM+I,UAAUnJ,WAAW;QAE3B,MAAMoJ,QAAsB;YAC1B9E,IAAI6E;YACJ3B;YACA9D;YACA2F,UAAU,EAAE;YACZjJ,QAAQ;gBACNkJ,SAAS,IAAI,CAAClJ,MAAM,CAACoB,YAAY;gBACjCkG,YAAY,IAAI,CAACtH,MAAM,CAACe,iBAAiB;gBACzCwG,SAAS,IAAI,CAACvH,MAAM,CAACiB,cAAc;gBACnCkI,YAAY;gBACZC,cAAc;gBACdC,aAAa;oBACXC,aAAa,IAAI,CAACtJ,MAAM,CAACuB,aAAa;oBACtCgI,cAAc;oBACdC,UAAU;oBACVhI,mBAAmB,IAAI,CAACxB,MAAM,CAACwB,iBAAiB;oBAChDiI,QAAQ;gBACV;gBACA,GAAGzJ,MAAM;YACX;YACA0J,aAAa,EAAE;YACfvB,YAAY,IAAI,CAACwB,qBAAqB;QACxC;QAEA,IAAI,CAACxJ,MAAM,CAACmF,GAAG,CAACyD,SAASC;QAEzB,IAAI,CAAClJ,MAAM,CAAC8C,IAAI,CAAC,iBAAiB;YAChCmG;YACA3B;YACA9D;YACAtD,QAAQgJ,MAAMhJ,MAAM;QACtB;QAEA,IAAI,CAACiD,IAAI,CAAC,iBAAiB;YAAE+F;QAAM;QAEnC,OAAOD;IACT;IAEA,MAAMa,eAAeb,OAAe,EAAE9E,OAAgB,EAAiB;QACrE,MAAM+E,QAAQ,IAAI,CAAC7I,MAAM,CAAC2F,GAAG,CAACiD;QAC9B,IAAI,CAACC,OAAO;YACV,MAAM,IAAIhD,MAAM,CAAC,MAAM,EAAE+C,QAAQ,UAAU,CAAC;QAC9C;QAGA,IAAIC,MAAMC,QAAQ,CAACR,MAAM,IAAIO,MAAMhJ,MAAM,CAACkJ,OAAO,EAAE;YACjD,IAAIF,MAAMhJ,MAAM,CAAC6J,eAAe,EAAE;gBAChC,MAAM,IAAI,CAACC,qBAAqB,CAACd,MAAMhJ,MAAM,CAAC6J,eAAe,EAAE5F,SAAS;gBACxE;YACF,OAAO;gBACL,MAAM,IAAI+B,MAAM,CAAC,MAAM,EAAE+C,QAAQ,QAAQ,CAAC;YAC5C;QACF;QAGA,IAAI,CAACgB,oBAAoB,CAACf,OAAO/E;QAEjC+E,MAAMb,UAAU,CAAC6B,KAAK,GAAGhB,MAAMC,QAAQ,CAACR,MAAM;QAC9CO,MAAMb,UAAU,CAAC8B,WAAW;QAE5B,IAAI,CAACnK,MAAM,CAAC4F,KAAK,CAAC,oBAAoB;YACpCqD;YACApF,WAAWM,QAAQC,EAAE;YACrBgG,YAAYlB,MAAMC,QAAQ,CAACR,MAAM;QACnC;QAEA,IAAI,CAACxF,IAAI,CAAC,oBAAoB;YAAE8F;YAAS9E;QAAQ;QAGjD,MAAM,IAAI,CAACkG,YAAY,CAACnB;IAC1B;IAEA,MAAMoB,eAAerB,OAAe,EAAEsB,YAAoB,EAA2B;QACnF,MAAMrB,QAAQ,IAAI,CAAC7I,MAAM,CAAC2F,GAAG,CAACiD;QAC9B,IAAI,CAACC,OAAO;YACV,MAAM,IAAIhD,MAAM,CAAC,MAAM,EAAE+C,QAAQ,UAAU,CAAC;QAC9C;QAEA,MAAMxC,aAAayC,MAAMU,WAAW,CAACY,IAAI,CAAC,CAACC,IAAMA,EAAErG,EAAE,KAAKmG;QAC1D,IAAI,CAAC9D,YAAY;YACf,MAAM,IAAIP,MAAM,CAAC,WAAW,EAAEqE,aAAa,oBAAoB,EAAEtB,SAAS;QAC5E;QAGA,IAAI9E,UAA0B;QAC9B,IAAIuG,eAAe,CAAC;QAEpB,IAAK,IAAIC,IAAI,GAAGA,IAAIzB,MAAMC,QAAQ,CAACR,MAAM,EAAEgC,IAAK;YAC9C,MAAMC,MAAM1B,MAAMC,QAAQ,CAACwB,EAAE;YAG7B,IAAIlE,WAAWL,MAAM,IAAI,CAAC,IAAI,CAACyE,aAAa,CAACD,KAAKnE,WAAWL,MAAM,GAAG;gBACpE;YACF;YAEAjC,UAAUyG;YACVF,eAAeC;YACf;QACF;QAEA,IAAI,CAACxG,SAAS;YACZ,OAAO;QACT;QAGA,IAAI+E,MAAMhJ,MAAM,CAACoJ,YAAY,KAAK,gBAAgB;YAChDJ,MAAMC,QAAQ,CAAC2B,MAAM,CAACJ,cAAc;QACtC;QAEAxB,MAAMb,UAAU,CAAC6B,KAAK,GAAGhB,MAAMC,QAAQ,CAACR,MAAM;QAC9CO,MAAMb,UAAU,CAAC0C,WAAW;QAC5BtE,WAAWuE,YAAY,GAAG,IAAIjH;QAE9B,IAAI,CAAC/D,MAAM,CAAC4F,KAAK,CAAC,oBAAoB;YACpCqD;YACApF,WAAWM,QAAQC,EAAE;YACrBmG;YACAH,YAAYlB,MAAMC,QAAQ,CAACR,MAAM;QACnC;QAEA,IAAI,CAACxF,IAAI,CAAC,oBAAoB;YAAE8F;YAAS9E;YAASoG;QAAa;QAE/D,OAAOpG;IACT;IAIA,MAAcsB,aAAatB,OAAgB,EAAE8G,gBAAyB,EAAiB;QAErF,MAAMhG,QAAQ,MAAM,IAAI,CAACtE,MAAM,CAACuK,cAAc,CAAC/G,SAAS8G;QAGxD9G,QAAQG,QAAQ,CAACW,KAAK,GAAG;eAAKd,QAAQG,QAAQ,CAACW,KAAK,IAAI,EAAE;eAAMA,MAAMkG,IAAI;SAAC;QAG3E,KAAK,MAAMC,UAAUnG,MAAMoG,OAAO,CAAE;YAClC,MAAM,IAAI,CAACC,cAAc,CAACnH,SAASiH;QACrC;IACF;IAEA,MAAcE,eAAenH,OAAgB,EAAEiH,MAAsB,EAAiB;QACpF,IAAI;YACF,MAAM,IAAI,CAACxK,eAAe,CAAC2K,OAAO,CAACpH,SAASiH;YAC5C,IAAI,CAACtK,OAAO,CAAC0K,qBAAqB,CAACrH;QACrC,EAAE,OAAOsH,OAAO;YACd,IAAI,CAAC3K,OAAO,CAAC4K,qBAAqB,CAACvH;YAGnC,IAAIA,QAAQnB,WAAW,KAAK,eAAe;gBACzC,MAAM,IAAI,CAACnC,YAAY,CAAC8K,aAAa,CAACxH,SAASiH,QAAQK;YACzD;QACF;IACF;IAIQlG,gBAAgBpB,OAAgB,EAAQ;QAC9C,IAAIA,QAAQG,QAAQ,CAACM,IAAI,GAAG,IAAI,CAAC1E,MAAM,CAACmB,cAAc,EAAE;YACtD,MAAM,IAAI6E,MACR,CAAC,aAAa,EAAE/B,QAAQG,QAAQ,CAACM,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC1E,MAAM,CAACmB,cAAc,EAAE;QAEvF;QAEA,IAAI8C,QAAQgB,SAAS,IAAIhB,QAAQgB,SAAS,IAAI,IAAIpB,QAAQ;YACxD,MAAM,IAAImC,MAAM;QAClB;QAEA,IAAI/B,QAAQR,SAAS,CAACgF,MAAM,KAAK,GAAG;YAClC,MAAM,IAAIzC,MAAM;QAClB;IACF;IAEA,MAAc7B,eAAeZ,OAAY,EAAgB;QACvD,IAAImI,YAAYnI;QAGhB,IAAI,IAAI,CAACvD,MAAM,CAACyB,kBAAkB,EAAE;YAClCiK,YAAY,MAAM,IAAI,CAACC,QAAQ,CAACD;QAClC;QAGA,IAAI,IAAI,CAAC1L,MAAM,CAAC0B,iBAAiB,EAAE;YACjCgK,YAAY,MAAM,IAAI,CAACE,OAAO,CAACF;QACjC;QAEA,OAAOA;IACT;IAEQ/G,cAAcpB,OAAY,EAAU;QAC1C,OAAOsI,KAAKC,SAAS,CAACvI,SAASkF,MAAM;IACvC;IAEQ5D,kBAAkBtB,OAAY,EAAU;QAC9C,IAAI,OAAOA,YAAY,UAAU,OAAO;QACxC,IAAI,OAAOA,YAAY,UAAU,OAAO;QACxC,IAAIwI,OAAOC,QAAQ,CAACzI,UAAU,OAAO;QACrC,OAAO;IACT;IAEA,MAAc6C,gBACZ3C,SAAoB,EACpByC,MAAqB,EACrB+F,OAAY,EACQ;QAEpB,OAAOxI;IACT;IAEQ+E,eAAehD,OAAuB,EAAElD,OAAgB,EAAW;QACzE,MAAM4J,MAAM1G,QAAQxF,MAAM,CAAC4H,aAAa;QAGxC,IAAIsE,IAAIhE,YAAY,CAACQ,IAAI,CAAC,CAACyD,SAAWA,OAAOjI,EAAE,KAAK5B,QAAQ4B,EAAE,GAAG;YAC/D,OAAO;QACT;QAGA,IAAIgI,IAAIlE,cAAc,CAACS,MAAM,GAAG,GAAG;YACjC,OAAOyD,IAAIlE,cAAc,CAACU,IAAI,CAAC,CAAC0D,UAAYA,QAAQlI,EAAE,KAAK5B,QAAQ4B,EAAE;QACvE;QAEA,OAAO;IACT;IAEQyG,cAAc1G,OAAgB,EAAEiC,MAAqB,EAAW;QACtE,OAAOA,OAAOmG,UAAU,CAACC,KAAK,CAAC,CAACC;YAC9B,MAAMC,aAAa,IAAI,CAACC,aAAa,CAACxI,SAASsI,UAAUG,KAAK;YAC9D,OAAO,IAAI,CAACC,iBAAiB,CAACH,YAAYD,UAAUK,QAAQ,EAAEL,UAAUM,KAAK;QAC/E;IACF;IAEQJ,cAAcxI,OAAgB,EAAEyI,KAAa,EAAO;QAC1D,MAAMI,QAAQJ,MAAMK,KAAK,CAAC;QAC1B,IAAIF,QAAa5I;QAEjB,KAAK,MAAM+I,QAAQF,MAAO;YACxBD,QAAQA,OAAO,CAACG,KAAK;QACvB;QAEA,OAAOH;IACT;IAEQF,kBAAkBH,UAAe,EAAEI,QAAgB,EAAEK,YAAiB,EAAW;QACvF,OAAQL;YACN,KAAK;gBACH,OAAOJ,eAAeS;YACxB,KAAK;gBACH,OAAOT,eAAeS;YACxB,KAAK;gBACH,OAAOT,aAAaS;YACtB,KAAK;gBACH,OAAOT,aAAaS;YACtB,KAAK;gBACH,OAAOC,OAAOV,YAAYW,QAAQ,CAACD,OAAOD;YAC5C,KAAK;gBACH,OAAO,IAAIG,OAAOH,cAAcI,IAAI,CAACH,OAAOV;YAC9C,KAAK;gBACH,OAAOzI,MAAMC,OAAO,CAACiJ,iBAAiBA,aAAaE,QAAQ,CAACX;YAC9D;gBACE,OAAO;QACX;IACF;IAEQzC,qBAAqBf,KAAmB,EAAE/E,OAAgB,EAAQ;QACxE,OAAQ+E,MAAM1F,IAAI;YAChB,KAAK;gBACH0F,MAAMC,QAAQ,CAACN,IAAI,CAAC1E;gBACpB;YACF,KAAK;gBACH+E,MAAMC,QAAQ,CAACqE,OAAO,CAACrJ;gBACvB;YACF,KAAK;gBACH,IAAI,CAACsJ,gBAAgB,CAACvE,MAAMC,QAAQ,EAAEhF;gBACtC;YACF,KAAK;gBACH,IAAI,CAACuJ,iBAAiB,CAACxE,MAAMC,QAAQ,EAAEhF;gBACvC;YACF;gBACE+E,MAAMC,QAAQ,CAACN,IAAI,CAAC1E;QACxB;IACF;IAEQsJ,iBAAiBtE,QAAmB,EAAEhF,OAAgB,EAAQ;QACpE,MAAMwJ,gBAAgB;YAAEC,UAAU;YAAGC,MAAM;YAAGC,QAAQ;YAAGC,KAAK;QAAE;QAChE,MAAMC,kBAAkBL,aAAa,CAACxJ,QAAQmB,QAAQ,CAAC;QAEvD,IAAI2I,cAAc9E,SAASR,MAAM;QACjC,IAAK,IAAIgC,IAAI,GAAGA,IAAIxB,SAASR,MAAM,EAAEgC,IAAK;YACxC,MAAMuD,kBAAkBP,aAAa,CAACxE,QAAQ,CAACwB,EAAE,CAACrF,QAAQ,CAAC;YAC3D,IAAI0I,kBAAkBE,iBAAiB;gBACrCD,cAActD;gBACd;YACF;QACF;QAEAxB,SAAS2B,MAAM,CAACmD,aAAa,GAAG9J;IAClC;IAEQuJ,kBAAkBvE,QAAmB,EAAEhF,OAAgB,EAAQ;QACrE,MAAMgK,aAAahK,QAAQgB,SAAS,IAAIhB,QAAQe,SAAS;QAEzD,IAAI+I,cAAc9E,SAASR,MAAM;QACjC,IAAK,IAAIgC,IAAI,GAAGA,IAAIxB,SAASR,MAAM,EAAEgC,IAAK;YACxC,MAAMyD,cAAcjF,QAAQ,CAACwB,EAAE,CAACxF,SAAS,IAAIgE,QAAQ,CAACwB,EAAE,CAACzF,SAAS;YAClE,IAAIiJ,cAAcC,aAAa;gBAC7BH,cAActD;gBACd;YACF;QACF;QAEAxB,SAAS2B,MAAM,CAACmD,aAAa,GAAG9J;IAClC;IAEA,MAAckG,aAAanB,KAAmB,EAAiB;QAE7D,KAAK,MAAMzC,cAAcyC,MAAMU,WAAW,CAAE;YAC1C,IAAInD,WAAW4H,aAAa,GAAG,GAAG;gBAEhC,IAAK,IAAI1D,IAAI,GAAGA,IAAIlE,WAAW4H,aAAa,EAAE1D,IAAK;oBACjD,MAAMxG,UAAU,MAAM,IAAI,CAACmG,cAAc,CAACpB,MAAM9E,EAAE,EAAEqC,WAAWrC,EAAE;oBACjE,IAAI,CAACD,SAAS;oBAEd,MAAM,IAAI,CAACmK,0BAA0B,CAACnK,SAASsC;gBACjD;YACF;QACF;IACF;IAEA,MAAc6H,2BACZnK,OAAgB,EAChBsC,UAA2B,EACZ;QACf,IAAI;YAEF,IAAI,CAACtD,IAAI,CAAC,qBAAqB;gBAC7BgB;gBACAsC,YAAYA,WAAW8H,KAAK;YAC9B;YAGA,IAAI9H,WAAW+H,OAAO,KAAK,QAAQ;gBACjC,MAAM,IAAI,CAACvH,kBAAkB,CAAC9C,QAAQC,EAAE,EAAEqC,WAAW8H,KAAK;YAC5D;QACF,EAAE,OAAO9C,OAAO;YACd,IAAI,CAACzL,MAAM,CAACyL,KAAK,CAAC,2CAA2C;gBAC3D5H,WAAWM,QAAQC,EAAE;gBACrBmG,cAAc9D,WAAWrC,EAAE;gBAC3BqH;YACF;QACF;IACF;IAEQrE,wBAAwBjD,OAAgB,EAAQ;QACtD,MAAMsK,eAAetK,QAAQR,SAAS,CAACgF,MAAM;QAC7C,MAAM+F,eAAevK,QAAQR,SAAS,CAACyC,MAAM,CAAC,CAACuI,WAC7C,IAAI,CAACjO,eAAe,CAACkO,GAAG,CAAC,GAAGzK,QAAQC,EAAE,CAAC,CAAC,EAAEuK,SAASvK,EAAE,EAAE,GACvDuE,MAAM;QAER,IAAI+F,iBAAiBD,cAAc;YACjC,IAAI,CAACtL,IAAI,CAAC,8BAA8B;gBAAEgB;YAAQ;YAGlDA,QAAQR,SAAS,CAACkL,OAAO,CAAC,CAACF;gBACzB,IAAI,CAACjO,eAAe,CAACsG,MAAM,CAAC,GAAG7C,QAAQC,EAAE,CAAC,CAAC,EAAEuK,SAASvK,EAAE,EAAE;YAC5D;QACF;IACF;IAEA,MAAcnB,wBAAuC;QAEnD,MAAM,IAAI,CAACoE,aAAa,CAAC,oBAAoB,aAAa;YACxDG,YAAY;YACZE,UAAU;YACVC,iBAAiB;QACnB;QAGA,MAAM,IAAI,CAACN,aAAa,CAAC,sBAAsB,aAAa;YAC1DG,YAAY;YACZE,UAAU;YACVD,SAAS;QACX;QAGA,MAAM,IAAI,CAACJ,aAAa,CAAC,qBAAqB,SAAS;YACrDG,YAAY;YACZE,UAAU;QACZ;IACF;IAEQzB,6BAAyD;QAC/D,OAAOhC,MAAM6K,IAAI,CAAC,IAAI,CAAC3O,QAAQ,CAAC4O,MAAM,IAAIvE,IAAI,CAAC,CAAC9E,UAAYA,QAAQlC,IAAI,KAAK;IAC/E;IAEQ8E,0BAA6C;QACnD,OAAO;YACL0G,eAAe;YACfC,mBAAmB;YACnBC,gBAAgB;YAChBC,kBAAkB;YAClBC,gBAAgB;YAChBC,YAAY;YACZC,WAAW;YACXxG,kBAAkB;YAClBkC,cAAc,IAAIjH;QACpB;IACF;IAEQ8F,wBAAyC;QAC/C,OAAO;YACLK,OAAO;YACPC,aAAa;YACbY,aAAa;YACbsE,YAAY;YACZE,iBAAiB;YACjBC,iBAAiB;YACjBC,iBAAiB;QACnB;IACF;IAEQvM,yBAA+B;QACrC,IAAI,CAACnC,eAAe,GAAG2O,YAAY;YACjC,IAAI,CAACC,aAAa;QACpB,GAAG;IACL;IAEQA,gBAAsB;QAE5B,KAAK,MAAMjK,WAAW,IAAI,CAACvF,QAAQ,CAAC4O,MAAM,GAAI;YAE5C,IAAI,CAACa,uBAAuB,CAAClK;QAC/B;QAGA,KAAK,MAAMwD,SAAS,IAAI,CAAC7I,MAAM,CAAC0O,MAAM,GAAI;YACxC,IAAI,CAACc,qBAAqB,CAAC3G;QAC7B;QAGA,IAAI,CAAC/F,IAAI,CAAC,mBAAmB;YAAErC,SAAS,IAAI,CAACgP,UAAU;QAAG;IAC5D;IAEQF,wBAAwBlK,OAAuB,EAAQ;QAE7DA,QAAQ2C,UAAU,CAAC2C,YAAY,GAAG,IAAIjH;IACxC;IAEQ8L,sBAAsB3G,KAAmB,EAAQ;QAEvDA,MAAMb,UAAU,CAAC6B,KAAK,GAAGhB,MAAMC,QAAQ,CAACR,MAAM;IAChD;IAEQpG,qBAAqBC,OAAgB,EAAQ;QACnD,IAAI,CAACxC,MAAM,CAAC8C,IAAI,CAAC,kCAAkC;YAAEN,SAASA,QAAQ4B,EAAE;QAAC;QACzE,IAAI,CAACjB,IAAI,CAAC,mBAAmB;YAAEX;QAAQ;IACzC;IAEQC,wBAAwBD,OAAgB,EAAQ;QACtD,IAAI,CAACxC,MAAM,CAAC8C,IAAI,CAAC,uCAAuC;YAAEN,SAASA,QAAQ4B,EAAE;QAAC;QAG9E,KAAK,MAAMsB,WAAW,IAAI,CAACvF,QAAQ,CAAC4O,MAAM,GAAI;YAC5CrJ,QAAQS,YAAY,GAAGT,QAAQS,YAAY,CAACC,MAAM,CAAC,CAACC,IAAMA,EAAEjC,EAAE,KAAK5B,QAAQ4B,EAAE;QAC/E;QAGA,KAAK,MAAM,CAAC2L,OAAOpJ,aAAa,IAAI,IAAI,CAACrG,aAAa,CAAE;YACtD,IAAIqG,aAAaF,UAAU,CAACrC,EAAE,KAAK5B,QAAQ4B,EAAE,EAAE;gBAC7C,IAAI,CAAC9D,aAAa,CAAC0G,MAAM,CAAC+I;YAC5B;QACF;QAEA,IAAI,CAAC5M,IAAI,CAAC,sBAAsB;YAAEX;QAAQ;IAC5C;IAEQE,sBAAsBL,IAAS,EAAQ;QAC7C,IAAI,CAACvB,OAAO,CAAC0K,qBAAqB,CAACnJ,KAAK8B,OAAO;IACjD;IAEQxB,sBAAsBN,IAAS,EAAQ;QAC7C,IAAI,CAACvB,OAAO,CAAC4K,qBAAqB,CAACrJ,KAAK8B,OAAO;IACjD;IAEQvB,qBAAqBP,IAAS,EAAQ;QAC5C,IAAI,CAACrC,MAAM,CAACyL,KAAK,CAAC,oCAAoC;YACpD5H,WAAWxB,KAAK8B,OAAO,CAACC,EAAE;YAC1BgH,QAAQ/I,KAAK+I,MAAM;QACrB;QAGA,IAAI,CAACpB,qBAAqB,CAAC,cAAc3H,KAAK8B,OAAO,EAAE;IACzD;IAEA,MAAc6F,sBACZf,OAAe,EACf9E,OAAgB,EAChB6L,MAAc,EACC;QACf,IAAI;YACF7L,QAAQG,QAAQ,CAAC2L,gBAAgB,GAAGD;YACpC7L,QAAQG,QAAQ,CAAC4L,mBAAmB,GAAG,IAAInM;YAE3C,MAAM,IAAI,CAAC+F,cAAc,CAACb,SAAS9E;QACrC,EAAE,OAAOsH,OAAO;YACd,IAAI,CAACzL,MAAM,CAACyL,KAAK,CAAC,+CAA+C;gBAC/D5H,WAAWM,QAAQC,EAAE;gBACrB6E;gBACA+G;gBACAvE;YACF;QACF;IACF;IAEA,MAAcI,SAASpI,OAAY,EAAgB;QAEjD,OAAOA;IACT;IAEA,MAAcqI,QAAQrI,OAAY,EAAgB;QAEhD,OAAOA;IACT;IAEA,MAAcH,kBAAiC;QAE7C,IAAI,CAACtD,MAAM,CAAC8C,IAAI,CAAC,uBAAuB;YAAEqN,OAAO,IAAI,CAAC3P,YAAY,CAACoE,IAAI;QAAC;IAC1E;IAIAwL,WAAW7I,SAAiB,EAA8B;QACxD,OAAO,IAAI,CAACpH,QAAQ,CAAC6F,GAAG,CAACuB;IAC3B;IAEA8I,iBAAmC;QACjC,OAAOpM,MAAM6K,IAAI,CAAC,IAAI,CAAC3O,QAAQ,CAAC4O,MAAM;IACxC;IAEAuB,SAASrH,OAAe,EAA4B;QAClD,OAAO,IAAI,CAAC5I,MAAM,CAAC2F,GAAG,CAACiD;IACzB;IAEAsH,eAA+B;QAC7B,OAAOtM,MAAM6K,IAAI,CAAC,IAAI,CAACzO,MAAM,CAAC0O,MAAM;IACtC;IAEAyB,gBAAgB9J,cAAsB,EAAiC;QACrE,OAAO,IAAI,CAACpG,aAAa,CAAC0F,GAAG,CAACU;IAChC;IAEA+J,sBAA2C;QACzC,OAAOxM,MAAM6K,IAAI,CAAC,IAAI,CAACxO,aAAa,CAACyO,MAAM;IAC7C;IAEAe,aAAkB;QAChB,OAAO;YACL3P,UAAU,IAAI,CAACA,QAAQ,CAACyE,IAAI;YAC5BvE,QAAQ,IAAI,CAACA,MAAM,CAACuE,IAAI;YACxBtE,eAAe,IAAI,CAACA,aAAa,CAACsE,IAAI;YACtC8L,gBAAgB,IAAI,CAAClQ,YAAY,CAACoE,IAAI;YACtCnE,kBAAkB,IAAI,CAACA,gBAAgB,CAACmE,IAAI;YAC5ClE,iBAAiB,IAAI,CAACA,eAAe,CAACkE,IAAI;YAC1C+L,YAAY,IAAI,CAAC7P,OAAO,CAACgP,UAAU;QACrC;IACF;IAEAc,WAAW/M,SAAiB,EAAuB;QACjD,OAAO,IAAI,CAACrD,YAAY,CAACwF,GAAG,CAACnC;IAC/B;IAEA,MAAMgN,iBAAiBtJ,SAAiB,EAAEnB,MAAqB,EAAiB;QAC9E,MAAMV,UAAU,IAAI,CAACvF,QAAQ,CAAC6F,GAAG,CAACuB;QAClC,IAAI,CAAC7B,SAAS;YACZ,MAAM,IAAIQ,MAAM,CAAC,QAAQ,EAAEqB,UAAU,UAAU,CAAC;QAClD;QAEA7B,QAAQ6C,OAAO,CAACM,IAAI,CAACzC;QACrBV,QAAQ6C,OAAO,CAACuI,IAAI,CAAC,CAACC,GAAGC,IAAMD,EAAEzL,QAAQ,GAAG0L,EAAE1L,QAAQ;IACxD;IAEA,MAAM2L,qBAAqB1J,SAAiB,EAAEiB,UAA6B,EAAiB;QAC1F,MAAM9C,UAAU,IAAI,CAACvF,QAAQ,CAAC6F,GAAG,CAACuB;QAClC,IAAI,CAAC7B,SAAS;YACZ,MAAM,IAAIQ,MAAM,CAAC,QAAQ,EAAEqB,UAAU,UAAU,CAAC;QAClD;QAEA7B,QAAQ8C,UAAU,CAACK,IAAI,CAACL;QACxB9C,QAAQ8C,UAAU,CAACsI,IAAI,CAAC,CAACC,GAAGC,IAAMD,EAAEG,KAAK,GAAGF,EAAEE,KAAK;IACrD;AACF;AAgCA,IAAA,AAAMnP,gBAAN,MAAMA;;;IACJ,YACE,AAAQ7B,MAAwB,EAChC,AAAQF,MAAe,CACvB;aAFQE,SAAAA;aACAF,SAAAA;IACP;IAEH,MAAM6C,aAA4B;QAChC,IAAI,CAAC7C,MAAM,CAAC4F,KAAK,CAAC;IACpB;IAEA,MAAMxC,WAA0B;QAC9B,IAAI,CAACpD,MAAM,CAAC4F,KAAK,CAAC;IACpB;IAEA,MAAMsF,eAAe/G,OAAgB,EAAE8G,gBAAyB,EAAwB;QACtF,MAAMI,UAA4B,EAAE;QACpC,MAAMF,OAAiB,EAAE;QAGzB,KAAK,MAAMwD,YAAYxK,QAAQR,SAAS,CAAE;YACxC0H,QAAQxC,IAAI,CAAC;gBACXrF,MAAM;gBACNY,IAAIuK,SAASvK,EAAE;YACjB;YACA+G,KAAKtC,IAAI,CAAC8F,SAASvK,EAAE;QACvB;QAEA,OAAO;YACLiH;YACAF;YACAgG,MAAM9F,QAAQ1C,MAAM;QACtB;IACF;AACF;AAEA,IAAA,AAAM3G,kBAAN,MAAMA,wBAAwBnC;;;IAC5B,YACE,AAAQK,MAAwB,EAChC,AAAQF,MAAe,CACvB;QACA,KAAK,SAHGE,SAAAA,aACAF,SAAAA;IAGV;IAEA,MAAM6C,aAA4B;QAChC,IAAI,CAAC7C,MAAM,CAAC4F,KAAK,CAAC;IACpB;IAEA,MAAMxC,WAA0B;QAC9B,IAAI,CAACpD,MAAM,CAAC4F,KAAK,CAAC;IACpB;IAEA,MAAM2F,QAAQpH,OAAgB,EAAEiH,MAAsB,EAAiB;QAErE,IAAI,CAACpL,MAAM,CAAC4F,KAAK,CAAC,sBAAsB;YACtC/B,WAAWM,QAAQC,EAAE;YACrBgH,QAAQA,OAAOhH,EAAE;YACjBZ,MAAM4H,OAAO5H,IAAI;QACnB;QAGA,IAAI,CAACL,IAAI,CAAC,oBAAoB;YAAEgB;YAASiH;QAAO;IAClD;AACF;AAEA,IAAA,AAAMnJ,eAAN,MAAMA,qBAAqBpC;;;IACjBuR,aAAoF,EAAE,CAAC;IACvFC,cAA+B;IAEvC,YACE,AAAQnR,MAAwB,EAChC,AAAQF,MAAe,CACvB;QACA,KAAK,SAHGE,SAAAA,aACAF,SAAAA;IAGV;IAEA,MAAM6C,aAA4B;QAChC,IAAI,CAACyO,mBAAmB;QACxB,IAAI,CAACtR,MAAM,CAAC4F,KAAK,CAAC;IACpB;IAEA,MAAMxC,WAA0B;QAC9B,IAAI,IAAI,CAACiO,aAAa,EAAE;YACtBhO,cAAc,IAAI,CAACgO,aAAa;QAClC;QACA,IAAI,CAACrR,MAAM,CAAC4F,KAAK,CAAC;IACpB;IAEA,MAAM+F,cAAcxH,OAAgB,EAAEiH,MAAsB,EAAEK,KAAU,EAAiB;QACvF,MAAM8F,gBAAgB,IAAI,CAACH,UAAU,CAAC5G,IAAI,CACxC,CAACgH,QAAUA,MAAMrN,OAAO,CAACC,EAAE,KAAKD,QAAQC,EAAE,IAAIoN,MAAMpG,MAAM,CAAChH,EAAE,KAAKgH,OAAOhH,EAAE;QAG7E,IAAImN,eAAe;YACjBA,cAAcE,QAAQ;QACxB,OAAO;YACL,IAAI,CAACL,UAAU,CAACvI,IAAI,CAAC;gBAAE1E;gBAASiH;gBAAQqG,UAAU;YAAE;QACtD;QAEA,IAAI,CAACzR,MAAM,CAAC4F,KAAK,CAAC,mBAAmB;YACnC/B,WAAWM,QAAQC,EAAE;YACrBgH,QAAQA,OAAOhH,EAAE;YACjBqH,OAAOA,iBAAiBvF,QAAQuF,MAAMtH,OAAO,GAAGiJ,OAAO3B;QACzD;IACF;IAEQ6F,sBAA4B;QAClC,IAAI,CAACD,aAAa,GAAG3B,YAAY;YAC/B,IAAI,CAACgC,cAAc;QACrB,GAAG;IACL;IAEA,MAAcA,iBAAgC;QAC5C,MAAM5N,MAAMC,KAAKD,GAAG;QACpB,MAAM6N,UAAU,IAAI,CAACP,UAAU,CAAChL,MAAM,CAAC,CAACoL;YACtC,MAAMI,QAAQ,IAAI,CAACC,cAAc,CAACL,MAAMC,QAAQ;YAChD,OAAO3N,OAAO0N,MAAMrN,OAAO,CAACe,SAAS,CAACE,OAAO,KAAKwM;QACpD;QAEA,KAAK,MAAMJ,SAASG,QAAS;YAC3B,IAAIH,MAAMC,QAAQ,IAAI,IAAI,CAACvR,MAAM,CAACuB,aAAa,EAAE;gBAE/C,IAAI,CAAC2P,UAAU,GAAG,IAAI,CAACA,UAAU,CAAChL,MAAM,CAAC,CAACN,IAAMA,MAAM0L;gBACtD,IAAI,CAACrO,IAAI,CAAC,mBAAmBqO;YAC/B,OAAO;gBAEL,IAAI;oBAEF,IAAI,CAACxR,MAAM,CAAC4F,KAAK,CAAC,6BAA6B;wBAC7C/B,WAAW2N,MAAMrN,OAAO,CAACC,EAAE;wBAC3B0N,SAASN,MAAMC,QAAQ;oBACzB;oBAGA,IAAI,CAACL,UAAU,GAAG,IAAI,CAACA,UAAU,CAAChL,MAAM,CAAC,CAACN,IAAMA,MAAM0L;gBACxD,EAAE,OAAO/F,OAAO;oBAEd,IAAI,CAACzL,MAAM,CAAC+R,IAAI,CAAC,wBAAwB;wBACvClO,WAAW2N,MAAMrN,OAAO,CAACC,EAAE;wBAC3B0N,SAASN,MAAMC,QAAQ;wBACvBhG,OAAOA,iBAAiBvF,QAAQuF,MAAMtH,OAAO,GAAGiJ,OAAO3B;oBACzD;gBACF;YACF;QACF;IACF;IAEQoG,eAAeJ,QAAgB,EAAU;QAC/C,MAAMO,YAAY;QAClB,OAAOC,KAAKC,GAAG,CACbF,YAAYC,KAAKE,GAAG,CAAC,IAAI,CAACjS,MAAM,CAACwB,iBAAiB,EAAE+P,WAAW,IAC/D;IAEJ;AACF;AAEA,IAAA,AAAMvP,oBAAN,MAAMA;IACIkQ,eAAe,EAAE;IACjBnD,oBAAoB,EAAE;IACtBC,iBAAiB,EAAE;IACnBC,mBAAmB,EAAE;IACrBkD,oBAA8B,EAAE,CAAC;IAEzC1M,kBAAkBxB,OAAgB,EAAQ;QACxC,IAAI,CAACiO,YAAY;QACjB,IAAI,CAACjD,gBAAgB,IAAIhL,QAAQG,QAAQ,CAACM,IAAI;IAChD;IAEA4G,sBAAsBrH,OAAgB,EAAQ;QAC5C,IAAI,CAAC8K,iBAAiB;QACtB,MAAMqD,UAAUvO,KAAKD,GAAG,KAAKK,QAAQe,SAAS,CAACE,OAAO;QACtD,IAAI,CAACiN,iBAAiB,CAACxJ,IAAI,CAACyJ;QAG5B,IAAI,IAAI,CAACD,iBAAiB,CAAC1J,MAAM,GAAG,MAAM;YACxC,IAAI,CAAC0J,iBAAiB,CAACE,KAAK;QAC9B;IACF;IAEA7G,sBAAsBvH,OAAgB,EAAQ;QAC5C,IAAI,CAAC+K,cAAc;IACrB;IAEAY,aAAkB;QAChB,MAAM0C,aACJ,IAAI,CAACH,iBAAiB,CAAC1J,MAAM,GAAG,IAC5B,IAAI,CAAC0J,iBAAiB,CAACI,MAAM,CAAC,CAACC,KAAKC,MAAQD,MAAMC,KAAK,KAAK,IAAI,CAACN,iBAAiB,CAAC1J,MAAM,GACzF;QAEN,OAAO;YACLyJ,cAAc,IAAI,CAACA,YAAY;YAC/BnD,mBAAmB,IAAI,CAACA,iBAAiB;YACzCC,gBAAgB,IAAI,CAACA,cAAc;YACnCC,kBAAkB,IAAI,CAACA,gBAAgB;YACvCC,gBAAgBoD;YAChBI,aAAa,IAAI,CAACR,YAAY,GAAG,IAAI,AAAC,IAAI,CAACnD,iBAAiB,GAAG,IAAI,CAACmD,YAAY,GAAI,MAAM;QAC5F;IACF;AACF"}