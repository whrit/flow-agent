{"version":3,"sources":["../../../src/mcp/router.ts"],"sourcesContent":["/**\n * Request router for MCP\n */\n\nimport type { MCPRequest } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPMethodNotFoundError } from '../utils/errors.js';\nimport type { ToolRegistry } from './tools.js';\n\n/**\n * Request router implementation\n */\nexport class RequestRouter {\n  private totalRequests = 0;\n  private successfulRequests = 0;\n  private failedRequests = 0;\n\n  constructor(\n    private toolRegistry: ToolRegistry,\n    private logger: ILogger,\n  ) {}\n\n  /**\n   * Routes a request to the appropriate handler\n   */\n  async route(request: MCPRequest): Promise<unknown> {\n    this.totalRequests++;\n\n    try {\n      // Parse method to determine handler\n      const { method, params } = request;\n\n      // Handle built-in methods\n      if (method.startsWith('rpc.')) {\n        return await this.handleRPCMethod(method, params);\n      }\n\n      // Handle tool invocations\n      if (method.startsWith('tools.')) {\n        return await this.handleToolMethod(method, params);\n      }\n\n      // Try to execute as a tool directly\n      const tool = this.toolRegistry.getTool(method);\n      if (tool) {\n        const result = await this.toolRegistry.executeTool(method, params);\n        this.successfulRequests++;\n        return result;\n      }\n\n      // Method not found\n      throw new MCPMethodNotFoundError(method);\n    } catch (error) {\n      this.failedRequests++;\n      throw error;\n    }\n  }\n\n  /**\n   * Gets router metrics\n   */\n  getMetrics(): {\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n  } {\n    return {\n      totalRequests: this.totalRequests,\n      successfulRequests: this.successfulRequests,\n      failedRequests: this.failedRequests,\n    };\n  }\n\n  /**\n   * Handles built-in RPC methods\n   */\n  private async handleRPCMethod(method: string, params: unknown): Promise<unknown> {\n    switch (method) {\n      case 'rpc.discover':\n        return this.discoverMethods();\n\n      case 'rpc.ping':\n        return { pong: true };\n\n      case 'rpc.describe':\n        return this.describeMethod(params);\n\n      default:\n        throw new MCPMethodNotFoundError(method);\n    }\n  }\n\n  /**\n   * Handles tool-related methods\n   */\n  private async handleToolMethod(method: string, params: unknown): Promise<unknown> {\n    switch (method) {\n      case 'tools.list':\n        return this.toolRegistry.listTools();\n\n      case 'tools.invoke':\n        return await this.invokeTool(params);\n\n      case 'tools.describe':\n        return this.describeTool(params);\n\n      default:\n        throw new MCPMethodNotFoundError(method);\n    }\n  }\n\n  /**\n   * Discovers all available methods\n   */\n  private discoverMethods(): Record<string, string> {\n    const methods: Record<string, string> = {\n      'rpc.discover': 'Discover all available methods',\n      'rpc.ping': 'Ping the server',\n      'rpc.describe': 'Describe a specific method',\n      'tools.list': 'List all available tools',\n      'tools.invoke': 'Invoke a specific tool',\n      'tools.describe': 'Describe a specific tool',\n    };\n\n    // Add all registered tools\n    for (const tool of this.toolRegistry.listTools()) {\n      methods[tool.name] = tool.description;\n    }\n\n    return methods;\n  }\n\n  /**\n   * Describes a specific method\n   */\n  private describeMethod(params: unknown): unknown {\n    if (!params || typeof params !== 'object' || !('method' in params)) {\n      throw new Error('Invalid params: method required');\n    }\n\n    const { method } = params as { method: string };\n\n    // Check if it's a tool\n    const tool = this.toolRegistry.getTool(method);\n    if (tool) {\n      return {\n        name: tool.name,\n        description: tool.description,\n        inputSchema: tool.inputSchema,\n      };\n    }\n\n    // Check built-in methods\n    const builtInMethods: Record<string, unknown> = {\n      'rpc.discover': {\n        description: 'Discover all available methods',\n        inputSchema: { type: 'object', properties: {} },\n      },\n      'rpc.ping': {\n        description: 'Ping the server',\n        inputSchema: { type: 'object', properties: {} },\n      },\n      'rpc.describe': {\n        description: 'Describe a specific method',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            method: { type: 'string' },\n          },\n          required: ['method'],\n        },\n      },\n      'tools.list': {\n        description: 'List all available tools',\n        inputSchema: { type: 'object', properties: {} },\n      },\n      'tools.invoke': {\n        description: 'Invoke a specific tool',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tool: { type: 'string' },\n            input: { type: 'object' },\n          },\n          required: ['tool', 'input'],\n        },\n      },\n      'tools.describe': {\n        description: 'Describe a specific tool',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            tool: { type: 'string' },\n          },\n          required: ['tool'],\n        },\n      },\n    };\n\n    if (method in builtInMethods) {\n      return builtInMethods[method];\n    }\n\n    throw new MCPMethodNotFoundError(method);\n  }\n\n  /**\n   * Invokes a tool\n   */\n  private async invokeTool(params: unknown): Promise<unknown> {\n    if (!params || typeof params !== 'object' || !('tool' in params)) {\n      throw new Error('Invalid params: tool required');\n    }\n\n    const { tool, input } = params as { tool: string; input?: unknown };\n    return await this.toolRegistry.executeTool(tool, input || {});\n  }\n\n  /**\n   * Describes a specific tool\n   */\n  private describeTool(params: unknown): unknown {\n    if (!params || typeof params !== 'object' || !('tool' in params)) {\n      throw new Error('Invalid params: tool required');\n    }\n\n    const { tool: toolName } = params as { tool: string };\n    const tool = this.toolRegistry.getTool(toolName);\n\n    if (!tool) {\n      throw new Error(`Tool not found: ${toolName}`);\n    }\n\n    return {\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.inputSchema,\n    };\n  }\n}\n"],"names":["MCPMethodNotFoundError","RequestRouter","totalRequests","successfulRequests","failedRequests","toolRegistry","logger","route","request","method","params","startsWith","handleRPCMethod","handleToolMethod","tool","getTool","result","executeTool","error","getMetrics","discoverMethods","pong","describeMethod","listTools","invokeTool","describeTool","methods","name","description","Error","inputSchema","builtInMethods","type","properties","required","input","toolName"],"mappings":"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"}