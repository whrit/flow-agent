{"version":3,"sources":["../../../src/mcp/performance-monitor.ts"],"sourcesContent":["/**\n * MCP Performance Monitoring and Optimization\n */\n\nimport { EventEmitter } from 'node:events';\nimport { performance } from 'node:perf_hooks';\nimport type { ILogger } from '../core/logger.js';\nimport type { MCPSession, MCPRequest, MCPResponse, MCPMetrics } from '../utils/types.js';\n\nexport interface PerformanceMetrics {\n  requestCount: number;\n  averageResponseTime: number;\n  minResponseTime: number;\n  maxResponseTime: number;\n  p50ResponseTime: number;\n  p95ResponseTime: number;\n  p99ResponseTime: number;\n  errorRate: number;\n  throughput: number; // requests per second\n  activeConnections: number;\n  memoryUsage: {\n    heapUsed: number;\n    heapTotal: number;\n    external: number;\n    rss: number;\n  };\n  cpuUsage: {\n    user: number;\n    system: number;\n  };\n  timestamp: Date;\n}\n\nexport interface RequestMetrics {\n  id: string;\n  method: string;\n  sessionId: string;\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  success?: boolean;\n  error?: string;\n  requestSize?: number;\n  responseSize?: number;\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  metric: string;\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n  threshold: number;\n  duration: number; // milliseconds\n  enabled: boolean;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  actions: string[];\n}\n\nexport interface Alert {\n  id: string;\n  ruleId: string;\n  ruleName: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  message: string;\n  triggeredAt: Date;\n  resolvedAt?: Date;\n  currentValue: number;\n  threshold: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface OptimizationSuggestion {\n  id: string;\n  type: 'performance' | 'memory' | 'throughput' | 'latency';\n  priority: 'low' | 'medium' | 'high';\n  title: string;\n  description: string;\n  impact: string;\n  implementation: string;\n  estimatedImprovement: string;\n  detectedAt: Date;\n  metrics: Record<string, number>;\n}\n\n/**\n * MCP Performance Monitor\n * Provides comprehensive performance monitoring, alerting, and optimization suggestions\n */\nexport class MCPPerformanceMonitor extends EventEmitter {\n  private requestMetrics = new Map<string, RequestMetrics>();\n  private historicalMetrics: PerformanceMetrics[] = [];\n  private responseTimes: number[] = [];\n  private alertRules = new Map<string, AlertRule>();\n  private activeAlerts = new Map<string, Alert>();\n  private optimizationSuggestions: OptimizationSuggestion[] = [];\n\n  private metricsTimer?: NodeJS.Timeout;\n  private alertCheckTimer?: NodeJS.Timeout;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  private readonly config = {\n    metricsInterval: 10000, // 10 seconds\n    alertCheckInterval: 5000, // 5 seconds\n    maxHistorySize: 1000,\n    maxResponseTimeHistory: 10000,\n    cleanupInterval: 300000, // 5 minutes\n    requestTimeout: 30000, // 30 seconds\n  };\n\n  constructor(private logger: ILogger) {\n    super();\n    this.setupDefaultAlertRules();\n    this.startMonitoring();\n  }\n\n  /**\n   * Record the start of a request\n   */\n  recordRequestStart(request: MCPRequest, session: MCPSession): string {\n    const requestId = `${request.id}_${Date.now()}`;\n    const metrics: RequestMetrics = {\n      id: requestId,\n      method: request.method,\n      sessionId: session.id,\n      startTime: performance.now(),\n      requestSize: this.calculateRequestSize(request),\n    };\n\n    this.requestMetrics.set(requestId, metrics);\n\n    this.logger.debug('Request started', {\n      requestId,\n      method: request.method,\n      sessionId: session.id,\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Record the completion of a request\n   */\n  recordRequestEnd(requestId: string, response?: MCPResponse, error?: Error): void {\n    const metrics = this.requestMetrics.get(requestId);\n    if (!metrics) {\n      this.logger.warn('Request metrics not found', { requestId });\n      return;\n    }\n\n    const endTime = performance.now();\n    const duration = endTime - metrics.startTime;\n\n    metrics.endTime = endTime;\n    metrics.duration = duration;\n    metrics.success = !error;\n    metrics.error = error?.message;\n    metrics.responseSize = response ? this.calculateResponseSize(response) : 0;\n\n    // Add to response time history\n    this.responseTimes.push(duration);\n    if (this.responseTimes.length > this.config.maxResponseTimeHistory) {\n      this.responseTimes.shift();\n    }\n\n    this.logger.debug('Request completed', {\n      requestId,\n      duration,\n      success: metrics.success,\n      error: metrics.error,\n    });\n\n    this.emit('requestCompleted', metrics);\n\n    // Remove from active metrics after some time\n    setTimeout(() => {\n      this.requestMetrics.delete(requestId);\n    }, 60000); // Keep for 1 minute\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  getCurrentMetrics(): PerformanceMetrics {\n    const now = Date.now();\n    const completedRequests = Array.from(this.requestMetrics.values()).filter(\n      (m) => m.endTime !== undefined,\n    );\n\n    const successfulRequests = completedRequests.filter((m) => m.success);\n    const errorRate =\n      completedRequests.length > 0\n        ? ((completedRequests.length - successfulRequests.length) / completedRequests.length) * 100\n        : 0;\n\n    // Calculate response time percentiles\n    const sortedTimes = [...this.responseTimes].sort((a, b) => a - b);\n    const p50 = this.getPercentile(sortedTimes, 0.5);\n    const p95 = this.getPercentile(sortedTimes, 0.95);\n    const p99 = this.getPercentile(sortedTimes, 0.99);\n\n    // Calculate throughput (requests per second over last minute)\n    const oneMinuteAgo = now - 60000;\n    const recentRequests = completedRequests.filter(\n      (m) => m.endTime && m.startTime + oneMinuteAgo > 0,\n    );\n    const throughput = recentRequests.length / 60;\n\n    const memUsage = process.memoryUsage();\n    const cpuUsage = process.cpuUsage();\n\n    const metrics: PerformanceMetrics = {\n      requestCount: completedRequests.length,\n      averageResponseTime:\n        this.responseTimes.length > 0\n          ? this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length\n          : 0,\n      minResponseTime: sortedTimes.length > 0 ? sortedTimes[0] : 0,\n      maxResponseTime: sortedTimes.length > 0 ? sortedTimes[sortedTimes.length - 1] : 0,\n      p50ResponseTime: p50,\n      p95ResponseTime: p95,\n      p99ResponseTime: p99,\n      errorRate,\n      throughput,\n      activeConnections: this.requestMetrics.size,\n      memoryUsage: {\n        heapUsed: memUsage.heapUsed,\n        heapTotal: memUsage.heapTotal,\n        external: memUsage.external,\n        rss: memUsage.rss,\n      },\n      cpuUsage: {\n        user: cpuUsage.user / 1000000, // Convert to seconds\n        system: cpuUsage.system / 1000000,\n      },\n      timestamp: new Date(),\n    };\n\n    return metrics;\n  }\n\n  /**\n   * Get historical metrics\n   */\n  getHistoricalMetrics(limit?: number): PerformanceMetrics[] {\n    return limit ? this.historicalMetrics.slice(-limit) : [...this.historicalMetrics];\n  }\n\n  /**\n   * Add custom alert rule\n   */\n  addAlertRule(rule: AlertRule): void {\n    this.alertRules.set(rule.id, rule);\n    this.logger.info('Alert rule added', {\n      id: rule.id,\n      name: rule.name,\n      metric: rule.metric,\n      threshold: rule.threshold,\n    });\n  }\n\n  /**\n   * Remove alert rule\n   */\n  removeAlertRule(ruleId: string): void {\n    this.alertRules.delete(ruleId);\n\n    // Resolve any active alerts for this rule\n    for (const [alertId, alert] of this.activeAlerts.entries()) {\n      if (alert.ruleId === ruleId) {\n        this.resolveAlert(alertId);\n      }\n    }\n\n    this.logger.info('Alert rule removed', { ruleId });\n  }\n\n  /**\n   * Get active alerts\n   */\n  getActiveAlerts(): Alert[] {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  /**\n   * Get optimization suggestions\n   */\n  getOptimizationSuggestions(): OptimizationSuggestion[] {\n    return [...this.optimizationSuggestions];\n  }\n\n  /**\n   * Get performance summary\n   */\n  getPerformanceSummary(): {\n    current: PerformanceMetrics;\n    trends: {\n      responseTime: 'improving' | 'degrading' | 'stable';\n      throughput: 'improving' | 'degrading' | 'stable';\n      errorRate: 'improving' | 'degrading' | 'stable';\n    };\n    alerts: number;\n    suggestions: number;\n  } {\n    const current = this.getCurrentMetrics();\n    const trends = this.calculateTrends();\n\n    return {\n      current,\n      trends,\n      alerts: this.activeAlerts.size,\n      suggestions: this.optimizationSuggestions.length,\n    };\n  }\n\n  /**\n   * Resolve an alert\n   */\n  resolveAlert(alertId: string): void {\n    const alert = this.activeAlerts.get(alertId);\n    if (alert) {\n      alert.resolvedAt = new Date();\n      this.activeAlerts.delete(alertId);\n\n      this.logger.info('Alert resolved', {\n        alertId,\n        ruleName: alert.ruleName,\n        duration: alert.resolvedAt.getTime() - alert.triggeredAt.getTime(),\n      });\n\n      this.emit('alertResolved', alert);\n    }\n  }\n\n  /**\n   * Clear all optimization suggestions\n   */\n  clearOptimizationSuggestions(): void {\n    this.optimizationSuggestions = [];\n    this.logger.info('Optimization suggestions cleared');\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stop(): void {\n    if (this.metricsTimer) {\n      clearInterval(this.metricsTimer);\n      this.metricsTimer = undefined;\n    }\n\n    if (this.alertCheckTimer) {\n      clearInterval(this.alertCheckTimer);\n      this.alertCheckTimer = undefined;\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n\n    this.logger.info('Performance monitoring stopped');\n  }\n\n  private startMonitoring(): void {\n    // Collect metrics periodically\n    this.metricsTimer = setInterval(() => {\n      const metrics = this.getCurrentMetrics();\n      this.historicalMetrics.push(metrics);\n\n      // Keep only recent history\n      if (this.historicalMetrics.length > this.config.maxHistorySize) {\n        this.historicalMetrics.shift();\n      }\n\n      this.emit('metricsCollected', metrics);\n    }, this.config.metricsInterval);\n\n    // Check alerts periodically\n    this.alertCheckTimer = setInterval(() => {\n      this.checkAlerts();\n    }, this.config.alertCheckInterval);\n\n    // Cleanup old data\n    this.cleanupTimer = setInterval(() => {\n      this.cleanup();\n      this.generateOptimizationSuggestions();\n    }, this.config.cleanupInterval);\n\n    this.logger.info('Performance monitoring started');\n  }\n\n  private setupDefaultAlertRules(): void {\n    const defaultRules: AlertRule[] = [\n      {\n        id: 'high_response_time',\n        name: 'High Response Time',\n        metric: 'averageResponseTime',\n        operator: 'gt',\n        threshold: 5000, // 5 seconds\n        duration: 30000, // 30 seconds\n        enabled: true,\n        severity: 'medium',\n        actions: ['log', 'notify'],\n      },\n      {\n        id: 'high_error_rate',\n        name: 'High Error Rate',\n        metric: 'errorRate',\n        operator: 'gt',\n        threshold: 10, // 10%\n        duration: 60000, // 1 minute\n        enabled: true,\n        severity: 'high',\n        actions: ['log', 'notify', 'alert'],\n      },\n      {\n        id: 'low_throughput',\n        name: 'Low Throughput',\n        metric: 'throughput',\n        operator: 'lt',\n        threshold: 1, // 1 request per second\n        duration: 120000, // 2 minutes\n        enabled: true,\n        severity: 'medium',\n        actions: ['log', 'notify'],\n      },\n      {\n        id: 'high_memory_usage',\n        name: 'High Memory Usage',\n        metric: 'memoryUsage.heapUsed',\n        operator: 'gt',\n        threshold: 1024 * 1024 * 1024, // 1GB\n        duration: 300000, // 5 minutes\n        enabled: true,\n        severity: 'high',\n        actions: ['log', 'notify', 'alert'],\n      },\n    ];\n\n    for (const rule of defaultRules) {\n      this.alertRules.set(rule.id, rule);\n    }\n  }\n\n  private checkAlerts(): void {\n    const metrics = this.getCurrentMetrics();\n\n    for (const rule of this.alertRules.values()) {\n      if (!rule.enabled) continue;\n\n      const value = this.getMetricValue(metrics, rule.metric);\n      const triggered = this.evaluateCondition(value, rule.operator, rule.threshold);\n\n      const existingAlert = Array.from(this.activeAlerts.values()).find(\n        (a) => a.ruleId === rule.id && !a.resolvedAt,\n      );\n\n      if (triggered && !existingAlert) {\n        // Create new alert\n        const alert: Alert = {\n          id: `alert_${rule.id}_${Date.now()}`,\n          ruleId: rule.id,\n          ruleName: rule.name,\n          severity: rule.severity,\n          message: `${rule.name}: ${rule.metric} is ${value} (threshold: ${rule.threshold})`,\n          triggeredAt: new Date(),\n          currentValue: value,\n          threshold: rule.threshold,\n        };\n\n        this.activeAlerts.set(alert.id, alert);\n\n        this.logger.warn('Alert triggered', {\n          alertId: alert.id,\n          ruleName: rule.name,\n          metric: rule.metric,\n          value,\n          threshold: rule.threshold,\n        });\n\n        this.emit('alertTriggered', alert);\n      } else if (!triggered && existingAlert) {\n        // Resolve existing alert\n        this.resolveAlert(existingAlert.id);\n      }\n    }\n  }\n\n  private getMetricValue(metrics: PerformanceMetrics, path: string): number {\n    const parts = path.split('.');\n    let value: any = metrics;\n\n    for (const part of parts) {\n      value = value?.[part];\n      if (value === undefined) break;\n    }\n\n    return typeof value === 'number' ? value : 0;\n  }\n\n  private evaluateCondition(value: number, operator: string, threshold: number): boolean {\n    switch (operator) {\n      case 'gt':\n        return value > threshold;\n      case 'gte':\n        return value >= threshold;\n      case 'lt':\n        return value < threshold;\n      case 'lte':\n        return value <= threshold;\n      case 'eq':\n        return value === threshold;\n      default:\n        return false;\n    }\n  }\n\n  private getPercentile(sortedArray: number[], percentile: number): number {\n    if (sortedArray.length === 0) return 0;\n\n    const index = Math.ceil(sortedArray.length * percentile) - 1;\n    return sortedArray[Math.max(0, Math.min(index, sortedArray.length - 1))];\n  }\n\n  private calculateTrends(): {\n    responseTime: 'improving' | 'degrading' | 'stable';\n    throughput: 'improving' | 'degrading' | 'stable';\n    errorRate: 'improving' | 'degrading' | 'stable';\n  } {\n    const recentMetrics = this.historicalMetrics.slice(-10); // Last 10 data points\n\n    if (recentMetrics.length < 2) {\n      return {\n        responseTime: 'stable',\n        throughput: 'stable',\n        errorRate: 'stable',\n      };\n    }\n\n    const first = recentMetrics[0];\n    const last = recentMetrics[recentMetrics.length - 1];\n\n    return {\n      responseTime: this.getTrend(first.averageResponseTime, last.averageResponseTime, true),\n      throughput: this.getTrend(first.throughput, last.throughput, false),\n      errorRate: this.getTrend(first.errorRate, last.errorRate, true),\n    };\n  }\n\n  private getTrend(\n    oldValue: number,\n    newValue: number,\n    lowerIsBetter: boolean,\n  ): 'improving' | 'degrading' | 'stable' {\n    const change = (newValue - oldValue) / oldValue;\n    const threshold = 0.1; // 10% change threshold\n\n    if (Math.abs(change) < threshold) {\n      return 'stable';\n    }\n\n    const improving = lowerIsBetter ? change < 0 : change > 0;\n    return improving ? 'improving' : 'degrading';\n  }\n\n  private generateOptimizationSuggestions(): void {\n    const metrics = this.getCurrentMetrics();\n    const suggestions: OptimizationSuggestion[] = [];\n\n    // High response time suggestion\n    if (metrics.averageResponseTime > 2000) {\n      suggestions.push({\n        id: `opt_response_time_${Date.now()}`,\n        type: 'performance',\n        priority: 'high',\n        title: 'Optimize Response Time',\n        description: 'Average response time is above 2 seconds',\n        impact: 'Improve user experience and system throughput',\n        implementation:\n          'Consider implementing caching, optimizing database queries, or adding connection pooling',\n        estimatedImprovement: '30-50% response time reduction',\n        detectedAt: new Date(),\n        metrics: { averageResponseTime: metrics.averageResponseTime },\n      });\n    }\n\n    // High memory usage suggestion\n    if (metrics.memoryUsage.heapUsed > 512 * 1024 * 1024) {\n      // 512MB\n      suggestions.push({\n        id: `opt_memory_${Date.now()}`,\n        type: 'memory',\n        priority: 'medium',\n        title: 'Optimize Memory Usage',\n        description: 'Heap memory usage is high',\n        impact: 'Prevent memory leaks and improve stability',\n        implementation:\n          'Review memory usage patterns, implement object pooling, or add garbage collection tuning',\n        estimatedImprovement: '20-30% memory reduction',\n        detectedAt: new Date(),\n        metrics: { heapUsed: metrics.memoryUsage.heapUsed },\n      });\n    }\n\n    // Low throughput suggestion\n    if (metrics.throughput < 5 && metrics.requestCount > 100) {\n      suggestions.push({\n        id: `opt_throughput_${Date.now()}`,\n        type: 'throughput',\n        priority: 'medium',\n        title: 'Improve Throughput',\n        description: 'Request throughput is below optimal levels',\n        impact: 'Handle more concurrent requests efficiently',\n        implementation: 'Consider horizontal scaling, load balancing, or request batching',\n        estimatedImprovement: '2-3x throughput increase',\n        detectedAt: new Date(),\n        metrics: { throughput: metrics.throughput },\n      });\n    }\n\n    // Add only new suggestions\n    for (const suggestion of suggestions) {\n      const exists = this.optimizationSuggestions.some(\n        (s) => s.type === suggestion.type && s.title === suggestion.title,\n      );\n\n      if (!exists) {\n        this.optimizationSuggestions.push(suggestion);\n        this.emit('optimizationSuggestion', suggestion);\n      }\n    }\n\n    // Keep only recent suggestions (last 24 hours)\n    const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n    this.optimizationSuggestions = this.optimizationSuggestions.filter(\n      (s) => s.detectedAt > dayAgo,\n    );\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n\n    // Clean up old request metrics\n    for (const [id, metrics] of this.requestMetrics.entries()) {\n      if (now - metrics.startTime > this.config.requestTimeout) {\n        this.requestMetrics.delete(id);\n      }\n    }\n\n    // Clean up old response times\n    if (this.responseTimes.length > this.config.maxResponseTimeHistory) {\n      this.responseTimes = this.responseTimes.slice(-this.config.maxResponseTimeHistory);\n    }\n  }\n\n  private calculateRequestSize(request: MCPRequest): number {\n    return JSON.stringify(request).length;\n  }\n\n  private calculateResponseSize(response: MCPResponse): number {\n    return JSON.stringify(response).length;\n  }\n}\n"],"names":["EventEmitter","performance","MCPPerformanceMonitor","requestMetrics","Map","historicalMetrics","responseTimes","alertRules","activeAlerts","optimizationSuggestions","metricsTimer","alertCheckTimer","cleanupTimer","config","metricsInterval","alertCheckInterval","maxHistorySize","maxResponseTimeHistory","cleanupInterval","requestTimeout","logger","setupDefaultAlertRules","startMonitoring","recordRequestStart","request","session","requestId","id","Date","now","metrics","method","sessionId","startTime","requestSize","calculateRequestSize","set","debug","recordRequestEnd","response","error","get","warn","endTime","duration","success","message","responseSize","calculateResponseSize","push","length","shift","emit","setTimeout","delete","getCurrentMetrics","completedRequests","Array","from","values","filter","m","undefined","successfulRequests","errorRate","sortedTimes","sort","a","b","p50","getPercentile","p95","p99","oneMinuteAgo","recentRequests","throughput","memUsage","process","memoryUsage","cpuUsage","requestCount","averageResponseTime","reduce","minResponseTime","maxResponseTime","p50ResponseTime","p95ResponseTime","p99ResponseTime","activeConnections","size","heapUsed","heapTotal","external","rss","user","system","timestamp","getHistoricalMetrics","limit","slice","addAlertRule","rule","info","name","metric","threshold","removeAlertRule","ruleId","alertId","alert","entries","resolveAlert","getActiveAlerts","getOptimizationSuggestions","getPerformanceSummary","current","trends","calculateTrends","alerts","suggestions","resolvedAt","ruleName","getTime","triggeredAt","clearOptimizationSuggestions","stop","clearInterval","setInterval","checkAlerts","cleanup","generateOptimizationSuggestions","defaultRules","operator","enabled","severity","actions","value","getMetricValue","triggered","evaluateCondition","existingAlert","find","currentValue","path","parts","split","part","sortedArray","percentile","index","Math","ceil","max","min","recentMetrics","responseTime","first","last","getTrend","oldValue","newValue","lowerIsBetter","change","abs","improving","type","priority","title","description","impact","implementation","estimatedImprovement","detectedAt","suggestion","exists","some","s","dayAgo","JSON","stringify"],"mappings":"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"}