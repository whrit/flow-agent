{"version":3,"sources":["../../../src/mcp/client.ts"],"sourcesContent":["/**\n * MCP Client for Model Context Protocol\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ITransport } from './transports/base.js';\nimport { logger } from '../core/logger.js';\nimport type { MCPRequest, MCPResponse, MCPNotification, MCPConfig } from '../utils/types.js';\nimport { RecoveryManager, RecoveryConfig } from './recovery/index.js';\n\nexport interface MCPClientConfig {\n  transport: ITransport;\n  timeout?: number;\n  enableRecovery?: boolean;\n  recoveryConfig?: RecoveryConfig;\n  mcpConfig?: MCPConfig;\n}\n\nexport class MCPClient extends EventEmitter {\n  private transport: ITransport;\n  private timeout: number;\n  private connected = false;\n  private recoveryManager?: RecoveryManager;\n  private pendingRequests = new Map<\n    string,\n    { resolve: Function; reject: Function; timer: NodeJS.Timeout }\n  >();\n\n  constructor(config: MCPClientConfig) {\n    super();\n    this.transport = config.transport;\n    this.timeout = config.timeout || 30000;\n\n    // Initialize recovery manager if enabled\n    if (config.enableRecovery) {\n      this.recoveryManager = new RecoveryManager(\n        this,\n        config.mcpConfig || {},\n        logger,\n        config.recoveryConfig,\n      );\n      this.setupRecoveryHandlers();\n    }\n  }\n\n  async connect(): Promise<void> {\n    try {\n      await this.transport.connect();\n      this.connected = true;\n      logger.info('MCP Client connected');\n\n      // Start recovery manager if enabled\n      if (this.recoveryManager) {\n        await this.recoveryManager.start();\n      }\n\n      this.emit('connected');\n    } catch (error) {\n      logger.error('Failed to connect MCP client', error);\n      this.connected = false;\n\n      // Trigger recovery if enabled\n      if (this.recoveryManager) {\n        await this.recoveryManager.forceRecovery();\n      }\n\n      throw error;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.connected) {\n      // Stop recovery manager first\n      if (this.recoveryManager) {\n        await this.recoveryManager.stop();\n      }\n\n      await this.transport.disconnect();\n      this.connected = false;\n      logger.info('MCP Client disconnected');\n\n      this.emit('disconnected');\n    }\n  }\n\n  async request(method: string, params?: unknown): Promise<unknown> {\n    const request: MCPRequest = {\n      jsonrpc: '2.0' as const,\n      method,\n      params,\n      id: Math.random().toString(36).slice(2),\n    };\n\n    // If recovery manager is enabled, let it handle the request\n    if (this.recoveryManager && !this.connected) {\n      await this.recoveryManager.handleRequest(request);\n    }\n\n    if (!this.connected) {\n      throw new Error('Client not connected');\n    }\n\n    // Create promise for tracking the request\n    const requestPromise = new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        this.pendingRequests.delete(request.id!);\n        reject(new Error(`Request timeout: ${method}`));\n      }, this.timeout);\n\n      this.pendingRequests.set(request.id!, { resolve, reject, timer });\n    });\n\n    try {\n      const response = await this.transport.sendRequest(request);\n\n      // Clear pending request\n      const pending = this.pendingRequests.get(request.id!);\n      if (pending) {\n        clearTimeout(pending.timer);\n        this.pendingRequests.delete(request.id!);\n      }\n\n      if ('error' in response) {\n        throw new Error(response.error);\n      }\n\n      return response.result;\n    } catch (error) {\n      // Clear pending request on error\n      const pending = this.pendingRequests.get(request.id!);\n      if (pending) {\n        clearTimeout(pending.timer);\n        this.pendingRequests.delete(request.id!);\n      }\n\n      throw error;\n    }\n  }\n\n  async notify(method: string, params?: unknown): Promise<void> {\n    // Special handling for heartbeat notifications\n    if (method === 'heartbeat') {\n      // Always allow heartbeat notifications for recovery\n      const notification: MCPNotification = {\n        jsonrpc: '2.0' as const,\n        method,\n        params,\n      };\n\n      if (this.transport.sendNotification) {\n        await this.transport.sendNotification(notification);\n      }\n      return;\n    }\n\n    if (!this.connected) {\n      throw new Error('Client not connected');\n    }\n\n    const notification: MCPNotification = {\n      jsonrpc: '2.0' as const,\n      method,\n      params,\n    };\n\n    if (this.transport.sendNotification) {\n      await this.transport.sendNotification(notification);\n    } else {\n      throw new Error('Transport does not support notifications');\n    }\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Get recovery status if recovery is enabled\n   */\n  getRecoveryStatus() {\n    return this.recoveryManager?.getStatus();\n  }\n\n  /**\n   * Force a recovery attempt\n   */\n  async forceRecovery(): Promise<boolean> {\n    if (!this.recoveryManager) {\n      throw new Error('Recovery not enabled');\n    }\n    return this.recoveryManager.forceRecovery();\n  }\n\n  private setupRecoveryHandlers(): void {\n    if (!this.recoveryManager) {\n      return;\n    }\n\n    // Handle recovery events\n    this.recoveryManager.on('recoveryStart', ({ trigger }) => {\n      logger.info('Recovery started', { trigger });\n      this.emit('recoveryStart', { trigger });\n    });\n\n    this.recoveryManager.on('recoveryComplete', ({ success, duration }) => {\n      if (success) {\n        logger.info('Recovery completed successfully', { duration });\n        this.connected = true;\n        this.emit('recoverySuccess', { duration });\n      } else {\n        logger.error('Recovery failed');\n        this.emit('recoveryFailed', { duration });\n      }\n    });\n\n    this.recoveryManager.on('fallbackActivated', (state) => {\n      logger.warn('Fallback mode activated', state);\n      this.emit('fallbackActivated', state);\n    });\n\n    this.recoveryManager.on('healthChange', (newStatus, oldStatus) => {\n      this.emit('healthChange', newStatus, oldStatus);\n    });\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    // Clear all pending requests\n    for (const [id, pending] of this.pendingRequests) {\n      clearTimeout(pending.timer);\n      pending.reject(new Error('Client cleanup'));\n    }\n    this.pendingRequests.clear();\n\n    // Cleanup recovery manager\n    if (this.recoveryManager) {\n      await this.recoveryManager.cleanup();\n    }\n\n    // Disconnect if connected\n    await this.disconnect();\n  }\n}\n"],"names":["EventEmitter","logger","RecoveryManager","MCPClient","transport","timeout","connected","recoveryManager","pendingRequests","Map","config","enableRecovery","mcpConfig","recoveryConfig","setupRecoveryHandlers","connect","info","start","emit","error","forceRecovery","disconnect","stop","request","method","params","jsonrpc","id","Math","random","toString","slice","handleRequest","Error","requestPromise","Promise","resolve","reject","timer","setTimeout","delete","set","response","sendRequest","pending","get","clearTimeout","result","notify","notification","sendNotification","isConnected","getRecoveryStatus","getStatus","on","trigger","success","duration","state","warn","newStatus","oldStatus","cleanup","clear"],"mappings":"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"}