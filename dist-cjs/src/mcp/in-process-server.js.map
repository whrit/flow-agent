{"version":3,"sources":["../../../src/mcp/in-process-server.ts"],"sourcesContent":["/**\n * In-Process MCP Server Implementation\n *\n * Provides 10-100x performance improvement by eliminating IPC overhead.\n * Uses Claude Code SDK's in-process server API for direct tool registration.\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '../core/logger.js';\nimport type { MCPTool, MCPContext } from '../utils/types.js';\n\nexport interface InProcessServerConfig {\n  name: string;\n  version?: string;\n  tools?: MCPTool[];\n  enableMetrics?: boolean;\n  enableCaching?: boolean;\n}\n\nexport interface ToolCallMetrics {\n  toolName: string;\n  duration: number;\n  success: boolean;\n  timestamp: number;\n  transport: 'in-process' | 'stdio' | 'sse';\n}\n\n/**\n * In-Process MCP Server\n * Registers Claude-Flow tools directly in the SDK process to eliminate IPC overhead\n */\nexport class InProcessMCPServer extends EventEmitter {\n  private name: string;\n  private version: string;\n  private tools: Map<string, MCPTool>;\n  private metrics: ToolCallMetrics[];\n  private context?: MCPContext;\n  private enableMetrics: boolean;\n  private enableCaching: boolean;\n  private cache: Map<string, { result: any; timestamp: number; ttl: number }>;\n\n  constructor(config: InProcessServerConfig) {\n    super();\n    this.name = config.name;\n    this.version = config.version || '1.0.0';\n    this.tools = new Map();\n    this.metrics = [];\n    this.enableMetrics = config.enableMetrics !== false;\n    this.enableCaching = config.enableCaching !== false;\n    this.cache = new Map();\n\n    if (config.tools) {\n      config.tools.forEach(tool => this.registerTool(tool));\n    }\n\n    logger.info('InProcessMCPServer initialized', {\n      name: this.name,\n      version: this.version,\n      toolCount: this.tools.size,\n    });\n  }\n\n  /**\n   * Register a tool for in-process execution\n   */\n  registerTool(tool: MCPTool): void {\n    if (this.tools.has(tool.name)) {\n      logger.warn('Tool already registered, overwriting', { name: tool.name });\n    }\n\n    this.tools.set(tool.name, tool);\n    logger.debug('Tool registered', { name: tool.name });\n    this.emit('toolRegistered', tool.name);\n  }\n\n  /**\n   * Unregister a tool\n   */\n  unregisterTool(name: string): boolean {\n    const deleted = this.tools.delete(name);\n    if (deleted) {\n      logger.debug('Tool unregistered', { name });\n      this.emit('toolUnregistered', name);\n    }\n    return deleted;\n  }\n\n  /**\n   * Get all registered tool names\n   */\n  getToolNames(): string[] {\n    return Array.from(this.tools.keys());\n  }\n\n  /**\n   * Get tool metadata\n   */\n  getTool(name: string): MCPTool | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Execute a tool call in-process\n   */\n  async callTool(\n    name: string,\n    args: Record<string, unknown>,\n    context?: MCPContext\n  ): Promise<CallToolResult> {\n    const startTime = performance.now();\n    let success = false;\n\n    try {\n      // Check cache first\n      if (this.enableCaching) {\n        const cached = this.checkCache(name, args);\n        if (cached) {\n          logger.debug('Cache hit for tool', { name });\n          success = true;\n          return cached;\n        }\n      }\n\n      const tool = this.tools.get(name);\n      if (!tool) {\n        throw new Error(`Tool not found: ${name}`);\n      }\n\n      logger.debug('Executing tool in-process', { name, args });\n\n      // Merge context\n      const execContext: MCPContext = {\n        ...this.context,\n        ...context,\n      };\n\n      // Execute tool handler directly (in-process, no IPC!)\n      const result = await tool.handler(args, execContext);\n\n      // Cache result if applicable\n      if (this.enableCaching && this.isCacheable(name)) {\n        this.cacheResult(name, args, result);\n      }\n\n      success = true;\n\n      // Return in MCP CallToolResult format\n      return {\n        content: [\n          {\n            type: 'text',\n            text: typeof result === 'string' ? result : JSON.stringify(result, null, 2),\n          },\n        ],\n        isError: false,\n      };\n    } catch (error) {\n      logger.error('Tool execution failed', { name, error });\n      success = false;\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error: ${error instanceof Error ? error.message : String(error)}`,\n          },\n        ],\n        isError: true,\n      };\n    } finally {\n      // Record metrics\n      if (this.enableMetrics) {\n        const duration = performance.now() - startTime;\n        this.recordMetric({\n          toolName: name,\n          duration,\n          success,\n          timestamp: Date.now(),\n          transport: 'in-process',\n        });\n      }\n    }\n  }\n\n  /**\n   * Set execution context (orchestrator, session, etc.)\n   */\n  setContext(context: MCPContext): void {\n    this.context = context;\n    logger.debug('Context updated', { sessionId: context.sessionId });\n  }\n\n  /**\n   * Get performance metrics\n   */\n  getMetrics(): ToolCallMetrics[] {\n    return [...this.metrics];\n  }\n\n  /**\n   * Get performance statistics\n   */\n  getStats() {\n    const stats: Record<\n      string,\n      {\n        totalCalls: number;\n        successRate: number;\n        avgDuration: number;\n        minDuration: number;\n        maxDuration: number;\n      }\n    > = {};\n\n    // Group by tool name\n    const grouped = new Map<string, ToolCallMetrics[]>();\n    for (const metric of this.metrics) {\n      if (!grouped.has(metric.toolName)) {\n        grouped.set(metric.toolName, []);\n      }\n      grouped.get(metric.toolName)!.push(metric);\n    }\n\n    // Calculate statistics\n    for (const [toolName, metrics] of grouped) {\n      const totalCalls = metrics.length;\n      const successfulCalls = metrics.filter(m => m.success).length;\n      const durations = metrics.map(m => m.duration);\n      const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;\n      const minDuration = Math.min(...durations);\n      const maxDuration = Math.max(...durations);\n\n      stats[toolName] = {\n        totalCalls,\n        successRate: successfulCalls / totalCalls,\n        avgDuration,\n        minDuration,\n        maxDuration,\n      };\n    }\n\n    return {\n      toolStats: stats,\n      totalCalls: this.metrics.length,\n      averageDuration:\n        this.metrics.reduce((sum, m) => sum + m.duration, 0) / this.metrics.length || 0,\n      cacheHitRate: this.getCacheHitRate(),\n    };\n  }\n\n  /**\n   * Clear metrics\n   */\n  clearMetrics(): void {\n    this.metrics = [];\n    logger.debug('Metrics cleared');\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n    logger.debug('Cache cleared');\n  }\n\n  /**\n   * Get server info\n   */\n  getInfo() {\n    return {\n      name: this.name,\n      version: this.version,\n      toolCount: this.tools.size,\n      tools: this.getToolNames(),\n      metrics: {\n        totalCalls: this.metrics.length,\n        cacheSize: this.cache.size,\n      },\n    };\n  }\n\n  /**\n   * Record a metric\n   */\n  private recordMetric(metric: ToolCallMetrics): void {\n    this.metrics.push(metric);\n    this.emit('metricRecorded', metric);\n\n    // Keep only last 1000 metrics\n    if (this.metrics.length > 1000) {\n      this.metrics = this.metrics.slice(-1000);\n    }\n  }\n\n  /**\n   * Check cache for a tool call result\n   */\n  private checkCache(\n    name: string,\n    args: Record<string, unknown>\n  ): CallToolResult | undefined {\n    const cacheKey = this.getCacheKey(name, args);\n    const cached = this.cache.get(cacheKey);\n\n    if (cached) {\n      const now = Date.now();\n      if (now - cached.timestamp < cached.ttl) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: typeof cached.result === 'string'\n                ? cached.result\n                : JSON.stringify(cached.result, null, 2),\n            },\n          ],\n          isError: false,\n        };\n      } else {\n        // Expired, remove from cache\n        this.cache.delete(cacheKey);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Cache a tool result\n   */\n  private cacheResult(name: string, args: Record<string, unknown>, result: any): void {\n    const cacheKey = this.getCacheKey(name, args);\n    const ttl = this.getCacheTTL(name);\n\n    this.cache.set(cacheKey, {\n      result,\n      timestamp: Date.now(),\n      ttl,\n    });\n\n    // Limit cache size\n    if (this.cache.size > 100) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n\n  /**\n   * Generate cache key\n   */\n  private getCacheKey(name: string, args: Record<string, unknown>): string {\n    return `${name}:${JSON.stringify(args)}`;\n  }\n\n  /**\n   * Determine if a tool is cacheable\n   */\n  private isCacheable(name: string): boolean {\n    // Only cache read-only operations\n    const cacheableTools = [\n      'agents/list',\n      'agents/info',\n      'tasks/list',\n      'tasks/status',\n      'system/status',\n      'system/metrics',\n      'config/get',\n      'workflow/list',\n      'terminal/list',\n    ];\n\n    return cacheableTools.includes(name);\n  }\n\n  /**\n   * Get cache TTL for a tool\n   */\n  private getCacheTTL(name: string): number {\n    // Different TTLs for different tools\n    const ttls: Record<string, number> = {\n      'agents/list': 5000, // 5 seconds\n      'agents/info': 10000, // 10 seconds\n      'system/status': 2000, // 2 seconds\n      'config/get': 30000, // 30 seconds\n    };\n\n    return ttls[name] || 10000; // Default 10 seconds\n  }\n\n  /**\n   * Calculate cache hit rate\n   */\n  private getCacheHitRate(): number {\n    // Simple estimation based on cache size vs total calls\n    if (this.metrics.length === 0) return 0;\n\n    const cacheableMetrics = this.metrics.filter(m => this.isCacheable(m.toolName));\n    if (cacheableMetrics.length === 0) return 0;\n\n    // Estimate: assume cache hits are very fast (< 1ms)\n    const likelyCacheHits = cacheableMetrics.filter(m => m.duration < 1).length;\n    return likelyCacheHits / cacheableMetrics.length;\n  }\n}\n\n/**\n * Factory function to create an in-process MCP server\n */\nexport function createInProcessServer(config: InProcessServerConfig): InProcessMCPServer {\n  return new InProcessMCPServer(config);\n}"],"names":["EventEmitter","logger","InProcessMCPServer","name","version","tools","metrics","context","enableMetrics","enableCaching","cache","config","Map","forEach","tool","registerTool","info","toolCount","size","has","warn","set","debug","emit","unregisterTool","deleted","delete","getToolNames","Array","from","keys","getTool","get","callTool","args","startTime","performance","now","success","cached","checkCache","Error","execContext","result","handler","isCacheable","cacheResult","content","type","text","JSON","stringify","isError","error","message","String","duration","recordMetric","toolName","timestamp","Date","transport","setContext","sessionId","getMetrics","getStats","stats","grouped","metric","push","totalCalls","length","successfulCalls","filter","m","durations","map","avgDuration","reduce","a","b","minDuration","Math","min","maxDuration","max","successRate","toolStats","averageDuration","sum","cacheHitRate","getCacheHitRate","clearMetrics","clearCache","clear","getInfo","cacheSize","slice","cacheKey","getCacheKey","ttl","undefined","getCacheTTL","firstKey","next","value","cacheableTools","includes","ttls","cacheableMetrics","likelyCacheHits","createInProcessServer"],"mappings":"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"}