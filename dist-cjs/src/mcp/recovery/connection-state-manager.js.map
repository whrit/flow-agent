{"version":3,"sources":["../../../../src/mcp/recovery/connection-state-manager.ts"],"sourcesContent":["/**\n * Connection State Manager for MCP\n * Persists connection state across disconnections\n */\n\nimport { promises as fs } from 'node:fs';\nimport { join } from 'node:path';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPRequest, MCPConfig } from '../../utils/types.js';\n\nexport interface ConnectionState {\n  sessionId: string;\n  lastConnected: Date;\n  lastDisconnected?: Date;\n  pendingRequests: MCPRequest[];\n  configuration: MCPConfig;\n  metadata: Record<string, unknown>;\n}\n\nexport interface ConnectionEvent {\n  timestamp: Date;\n  type: 'connect' | 'disconnect' | 'reconnect' | 'error';\n  sessionId: string;\n  details?: Record<string, unknown>;\n  error?: string;\n}\n\nexport interface ConnectionMetrics {\n  totalConnections: number;\n  totalDisconnections: number;\n  totalReconnections: number;\n  averageSessionDuration: number;\n  averageReconnectionTime: number;\n  lastConnectionDuration?: number;\n  connectionHistory: ConnectionEvent[];\n}\n\nexport interface StateManagerConfig {\n  enablePersistence: boolean;\n  stateDirectory: string;\n  maxHistorySize: number;\n  persistenceInterval: number;\n}\n\nexport class ConnectionStateManager {\n  private currentState?: ConnectionState;\n  private connectionHistory: ConnectionEvent[] = [];\n  private metrics: ConnectionMetrics = {\n    totalConnections: 0,\n    totalDisconnections: 0,\n    totalReconnections: 0,\n    averageSessionDuration: 0,\n    averageReconnectionTime: 0,\n    connectionHistory: [],\n  };\n\n  private persistenceTimer?: NodeJS.Timeout;\n  private statePath: string;\n  private metricsPath: string;\n\n  private readonly defaultConfig: StateManagerConfig = {\n    enablePersistence: true,\n    stateDirectory: '.mcp-state',\n    maxHistorySize: 1000,\n    persistenceInterval: 60000, // 1 minute\n  };\n\n  constructor(\n    private logger: ILogger,\n    config?: Partial<StateManagerConfig>,\n  ) {\n    this.config = { ...this.defaultConfig, ...config };\n\n    this.statePath = join(this.config.stateDirectory, 'connection-state.json');\n    this.metricsPath = join(this.config.stateDirectory, 'connection-metrics.json');\n\n    this.initialize().catch((error) => {\n      this.logger.error('Failed to initialize state manager', error);\n    });\n  }\n\n  private config: StateManagerConfig;\n\n  /**\n   * Initialize the state manager\n   */\n  private async initialize(): Promise<void> {\n    if (!this.config.enablePersistence) {\n      return;\n    }\n\n    try {\n      // Ensure state directory exists\n      await fs.mkdir(this.config.stateDirectory, { recursive: true });\n\n      // Load existing state\n      await this.loadState();\n      await this.loadMetrics();\n\n      // Start persistence timer\n      this.startPersistenceTimer();\n\n      this.logger.info('Connection state manager initialized', {\n        stateDirectory: this.config.stateDirectory,\n      });\n    } catch (error) {\n      this.logger.error('Failed to initialize state manager', error);\n    }\n  }\n\n  /**\n   * Save current connection state\n   */\n  saveState(state: ConnectionState): void {\n    this.currentState = {\n      ...state,\n      metadata: {\n        ...state.metadata,\n        lastSaved: new Date().toISOString(),\n      },\n    };\n\n    this.logger.debug('Connection state saved', {\n      sessionId: state.sessionId,\n      pendingRequests: state.pendingRequests.length,\n    });\n\n    // Persist immediately if critical\n    if (state.pendingRequests.length > 0) {\n      this.persistState().catch((error) => {\n        this.logger.error('Failed to persist critical state', error);\n      });\n    }\n  }\n\n  /**\n   * Restore previous connection state\n   */\n  restoreState(): ConnectionState | null {\n    if (!this.currentState) {\n      this.logger.debug('No state to restore');\n      return null;\n    }\n\n    this.logger.info('Restoring connection state', {\n      sessionId: this.currentState.sessionId,\n      pendingRequests: this.currentState.pendingRequests.length,\n    });\n\n    return { ...this.currentState };\n  }\n\n  /**\n   * Record a connection event\n   */\n  recordEvent(event: Omit<ConnectionEvent, 'timestamp'>): void {\n    const fullEvent: ConnectionEvent = {\n      ...event,\n      timestamp: new Date(),\n    };\n\n    this.connectionHistory.push(fullEvent);\n\n    // Trim history if needed\n    if (this.connectionHistory.length > this.config.maxHistorySize) {\n      this.connectionHistory = this.connectionHistory.slice(-this.config.maxHistorySize);\n    }\n\n    // Update metrics\n    this.updateMetrics(fullEvent);\n\n    this.logger.debug('Connection event recorded', {\n      type: event.type,\n      sessionId: event.sessionId,\n    });\n  }\n\n  /**\n   * Get connection metrics\n   */\n  getMetrics(): ConnectionMetrics {\n    return {\n      ...this.metrics,\n      connectionHistory: [...this.connectionHistory],\n    };\n  }\n\n  /**\n   * Clear a specific session state\n   */\n  clearSession(sessionId: string): void {\n    if (this.currentState?.sessionId === sessionId) {\n      this.currentState = undefined;\n\n      this.logger.info('Session state cleared', { sessionId });\n\n      this.persistState().catch((error) => {\n        this.logger.error('Failed to persist cleared state', error);\n      });\n    }\n  }\n\n  /**\n   * Add a pending request\n   */\n  addPendingRequest(request: MCPRequest): void {\n    if (!this.currentState) {\n      this.logger.warn('No active state to add pending request');\n      return;\n    }\n\n    this.currentState.pendingRequests.push(request);\n\n    this.logger.debug('Pending request added', {\n      requestId: request.id,\n      method: request.method,\n      total: this.currentState.pendingRequests.length,\n    });\n  }\n\n  /**\n   * Remove a pending request\n   */\n  removePendingRequest(requestId: string): void {\n    if (!this.currentState) {\n      return;\n    }\n\n    this.currentState.pendingRequests = this.currentState.pendingRequests.filter(\n      (req) => req.id !== requestId,\n    );\n  }\n\n  /**\n   * Get pending requests\n   */\n  getPendingRequests(): MCPRequest[] {\n    return this.currentState?.pendingRequests || [];\n  }\n\n  /**\n   * Update session metadata\n   */\n  updateMetadata(metadata: Record<string, unknown>): void {\n    if (!this.currentState) {\n      return;\n    }\n\n    this.currentState.metadata = {\n      ...this.currentState.metadata,\n      ...metadata,\n    };\n  }\n\n  /**\n   * Calculate session duration\n   */\n  getSessionDuration(sessionId: string): number | null {\n    const connectEvent = this.connectionHistory.find(\n      (e) => e.sessionId === sessionId && e.type === 'connect',\n    );\n\n    const disconnectEvent = this.connectionHistory.find(\n      (e) => e.sessionId === sessionId && e.type === 'disconnect',\n    );\n\n    if (!connectEvent) {\n      return null;\n    }\n\n    const endTime = disconnectEvent ? disconnectEvent.timestamp : new Date();\n    return endTime.getTime() - connectEvent.timestamp.getTime();\n  }\n\n  /**\n   * Get reconnection time for a session\n   */\n  getReconnectionTime(sessionId: string): number | null {\n    const disconnectEvent = this.connectionHistory.find(\n      (e) => e.sessionId === sessionId && e.type === 'disconnect',\n    );\n\n    const reconnectEvent = this.connectionHistory.find(\n      (e) =>\n        e.sessionId === sessionId &&\n        e.type === 'reconnect' &&\n        e.timestamp > (disconnectEvent?.timestamp || new Date(0)),\n    );\n\n    if (!disconnectEvent || !reconnectEvent) {\n      return null;\n    }\n\n    return reconnectEvent.timestamp.getTime() - disconnectEvent.timestamp.getTime();\n  }\n\n  private updateMetrics(event: ConnectionEvent): void {\n    switch (event.type) {\n      case 'connect':\n        this.metrics.totalConnections++;\n        break;\n\n      case 'disconnect':\n        this.metrics.totalDisconnections++;\n\n        // Calculate session duration\n        const duration = this.getSessionDuration(event.sessionId);\n        if (duration !== null) {\n          this.metrics.lastConnectionDuration = duration;\n\n          // Update average\n          const totalDuration =\n            this.metrics.averageSessionDuration * (this.metrics.totalDisconnections - 1) + duration;\n          this.metrics.averageSessionDuration = totalDuration / this.metrics.totalDisconnections;\n        }\n        break;\n\n      case 'reconnect':\n        this.metrics.totalReconnections++;\n\n        // Calculate reconnection time\n        const reconnectTime = this.getReconnectionTime(event.sessionId);\n        if (reconnectTime !== null) {\n          // Update average\n          const totalTime =\n            this.metrics.averageReconnectionTime * (this.metrics.totalReconnections - 1) +\n            reconnectTime;\n          this.metrics.averageReconnectionTime = totalTime / this.metrics.totalReconnections;\n        }\n        break;\n    }\n  }\n\n  private async loadState(): Promise<void> {\n    try {\n      const data = await fs.readFile(this.statePath, 'utf-8');\n      const state = JSON.parse(data);\n\n      // Convert date strings back to Date objects\n      state.lastConnected = new Date(state.lastConnected);\n      if (state.lastDisconnected) {\n        state.lastDisconnected = new Date(state.lastDisconnected);\n      }\n\n      this.currentState = state;\n\n      this.logger.info('Connection state loaded', {\n        sessionId: state.sessionId,\n        pendingRequests: state.pendingRequests.length,\n      });\n    } catch (error) {\n      if ((error as any).code !== 'ENOENT') {\n        this.logger.error('Failed to load connection state', error);\n      }\n    }\n  }\n\n  private async loadMetrics(): Promise<void> {\n    try {\n      const data = await fs.readFile(this.metricsPath, 'utf-8');\n      const loaded = JSON.parse(data);\n\n      // Convert date strings back to Date objects\n      loaded.connectionHistory = loaded.connectionHistory.map((event: any) => ({\n        ...event,\n        timestamp: new Date(event.timestamp),\n      }));\n\n      this.metrics = loaded;\n      this.connectionHistory = loaded.connectionHistory;\n\n      this.logger.info('Connection metrics loaded', {\n        totalConnections: this.metrics.totalConnections,\n        historySize: this.connectionHistory.length,\n      });\n    } catch (error) {\n      if ((error as any).code !== 'ENOENT') {\n        this.logger.error('Failed to load connection metrics', error);\n      }\n    }\n  }\n\n  private async persistState(): Promise<void> {\n    if (!this.config.enablePersistence) {\n      return;\n    }\n\n    try {\n      if (this.currentState) {\n        await fs.writeFile(this.statePath, JSON.stringify(this.currentState, null, 2), 'utf-8');\n      }\n\n      // Also persist metrics\n      await fs.writeFile(\n        this.metricsPath,\n        JSON.stringify(\n          {\n            ...this.metrics,\n            connectionHistory: this.connectionHistory,\n          },\n          null,\n          2,\n        ),\n        'utf-8',\n      );\n\n      this.logger.debug('State and metrics persisted');\n    } catch (error) {\n      this.logger.error('Failed to persist state', error);\n    }\n  }\n\n  private startPersistenceTimer(): void {\n    if (this.persistenceTimer) {\n      return;\n    }\n\n    this.persistenceTimer = setInterval(() => {\n      this.persistState().catch((error) => {\n        this.logger.error('Periodic persistence failed', error);\n      });\n    }, this.config.persistenceInterval);\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    if (this.persistenceTimer) {\n      clearInterval(this.persistenceTimer);\n      this.persistenceTimer = undefined;\n    }\n\n    // Final persistence\n    await this.persistState();\n  }\n}\n"],"names":["promises","fs","join","ConnectionStateManager","currentState","connectionHistory","metrics","totalConnections","totalDisconnections","totalReconnections","averageSessionDuration","averageReconnectionTime","persistenceTimer","statePath","metricsPath","defaultConfig","enablePersistence","stateDirectory","maxHistorySize","persistenceInterval","logger","config","initialize","catch","error","mkdir","recursive","loadState","loadMetrics","startPersistenceTimer","info","saveState","state","metadata","lastSaved","Date","toISOString","debug","sessionId","pendingRequests","length","persistState","restoreState","recordEvent","event","fullEvent","timestamp","push","slice","updateMetrics","type","getMetrics","clearSession","undefined","addPendingRequest","request","warn","requestId","id","method","total","removePendingRequest","filter","req","getPendingRequests","updateMetadata","getSessionDuration","connectEvent","find","e","disconnectEvent","endTime","getTime","getReconnectionTime","reconnectEvent","duration","lastConnectionDuration","totalDuration","reconnectTime","totalTime","data","readFile","JSON","parse","lastConnected","lastDisconnected","code","loaded","map","historySize","writeFile","stringify","setInterval","cleanup","clearInterval"],"mappings":"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"}