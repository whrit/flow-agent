{"version":3,"sources":["../../../../src/mcp/recovery/recovery-manager.ts"],"sourcesContent":["/**\n * Recovery Manager for MCP\n * Orchestrates all recovery components for comprehensive connection stability\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPClient } from '../client.js';\nimport { ConnectionHealthMonitor, HealthStatus } from './connection-health-monitor.js';\nimport { ReconnectionManager } from './reconnection-manager.js';\nimport { FallbackCoordinator } from './fallback-coordinator.js';\nimport { ConnectionStateManager } from './connection-state-manager.js';\nimport type { MCPConfig, MCPRequest } from '../../utils/types.js';\n\nexport interface RecoveryConfig {\n  enableRecovery: boolean;\n  healthMonitor?: {\n    heartbeatInterval?: number;\n    heartbeatTimeout?: number;\n    maxMissedHeartbeats?: number;\n  };\n  reconnection?: {\n    maxRetries?: number;\n    initialDelay?: number;\n    maxDelay?: number;\n    backoffMultiplier?: number;\n  };\n  fallback?: {\n    enableFallback?: boolean;\n    maxQueueSize?: number;\n    cliPath?: string;\n  };\n  state?: {\n    enablePersistence?: boolean;\n    stateDirectory?: string;\n  };\n}\n\nexport interface RecoveryStatus {\n  isRecoveryActive: boolean;\n  connectionHealth: HealthStatus;\n  reconnectionState: {\n    attempts: number;\n    isReconnecting: boolean;\n    nextDelay?: number;\n  };\n  fallbackState: {\n    isFallbackActive: boolean;\n    queuedOperations: number;\n  };\n  metrics: {\n    totalRecoveries: number;\n    successfulRecoveries: number;\n    failedRecoveries: number;\n    averageRecoveryTime: number;\n  };\n}\n\nexport class RecoveryManager extends EventEmitter {\n  private healthMonitor: ConnectionHealthMonitor;\n  private reconnectionManager: ReconnectionManager;\n  private fallbackCoordinator: FallbackCoordinator;\n  private stateManager: ConnectionStateManager;\n\n  private isRecoveryActive = false;\n  private recoveryStartTime?: Date;\n  private metrics = {\n    totalRecoveries: 0,\n    successfulRecoveries: 0,\n    failedRecoveries: 0,\n    totalRecoveryTime: 0,\n  };\n\n  constructor(\n    private client: MCPClient,\n    private mcpConfig: MCPConfig,\n    private logger: ILogger,\n    config?: RecoveryConfig,\n  ) {\n    super();\n\n    // Initialize components\n    this.healthMonitor = new ConnectionHealthMonitor(client, logger, config?.healthMonitor);\n\n    this.reconnectionManager = new ReconnectionManager(client, logger, config?.reconnection);\n\n    this.fallbackCoordinator = new FallbackCoordinator(logger, config?.fallback);\n\n    this.stateManager = new ConnectionStateManager(logger, config?.state);\n\n    // Set up component event handlers\n    this.setupEventHandlers();\n\n    this.logger.info('Recovery manager initialized');\n  }\n\n  /**\n   * Start recovery management\n   */\n  async start(): Promise<void> {\n    this.logger.info('Starting recovery manager');\n\n    // Start health monitoring\n    await this.healthMonitor.start();\n\n    // Restore any previous state\n    const previousState = this.stateManager.restoreState();\n    if (previousState && previousState.pendingRequests.length > 0) {\n      this.logger.info('Restored previous connection state', {\n        sessionId: previousState.sessionId,\n        pendingRequests: previousState.pendingRequests.length,\n      });\n\n      // Queue pending requests for retry\n      previousState.pendingRequests.forEach((request) => {\n        this.fallbackCoordinator.queueOperation({\n          type: 'tool',\n          method: request.method,\n          params: request.params,\n          priority: 'high',\n          retryable: true,\n        });\n      });\n    }\n\n    this.emit('started');\n  }\n\n  /**\n   * Stop recovery management\n   */\n  async stop(): Promise<void> {\n    this.logger.info('Stopping recovery manager');\n\n    // Stop all components\n    await this.healthMonitor.stop();\n    this.reconnectionManager.stopReconnection();\n    this.fallbackCoordinator.disableCLIFallback();\n    await this.stateManager.cleanup();\n\n    this.emit('stopped');\n  }\n\n  /**\n   * Get current recovery status\n   */\n  getStatus(): RecoveryStatus {\n    const healthStatus = this.healthMonitor.getHealthStatus();\n    const reconnectionState = this.reconnectionManager.getState();\n    const fallbackState = this.fallbackCoordinator.getState();\n\n    return {\n      isRecoveryActive: this.isRecoveryActive,\n      connectionHealth: healthStatus,\n      reconnectionState: {\n        attempts: reconnectionState.attempts,\n        isReconnecting: reconnectionState.isReconnecting,\n        nextDelay: reconnectionState.nextDelay,\n      },\n      fallbackState: {\n        isFallbackActive: fallbackState.isFallbackActive,\n        queuedOperations: fallbackState.queuedOperations,\n      },\n      metrics: {\n        totalRecoveries: this.metrics.totalRecoveries,\n        successfulRecoveries: this.metrics.successfulRecoveries,\n        failedRecoveries: this.metrics.failedRecoveries,\n        averageRecoveryTime:\n          this.metrics.totalRecoveries > 0\n            ? this.metrics.totalRecoveryTime / this.metrics.totalRecoveries\n            : 0,\n      },\n    };\n  }\n\n  /**\n   * Force a recovery attempt\n   */\n  async forceRecovery(): Promise<boolean> {\n    this.logger.info('Forcing recovery attempt');\n\n    // Check if already recovering\n    if (this.isRecoveryActive) {\n      this.logger.warn('Recovery already in progress');\n      return false;\n    }\n\n    return this.startRecovery('manual');\n  }\n\n  /**\n   * Handle a request that needs recovery consideration\n   */\n  async handleRequest(request: MCPRequest): Promise<void> {\n    // Add to pending requests if disconnected\n    if (!this.client.isConnected()) {\n      this.stateManager.addPendingRequest(request);\n\n      // Queue for fallback execution\n      this.fallbackCoordinator.queueOperation({\n        type: 'tool',\n        method: request.method,\n        params: request.params,\n        priority: 'medium',\n        retryable: true,\n      });\n    }\n  }\n\n  private setupEventHandlers(): void {\n    // Health monitor events\n    this.healthMonitor.on('connectionLost', async ({ error }) => {\n      this.logger.error('Connection lost, initiating recovery', error);\n      await this.startRecovery('health-check');\n    });\n\n    this.healthMonitor.on('healthChange', (newStatus, oldStatus) => {\n      this.emit('healthChange', newStatus, oldStatus);\n\n      // Record state change\n      this.stateManager.recordEvent({\n        type: newStatus.healthy ? 'connect' : 'disconnect',\n        sessionId: this.generateSessionId(),\n        details: { health: newStatus },\n      });\n    });\n\n    // Reconnection manager events\n    this.reconnectionManager.on('success', async ({ attempts, duration }) => {\n      this.logger.info('Reconnection successful', { attempts, duration });\n      await this.completeRecovery(true);\n    });\n\n    this.reconnectionManager.on('maxRetriesExceeded', async () => {\n      this.logger.error('Max reconnection attempts exceeded');\n      await this.completeRecovery(false);\n    });\n\n    this.reconnectionManager.on('attemptFailed', ({ attempt, error }) => {\n      this.emit('recoveryAttemptFailed', { attempt, error });\n    });\n\n    // Fallback coordinator events\n    this.fallbackCoordinator.on('fallbackEnabled', (state) => {\n      this.logger.warn('Fallback mode activated', state);\n      this.emit('fallbackActivated', state);\n    });\n\n    this.fallbackCoordinator.on('replayOperation', async (operation) => {\n      // Replay operation through MCP client\n      if (this.client.isConnected()) {\n        try {\n          await this.client.request(operation.method, operation.params);\n          this.stateManager.removePendingRequest(operation.id);\n        } catch (error) {\n          this.logger.error('Failed to replay operation', { operation, error });\n        }\n      }\n    });\n  }\n\n  private async startRecovery(trigger: string): Promise<boolean> {\n    if (this.isRecoveryActive) {\n      return false;\n    }\n\n    this.isRecoveryActive = true;\n    this.recoveryStartTime = new Date();\n    this.metrics.totalRecoveries++;\n\n    this.logger.info('Starting recovery process', { trigger });\n    this.emit('recoveryStart', { trigger });\n\n    // Save current state\n    this.stateManager.saveState({\n      sessionId: this.generateSessionId(),\n      lastConnected: new Date(),\n      pendingRequests: [],\n      configuration: this.mcpConfig,\n      metadata: { trigger },\n    });\n\n    // Enable fallback mode immediately\n    this.fallbackCoordinator.enableCLIFallback();\n\n    // Start reconnection attempts\n    this.reconnectionManager.startAutoReconnect();\n\n    return true;\n  }\n\n  private async completeRecovery(success: boolean): Promise<void> {\n    if (!this.isRecoveryActive) {\n      return;\n    }\n\n    const duration = this.recoveryStartTime ? Date.now() - this.recoveryStartTime.getTime() : 0;\n\n    this.isRecoveryActive = false;\n    this.recoveryStartTime = undefined;\n\n    if (success) {\n      this.metrics.successfulRecoveries++;\n      this.metrics.totalRecoveryTime += duration;\n\n      // Disable fallback mode\n      this.fallbackCoordinator.disableCLIFallback();\n\n      // Process any queued operations\n      await this.fallbackCoordinator.processQueue();\n\n      // Reset health monitor\n      this.healthMonitor.reset();\n\n      // Record reconnection\n      this.stateManager.recordEvent({\n        type: 'reconnect',\n        sessionId: this.generateSessionId(),\n        details: { duration },\n      });\n\n      this.logger.info('Recovery completed successfully', { duration });\n      this.emit('recoveryComplete', { success: true, duration });\n    } else {\n      this.metrics.failedRecoveries++;\n\n      this.logger.error('Recovery failed');\n      this.emit('recoveryComplete', { success: false, duration });\n\n      // Keep fallback active\n      this.emit('fallbackPermanent');\n    }\n  }\n\n  private generateSessionId(): string {\n    return `recovery-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    await this.stop();\n  }\n}\n"],"names":["EventEmitter","ConnectionHealthMonitor","ReconnectionManager","FallbackCoordinator","ConnectionStateManager","RecoveryManager","healthMonitor","reconnectionManager","fallbackCoordinator","stateManager","isRecoveryActive","recoveryStartTime","metrics","totalRecoveries","successfulRecoveries","failedRecoveries","totalRecoveryTime","client","mcpConfig","logger","config","reconnection","fallback","state","setupEventHandlers","info","start","previousState","restoreState","pendingRequests","length","sessionId","forEach","request","queueOperation","type","method","params","priority","retryable","emit","stop","stopReconnection","disableCLIFallback","cleanup","getStatus","healthStatus","getHealthStatus","reconnectionState","getState","fallbackState","connectionHealth","attempts","isReconnecting","nextDelay","isFallbackActive","queuedOperations","averageRecoveryTime","forceRecovery","warn","startRecovery","handleRequest","isConnected","addPendingRequest","on","error","newStatus","oldStatus","recordEvent","healthy","generateSessionId","details","health","duration","completeRecovery","attempt","operation","removePendingRequest","id","trigger","Date","saveState","lastConnected","configuration","metadata","enableCLIFallback","startAutoReconnect","success","now","getTime","undefined","processQueue","reset","Math","random","toString","slice"],"mappings":"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"}