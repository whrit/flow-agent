{"version":3,"sources":["../../../../src/mcp/recovery/fallback-coordinator.ts"],"sourcesContent":["/**\n * Fallback Coordinator for MCP\n * Manages graceful degradation to CLI when MCP connection fails\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPRequest } from '../../utils/types.js';\nimport { exec } from 'node:child_process';\nimport { promisify } from 'node:util';\n\nconst execAsync = promisify(exec);\n\nexport interface FallbackOperation {\n  id: string;\n  type: 'tool' | 'resource' | 'notification';\n  method: string;\n  params: unknown;\n  timestamp: Date;\n  priority: 'high' | 'medium' | 'low';\n  retryable: boolean;\n}\n\nexport interface FallbackConfig {\n  enableFallback: boolean;\n  maxQueueSize: number;\n  queueTimeout: number;\n  cliPath: string;\n  fallbackNotificationInterval: number;\n}\n\nexport interface FallbackState {\n  isFallbackActive: boolean;\n  queuedOperations: number;\n  failedOperations: number;\n  successfulOperations: number;\n  lastFallbackActivation?: Date;\n}\n\nexport class FallbackCoordinator extends EventEmitter {\n  private operationQueue: FallbackOperation[] = [];\n  private state: FallbackState;\n  private notificationTimer?: NodeJS.Timeout;\n  private processingQueue = false;\n\n  private readonly defaultConfig: FallbackConfig = {\n    enableFallback: true,\n    maxQueueSize: 100,\n    queueTimeout: 300000, // 5 minutes\n    cliPath: 'npx ruv-swarm',\n    fallbackNotificationInterval: 30000, // 30 seconds\n  };\n\n  constructor(\n    private logger: ILogger,\n    config?: Partial<FallbackConfig>,\n  ) {\n    super();\n    this.config = { ...this.defaultConfig, ...config };\n\n    this.state = {\n      isFallbackActive: false,\n      queuedOperations: 0,\n      failedOperations: 0,\n      successfulOperations: 0,\n    };\n  }\n\n  private config: FallbackConfig;\n\n  /**\n   * Check if MCP is available\n   */\n  async isMCPAvailable(): Promise<boolean> {\n    try {\n      // Try to execute a simple MCP command\n      const { stdout } = await execAsync(`${this.config.cliPath} status --json`);\n      const status = JSON.parse(stdout);\n      return status.connected === true;\n    } catch (error) {\n      this.logger.debug('MCP availability check failed', error);\n      return false;\n    }\n  }\n\n  /**\n   * Enable CLI fallback mode\n   */\n  enableCLIFallback(): void {\n    if (this.state.isFallbackActive) {\n      this.logger.debug('Fallback already active');\n      return;\n    }\n\n    this.logger.warn('Enabling CLI fallback mode');\n\n    this.state.isFallbackActive = true;\n    this.state.lastFallbackActivation = new Date();\n\n    // Start notification timer\n    this.startNotificationTimer();\n\n    this.emit('fallbackEnabled', this.state);\n  }\n\n  /**\n   * Disable CLI fallback mode\n   */\n  disableCLIFallback(): void {\n    if (!this.state.isFallbackActive) {\n      return;\n    }\n\n    this.logger.info('Disabling CLI fallback mode');\n\n    this.state.isFallbackActive = false;\n\n    // Stop notification timer\n    this.stopNotificationTimer();\n\n    this.emit('fallbackDisabled', this.state);\n\n    // Process any queued operations\n    if (this.operationQueue.length > 0) {\n      this.processQueue().catch((error) => {\n        this.logger.error('Error processing queue after fallback disabled', error);\n      });\n    }\n  }\n\n  /**\n   * Queue an operation for later execution\n   */\n  queueOperation(operation: Omit<FallbackOperation, 'id' | 'timestamp'>): void {\n    if (!this.config.enableFallback) {\n      this.logger.debug('Fallback disabled, operation not queued');\n      return;\n    }\n\n    if (this.operationQueue.length >= this.config.maxQueueSize) {\n      this.logger.warn('Operation queue full, removing oldest operation');\n      this.operationQueue.shift();\n      this.state.failedOperations++;\n    }\n\n    const queuedOp: FallbackOperation = {\n      ...operation,\n      id: this.generateOperationId(),\n      timestamp: new Date(),\n    };\n\n    this.operationQueue.push(queuedOp);\n    this.state.queuedOperations = this.operationQueue.length;\n\n    this.logger.debug('Operation queued', {\n      id: queuedOp.id,\n      type: queuedOp.type,\n      method: queuedOp.method,\n      queueSize: this.operationQueue.length,\n    });\n\n    this.emit('operationQueued', queuedOp);\n\n    // If in fallback mode, try to execute via CLI\n    if (this.state.isFallbackActive && !this.processingQueue) {\n      this.executeViaCliFallback(queuedOp).catch((error) => {\n        this.logger.error('CLI fallback execution failed', { operation: queuedOp, error });\n      });\n    }\n  }\n\n  /**\n   * Process all queued operations\n   */\n  async processQueue(): Promise<void> {\n    if (this.processingQueue || this.operationQueue.length === 0) {\n      return;\n    }\n\n    this.processingQueue = true;\n    this.logger.info('Processing operation queue', {\n      queueSize: this.operationQueue.length,\n    });\n\n    this.emit('queueProcessingStart', this.operationQueue.length);\n\n    const results = {\n      successful: 0,\n      failed: 0,\n    };\n\n    // Process operations in order\n    while (this.operationQueue.length > 0) {\n      const operation = this.operationQueue.shift()!;\n\n      // Check if operation has expired\n      if (this.isOperationExpired(operation)) {\n        this.logger.warn('Operation expired', { id: operation.id });\n        results.failed++;\n        continue;\n      }\n\n      try {\n        await this.replayOperation(operation);\n        results.successful++;\n        this.state.successfulOperations++;\n      } catch (error) {\n        this.logger.error('Failed to replay operation', {\n          operation,\n          error,\n        });\n        results.failed++;\n        this.state.failedOperations++;\n\n        // Re-queue if retryable\n        if (operation.retryable) {\n          this.operationQueue.push(operation);\n        }\n      }\n    }\n\n    this.state.queuedOperations = this.operationQueue.length;\n    this.processingQueue = false;\n\n    this.logger.info('Queue processing complete', results);\n    this.emit('queueProcessingComplete', results);\n  }\n\n  /**\n   * Get current fallback state\n   */\n  getState(): FallbackState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get queued operations\n   */\n  getQueuedOperations(): FallbackOperation[] {\n    return [...this.operationQueue];\n  }\n\n  /**\n   * Clear operation queue\n   */\n  clearQueue(): void {\n    const clearedCount = this.operationQueue.length;\n    this.operationQueue = [];\n    this.state.queuedOperations = 0;\n\n    this.logger.info('Operation queue cleared', { clearedCount });\n    this.emit('queueCleared', clearedCount);\n  }\n\n  private async executeViaCliFallback(operation: FallbackOperation): Promise<void> {\n    this.logger.debug('Executing operation via CLI fallback', {\n      id: operation.id,\n      method: operation.method,\n    });\n\n    try {\n      // Map MCP operations to CLI commands\n      const cliCommand = this.mapOperationToCli(operation);\n\n      if (!cliCommand) {\n        throw new Error(`No CLI mapping for operation: ${operation.method}`);\n      }\n\n      const { stdout, stderr } = await execAsync(cliCommand);\n\n      if (stderr) {\n        this.logger.warn('CLI command stderr', { stderr });\n      }\n\n      this.logger.debug('CLI fallback execution successful', {\n        id: operation.id,\n        stdout: stdout.substring(0, 200), // Log first 200 chars\n      });\n\n      this.state.successfulOperations++;\n      this.emit('fallbackExecutionSuccess', { operation, result: stdout });\n    } catch (error) {\n      this.logger.error('CLI fallback execution failed', {\n        operation,\n        error,\n      });\n\n      this.state.failedOperations++;\n      this.emit('fallbackExecutionFailed', { operation, error });\n\n      // Re-queue if retryable\n      if (operation.retryable) {\n        this.queueOperation(operation);\n      }\n    }\n  }\n\n  private async replayOperation(operation: FallbackOperation): Promise<void> {\n    // This would typically use the MCP client to replay the operation\n    // For now, we'll log it\n    this.logger.info('Replaying operation', {\n      id: operation.id,\n      method: operation.method,\n    });\n\n    // Emit event for handling by the MCP client\n    this.emit('replayOperation', operation);\n  }\n\n  private mapOperationToCli(operation: FallbackOperation): string | null {\n    // Map common MCP operations to CLI commands\n    const mappings: Record<string, (params: any) => string> = {\n      // Tool operations\n      'tools/list': () => `${this.config.cliPath} tools list`,\n      'tools/call': (params) =>\n        `${this.config.cliPath} tools call ${params.name} '${JSON.stringify(params.arguments)}'`,\n\n      // Resource operations\n      'resources/list': () => `${this.config.cliPath} resources list`,\n      'resources/read': (params) => `${this.config.cliPath} resources read ${params.uri}`,\n\n      // Session operations\n      initialize: () => `${this.config.cliPath} session init`,\n      shutdown: () => `${this.config.cliPath} session shutdown`,\n\n      // Custom operations\n      heartbeat: () => `${this.config.cliPath} health check`,\n    };\n\n    const mapper = mappings[operation.method];\n    return mapper ? mapper(operation.params) : null;\n  }\n\n  private isOperationExpired(operation: FallbackOperation): boolean {\n    const age = Date.now() - operation.timestamp.getTime();\n    return age > this.config.queueTimeout;\n  }\n\n  private generateOperationId(): string {\n    return `op-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  }\n\n  private startNotificationTimer(): void {\n    if (this.notificationTimer) {\n      return;\n    }\n\n    this.notificationTimer = setInterval(() => {\n      if (this.state.isFallbackActive && this.operationQueue.length > 0) {\n        this.logger.info('Fallback mode active', {\n          queuedOperations: this.operationQueue.length,\n          duration: Date.now() - (this.state.lastFallbackActivation?.getTime() || 0),\n        });\n\n        this.emit('fallbackStatus', this.state);\n      }\n    }, this.config.fallbackNotificationInterval);\n  }\n\n  private stopNotificationTimer(): void {\n    if (this.notificationTimer) {\n      clearInterval(this.notificationTimer);\n      this.notificationTimer = undefined;\n    }\n  }\n}\n"],"names":["EventEmitter","exec","promisify","execAsync","FallbackCoordinator","operationQueue","state","notificationTimer","processingQueue","defaultConfig","enableFallback","maxQueueSize","queueTimeout","cliPath","fallbackNotificationInterval","logger","config","isFallbackActive","queuedOperations","failedOperations","successfulOperations","isMCPAvailable","stdout","status","JSON","parse","connected","error","debug","enableCLIFallback","warn","lastFallbackActivation","Date","startNotificationTimer","emit","disableCLIFallback","info","stopNotificationTimer","length","processQueue","catch","queueOperation","operation","shift","queuedOp","id","generateOperationId","timestamp","push","type","method","queueSize","executeViaCliFallback","results","successful","failed","isOperationExpired","replayOperation","retryable","getState","getQueuedOperations","clearQueue","clearedCount","cliCommand","mapOperationToCli","Error","stderr","substring","result","mappings","params","name","stringify","arguments","uri","initialize","shutdown","heartbeat","mapper","age","now","getTime","Math","random","toString","slice","setInterval","duration","clearInterval","undefined"],"mappings":"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"}