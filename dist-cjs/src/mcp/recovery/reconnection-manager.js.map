{"version":3,"sources":["../../../../src/mcp/recovery/reconnection-manager.ts"],"sourcesContent":["/**\n * Reconnection Manager for MCP\n * Handles automatic reconnection with exponential backoff\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../core/logger.js';\nimport type { MCPClient } from '../client.js';\n\nexport interface ReconnectionConfig {\n  maxRetries: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitterFactor: number;\n  resetAfterSuccess: boolean;\n}\n\nexport interface ReconnectionState {\n  attempts: number;\n  nextDelay: number;\n  isReconnecting: boolean;\n  lastAttempt?: Date;\n  lastError?: Error;\n}\n\nexport class ReconnectionManager extends EventEmitter {\n  private state: ReconnectionState;\n  private reconnectTimer?: NodeJS.Timeout;\n  private reconnectPromise?: Promise<boolean>;\n\n  private readonly defaultConfig: ReconnectionConfig = {\n    maxRetries: 10,\n    initialDelay: 1000,\n    maxDelay: 30000,\n    backoffMultiplier: 2,\n    jitterFactor: 0.1,\n    resetAfterSuccess: true,\n  };\n\n  constructor(\n    private client: MCPClient,\n    private logger: ILogger,\n    config?: Partial<ReconnectionConfig>,\n  ) {\n    super();\n    this.config = { ...this.defaultConfig, ...config };\n\n    this.state = {\n      attempts: 0,\n      nextDelay: this.config.initialDelay,\n      isReconnecting: false,\n    };\n  }\n\n  private config: ReconnectionConfig;\n\n  /**\n   * Attempt to reconnect\n   */\n  async attemptReconnection(): Promise<boolean> {\n    // Prevent concurrent reconnection attempts\n    if (this.reconnectPromise) {\n      this.logger.debug('Reconnection already in progress');\n      return this.reconnectPromise;\n    }\n\n    if (this.state.attempts >= this.config.maxRetries) {\n      this.logger.error('Max reconnection attempts exceeded');\n      this.emit('maxRetriesExceeded', this.state);\n      return false;\n    }\n\n    this.reconnectPromise = this.performReconnection();\n    const result = await this.reconnectPromise;\n    this.reconnectPromise = undefined;\n\n    return result;\n  }\n\n  /**\n   * Start automatic reconnection\n   */\n  startAutoReconnect(): void {\n    if (this.state.isReconnecting) {\n      this.logger.debug('Auto-reconnect already active');\n      return;\n    }\n\n    this.logger.info('Starting automatic reconnection');\n    this.state.isReconnecting = true;\n    this.emit('reconnectStart');\n\n    this.scheduleReconnect();\n  }\n\n  /**\n   * Stop reconnection attempts\n   */\n  stopReconnection(): void {\n    if (!this.state.isReconnecting) {\n      return;\n    }\n\n    this.logger.info('Stopping reconnection attempts');\n\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = undefined;\n    }\n\n    this.state.isReconnecting = false;\n    this.emit('reconnectStop');\n  }\n\n  /**\n   * Reset reconnection state\n   */\n  reset(): void {\n    this.logger.debug('Resetting reconnection manager');\n\n    this.stopReconnection();\n    this.state = {\n      attempts: 0,\n      nextDelay: this.config.initialDelay,\n      isReconnecting: false,\n    };\n  }\n\n  /**\n   * Get current reconnection state\n   */\n  getState(): ReconnectionState {\n    return { ...this.state };\n  }\n\n  /**\n   * Calculate next retry delay\n   */\n  getNextDelay(): number {\n    return this.state.nextDelay;\n  }\n\n  private async performReconnection(): Promise<boolean> {\n    this.state.attempts++;\n    this.state.lastAttempt = new Date();\n\n    this.logger.info('Attempting reconnection', {\n      attempt: this.state.attempts,\n      maxRetries: this.config.maxRetries,\n      delay: this.state.nextDelay,\n    });\n\n    this.emit('attemptStart', {\n      attempt: this.state.attempts,\n      delay: this.state.nextDelay,\n    });\n\n    try {\n      // Disconnect first if needed\n      if (this.client.isConnected()) {\n        await this.client.disconnect();\n      }\n\n      // Attempt to reconnect\n      await this.client.connect();\n\n      // Success!\n      this.logger.info('Reconnection successful', {\n        attempts: this.state.attempts,\n      });\n\n      this.emit('success', {\n        attempts: this.state.attempts,\n        duration: Date.now() - this.state.lastAttempt.getTime(),\n      });\n\n      // Reset state if configured\n      if (this.config.resetAfterSuccess) {\n        this.reset();\n      }\n\n      return true;\n    } catch (error) {\n      this.state.lastError = error as Error;\n\n      this.logger.error('Reconnection failed', {\n        attempt: this.state.attempts,\n        error: (error as Error).message,\n      });\n\n      this.emit('attemptFailed', {\n        attempt: this.state.attempts,\n        error: error as Error,\n      });\n\n      // Calculate next delay with exponential backoff\n      this.calculateNextDelay();\n\n      // Schedule next attempt if within retry limit\n      if (this.state.attempts < this.config.maxRetries && this.state.isReconnecting) {\n        this.scheduleReconnect();\n      } else if (this.state.attempts >= this.config.maxRetries) {\n        this.logger.error('Max reconnection attempts reached');\n        this.emit('maxRetriesExceeded', this.state);\n        this.state.isReconnecting = false;\n      }\n\n      return false;\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (!this.state.isReconnecting) {\n      return;\n    }\n\n    const delay = this.addJitter(this.state.nextDelay);\n\n    this.logger.debug('Scheduling next reconnection attempt', {\n      delay,\n      baseDelay: this.state.nextDelay,\n    });\n\n    this.reconnectTimer = setTimeout(() => {\n      this.attemptReconnection().catch((error) => {\n        this.logger.error('Scheduled reconnection error', error);\n      });\n    }, delay);\n\n    this.emit('attemptScheduled', {\n      attempt: this.state.attempts + 1,\n      delay,\n    });\n  }\n\n  private calculateNextDelay(): void {\n    // Exponential backoff calculation\n    const nextDelay = Math.min(\n      this.state.nextDelay * this.config.backoffMultiplier,\n      this.config.maxDelay,\n    );\n\n    this.state.nextDelay = nextDelay;\n\n    this.logger.debug('Calculated next delay', {\n      delay: nextDelay,\n      multiplier: this.config.backoffMultiplier,\n      maxDelay: this.config.maxDelay,\n    });\n  }\n\n  private addJitter(delay: number): number {\n    // Add random jitter to prevent thundering herd\n    const jitter = delay * this.config.jitterFactor;\n    const randomJitter = (Math.random() - 0.5) * 2 * jitter;\n\n    return Math.max(0, delay + randomJitter);\n  }\n\n  /**\n   * Force immediate reconnection attempt\n   */\n  async forceReconnect(): Promise<boolean> {\n    this.logger.info('Forcing immediate reconnection');\n\n    // Cancel any scheduled reconnect\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = undefined;\n    }\n\n    // Reset delay for immediate attempt\n    const originalDelay = this.state.nextDelay;\n    this.state.nextDelay = 0;\n\n    const result = await this.attemptReconnection();\n\n    // Restore delay if failed\n    if (!result) {\n      this.state.nextDelay = originalDelay;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get estimated time until next reconnection attempt\n   */\n  getTimeUntilNextAttempt(): number | null {\n    if (!this.state.isReconnecting || !this.reconnectTimer) {\n      return null;\n    }\n\n    // This is an approximation since we don't track the exact timer start\n    return this.state.nextDelay;\n  }\n}\n"],"names":["EventEmitter","ReconnectionManager","state","reconnectTimer","reconnectPromise","defaultConfig","maxRetries","initialDelay","maxDelay","backoffMultiplier","jitterFactor","resetAfterSuccess","client","logger","config","attempts","nextDelay","isReconnecting","attemptReconnection","debug","error","emit","performReconnection","result","undefined","startAutoReconnect","info","scheduleReconnect","stopReconnection","clearTimeout","reset","getState","getNextDelay","lastAttempt","Date","attempt","delay","isConnected","disconnect","connect","duration","now","getTime","lastError","message","calculateNextDelay","addJitter","baseDelay","setTimeout","catch","Math","min","multiplier","jitter","randomJitter","random","max","forceReconnect","originalDelay","getTimeUntilNextAttempt"],"mappings":"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"}