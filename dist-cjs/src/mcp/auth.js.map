{"version":3,"sources":["../../../src/mcp/auth.ts"],"sourcesContent":["/**\n * Authentication and authorization for MCP\n */\n\nimport type { MCPAuthConfig, MCPSession } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport type { MCPError } from '../utils/errors.js';\nimport { createHash, timingSafeEqual } from 'node:crypto';\n\nexport interface IAuthManager {\n  authenticate(credentials: unknown): Promise<AuthResult>;\n  authorize(session: MCPSession, permission: string): boolean;\n  validateToken(token: string): Promise<TokenValidation>;\n  generateToken(userId: string, permissions: string[]): Promise<string>;\n  revokeToken(token: string): Promise<void>;\n}\n\nexport interface AuthResult {\n  success: boolean;\n  user?: string;\n  permissions?: string[];\n  token?: string;\n  error?: string;\n}\n\nexport interface TokenValidation {\n  valid: boolean;\n  user?: string;\n  permissions?: string[];\n  expiresAt?: Date;\n  error?: string;\n}\n\n/**\n * Authentication manager implementation\n */\nexport class AuthManager implements IAuthManager {\n  private revokedTokens = new Set<string>();\n  private tokenStore = new Map<\n    string,\n    {\n      user: string;\n      permissions: string[];\n      createdAt: Date;\n      expiresAt: Date;\n    }\n  >();\n\n  constructor(\n    private config: MCPAuthConfig,\n    private logger: ILogger,\n  ) {\n    // Start token cleanup timer\n    if (config.enabled) {\n      setInterval(() => {\n        this.cleanupExpiredTokens();\n      }, 300000); // Clean up every 5 minutes\n    }\n  }\n\n  async authenticate(credentials: unknown): Promise<AuthResult> {\n    if (!this.config.enabled) {\n      return {\n        success: true,\n        user: 'anonymous',\n        permissions: ['*'],\n      };\n    }\n\n    this.logger.debug('Authenticating credentials', {\n      method: this.config.method,\n      hasCredentials: !!credentials,\n    });\n\n    try {\n      switch (this.config.method) {\n        case 'token':\n          return await this.authenticateToken(credentials);\n        case 'basic':\n          return await this.authenticateBasic(credentials);\n        case 'oauth':\n          return await this.authenticateOAuth(credentials);\n        default:\n          return {\n            success: false,\n            error: `Unsupported authentication method: ${this.config.method}`,\n          };\n      }\n    } catch (error) {\n      this.logger.error('Authentication error', error);\n      return {\n        success: false,\n        error:\n          error instanceof Error\n            ? error instanceof Error\n              ? error.message\n              : String(error)\n            : 'Authentication failed',\n      };\n    }\n  }\n\n  authorize(session: MCPSession, permission: string): boolean {\n    if (!this.config.enabled || !session.authenticated) {\n      return !this.config.enabled; // If auth disabled, allow all\n    }\n\n    const permissions = session.authData?.permissions || [];\n\n    // Check for wildcard permission\n    if (permissions.includes('*')) {\n      return true;\n    }\n\n    // Check for exact permission match\n    if (permissions.includes(permission)) {\n      return true;\n    }\n\n    // Check for prefix-based permissions (e.g., \"tools.*\" matches \"tools.list\")\n    for (const perm of permissions) {\n      if (perm.endsWith('*') && permission.startsWith(perm.slice(0, -1))) {\n        return true;\n      }\n    }\n\n    this.logger.warn('Authorization denied', {\n      sessionId: session.id,\n      user: session.authData?.user,\n      permission,\n      userPermissions: permissions,\n    });\n\n    return false;\n  }\n\n  async validateToken(token: string): Promise<TokenValidation> {\n    if (this.revokedTokens.has(token)) {\n      return {\n        valid: false,\n        error: 'Token has been revoked',\n      };\n    }\n\n    const tokenData = this.tokenStore.get(token);\n    if (!tokenData) {\n      return {\n        valid: false,\n        error: 'Invalid token',\n      };\n    }\n\n    if (tokenData.expiresAt < new Date()) {\n      this.tokenStore.delete(token);\n      return {\n        valid: false,\n        error: 'Token has expired',\n      };\n    }\n\n    return {\n      valid: true,\n      user: tokenData.user,\n      permissions: tokenData.permissions,\n      expiresAt: tokenData.expiresAt,\n    };\n  }\n\n  async generateToken(userId: string, permissions: string[]): Promise<string> {\n    const token = this.createSecureToken();\n    const now = new Date();\n    const expiresAt = new Date(now.getTime() + (this.config.sessionTimeout || 3600000));\n\n    this.tokenStore.set(token, {\n      user: userId,\n      permissions,\n      createdAt: now,\n      expiresAt,\n    });\n\n    this.logger.info('Token generated', {\n      userId,\n      permissions,\n      expiresAt,\n    });\n\n    return token;\n  }\n\n  async revokeToken(token: string): Promise<void> {\n    this.revokedTokens.add(token);\n    this.tokenStore.delete(token);\n    this.logger.info('Token revoked', { token: token.substring(0, 8) + '...' });\n  }\n\n  private async authenticateToken(credentials: unknown): Promise<AuthResult> {\n    const token = this.extractToken(credentials);\n    if (!token) {\n      return {\n        success: false,\n        error: 'Token not provided',\n      };\n    }\n\n    // Check if it's a stored token (generated by us)\n    const validation = await this.validateToken(token);\n    if (validation.valid) {\n      return {\n        success: true,\n        user: validation.user!,\n        permissions: validation.permissions!,\n        token,\n      };\n    }\n\n    // Check against configured static tokens\n    if (this.config.tokens && this.config.tokens.length > 0) {\n      const isValid = this.config.tokens.some((validToken) => {\n        return this.timingSafeEqual(token, validToken);\n      });\n\n      if (isValid) {\n        return {\n          success: true,\n          user: 'token-user',\n          permissions: ['*'], // Static tokens get all permissions\n          token,\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: 'Invalid token',\n    };\n  }\n\n  private async authenticateBasic(credentials: unknown): Promise<AuthResult> {\n    const { username, password } = this.extractBasicAuth(credentials);\n    if (!username || !password) {\n      return {\n        success: false,\n        error: 'Username and password required',\n      };\n    }\n\n    if (!this.config.users || this.config.users.length === 0) {\n      return {\n        success: false,\n        error: 'No users configured',\n      };\n    }\n\n    const user = this.config.users.find((u) => u.username === username);\n    if (!user) {\n      return {\n        success: false,\n        error: 'Invalid username or password',\n      };\n    }\n\n    // Verify password\n    const isValidPassword = this.verifyPassword(password, user.password);\n    if (!isValidPassword) {\n      return {\n        success: false,\n        error: 'Invalid username or password',\n      };\n    }\n\n    // Generate a session token\n    const token = await this.generateToken(username, user.permissions);\n\n    return {\n      success: true,\n      user: username,\n      permissions: user.permissions,\n      token,\n    };\n  }\n\n  private async authenticateOAuth(credentials: unknown): Promise<AuthResult> {\n    // TODO: Implement OAuth authentication\n    // This would typically involve:\n    // 1. Validating JWT tokens\n    // 2. Checking token expiration\n    // 3. Extracting user info and permissions from token claims\n\n    this.logger.warn('OAuth authentication not yet implemented');\n    return {\n      success: false,\n      error: 'OAuth authentication not implemented',\n    };\n  }\n\n  private extractToken(credentials: unknown): string | null {\n    if (typeof credentials === 'string') {\n      return credentials;\n    }\n\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n\n      if (typeof creds.token === 'string') {\n        return creds.token;\n      }\n\n      if (typeof creds.authorization === 'string') {\n        const match = creds.authorization.match(/^Bearer\\s+(.+)$/i);\n        return match ? match[1] : null;\n      }\n    }\n\n    return null;\n  }\n\n  private extractBasicAuth(credentials: unknown): { username?: string; password?: string } {\n    if (typeof credentials === 'object' && credentials !== null) {\n      const creds = credentials as Record<string, unknown>;\n\n      if (typeof creds.username === 'string' && typeof creds.password === 'string') {\n        return {\n          username: creds.username,\n          password: creds.password,\n        };\n      }\n\n      if (typeof creds.authorization === 'string') {\n        const match = creds.authorization.match(/^Basic\\s+(.+)$/i);\n        if (match) {\n          try {\n            const decoded = atob(match[1]);\n            const colonIndex = decoded.indexOf(':');\n            if (colonIndex >= 0) {\n              return {\n                username: decoded.substring(0, colonIndex),\n                password: decoded.substring(colonIndex + 1),\n              };\n            }\n          } catch {\n            // Invalid base64\n          }\n        }\n      }\n    }\n\n    return {};\n  }\n\n  private verifyPassword(providedPassword: string, storedPassword: string): boolean {\n    // For now, using simple hash comparison\n    // In production, use proper password hashing like bcrypt\n    const hashedProvided = this.hashPassword(providedPassword);\n    const hashedStored = this.hashPassword(storedPassword);\n\n    return this.timingSafeEqual(hashedProvided, hashedStored);\n  }\n\n  private hashPassword(password: string): string {\n    return createHash('sha256').update(password).digest('hex');\n  }\n\n  private timingSafeEqual(a: string, b: string): boolean {\n    const encoder = new TextEncoder();\n    const bufferA = encoder.encode(a);\n    const bufferB = encoder.encode(b);\n\n    if (bufferA.length !== bufferB.length) {\n      return false;\n    }\n\n    return timingSafeEqual(bufferA, bufferB);\n  }\n\n  private createSecureToken(): string {\n    // Generate a secure random token\n    const timestamp = Date.now().toString(36);\n    const random1 = Math.random().toString(36).substring(2, 15);\n    const random2 = Math.random().toString(36).substring(2, 15);\n    const hash = createHash('sha256')\n      .update(`${timestamp}${random1}${random2}`)\n      .digest('hex')\n      .substring(0, 32);\n\n    return `mcp_${timestamp}_${hash}`;\n  }\n\n  private cleanupExpiredTokens(): void {\n    const now = new Date();\n    let cleaned = 0;\n\n    for (const [token, data] of this.tokenStore.entries()) {\n      if (data.expiresAt < now) {\n        this.tokenStore.delete(token);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.debug('Cleaned up expired tokens', { count: cleaned });\n    }\n  }\n}\n\n/**\n * Permission constants for common operations\n */\nexport const Permissions = {\n  // System operations\n  SYSTEM_INFO: 'system.info',\n  SYSTEM_HEALTH: 'system.health',\n  SYSTEM_METRICS: 'system.metrics',\n\n  // Tool operations\n  TOOLS_LIST: 'tools.list',\n  TOOLS_INVOKE: 'tools.invoke',\n  TOOLS_DESCRIBE: 'tools.describe',\n\n  // Agent operations\n  AGENTS_LIST: 'agents.list',\n  AGENTS_SPAWN: 'agents.spawn',\n  AGENTS_TERMINATE: 'agents.terminate',\n  AGENTS_INFO: 'agents.info',\n\n  // Task operations\n  TASKS_LIST: 'tasks.list',\n  TASKS_CREATE: 'tasks.create',\n  TASKS_CANCEL: 'tasks.cancel',\n  TASKS_STATUS: 'tasks.status',\n\n  // Memory operations\n  MEMORY_READ: 'memory.read',\n  MEMORY_WRITE: 'memory.write',\n  MEMORY_QUERY: 'memory.query',\n  MEMORY_DELETE: 'memory.delete',\n\n  // Administrative operations\n  ADMIN_CONFIG: 'admin.config',\n  ADMIN_LOGS: 'admin.logs',\n  ADMIN_SESSIONS: 'admin.sessions',\n\n  // Wildcard permission\n  ALL: '*',\n} as const;\n\nexport type Permission = (typeof Permissions)[keyof typeof Permissions];\n"],"names":["createHash","timingSafeEqual","AuthManager","revokedTokens","Set","tokenStore","Map","config","logger","enabled","setInterval","cleanupExpiredTokens","authenticate","credentials","success","user","permissions","debug","method","hasCredentials","authenticateToken","authenticateBasic","authenticateOAuth","error","Error","message","String","authorize","session","permission","authenticated","authData","includes","perm","endsWith","startsWith","slice","warn","sessionId","id","userPermissions","validateToken","token","has","valid","tokenData","get","expiresAt","Date","delete","generateToken","userId","createSecureToken","now","getTime","sessionTimeout","set","createdAt","info","revokeToken","add","substring","extractToken","validation","tokens","length","isValid","some","validToken","username","password","extractBasicAuth","users","find","u","isValidPassword","verifyPassword","creds","authorization","match","decoded","atob","colonIndex","indexOf","providedPassword","storedPassword","hashedProvided","hashPassword","hashedStored","update","digest","a","b","encoder","TextEncoder","bufferA","encode","bufferB","timestamp","toString","random1","Math","random","random2","hash","cleaned","data","entries","count","Permissions","SYSTEM_INFO","SYSTEM_HEALTH","SYSTEM_METRICS","TOOLS_LIST","TOOLS_INVOKE","TOOLS_DESCRIBE","AGENTS_LIST","AGENTS_SPAWN","AGENTS_TERMINATE","AGENTS_INFO","TASKS_LIST","TASKS_CREATE","TASKS_CANCEL","TASKS_STATUS","MEMORY_READ","MEMORY_WRITE","MEMORY_QUERY","MEMORY_DELETE","ADMIN_CONFIG","ADMIN_LOGS","ADMIN_SESSIONS","ALL"],"mappings":"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"}