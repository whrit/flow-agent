{"version":3,"sources":["../../../src/mcp/claude-code-wrapper.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  Tool,\n  CallToolResult,\n  TextContent,\n  ImageContent,\n  EmbeddedResource,\n} from '@modelcontextprotocol/sdk/types.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\nimport { SparcMode, loadSparcModes } from './sparc-modes.js';\n// Simple ID generation\nfunction generateId(): string {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\ninterface SparcContext {\n  memoryKey?: string;\n  parallel?: boolean;\n  timeout?: number;\n  workingDirectory?: string;\n}\n\ninterface SwarmAgent {\n  id: string;\n  mode: string;\n  task: string;\n  status: 'pending' | 'active' | 'completed' | 'failed';\n  result?: any;\n}\n\ninterface SwarmExecution {\n  id: string;\n  objective: string;\n  strategy: string;\n  mode: string;\n  agents: SwarmAgent[];\n  startTime: Date;\n  endTime?: Date;\n  status: 'active' | 'completed' | 'failed';\n}\n\nexport class ClaudeCodeMCPWrapper {\n  private server: Server;\n  private sparcModes: Map<string, SparcMode> = new Map();\n  private swarmExecutions: Map<string, SwarmExecution> = new Map();\n  private claudeCodeMCP: any; // Reference to Claude Code MCP client\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'claude-flow-wrapper',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    this.setupHandlers();\n    this.loadSparcModes();\n  }\n\n  private async loadSparcModes() {\n    try {\n      const modes = await loadSparcModes();\n      modes.forEach((mode) => {\n        this.sparcModes.set(mode.name, mode);\n      });\n    } catch (error) {\n      console.error('Failed to load SPARC modes:', error);\n    }\n  }\n\n  private setupHandlers() {\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({\n      tools: await this.getTools(),\n    }));\n\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =>\n      this.handleToolCall(request.params.name, request.params.arguments || {}),\n    );\n  }\n\n  private async getTools(): Promise<Tool[]> {\n    const tools: Tool[] = [];\n\n    // Add SPARC mode tools\n    for (const [name, mode] of this.sparcModes) {\n      tools.push({\n        name: `sparc_${name}`,\n        description: `Execute SPARC ${name} mode: ${mode.description}`,\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task: {\n              type: 'string',\n              description: 'The task description for the SPARC mode to execute',\n            },\n            context: {\n              type: 'object',\n              description: 'Optional context or parameters for the task',\n              properties: {\n                memoryKey: {\n                  type: 'string',\n                  description: 'Memory key to store results',\n                },\n                parallel: {\n                  type: 'boolean',\n                  description: 'Enable parallel execution',\n                },\n              },\n            },\n          },\n          required: ['task'],\n        },\n      });\n    }\n\n    // Add meta tools\n    tools.push(\n      {\n        name: 'sparc_list',\n        description: 'List all available SPARC modes',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            verbose: {\n              type: 'boolean',\n              description: 'Include detailed information',\n            },\n          },\n        },\n      },\n      {\n        name: 'sparc_swarm',\n        description: 'Coordinate multiple SPARC agents in a swarm',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            objective: {\n              type: 'string',\n              description: 'The swarm objective',\n            },\n            strategy: {\n              type: 'string',\n              enum: [\n                'research',\n                'development',\n                'analysis',\n                'testing',\n                'optimization',\n                'maintenance',\n              ],\n              description: 'Swarm execution strategy',\n            },\n            mode: {\n              type: 'string',\n              enum: ['centralized', 'distributed', 'hierarchical', 'mesh', 'hybrid'],\n              description: 'Coordination mode',\n            },\n            maxAgents: {\n              type: 'number',\n              description: 'Maximum number of agents',\n              default: 5,\n            },\n          },\n          required: ['objective', 'strategy'],\n        },\n      },\n      {\n        name: 'sparc_swarm_status',\n        description: 'Check status of running swarms and list created files',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            swarmId: {\n              type: 'string',\n              description: 'Optional swarm ID to check specific swarm',\n            },\n          },\n        },\n      },\n    );\n\n    return tools;\n  }\n\n  private async handleToolCall(toolName: string, args: any): Promise<CallToolResult> {\n    try {\n      if (toolName.startsWith('sparc_')) {\n        return await this.handleSparcTool(toolName, args);\n      }\n\n      // Pass through to Claude Code MCP\n      return this.forwardToClaudeCode(toolName, args);\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error: ${error instanceof Error ? error.message : String(error)}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n\n  private async handleSparcTool(toolName: string, args: any): Promise<CallToolResult> {\n    const mode = toolName.replace('sparc_', '');\n\n    // Handle special tools\n    if (mode === 'list') {\n      return this.listModes(args.verbose);\n    }\n    if (mode === 'swarm') {\n      return this.handleSwarm(args);\n    }\n    if (mode === 'swarm_status') {\n      return this.getSwarmStatus(args.swarmId);\n    }\n\n    // Standard SPARC mode execution\n    const sparcMode = this.sparcModes.get(mode);\n    if (!sparcMode) {\n      throw new Error(`Unknown SPARC mode: ${mode}`);\n    }\n\n    // Execute the SPARC mode directly\n    try {\n      // Import the execution function dynamically to avoid circular dependencies\n      // const { executeSparcMode } = await import('../cli/mcp-stdio-server.js');\n      // TODO: Implement proper SPARC mode execution or fix import path\n      const executeSparcMode = (mode: string, task: string, tools: any[], context: any) => {\n        throw new Error('SPARC mode execution not yet implemented in wrapper');\n      };\n\n      const result = await executeSparcMode(\n        mode,\n        args.task,\n        sparcMode.tools || [],\n        args.context || {},\n      );\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: result.output,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error executing SPARC ${mode}: ${error instanceof Error ? error.message : String(error)}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n  }\n\n  private buildEnhancedPrompt(mode: SparcMode, task: string, context?: SparcContext): string {\n    const parts: string[] = [];\n\n    // Add SPARC mode header\n    parts.push(`SPARC: ${mode.name}\\n`);\n    parts.push(`## Mode Description\\n${mode.description}\\n`);\n\n    // Add available tools\n    if (mode.tools && mode.tools.length > 0) {\n      parts.push(`## Available Tools`);\n      mode.tools.forEach((tool) => {\n        parts.push(`- **${tool}**: ${this.getToolDescription(tool)}`);\n      });\n      parts.push('');\n    }\n\n    // Add usage pattern\n    if (mode.usagePattern) {\n      parts.push(`## Usage Pattern\\n\\`\\`\\`javascript\\n${mode.usagePattern}\\n\\`\\`\\`\\n`);\n    }\n\n    // Add best practices\n    if (mode.bestPractices) {\n      parts.push(`## Best Practices`);\n      mode.bestPractices.forEach((practice) => {\n        parts.push(`- ${practice}`);\n      });\n      parts.push('');\n    }\n\n    // Add integration capabilities\n    if (mode.integrationCapabilities) {\n      parts.push(`## Integration Capabilities\\nThis mode integrates with:`);\n      mode.integrationCapabilities.forEach((capability) => {\n        parts.push(`- ${capability}`);\n      });\n      parts.push('');\n    }\n\n    // Add instructions\n    if (mode.instructions) {\n      parts.push(`## Instructions\\n${mode.instructions}\\n`);\n    }\n\n    // Add the actual task\n    parts.push(`## TASK: ${task}\\n`);\n\n    // Add SPARC methodology\n    parts.push(this.getSparcMethodology(mode.name, task, context));\n\n    // Add context if provided\n    if (context) {\n      if (context.memoryKey) {\n        parts.push(`**Memory Key:** \\`${context.memoryKey}\\``);\n      }\n      if (context.parallel) {\n        parts.push(`**Parallel Execution:** Enabled`);\n      }\n      if (context.workingDirectory) {\n        parts.push(`**Working Directory:** ${context.workingDirectory}`);\n      }\n    }\n\n    return parts.join('\\n');\n  }\n\n  private getToolDescription(tool: string): string {\n    const descriptions: Record<string, string> = {\n      TodoWrite: 'Create and manage task coordination',\n      TodoRead: 'Monitor task progress and status',\n      Task: 'Spawn and manage specialized agents',\n      Memory: 'Store and retrieve coordination data',\n      Bash: 'Execute system commands',\n      Read: 'Read file contents',\n      Write: 'Write files',\n      Edit: 'Edit existing files',\n      MultiEdit: 'Make multiple edits to a file',\n      Glob: 'Search for files by pattern',\n      Grep: 'Search file contents',\n      WebSearch: 'Search the web',\n      WebFetch: 'Fetch web content',\n    };\n    return descriptions[tool] || `${tool} tool`;\n  }\n\n  private getSparcMethodology(mode: string, task: string, context?: SparcContext): string {\n    return `\n# üéØ SPARC METHODOLOGY EXECUTION FRAMEWORK\n\nYou are operating in **SPARC ${mode} mode**. Follow the SPARC Workflow precisely:\n\n## SPARC Workflow Steps\n\n### 1Ô∏è‚É£ SPECIFICATION - Clarify goals, scope, constraints\n**Your Task:** ${task}\n\n**Analysis Required:**\n- Break down into clear, measurable objectives\n- Identify all requirements and constraints  \n- Define acceptance criteria\n- Never hard-code environment variables\n\n**Use TodoWrite to capture specifications:**\n\\`\\`\\`javascript\nTodoWrite([\n  {\n    id: \"specification\",\n    content: \"Clarify goals, scope, and constraints for: ${task}\",\n    status: \"pending\",\n    priority: \"high\"\n  },\n  {\n    id: \"acceptance_criteria\", \n    content: \"Define clear acceptance criteria and success metrics\",\n    status: \"pending\",\n    priority: \"high\"\n  }\n]);\n\\`\\`\\`\n\n### 2Ô∏è‚É£ PSEUDOCODE - High-level logic with TDD anchors\n**Design Approach:**\n- Identify core functions and data structures\n- Create TDD test anchors before implementation\n- Map out component interactions\n\n### 3Ô∏è‚É£ ARCHITECTURE - Design extensible systems\n**Architecture Requirements:**\n- Clear service boundaries\n- Define interfaces between components\n- Design for extensibility and maintainability\n- Mode-specific architecture: ${this.getModeSpecificArchitecture(mode)}\n\n### 4Ô∏è‚É£ REFINEMENT - Iterate with TDD and security\n**Refinement Process:**\n- TDD implementation cycles\n- Security vulnerability checks (injection, XSS, CSRF)\n- Performance optimization\n- Code review and refactoring\n- All files must be ‚â§ 500 lines\n\n### 5Ô∏è‚É£ COMPLETION - Integrate and verify\n**Completion Checklist:**\n- [ ] All acceptance criteria met\n- [ ] Tests passing (comprehensive test suite)\n- [ ] Security review completed\n- [ ] Documentation updated\n- [ ] Results stored in Memory: \\`sparc_${mode}_${Date.now()}\\`\n- [ ] No hard-coded secrets or env vars\n- [ ] Proper error handling in all code paths\n\n## üöÄ Execution Configuration\n\n**Mode:** ${mode}\n**Strategy:** ${this.getModeStrategy(mode)}\n**Memory Key:** \\`sparc_${mode}_${Date.now()}\\`\n**Batch Operations:** ${context?.parallel ? 'Enabled' : 'Standard operations'}\n**Primary Tools:** ${this.sparcModes.get(mode)?.tools?.join(', ') || 'Standard tools'}\n\n## üìã Must Block (Non-negotiable)\n- Every file ‚â§ 500 lines\n- No hard-coded secrets or env vars\n- All user inputs validated\n- No security vulnerabilities\n- Proper error handling in all paths\n- Each subtask ends with completion check\n\n## üéØ IMMEDIATE ACTION REQUIRED\n\n**START NOW with SPARC Step 1 - SPECIFICATION:**\n\n1. Create comprehensive TodoWrite task breakdown following SPARC workflow\n2. Set \"specification\" task to \"in_progress\"\n3. Analyze requirements and define acceptance criteria\n4. Store initial analysis in Memory: \\`sparc_${mode}_${Date.now()}\\`\n\n**Remember:** You're in **${mode}** mode. Follow the SPARC workflow systematically:\nSpecification ‚Üí Pseudocode ‚Üí Architecture ‚Üí Refinement ‚Üí Completion\n\nUse the appropriate tools for each phase and maintain progress in TodoWrite.`;\n  }\n\n  private getModeSpecificArchitecture(mode: string): string {\n    const architectures: Record<string, string> = {\n      orchestrator: 'Design for parallel agent coordination with clear task boundaries',\n      coder: 'Focus on clean code architecture with proper abstractions',\n      researcher: 'Structure for data collection and analysis pipelines',\n      tdd: 'Test-first design with comprehensive test coverage',\n      architect: 'System-wide design patterns and component interactions',\n      reviewer: 'Code quality gates and review checkpoints',\n      debugger: 'Diagnostic and monitoring integration points',\n      tester: 'Test framework integration and coverage analysis',\n    };\n    return architectures[mode] || 'Design for the specific mode requirements';\n  }\n\n  private getModeStrategy(mode: string): string {\n    const strategies: Record<string, string> = {\n      orchestrator: 'Parallel coordination',\n      coder: 'Iterative development',\n      researcher: 'Deep analysis',\n      tdd: 'Test-driven cycles',\n      architect: 'System design',\n      reviewer: 'Quality assurance',\n      debugger: 'Systematic debugging',\n      tester: 'Comprehensive validation',\n    };\n    return strategies[mode] || 'Mode-specific execution';\n  }\n\n  private listModes(verbose: boolean): CallToolResult {\n    const modes = Array.from(this.sparcModes.values());\n\n    if (verbose) {\n      const content = modes.map((mode) => ({\n        name: mode.name,\n        description: mode.description,\n        tools: mode.tools,\n        bestPractices: mode.bestPractices,\n      }));\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(content, null, 2),\n          },\n        ],\n      };\n    }\n\n    const list = modes.map((m) => `- **${m.name}**: ${m.description}`).join('\\n');\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Available SPARC modes:\\n\\n${list}`,\n        },\n      ],\n    };\n  }\n\n  private async handleSwarm(args: any): Promise<CallToolResult> {\n    const { objective, strategy, mode = 'distributed', maxAgents = 5 } = args;\n    const swarmId = generateId();\n\n    // Plan swarm agents\n    const agents = this.planSwarmAgents(objective, strategy, maxAgents);\n\n    // Create swarm execution record\n    const execution: SwarmExecution = {\n      id: swarmId,\n      objective,\n      strategy,\n      mode,\n      agents,\n      startTime: new Date(),\n      status: 'active',\n    };\n\n    this.swarmExecutions.set(swarmId, execution);\n\n    // Launch agents based on coordination mode\n    if (mode === 'distributed' || mode === 'mesh') {\n      // Parallel execution\n      await Promise.all(agents.map((agent) => this.launchSwarmAgent(agent, execution)));\n    } else {\n      // Sequential execution\n      for (const agent of agents) {\n        await this.launchSwarmAgent(agent, execution);\n      }\n    }\n\n    execution.status = 'completed';\n    execution.endTime = new Date();\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify(\n            {\n              swarmId,\n              objective,\n              strategy,\n              mode,\n              agentCount: agents.length,\n              status: 'launched',\n              message: 'Swarm coordination initiated',\n            },\n            null,\n            2,\n          ),\n        },\n      ],\n    };\n  }\n\n  private planSwarmAgents(objective: string, strategy: string, maxAgents: number): SwarmAgent[] {\n    const agents: SwarmAgent[] = [];\n\n    // Strategy-based agent planning\n    switch (strategy) {\n      case 'research':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'researcher',\n            task: `Research: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'analyst',\n            task: `Analyze findings for: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'documenter',\n            task: `Document research results: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'development':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'architect',\n            task: `Design architecture: ${objective}`,\n            status: 'pending',\n          },\n          { id: generateId(), mode: 'coder', task: `Implement: ${objective}`, status: 'pending' },\n          {\n            id: generateId(),\n            mode: 'tester',\n            task: `Test implementation: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'reviewer',\n            task: `Review code: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'analysis':\n        agents.push(\n          { id: generateId(), mode: 'analyst', task: `Analyze: ${objective}`, status: 'pending' },\n          {\n            id: generateId(),\n            mode: 'optimizer',\n            task: `Optimize based on analysis: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'testing':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'tester',\n            task: `Create test suite: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'debugger',\n            task: `Debug issues: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'optimization':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'analyst',\n            task: `Performance analysis: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'optimizer',\n            task: `Optimize: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n\n      case 'maintenance':\n        agents.push(\n          {\n            id: generateId(),\n            mode: 'reviewer',\n            task: `Code review: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'debugger',\n            task: `Fix issues: ${objective}`,\n            status: 'pending',\n          },\n          {\n            id: generateId(),\n            mode: 'documenter',\n            task: `Update documentation: ${objective}`,\n            status: 'pending',\n          },\n        );\n        break;\n    }\n\n    // Limit to maxAgents\n    return agents.slice(0, maxAgents);\n  }\n\n  private async launchSwarmAgent(agent: SwarmAgent, execution: SwarmExecution): Promise<void> {\n    agent.status = 'active';\n\n    try {\n      // Use the SPARC mode handler\n      const result = await this.handleSparcTool(`sparc_${agent.mode}`, {\n        task: agent.task,\n        context: {\n          memoryKey: `swarm_${execution.id}_${agent.id}`,\n          parallel: execution.mode === 'distributed',\n        },\n      });\n\n      agent.status = 'completed';\n      agent.result = result;\n    } catch (error) {\n      agent.status = 'failed';\n      agent.result = { error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n\n  private getSwarmStatus(swarmId?: string): CallToolResult {\n    if (swarmId) {\n      const execution = this.swarmExecutions.get(swarmId);\n      if (!execution) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No swarm found with ID: ${swarmId}`,\n            },\n          ],\n        };\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(execution, null, 2),\n          },\n        ],\n      };\n    }\n\n    // Return all swarms\n    const swarms = Array.from(this.swarmExecutions.values()).map((e) => ({\n      id: e.id,\n      objective: e.objective,\n      status: e.status,\n      agentCount: e.agents.length,\n      startTime: e.startTime,\n      endTime: e.endTime,\n    }));\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify(swarms, null, 2),\n        },\n      ],\n    };\n  }\n\n  private async forwardToClaudeCode(toolName: string, args: any): Promise<CallToolResult> {\n    // For SPARC tools that were already handled, this shouldn't be called\n    // For other tools, we execute them using the existing logic\n\n    if (toolName === 'Task') {\n      // This is a SPARC task that's been enhanced with prompts\n      // Extract the mode from the description if possible\n      const modeMatch = args.description?.match(/SPARC (\\w+)/);\n      if (modeMatch) {\n        const modeName = modeMatch[1];\n        const mode = this.sparcModes.get(modeName);\n        if (mode) {\n          // Execute using the existing SPARC execution logic\n          try {\n            const result = await executeSparcMode(\n              modeName,\n              args.prompt || '',\n              mode.tools || [],\n              {},\n            );\n\n            return {\n              content: [\n                {\n                  type: 'text',\n                  text: result.output,\n                },\n              ],\n            };\n          } catch (error) {\n            return {\n              content: [\n                {\n                  type: 'text',\n                  text: `Error executing SPARC ${modeName}: ${error instanceof Error ? error.message : String(error)}`,\n                },\n              ],\n              isError: true,\n            };\n          }\n        }\n      }\n    }\n\n    // For non-SPARC tools, return a message\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Tool ${toolName} is not available in this MCP server.`,\n        },\n      ],\n      isError: true,\n    };\n  }\n\n  async run() {\n    const transport = new StdioServerTransport();\n\n    // Log startup message\n    console.error('üöÄ Claude-Flow MCP Server (Wrapper Mode)');\n    console.error('üì¶ Using Claude Code MCP pass-through with SPARC prompt injection');\n    console.error('üîß All SPARC tools available with enhanced AI capabilities');\n    console.error('‚ÑπÔ∏è  To use legacy mode, set CLAUDE_FLOW_LEGACY_MCP=true');\n    console.error('');\n\n    await this.server.connect(transport);\n  }\n}\n\n// Run the server if this is the main module\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const wrapper = new ClaudeCodeMCPWrapper();\n  wrapper.run().catch(console.error);\n}\n"],"names":["Server","StdioServerTransport","CallToolRequestSchema","ListToolsRequestSchema","path","fileURLToPath","loadSparcModes","generateId","Date","now","Math","random","toString","substr","__filename","url","__dirname","dirname","ClaudeCodeMCPWrapper","server","sparcModes","Map","swarmExecutions","claudeCodeMCP","name","version","capabilities","tools","setupHandlers","modes","forEach","mode","set","error","console","setRequestHandler","getTools","request","handleToolCall","params","arguments","push","description","inputSchema","type","properties","task","context","memoryKey","parallel","required","verbose","objective","strategy","enum","maxAgents","default","swarmId","toolName","args","startsWith","handleSparcTool","forwardToClaudeCode","content","text","Error","message","String","isError","replace","listModes","handleSwarm","getSwarmStatus","sparcMode","get","executeSparcMode","result","output","buildEnhancedPrompt","parts","length","tool","getToolDescription","usagePattern","bestPractices","practice","integrationCapabilities","capability","instructions","getSparcMethodology","workingDirectory","join","descriptions","TodoWrite","TodoRead","Task","Memory","Bash","Read","Write","Edit","MultiEdit","Glob","Grep","WebSearch","WebFetch","getModeSpecificArchitecture","getModeStrategy","architectures","orchestrator","coder","researcher","tdd","architect","reviewer","debugger","tester","strategies","Array","from","values","map","JSON","stringify","list","m","agents","planSwarmAgents","execution","id","startTime","status","Promise","all","agent","launchSwarmAgent","endTime","agentCount","slice","swarms","e","modeMatch","match","modeName","prompt","run","transport","connect","process","argv","wrapper","catch"],"mappings":"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"}