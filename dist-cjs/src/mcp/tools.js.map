{"version":3,"sources":["../../../src/mcp/tools.ts"],"sourcesContent":["/**\n * Enhanced Tool registry for MCP with capability negotiation and discovery\n */\n\nimport type { MCPTool, MCPCapabilities, MCPProtocolVersion } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError } from '../utils/errors.js';\nimport { EventEmitter } from 'node:events';\n\nexport interface ToolCapability {\n  name: string;\n  version: string;\n  description: string;\n  category: string;\n  tags: string[];\n  requiredPermissions?: string[];\n  supportedProtocolVersions: MCPProtocolVersion[];\n  dependencies?: string[];\n  deprecated?: boolean;\n  deprecationMessage?: string;\n}\n\nexport interface ToolMetrics {\n  name: string;\n  totalInvocations: number;\n  successfulInvocations: number;\n  failedInvocations: number;\n  averageExecutionTime: number;\n  lastInvoked?: Date;\n  totalExecutionTime: number;\n}\n\nexport interface ToolDiscoveryQuery {\n  category?: string;\n  tags?: string[];\n  capabilities?: string[];\n  protocolVersion?: MCPProtocolVersion;\n  includeDeprecated?: boolean;\n  permissions?: string[];\n}\n\n/**\n * Enhanced Tool registry implementation with capability negotiation\n */\nexport class ToolRegistry extends EventEmitter {\n  private tools = new Map<string, MCPTool>();\n  private capabilities = new Map<string, ToolCapability>();\n  private metrics = new Map<string, ToolMetrics>();\n  private categories = new Set<string>();\n  private tags = new Set<string>();\n\n  constructor(private logger: ILogger) {\n    super();\n  }\n\n  /**\n   * Registers a new tool with enhanced capability information\n   */\n  register(tool: MCPTool, capability?: ToolCapability): void {\n    if (this.tools.has(tool.name)) {\n      throw new MCPError(`Tool already registered: ${tool.name}`);\n    }\n\n    // Validate tool schema\n    this.validateTool(tool);\n\n    // Register tool\n    this.tools.set(tool.name, tool);\n\n    // Register capability if provided\n    if (capability) {\n      this.registerCapability(tool.name, capability);\n    } else {\n      // Create default capability\n      const defaultCapability: ToolCapability = {\n        name: tool.name,\n        version: '1.0.0',\n        description: tool.description,\n        category: this.extractCategory(tool.name),\n        tags: this.extractTags(tool),\n        supportedProtocolVersions: [{ major: 2024, minor: 11, patch: 5 }],\n      };\n      this.registerCapability(tool.name, defaultCapability);\n    }\n\n    // Initialize metrics\n    this.metrics.set(tool.name, {\n      name: tool.name,\n      totalInvocations: 0,\n      successfulInvocations: 0,\n      failedInvocations: 0,\n      averageExecutionTime: 0,\n      totalExecutionTime: 0,\n    });\n\n    this.logger.debug('Tool registered', { name: tool.name });\n    this.emit('toolRegistered', { name: tool.name, capability });\n  }\n\n  /**\n   * Unregisters a tool\n   */\n  unregister(name: string): void {\n    if (!this.tools.has(name)) {\n      throw new MCPError(`Tool not found: ${name}`);\n    }\n\n    this.tools.delete(name);\n    this.logger.debug('Tool unregistered', { name });\n  }\n\n  /**\n   * Gets a tool by name\n   */\n  getTool(name: string): MCPTool | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Lists all registered tools\n   */\n  listTools(): Array<{ name: string; description: string }> {\n    return Array.from(this.tools.values()).map((tool) => ({\n      name: tool.name,\n      description: tool.description,\n    }));\n  }\n\n  /**\n   * Gets the number of registered tools\n   */\n  getToolCount(): number {\n    return this.tools.size;\n  }\n\n  /**\n   * Executes a tool with metrics tracking\n   */\n  async executeTool(name: string, input: unknown, context?: any): Promise<unknown> {\n    const tool = this.tools.get(name);\n    if (!tool) {\n      throw new MCPError(`Tool not found: ${name}`);\n    }\n\n    const startTime = Date.now();\n    const metrics = this.metrics.get(name);\n\n    this.logger.debug('Executing tool', { name, input });\n\n    try {\n      // Validate input against schema\n      this.validateInput(tool, input);\n\n      // Check tool capabilities and permissions\n      await this.checkToolCapabilities(name, context);\n\n      // Execute tool handler\n      const result = await tool.handler(input, context);\n\n      // Update success metrics\n      if (metrics) {\n        const executionTime = Date.now() - startTime;\n        metrics.totalInvocations++;\n        metrics.successfulInvocations++;\n        metrics.totalExecutionTime += executionTime;\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\n        metrics.lastInvoked = new Date();\n      }\n\n      this.logger.debug('Tool executed successfully', {\n        name,\n        executionTime: Date.now() - startTime,\n      });\n      this.emit('toolExecuted', { name, success: true, executionTime: Date.now() - startTime });\n\n      return result;\n    } catch (error) {\n      // Update failure metrics\n      if (metrics) {\n        const executionTime = Date.now() - startTime;\n        metrics.totalInvocations++;\n        metrics.failedInvocations++;\n        metrics.totalExecutionTime += executionTime;\n        metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalInvocations;\n        metrics.lastInvoked = new Date();\n      }\n\n      this.logger.error('Tool execution failed', {\n        name,\n        error,\n        executionTime: Date.now() - startTime,\n      });\n      this.emit('toolExecuted', {\n        name,\n        success: false,\n        error,\n        executionTime: Date.now() - startTime,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Validates tool definition\n   */\n  private validateTool(tool: MCPTool): void {\n    if (!tool.name || typeof tool.name !== 'string') {\n      throw new MCPError('Tool name must be a non-empty string');\n    }\n\n    if (!tool.description || typeof tool.description !== 'string') {\n      throw new MCPError('Tool description must be a non-empty string');\n    }\n\n    if (typeof tool.handler !== 'function') {\n      throw new MCPError('Tool handler must be a function');\n    }\n\n    if (!tool.inputSchema || typeof tool.inputSchema !== 'object') {\n      throw new MCPError('Tool inputSchema must be an object');\n    }\n\n    // Validate tool name format (namespace/name)\n    if (!tool.name.includes('/')) {\n      throw new MCPError('Tool name must be in format: namespace/name');\n    }\n  }\n\n  /**\n   * Validates input against tool schema\n   */\n  private validateInput(tool: MCPTool, input: unknown): void {\n    // Simple validation - in production, use a JSON Schema validator\n    const schema = tool.inputSchema as any;\n\n    if (schema.type === 'object' && schema.properties) {\n      if (typeof input !== 'object' || input === null) {\n        throw new MCPError('Input must be an object');\n      }\n\n      const inputObj = input as Record<string, unknown>;\n\n      // Check required properties\n      if (schema.required && Array.isArray(schema.required)) {\n        for (const prop of schema.required) {\n          if (!(prop in inputObj)) {\n            throw new MCPError(`Missing required property: ${prop}`);\n          }\n        }\n      }\n\n      // Check property types\n      for (const [prop, propSchema] of Object.entries(schema.properties)) {\n        if (prop in inputObj) {\n          const value = inputObj[prop];\n          const expectedType = (propSchema as any).type;\n\n          if (expectedType && !this.checkType(value, expectedType)) {\n            throw new MCPError(`Invalid type for property ${prop}: expected ${expectedType}`);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks if a value matches a JSON Schema type\n   */\n  private checkType(value: unknown, type: string): boolean {\n    switch (type) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number';\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'object':\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n      case 'array':\n        return Array.isArray(value);\n      case 'null':\n        return value === null;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Register tool capability information\n   */\n  private registerCapability(toolName: string, capability: ToolCapability): void {\n    this.capabilities.set(toolName, capability);\n    this.categories.add(capability.category);\n    capability.tags.forEach((tag) => this.tags.add(tag));\n  }\n\n  /**\n   * Extract category from tool name\n   */\n  private extractCategory(toolName: string): string {\n    const parts = toolName.split('/');\n    return parts.length > 1 ? parts[0] : 'general';\n  }\n\n  /**\n   * Extract tags from tool definition\n   */\n  private extractTags(tool: MCPTool): string[] {\n    const tags: string[] = [];\n\n    // Extract from description\n    if (tool.description.toLowerCase().includes('file')) tags.push('filesystem');\n    if (tool.description.toLowerCase().includes('search')) tags.push('search');\n    if (tool.description.toLowerCase().includes('memory')) tags.push('memory');\n    if (tool.description.toLowerCase().includes('swarm')) tags.push('swarm');\n    if (tool.description.toLowerCase().includes('task')) tags.push('orchestration');\n\n    return tags.length > 0 ? tags : ['general'];\n  }\n\n  /**\n   * Check tool capabilities and permissions\n   */\n  private async checkToolCapabilities(toolName: string, context?: any): Promise<void> {\n    const capability = this.capabilities.get(toolName);\n    if (!capability) {\n      return; // No capability checks needed\n    }\n\n    // Check if tool is deprecated\n    if (capability.deprecated) {\n      this.logger.warn('Using deprecated tool', {\n        name: toolName,\n        message: capability.deprecationMessage,\n      });\n    }\n\n    // Check required permissions\n    if (capability.requiredPermissions && context?.permissions) {\n      const hasAllPermissions = capability.requiredPermissions.every((permission) =>\n        context.permissions.includes(permission),\n      );\n\n      if (!hasAllPermissions) {\n        throw new MCPError(\n          `Insufficient permissions for tool ${toolName}. Required: ${capability.requiredPermissions.join(', ')}`,\n        );\n      }\n    }\n\n    // Check protocol version compatibility\n    if (context?.protocolVersion) {\n      const isCompatible = capability.supportedProtocolVersions.some((version) =>\n        this.isProtocolVersionCompatible(context.protocolVersion, version),\n      );\n\n      if (!isCompatible) {\n        throw new MCPError(\n          `Tool ${toolName} is not compatible with protocol version ${context.protocolVersion.major}.${context.protocolVersion.minor}.${context.protocolVersion.patch}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Check protocol version compatibility\n   */\n  private isProtocolVersionCompatible(\n    client: MCPProtocolVersion,\n    supported: MCPProtocolVersion,\n  ): boolean {\n    if (client.major !== supported.major) {\n      return false;\n    }\n\n    if (client.minor > supported.minor) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Discover tools based on query criteria\n   */\n  discoverTools(\n    query: ToolDiscoveryQuery = {},\n  ): Array<{ tool: MCPTool; capability: ToolCapability }> {\n    const results: Array<{ tool: MCPTool; capability: ToolCapability }> = [];\n\n    for (const [name, tool] of this.tools) {\n      const capability = this.capabilities.get(name);\n      if (!capability) continue;\n\n      // Filter by category\n      if (query.category && capability.category !== query.category) {\n        continue;\n      }\n\n      // Filter by tags\n      if (query.tags && !query.tags.some((tag) => capability.tags.includes(tag))) {\n        continue;\n      }\n\n      // Filter by capabilities\n      if (query.capabilities && !query.capabilities.every((cap) => capability.tags.includes(cap))) {\n        continue;\n      }\n\n      // Filter by protocol version\n      if (query.protocolVersion) {\n        const isCompatible = capability.supportedProtocolVersions.some((version) =>\n          this.isProtocolVersionCompatible(query.protocolVersion!, version),\n        );\n        if (!isCompatible) continue;\n      }\n\n      // Filter deprecated tools\n      if (!query.includeDeprecated && capability.deprecated) {\n        continue;\n      }\n\n      // Filter by permissions\n      if (query.permissions && capability.requiredPermissions) {\n        const hasAllPermissions = capability.requiredPermissions.every((permission) =>\n          query.permissions!.includes(permission),\n        );\n        if (!hasAllPermissions) continue;\n      }\n\n      results.push({ tool, capability });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get tool capability information\n   */\n  getToolCapability(name: string): ToolCapability | undefined {\n    return this.capabilities.get(name);\n  }\n\n  /**\n   * Get tool metrics\n   */\n  getToolMetrics(name?: string): ToolMetrics | ToolMetrics[] {\n    if (name) {\n      const metrics = this.metrics.get(name);\n      if (!metrics) {\n        throw new MCPError(`Metrics not found for tool: ${name}`);\n      }\n      return metrics;\n    }\n\n    return Array.from(this.metrics.values());\n  }\n\n  /**\n   * Get all available categories\n   */\n  getCategories(): string[] {\n    return Array.from(this.categories);\n  }\n\n  /**\n   * Get all available tags\n   */\n  getTags(): string[] {\n    return Array.from(this.tags);\n  }\n\n  /**\n   * Reset metrics for a tool or all tools\n   */\n  resetMetrics(toolName?: string): void {\n    if (toolName) {\n      const metrics = this.metrics.get(toolName);\n      if (metrics) {\n        Object.assign(metrics, {\n          totalInvocations: 0,\n          successfulInvocations: 0,\n          failedInvocations: 0,\n          averageExecutionTime: 0,\n          totalExecutionTime: 0,\n          lastInvoked: undefined,\n        });\n      }\n    } else {\n      for (const metrics of this.metrics.values()) {\n        Object.assign(metrics, {\n          totalInvocations: 0,\n          successfulInvocations: 0,\n          failedInvocations: 0,\n          averageExecutionTime: 0,\n          totalExecutionTime: 0,\n          lastInvoked: undefined,\n        });\n      }\n    }\n\n    this.emit('metricsReset', { toolName });\n  }\n\n  /**\n   * Get comprehensive registry statistics\n   */\n  getRegistryStats(): {\n    totalTools: number;\n    toolsByCategory: Record<string, number>;\n    toolsByTag: Record<string, number>;\n    totalInvocations: number;\n    successRate: number;\n    averageExecutionTime: number;\n  } {\n    const stats = {\n      totalTools: this.tools.size,\n      toolsByCategory: {} as Record<string, number>,\n      toolsByTag: {} as Record<string, number>,\n      totalInvocations: 0,\n      successRate: 0,\n      averageExecutionTime: 0,\n    };\n\n    // Count by category\n    for (const capability of this.capabilities.values()) {\n      stats.toolsByCategory[capability.category] =\n        (stats.toolsByCategory[capability.category] || 0) + 1;\n\n      for (const tag of capability.tags) {\n        stats.toolsByTag[tag] = (stats.toolsByTag[tag] || 0) + 1;\n      }\n    }\n\n    // Calculate execution stats\n    let totalExecutionTime = 0;\n    let totalSuccessful = 0;\n\n    for (const metrics of this.metrics.values()) {\n      stats.totalInvocations += metrics.totalInvocations;\n      totalSuccessful += metrics.successfulInvocations;\n      totalExecutionTime += metrics.totalExecutionTime;\n    }\n\n    if (stats.totalInvocations > 0) {\n      stats.successRate = (totalSuccessful / stats.totalInvocations) * 100;\n      stats.averageExecutionTime = totalExecutionTime / stats.totalInvocations;\n    }\n\n    return stats;\n  }\n}\n"],"names":["MCPError","EventEmitter","ToolRegistry","tools","Map","capabilities","metrics","categories","Set","tags","logger","register","tool","capability","has","name","validateTool","set","registerCapability","defaultCapability","version","description","category","extractCategory","extractTags","supportedProtocolVersions","major","minor","patch","totalInvocations","successfulInvocations","failedInvocations","averageExecutionTime","totalExecutionTime","debug","emit","unregister","delete","getTool","get","listTools","Array","from","values","map","getToolCount","size","executeTool","input","context","startTime","Date","now","validateInput","checkToolCapabilities","result","handler","executionTime","lastInvoked","success","error","inputSchema","includes","schema","type","properties","inputObj","required","isArray","prop","propSchema","Object","entries","value","expectedType","checkType","toolName","add","forEach","tag","parts","split","length","toLowerCase","push","deprecated","warn","message","deprecationMessage","requiredPermissions","permissions","hasAllPermissions","every","permission","join","protocolVersion","isCompatible","some","isProtocolVersionCompatible","client","supported","discoverTools","query","results","cap","includeDeprecated","getToolCapability","getToolMetrics","getCategories","getTags","resetMetrics","assign","undefined","getRegistryStats","stats","totalTools","toolsByCategory","toolsByTag","successRate","totalSuccessful"],"mappings":"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"}