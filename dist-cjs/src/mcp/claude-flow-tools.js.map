{"version":3,"sources":["../../../src/mcp/claude-flow-tools.ts"],"sourcesContent":["/**\n * Claude-Flow specific MCP tools\n */\n\nimport type { MCPTool, MCPContext, AgentProfile, Task, MemoryEntry } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { getAvailableAgentTypes, getAgentTypeSchema } from '../constants/agent-types.js';\nimport type { Permissions } from './auth.js';\n\nexport interface ClaudeFlowToolContext extends MCPContext {\n  orchestrator?: any; // Reference to orchestrator instance\n}\n\n/**\n * Enhance tool schema with dynamic agent types\n */\nasync function enhanceToolWithAgentTypes(tool: MCPTool): Promise<MCPTool> {\n  const availableTypes = await getAvailableAgentTypes();\n  \n  // Clone the tool to avoid modifying the original\n  const enhancedTool = JSON.parse(JSON.stringify(tool));\n  \n  // Find and populate enum fields for agent types\n  function addEnumToAgentTypeFields(obj: any) {\n    if (typeof obj !== 'object' || obj === null) return;\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'object' && value !== null) {\n        // Check if this is an agent type field\n        if (key === 'type' || key === 'filterByType' || key === 'assignToAgentType') {\n          const field = value as any;\n          if (field.type === 'string' && field.description?.includes('loaded dynamically from .claude/agents/')) {\n            field.enum = availableTypes;\n          }\n        }\n        addEnumToAgentTypeFields(value);\n      }\n    }\n  }\n  \n  addEnumToAgentTypeFields(enhancedTool.inputSchema);\n  return enhancedTool;\n}\n\n/**\n * Create all Claude-Flow specific MCP tools\n */\nexport async function createClaudeFlowTools(logger: ILogger): Promise<MCPTool[]> {\n  const tools = [\n    // Agent management tools\n    createSpawnAgentTool(logger),\n    createSpawnParallelAgentsTool(logger), // NEW: Phase 4 - Parallel spawning\n    createListAgentsTool(logger),\n    createTerminateAgentTool(logger),\n    createGetAgentInfoTool(logger),\n\n    // Query control tools (NEW: Phase 4 - Real-time control)\n    createQueryControlTool(logger),\n    createListQueriesTool(logger),\n\n    // Task management tools\n    createCreateTaskTool(logger),\n    createListTasksTool(logger),\n    createGetTaskStatusTool(logger),\n    createCancelTaskTool(logger),\n    createAssignTaskTool(logger),\n\n    // Memory management tools\n    createQueryMemoryTool(logger),\n    createStoreMemoryTool(logger),\n    createDeleteMemoryTool(logger),\n    createExportMemoryTool(logger),\n    createImportMemoryTool(logger),\n\n    // System monitoring tools\n    createGetSystemStatusTool(logger),\n    createGetMetricsTool(logger),\n    createHealthCheckTool(logger),\n\n    // Configuration tools\n    createGetConfigTool(logger),\n    createUpdateConfigTool(logger),\n    createValidateConfigTool(logger),\n\n    // Workflow tools\n    createExecuteWorkflowTool(logger),\n    createCreateWorkflowTool(logger),\n    createListWorkflowsTool(logger),\n\n    // Terminal management tools\n    createExecuteCommandTool(logger),\n    createListTerminalsTool(logger),\n    createCreateTerminalTool(logger),\n  ];\n\n  // Enhance tools with dynamic agent types\n  const enhancedTools = await Promise.all(\n    tools.map(tool => enhanceToolWithAgentTypes(tool))\n  );\n\n  return enhancedTools;\n}\n\nfunction createSpawnAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/spawn',\n    description: 'Spawn a new Claude agent with specified configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to spawn (loaded dynamically from .claude/agents/)',\n        },\n        name: {\n          type: 'string',\n          description: 'Display name for the agent',\n        },\n        capabilities: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of capabilities for the agent',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'Custom system prompt for the agent',\n        },\n        maxConcurrentTasks: {\n          type: 'number',\n          default: 3,\n          description: 'Maximum number of concurrent tasks',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Agent priority level (1-10)',\n        },\n        environment: {\n          type: 'object',\n          description: 'Environment variables for the agent',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Working directory for the agent',\n        },\n      },\n      required: ['type', 'name'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Spawning agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const profile: AgentProfile = {\n        id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        name: input.name,\n        type: input.type,\n        capabilities: input.capabilities || [],\n        systemPrompt: input.systemPrompt || getDefaultSystemPrompt(input.type),\n        maxConcurrentTasks: input.maxConcurrentTasks || 3,\n        priority: input.priority || 5,\n        environment: input.environment,\n        workingDirectory: input.workingDirectory,\n      };\n\n      const sessionId = await context.orchestrator.spawnAgent(profile);\n\n      return {\n        agentId: profile.id,\n        sessionId,\n        profile,\n        status: 'spawned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListAgentsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/list',\n    description: 'List all active agents in the system',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeTerminated: {\n          type: 'boolean',\n          default: false,\n          description: 'Include terminated agents in the list',\n        },\n        filterByType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Filter agents by type (loaded dynamically from .claude/agents/)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing agents', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agents = await context.orchestrator.listAgents();\n\n      let filteredAgents = agents;\n\n      if (!input.includeTerminated) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.status !== 'terminated');\n      }\n\n      if (input.filterByType) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.type === input.filterByType);\n      }\n\n      return {\n        agents: filteredAgents,\n        count: filteredAgents.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createTerminateAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/terminate',\n    description: 'Terminate a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to terminate',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for termination',\n        },\n        graceful: {\n          type: 'boolean',\n          default: true,\n          description: 'Whether to perform graceful shutdown',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Terminating agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.terminateAgent(input.agentId, {\n        reason: input.reason || 'Manual termination',\n        graceful: input.graceful !== false,\n      });\n\n      return {\n        agentId: input.agentId,\n        status: 'terminated',\n        reason: input.reason || 'Manual termination',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetAgentInfoTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/info',\n    description: 'Get detailed information about a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting agent info', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agentInfo = await context.orchestrator.getAgentInfo(input.agentId);\n\n      if (!agentInfo) {\n        throw new Error(`Agent not found: ${input.agentId}`);\n      }\n\n      return {\n        agent: agentInfo,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/create',\n    description: 'Create a new task for execution',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          description: 'Type of task to create',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the task',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Task priority (1-10)',\n        },\n        dependencies: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of task IDs this task depends on',\n        },\n        assignToAgent: {\n          type: 'string',\n          description: 'Specific agent ID to assign the task to',\n        },\n        assignToAgentType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to assign the task to (loaded dynamically from .claude/agents/)',\n        },\n        input: {\n          type: 'object',\n          description: 'Input data for the task',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Task timeout in milliseconds',\n        },\n      },\n      required: ['type', 'description'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task: Partial<Task> = {\n        type: input.type,\n        description: input.description,\n        priority: input.priority || 5,\n        dependencies: input.dependencies || [],\n        input: input.input || {},\n        status: 'pending',\n        createdAt: new Date(),\n      };\n\n      const taskId = await context.orchestrator.createTask(task);\n\n      // Handle assignment\n      if (input.assignToAgent) {\n        await context.orchestrator.assignTask(taskId, input.assignToAgent);\n      } else if (input.assignToAgentType) {\n        await context.orchestrator.assignTaskToType(taskId, input.assignToAgentType);\n      }\n\n      return {\n        taskId,\n        task: { ...task, id: taskId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTasksTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/list',\n    description: 'List tasks with optional filtering',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        status: {\n          type: 'string',\n          enum: ['pending', 'queued', 'assigned', 'running', 'completed', 'failed', 'cancelled'],\n          description: 'Filter by task status',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by assigned agent ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by task type',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of tasks to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of tasks to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing tasks', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const tasks = await context.orchestrator.listTasks({\n        status: input.status,\n        agentId: input.agentId,\n        type: input.type,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      });\n\n      return {\n        tasks,\n        count: tasks.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetTaskStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/status',\n    description: 'Get detailed status of a specific task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting task status', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task = await context.orchestrator.getTask(input.taskId);\n\n      if (!task) {\n        throw new Error(`Task not found: ${input.taskId}`);\n      }\n\n      return {\n        task,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCancelTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/cancel',\n    description: 'Cancel a pending or running task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to cancel',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for cancellation',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Cancelling task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.cancelTask(input.taskId, input.reason || 'Manual cancellation');\n\n      return {\n        taskId: input.taskId,\n        status: 'cancelled',\n        reason: input.reason || 'Manual cancellation',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createAssignTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/assign',\n    description: 'Assign a task to a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to assign',\n        },\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to assign the task to',\n        },\n      },\n      required: ['taskId', 'agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Assigning task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.assignTask(input.taskId, input.agentId);\n\n      return {\n        taskId: input.taskId,\n        agentId: input.agentId,\n        status: 'assigned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createQueryMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/query',\n    description: 'Query agent memory with filters and search',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Filter by entry type',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Filter by tags',\n        },\n        search: {\n          type: 'string',\n          description: 'Full-text search query',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries before this time',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of entries to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of entries to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Querying memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const query = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        tags: input.tags,\n        search: input.search,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      };\n\n      const entries = await context.orchestrator.queryMemory(query);\n\n      return {\n        entries,\n        count: entries.length,\n        query,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createStoreMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/store',\n    description: 'Store a new memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Agent ID for the memory entry',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for the memory entry',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Type of memory entry',\n        },\n        content: {\n          type: 'string',\n          description: 'Content of the memory entry',\n        },\n        context: {\n          type: 'object',\n          description: 'Context data for the memory entry',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Tags for the memory entry',\n        },\n        parentId: {\n          type: 'string',\n          description: 'Parent memory entry ID',\n        },\n      },\n      required: ['agentId', 'sessionId', 'type', 'content'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Storing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const entry: Partial<MemoryEntry> = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        content: input.content,\n        context: input.context || {},\n        tags: input.tags || [],\n        parentId: input.parentId,\n        timestamp: new Date(),\n        version: 1,\n      };\n\n      const entryId = await context.orchestrator.storeMemory(entry);\n\n      return {\n        entryId,\n        entry: { ...entry, id: entryId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createDeleteMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/delete',\n    description: 'Delete a memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        entryId: {\n          type: 'string',\n          description: 'ID of the memory entry to delete',\n        },\n      },\n      required: ['entryId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Deleting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.deleteMemory(input.entryId);\n\n      return {\n        entryId: input.entryId,\n        status: 'deleted',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/export',\n    description: 'Export memory entries to a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        format: {\n          type: 'string',\n          enum: ['json', 'csv', 'markdown'],\n          default: 'json',\n          description: 'Export format',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries before this time',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Exporting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const exportResult = await context.orchestrator.exportMemory({\n        format: input.format || 'json',\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n      });\n\n      return {\n        ...exportResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createImportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/import',\n    description: 'Import memory entries from a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to the file to import',\n        },\n        format: {\n          type: 'string',\n          enum: ['json', 'csv'],\n          default: 'json',\n          description: 'Import format',\n        },\n        mergeStrategy: {\n          type: 'string',\n          enum: ['skip', 'overwrite', 'version'],\n          default: 'skip',\n          description: 'Strategy for handling duplicate entries',\n        },\n      },\n      required: ['filePath'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Importing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const importResult = await context.orchestrator.importMemory({\n        filePath: input.filePath,\n        format: input.format || 'json',\n        mergeStrategy: input.mergeStrategy || 'skip',\n      });\n\n      return {\n        ...importResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetSystemStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/status',\n    description: 'Get comprehensive system status information',\n    inputSchema: {\n      type: 'object',\n      properties: {},\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system status', { sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const status = await context.orchestrator.getSystemStatus();\n\n      return {\n        ...status,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetMetricsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/metrics',\n    description: 'Get system performance metrics',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        timeRange: {\n          type: 'string',\n          enum: ['1h', '6h', '24h', '7d'],\n          default: '1h',\n          description: 'Time range for metrics',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system metrics', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const metrics = await context.orchestrator.getMetrics(input.timeRange || '1h');\n\n      return {\n        metrics,\n        timeRange: input.timeRange || '1h',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createHealthCheckTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/health',\n    description: 'Perform a comprehensive health check',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        deep: {\n          type: 'boolean',\n          default: false,\n          description: 'Perform deep health check including component tests',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Performing health check', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const healthCheck = await context.orchestrator.performHealthCheck(input.deep || false);\n\n      return {\n        ...healthCheck,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/get',\n    description: 'Get current system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Specific configuration section to retrieve',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const config = await context.orchestrator.getConfig(input.section);\n\n      return {\n        config,\n        section: input.section,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createUpdateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/update',\n    description: 'Update system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Configuration section to update',\n        },\n        config: {\n          type: 'object',\n          description: 'Configuration values to update',\n        },\n        restart: {\n          type: 'boolean',\n          default: false,\n          description: 'Restart affected components after update',\n        },\n      },\n      required: ['section', 'config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Updating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.updateConfig(\n        input.section,\n        input.config,\n        input.restart || false,\n      );\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createValidateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/validate',\n    description: 'Validate a configuration object',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        config: {\n          type: 'object',\n          description: 'Configuration object to validate',\n        },\n      },\n      required: ['config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Validating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const validation = await context.orchestrator.validateConfig(input.config);\n\n      return {\n        ...validation,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/execute',\n    description: 'Execute a workflow from a file or definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to workflow file',\n        },\n        workflow: {\n          type: 'object',\n          description: 'Inline workflow definition',\n        },\n        parameters: {\n          type: 'object',\n          description: 'Parameters to pass to the workflow',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      if (!input.filePath && !input.workflow) {\n        throw new Error('Either filePath or workflow must be provided');\n      }\n\n      const result = await context.orchestrator.executeWorkflow({\n        filePath: input.filePath,\n        workflow: input.workflow,\n        parameters: input.parameters || {},\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/create',\n    description: 'Create a new workflow definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Name of the workflow',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the workflow',\n        },\n        tasks: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string' },\n              type: { type: 'string' },\n              description: { type: 'string' },\n              dependencies: {\n                type: 'array',\n                items: { type: 'string' },\n              },\n              assignTo: { type: 'string' },\n            },\n            required: ['id', 'type', 'description'],\n          },\n          description: 'List of tasks in the workflow',\n        },\n        savePath: {\n          type: 'string',\n          description: 'Path to save the workflow file',\n        },\n      },\n      required: ['name', 'tasks'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflow = {\n        name: input.name,\n        description: input.description,\n        tasks: input.tasks,\n        created: new Date().toISOString(),\n      };\n\n      const result = await context.orchestrator.createWorkflow(workflow, input.savePath);\n\n      return {\n        ...result,\n        workflow,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListWorkflowsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/list',\n    description: 'List available workflows',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'Directory to search for workflows',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing workflows', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflows = await context.orchestrator.listWorkflows(input.directory);\n\n      return {\n        workflows,\n        count: workflows.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteCommandTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/execute',\n    description: 'Execute a command in a terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'Command to execute',\n        },\n        args: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Command arguments',\n        },\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the command',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        timeout: {\n          type: 'number',\n          default: 30000,\n          description: 'Command timeout in milliseconds',\n        },\n        terminalId: {\n          type: 'string',\n          description: 'Specific terminal ID to use',\n        },\n      },\n      required: ['command'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing command', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.executeCommand({\n        command: input.command,\n        args: input.args,\n        cwd: input.cwd,\n        env: input.env,\n        timeout: input.timeout || 30000,\n        terminalId: input.terminalId,\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTerminalsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/list',\n    description: 'List all terminal sessions',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeIdle: {\n          type: 'boolean',\n          default: true,\n          description: 'Include idle terminals',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing terminals', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminals = await context.orchestrator.listTerminals(input.includeIdle !== false);\n\n      return {\n        terminals,\n        count: terminals.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTerminalTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/create',\n    description: 'Create a new terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the terminal',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        shell: {\n          type: 'string',\n          description: 'Shell to use (bash, zsh, etc.)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating terminal', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminal = await context.orchestrator.createTerminal({\n        cwd: input.cwd,\n        env: input.env,\n        shell: input.shell,\n      });\n\n      return {\n        terminal,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\n/**\n * NEW: Phase 4 - Parallel Agent Spawning (10-20x faster)\n * Spawn multiple agents in parallel using ParallelSwarmExecutor\n */\nfunction createSpawnParallelAgentsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/spawn_parallel',\n    description: 'Spawn multiple agents in parallel (10-20x faster than sequential spawning)',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agents: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              type: { type: 'string', description: 'Agent type' },\n              name: { type: 'string', description: 'Agent name' },\n              capabilities: { type: 'array', items: { type: 'string' } },\n              priority: {\n                type: 'string',\n                enum: ['low', 'medium', 'high', 'critical'],\n                default: 'medium'\n              },\n            },\n            required: ['type', 'name'],\n          },\n          description: 'Array of agent configurations to spawn in parallel',\n        },\n        maxConcurrency: {\n          type: 'number',\n          default: 5,\n          description: 'Maximum number of agents to spawn concurrently',\n        },\n        batchSize: {\n          type: 'number',\n          default: 3,\n          description: 'Number of agents per batch',\n        },\n      },\n      required: ['agents'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Spawning parallel agents', {\n        count: input.agents?.length,\n        sessionId: context?.sessionId\n      });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const executor = context.orchestrator.getParallelExecutor();\n      if (!executor) {\n        throw new Error('ParallelSwarmExecutor not initialized');\n      }\n\n      // Convert input agents to ParallelAgentConfig format\n      const agentConfigs = input.agents.map((agent: any) => ({\n        agentId: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        agentType: agent.type,\n        task: `Spawn ${agent.name} agent`,\n        capabilities: agent.capabilities || [],\n        priority: agent.priority || 'medium',\n      }));\n\n      const startTime = Date.now();\n      const sessions = await executor.spawnParallelAgents(agentConfigs, {\n        maxConcurrency: input.maxConcurrency || 5,\n        batchSize: input.batchSize || 3,\n      });\n\n      const elapsedTime = Date.now() - startTime;\n\n      return {\n        success: true,\n        agentsSpawned: sessions.size,\n        sessions: Array.from(sessions.entries()).map(([id, session]) => ({\n          agentId: id,\n          sessionId: session.sessionId,\n          status: session.status,\n        })),\n        performance: {\n          totalTime: elapsedTime,\n          averageTimePerAgent: elapsedTime / sessions.size,\n          speedupVsSequential: `~${Math.round((sessions.size * 750) / elapsedTime)}x`,\n        },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\n/**\n * NEW: Phase 4 - Real-Time Query Control\n * Control running queries: pause, resume, terminate, change model\n */\nfunction createQueryControlTool(logger: ILogger): MCPTool {\n  return {\n    name: 'query/control',\n    description: 'Control running queries (pause, resume, terminate, change model)',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        action: {\n          type: 'string',\n          enum: ['pause', 'resume', 'terminate', 'change_model', 'change_permissions', 'execute_command'],\n          description: 'Control action to perform',\n        },\n        queryId: {\n          type: 'string',\n          description: 'ID of the query to control',\n        },\n        model: {\n          type: 'string',\n          enum: ['claude-3-5-sonnet-20241022', 'claude-3-5-haiku-20241022', 'claude-3-opus-20240229'],\n          description: 'Model to switch to (for change_model action)',\n        },\n        permissionMode: {\n          type: 'string',\n          enum: ['default', 'acceptEdits', 'bypassPermissions', 'plan'],\n          description: 'Permission mode to switch to (for change_permissions action)',\n        },\n        command: {\n          type: 'string',\n          description: 'Command to execute (for execute_command action)',\n        },\n      },\n      required: ['action', 'queryId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Query control action', {\n        action: input.action,\n        queryId: input.queryId,\n        sessionId: context?.sessionId\n      });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const controller = context.orchestrator.getQueryController();\n      if (!controller) {\n        throw new Error('RealTimeQueryController not initialized');\n      }\n\n      let result;\n      switch (input.action) {\n        case 'pause':\n          result = await controller.pauseQuery(input.queryId);\n          break;\n        case 'resume':\n          result = await controller.resumeQuery(input.queryId);\n          break;\n        case 'terminate':\n          result = await controller.terminateQuery(input.queryId);\n          break;\n        case 'change_model':\n          if (!input.model) {\n            throw new Error('model parameter required for change_model action');\n          }\n          result = await controller.changeModel(input.queryId, input.model);\n          break;\n        case 'change_permissions':\n          if (!input.permissionMode) {\n            throw new Error('permissionMode parameter required for change_permissions action');\n          }\n          result = await controller.changePermissionMode(input.queryId, input.permissionMode);\n          break;\n        case 'execute_command':\n          if (!input.command) {\n            throw new Error('command parameter required for execute_command action');\n          }\n          result = await controller.executeCommand(input.queryId, input.command);\n          break;\n        default:\n          throw new Error(`Unknown action: ${input.action}`);\n      }\n\n      return {\n        success: true,\n        action: input.action,\n        queryId: input.queryId,\n        result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\n/**\n * NEW: Phase 4 - List Active Queries\n * Get status of all active queries being controlled\n */\nfunction createListQueriesTool(logger: ILogger): MCPTool {\n  return {\n    name: 'query/list',\n    description: 'List all active queries and their status',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeHistory: {\n          type: 'boolean',\n          default: false,\n          description: 'Include completed queries in the list',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing queries', { sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const controller = context.orchestrator.getQueryController();\n      if (!controller) {\n        throw new Error('RealTimeQueryController not initialized');\n      }\n\n      const queries = controller.getAllQueries();\n\n      return {\n        success: true,\n        queries: Array.from(queries.entries()).map(([id, status]) => ({\n          queryId: id,\n          ...status,\n        })),\n        count: queries.size,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction getDefaultSystemPrompt(type: string): string {\n  const prompts = {\n    coordinator:\n      'You are a coordinator agent responsible for planning, delegating, and orchestrating tasks across multiple agents.',\n    researcher:\n      'You are a research agent specialized in gathering, analyzing, and synthesizing information from various sources.',\n    implementer:\n      'You are an implementation agent focused on writing code, creating solutions, and executing technical tasks.',\n    analyst:\n      'You are an analysis agent that identifies patterns, generates insights, and provides data-driven recommendations.',\n    custom: 'You are a specialized agent with custom capabilities defined by your configuration.',\n  };\n\n  return prompts[type as keyof typeof prompts] || prompts.custom;\n}\n"],"names":["getAvailableAgentTypes","enhanceToolWithAgentTypes","tool","availableTypes","enhancedTool","JSON","parse","stringify","addEnumToAgentTypeFields","obj","key","value","Object","entries","field","type","description","includes","enum","inputSchema","createClaudeFlowTools","logger","tools","createSpawnAgentTool","createSpawnParallelAgentsTool","createListAgentsTool","createTerminateAgentTool","createGetAgentInfoTool","createQueryControlTool","createListQueriesTool","createCreateTaskTool","createListTasksTool","createGetTaskStatusTool","createCancelTaskTool","createAssignTaskTool","createQueryMemoryTool","createStoreMemoryTool","createDeleteMemoryTool","createExportMemoryTool","createImportMemoryTool","createGetSystemStatusTool","createGetMetricsTool","createHealthCheckTool","createGetConfigTool","createUpdateConfigTool","createValidateConfigTool","createExecuteWorkflowTool","createCreateWorkflowTool","createListWorkflowsTool","createExecuteCommandTool","createListTerminalsTool","createCreateTerminalTool","enhancedTools","Promise","all","map","name","properties","capabilities","items","systemPrompt","maxConcurrentTasks","default","priority","environment","workingDirectory","required","handler","input","context","info","sessionId","orchestrator","Error","profile","id","Date","now","Math","random","toString","substr","getDefaultSystemPrompt","spawnAgent","agentId","status","timestamp","toISOString","includeTerminated","filterByType","agents","listAgents","filteredAgents","filter","agent","count","length","reason","graceful","terminateAgent","agentInfo","getAgentInfo","dependencies","assignToAgent","assignToAgentType","timeout","task","createdAt","taskId","createTask","assignTask","assignTaskToType","limit","offset","tasks","listTasks","getTask","cancelTask","tags","search","startTime","format","endTime","query","undefined","queryMemory","content","parentId","entry","version","entryId","storeMemory","deleteMemory","exportResult","exportMemory","filePath","mergeStrategy","importResult","importMemory","getSystemStatus","timeRange","metrics","getMetrics","deep","healthCheck","performHealthCheck","section","config","getConfig","restart","result","updateConfig","validation","validateConfig","workflow","parameters","executeWorkflow","assignTo","savePath","created","createWorkflow","directory","workflows","listWorkflows","command","args","cwd","env","terminalId","executeCommand","includeIdle","terminals","listTerminals","shell","terminal","createTerminal","maxConcurrency","batchSize","executor","getParallelExecutor","agentConfigs","agentType","sessions","spawnParallelAgents","elapsedTime","success","agentsSpawned","size","Array","from","session","performance","totalTime","averageTimePerAgent","speedupVsSequential","round","action","queryId","model","permissionMode","controller","getQueryController","pauseQuery","resumeQuery","terminateQuery","changeModel","changePermissionMode","includeHistory","queries","getAllQueries","prompts","coordinator","researcher","implementer","analyst","custom"],"mappings":"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"}